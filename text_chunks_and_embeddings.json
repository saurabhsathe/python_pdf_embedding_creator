[{"page_number": 1, "sentence_chunk": "Chapter 1. Spring Framework Overview Spring makes it easy to create Java enterprise applications. It provides everything you need to embrace the Java language in an enterprise environment, with support for Groovy and Kotlin as alternative languages on the JVM, and with the flexibility to create many kinds of architectures depending on an application\u2019s needs. As of Spring Framework 5.1, Spring requires JDK 8+ (Java SE 8+) and provides out-of-the-box support for JDK 11 LTS. Java SE 8 update 60 is suggested as the minimum patch release for Java 8, but it is generally recommended to use a recent patch release. Spring supports a wide range of application scenarios. In a large enterprise, applications often exist for a long time and have to run on a JDK and application server whose upgrade cycle is beyond developer control. Others may run as a single jar with the server embedded, possibly in a cloud environment. Yet others may be standalone applications (such as batch or integration workloads) that do not need a server. Spring is open source.", "chunk_char_count": 1052, "chunk_word_count": 175, "chunk_token_count": 263.0}, {"page_number": 1, "sentence_chunk": "It has a large and active community that provides continuous feedback based on a diverse range of real-world use cases. This has helped Spring to successfully evolve over a very long time.1.1. What We Mean by \"Spring\" The term \"Spring\" means different things in different contexts. It can be used to refer to the Spring Framework project itself, which is where it all started. Over time, other Spring projects have been built on top of the Spring Framework. Most often, when people say \"Spring\", they mean the entire family of projects. This reference documentation focuses on the foundation: the Spring Framework itself. The Spring Framework is divided into modules. Applications can choose which modules they need.", "chunk_char_count": 716, "chunk_word_count": 116, "chunk_token_count": 179.0}, {"page_number": 1, "sentence_chunk": "At the heart are the modules of the core container, including a configuration model and a dependency injection mechanism. Beyond that, the Spring Framework provides foundational support for different application architectures, including messaging, transactional data and persistence, and web. It also includes the Servlet-based Spring MVC web framework and, in parallel, the Spring WebFlux reactive web framework. A note about modules: Spring\u2019s framework jars allow for deployment to JDK 9\u2019s module path (\"Jigsaw\"). For use in Jigsaw-enabled applications, the Spring Framework 5 jars come with \"Automatic-Module-Name\" manifest entries which define stable language-level module names (\"spring.core\", \"spring.context\", etc.)independent from jar artifact names (the jars follow the same naming pattern with \"-\" instead of \".\",e.g. \"spring-core\" and \"spring-context\"). Of course, Spring\u2019s framework jars keep working fine on the classpath on both JDK 8 and 9+.1.2. History of Spring and the Spring Framework Spring came into being in 2003 as a response to the complexity of the early J2EE specifications.", "chunk_char_count": 1100, "chunk_word_count": 157, "chunk_token_count": 275.0}, {"page_number": 1, "sentence_chunk": "While some consider Java EE and its modern-day successor Jakarta EE to be in competition with Spring, they are in fact complementary. The Spring programming model does not embrace the Jakarta EE platform specification; rather, it integrates with carefully selected individual 1", "chunk_char_count": 277, "chunk_word_count": 42, "chunk_token_count": 69.25}, {"page_number": 2, "sentence_chunk": "specifications from the traditional EE umbrella: \u2022 Servlet API (JSR 340) \u2022 WebSocket API (JSR 356) \u2022 Concurrency Utilities (JSR 236) \u2022 JSON Binding API (JSR 367) \u2022 Bean Validation (JSR 303) \u2022 JPA (JSR 338) \u2022 JMS (JSR 914) \u2022 as well as JTA/JCA setups for transaction coordination, if necessary. The Spring Framework also supports the Dependency Injection (JSR 330) and Common Annotations (JSR 250) specifications, which application developers may choose to use instead of the Spring- specific mechanisms provided by the Spring Framework. Originally, those were based on common javax packages. As of Spring Framework 6.0, Spring has been upgraded to the Jakarta EE 9 level (e.g. Servlet 5.0+, JPA 3.0+), based on the jakarta namespace instead of the traditional javax packages. With EE 9 as the minimum and EE 10 supported already, Spring is prepared to provide out-of-the-box support for the further evolution of the Jakarta EE APIs. Spring Framework 6.0 is fully compatible with Tomcat 10.1, Jetty 11 and Undertow 2.3 as web servers, and also with Hibernate ORM 6.1. Over time, the role of Java/Jakarta EE in application development has evolved. In the early days of J2EE and Spring, applications were created to be deployed to an application server. Today, with the help of Spring Boot, applications are created in a devops- and cloud-friendly way, with the Servlet container embedded and trivial to change. As of Spring Framework 5, a WebFlux application does not even use the Servlet API directly and can run on servers (such as Netty) that are not Servlet containers.", "chunk_char_count": 1571, "chunk_word_count": 258, "chunk_token_count": 392.75}, {"page_number": 2, "sentence_chunk": "Spring continues to innovate and to evolve. Beyond the Spring Framework, there are other projects, such as Spring Boot, Spring Security, Spring Data, Spring Cloud, Spring Batch, among others. It\u2019s important to remember that each project has its own source code repository, issue tracker, and release cadence. See spring.io/projects for the complete list of Spring projects.1.3. Design Philosophy When you learn about a framework, it\u2019s important to know not only what it does but what principles it follows. Here are the guiding principles of the Spring Framework: \u2022 Provide choice at every level. Spring lets you defer design decisions as late as possible. For example, you can switch persistence providers through configuration without changing your code. The same is true for many other infrastructure concerns and integration with third-party APIs. \u2022", "chunk_char_count": 853, "chunk_word_count": 131, "chunk_token_count": 213.25}, {"page_number": 2, "sentence_chunk": "Accommodate diverse perspectives. Spring embraces flexibility and is not opinionated about how things should be done. It supports a wide range of application needs with different perspectives.2", "chunk_char_count": 193, "chunk_word_count": 27, "chunk_token_count": 48.25}, {"page_number": 3, "sentence_chunk": "\u2022 Maintain strong backward compatibility. Spring\u2019s evolution has been carefully managed to force few breaking changes between versions. Spring supports a carefully chosen range of JDK versions and third-party libraries to facilitate maintenance of applications and libraries that depend on Spring. \u2022Care about API design. The Spring team puts a lot of thought and time into making APIs that are intuitive and that hold up across many versions and many years. \u2022Set high standards for code quality. The Spring Framework puts a strong emphasis on meaningful, current, and accurate javadoc. It is one of very few projects that can claim clean code structure with no circular dependencies between packages.1.4. Feedback and Contributions For how-to questions or diagnosing or debugging issues, we suggest using Stack Overflow.", "chunk_char_count": 821, "chunk_word_count": 125, "chunk_token_count": 205.25}, {"page_number": 3, "sentence_chunk": "Click here for a list of the suggested tags to use on Stack Overflow. If you\u2019re fairly certain that there is a problem in the Spring Framework or would like to suggest a feature, please use the GitHub Issues. If you have a solution in mind or a suggested fix, you can submit a pull request on Github. However, please keep in mind that, for all but the most trivial issues, we expect a ticket to be filed in the issue tracker, where discussions take place and leave a record for future reference. For more details see the guidelines at the CONTRIBUTING, top-level project page.1.5. Getting Started If you are just getting started with Spring, you may want to begin using the Spring Framework by creating a Spring Boot-based application. Spring Boot provides a quick (and opinionated) way to create a production-ready Spring-based application. It is based on the Spring Framework, favors convention over configuration, and is designed to get you up and running as quickly as possible. You can use start.spring.io to generate a basic project or follow one of the \"Getting Started\" guides, such as Getting Started Building a RESTful Web Service.", "chunk_char_count": 1141, "chunk_word_count": 194, "chunk_token_count": 285.25}, {"page_number": 3, "sentence_chunk": "As well as being easier to digest, these guides are very task focused, and most of them are based on Spring Boot. They also cover other projects from the Spring portfolio that you might want to consider when solving a particular problem.3", "chunk_char_count": 238, "chunk_word_count": 42, "chunk_token_count": 59.5}, {"page_number": 4, "sentence_chunk": "Chapter 2. Core Technologies This part of the reference documentation covers all the technologies that are absolutely integral to the Spring Framework. Foremost amongst these is the Spring Framework\u2019s Inversion of Control (IoC) container. A thorough treatment of the Spring Framework\u2019s IoC container is closely followed by comprehensive coverage of Spring\u2019s Aspect-Oriented Programming (AOP) technologies. The Spring Framework has its own AOP framework, which is conceptually easy to understand and which successfully addresses the 80% sweet spot of AOP requirements in Java enterprise programming. Coverage of Spring\u2019s integration with AspectJ (currently the richest\u2009\u2014\u2009in terms of features\u2009\u2014\u2009and certainly most mature AOP implementation in the Java enterprise space) is also provided. AOT processing can be used to optimize your application ahead-of-time. It is typically used for native image deployment using GraalVM.2.1. The IoC Container This chapter covers Spring\u2019s Inversion of Control (IoC) container.", "chunk_char_count": 1009, "chunk_word_count": 141, "chunk_token_count": 252.25}, {"page_number": 4, "sentence_chunk": "2.1.1. Introduction to the Spring IoC Container and Beans This chapter covers the Spring Framework implementation of the Inversion of Control (IoC) principle. IoC is also known as dependency injection (DI). It is a process whereby objects define their dependencies (that is, the other objects they work with) only through constructor arguments, arguments to a factory method, or properties that are set on the object instance after it is constructed or returned from a factory method. The container then injects those dependencies when it creates the bean. This process is fundamentally the inverse (hence the name, Inversion of Control) of the bean itself controlling the instantiation or location of its dependencies by using direct construction of classes or a mechanism such as the Service Locator pattern. The org.springframework.beans and org.springframework.context packages are the basis for Spring Framework\u2019s IoC container. The BeanFactory interface provides an advanced configuration mechanism capable of managing any type of object. ApplicationContext is a sub-interface of BeanFactory. It adds: \u2022 Easier integration with Spring\u2019s AOP features \u2022 Message resource handling (for use in internationalization) \u2022 Event publication \u2022 Application-layer specific contexts such as the WebApplicationContext for use in web applications.", "chunk_char_count": 1338, "chunk_word_count": 193, "chunk_token_count": 334.5}, {"page_number": 4, "sentence_chunk": "In short, the BeanFactory provides the configuration framework and basic functionality, and the ApplicationContext adds more enterprise-specific functionality. The ApplicationContext is a complete superset of the BeanFactory and is used exclusively in this chapter in descriptions of Spring\u2019s IoC container. For more information on using the BeanFactory instead of the 4", "chunk_char_count": 370, "chunk_word_count": 51, "chunk_token_count": 92.5}, {"page_number": 5, "sentence_chunk": "ApplicationContext, see the section covering the BeanFactory API. In Spring, the objects that form the backbone of your application and that are managed by the Spring IoC container are called beans. A bean is an object that is instantiated, assembled, and managed by a Spring IoC container. Otherwise, a bean is simply one of many objects in your application. Beans, and the dependencies among them, are reflected in the configuration metadata used by a container.2.1.2. Container Overview The org.springframework.context. ApplicationContext interface represents the Spring IoC container and is responsible for instantiating, configuring, and assembling the beans. The container gets its instructions on what objects to instantiate, configure, and assemble by reading configuration metadata. The configuration metadata is represented in XML, Java annotations, or Java code.", "chunk_char_count": 873, "chunk_word_count": 125, "chunk_token_count": 218.25}, {"page_number": 5, "sentence_chunk": "It lets you express the objects that compose your application and the rich interdependencies between those objects. Several implementations of the ApplicationContext interface are supplied with Spring. In stand- alone applications, it is common to create an instance of ClassPathXmlApplicationContext or FileSystemXmlApplicationContext. While XML has been the traditional format for defining configuration metadata, you can instruct the container to use Java annotations or code as the metadata format by providing a small amount of XML configuration to declaratively enable support for these additional metadata formats. In most application scenarios, explicit user code is not required to instantiate one or more instances of a Spring IoC container. For example, in a web application scenario, a simple eight (or so) lines of boilerplate web descriptor XML in the web.xml file of the application typically suffices (see Convenient ApplicationContext Instantiation for Web Applications). If you use the Spring Tools for Eclipse (an Eclipse-powered development environment), you can easily create this boilerplate configuration with a few mouse clicks or keystrokes. The following diagram shows a high-level view of how Spring works. Your application classes are combined with configuration metadata so that, after the ApplicationContext is created and initialized, you have a fully configured and executable system or application.5", "chunk_char_count": 1432, "chunk_word_count": 204, "chunk_token_count": 358.0}, {"page_number": 6, "sentence_chunk": "Figure 1. The Spring IoC container Configuration Metadata As the preceding diagram shows, the Spring IoC container consumes a form of configuration metadata. This configuration metadata represents how you, as an application developer, tell the Spring container to instantiate, configure, and assemble the objects in your application. Configuration metadata is traditionally supplied in a simple and intuitive XML format, which is what most of this chapter uses to convey key concepts and features of the Spring IoC container.\uf05a XML-based metadata is not the only allowed form of configuration metadata. The Spring IoC container itself is totally decoupled from the format in which this configuration metadata is actually written. These days, many developers choose Java-based configuration for their Spring applications. For information about using other forms of metadata with the Spring container, see: \u2022 Annotation-based configuration: Spring 2.5 introduced support for annotation-based configuration metadata. \u2022Java-based configuration: Starting with Spring 3.0, many features provided by the Spring JavaConfig project became part of the core Spring Framework. Thus, you can define beans external to your application classes by using Java rather than XML files.", "chunk_char_count": 1264, "chunk_word_count": 181, "chunk_token_count": 316.0}, {"page_number": 6, "sentence_chunk": "To use these new features, see the @Configuration, @Bean, @Import, and @DependsOn annotations. Spring configuration consists of at least one and typically more than one bean definition that the container must manage. XML-based configuration metadata configures these beans as <bean/> elements inside a top-level <beans/> element. Java configuration typically uses @Bean-annotated methods within a @Configuration class. These bean definitions correspond to the actual objects that make up your application. Typically, you define service layer objects, data access objects (DAOs), presentation objects such as Struts Action instances, infrastructure objects such as Hibernate SessionFactories, JMS Queues, and so forth. Typically, one does not configure fine-grained domain objects in the container, because it is 6", "chunk_char_count": 813, "chunk_word_count": 112, "chunk_token_count": 203.25}, {"page_number": 7, "sentence_chunk": "usually the responsibility of DAOs and business logic to create and load domain objects. However, you can use Spring\u2019s integration with AspectJ to configure objects that have been created outside the control of an IoC container. See Using AspectJ to dependency-inject domain objects with Spring. The following example shows the basic structure of XML-based configuration metadata: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xsi:schemaLocation=\"http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd\"> \u00a0  <bean id=\"...\" class=\"...\"> \u2460 \u2461 \u00a0    <!--collaborators and configuration for this bean go here --> \u00a0  </bean> \u00a0  <bean id=\"...\" class=\"...\"> \u00a0    <!--collaborators and configuration for this bean go here --> \u00a0  </bean> \u00a0  <!--more bean definitions go here --> </beans> \u2460 The id attribute is a string that identifies the individual bean definition.\u2461 The class attribute defines the type of the bean and uses the fully qualified classname.", "chunk_char_count": 1112, "chunk_word_count": 153, "chunk_token_count": 278.0}, {"page_number": 7, "sentence_chunk": "The value of the id attribute refers to collaborating objects. The XML for referring to collaborating objects is not shown in this example. See Dependencies for more information. Instantiating a Container The location path or paths supplied to an ApplicationContext constructor are resource strings that let the container load configuration metadata from a variety of external resources, such as the local file system, the Java CLASSPATH, and so on. Java ApplicationContext context = new ClassPathXmlApplicationContext(\"services.xml\", \"daos.xml\"); Kotlin val context = ClassPathXmlApplicationContext(\"services.xml\", \"daos.xml\") 7", "chunk_char_count": 629, "chunk_word_count": 83, "chunk_token_count": 157.25}, {"page_number": 8, "sentence_chunk": "\uf05a After you learn about Spring\u2019s IoC container, you may want to know more about Spring\u2019s Resource abstraction (as described in Resources), which provides a convenient mechanism for reading an InputStream from locations defined in a URI syntax. In particular, Resource paths are used to construct applications contexts, as described in Application Contexts and Resource Paths. The following example shows the service layer objects (services.xml) configuration file: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xsi:schemaLocation=\"http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd\"> \u00a0  <!--services --> \u00a0  <bean id=\"petStore\" class=\"org.springframework.samples.jpetstore.services. PetStoreServiceImpl\"> \u00a0    <property name=\"accountDao\" ref=\"accountDao\"/> \u00a0    <property name=\"itemDao\" ref=\"itemDao\"/> \u00a0    <!--additional collaborators and configuration for this bean go here --> \u00a0  </bean> \u00a0  <!--more bean definitions for services go here --> </beans> The following example shows the data access objects daos.xml file: <?xml version=\"1.0\" encoding=\"UTF-8\"?", "chunk_char_count": 1230, "chunk_word_count": 148, "chunk_token_count": 307.5}, {"page_number": 8, "sentence_chunk": "> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xsi:schemaLocation=\"http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd\"> \u00a0  <bean id=\"accountDao\" \u00a0    class=\"org.springframework.samples.jpetstore.dao.jpa. JpaAccountDao\"> \u00a0    <!--additional collaborators and configuration for this bean go here --> \u00a0  </bean> \u00a0  <bean id=\"itemDao\" class=\"org.springframework.samples.jpetstore.dao.jpa. JpaItemDao\"> \u00a0    <!--additional collaborators and configuration for this bean go here --> \u00a0  </bean> \u00a0  <!--more bean definitions for data access objects go here --> </beans> 8", "chunk_char_count": 696, "chunk_word_count": 78, "chunk_token_count": 174.0}, {"page_number": 9, "sentence_chunk": "In the preceding example, the service layer consists of the PetStoreServiceImpl class and two data access objects of the types JpaAccountDao and JpaItemDao (based on the JPA Object-Relational Mapping standard). The property name element refers to the name of the JavaBean property, and the ref element refers to the name of another bean definition. This linkage between id and ref elements expresses the dependency between collaborating objects. For details of configuring an object\u2019s dependencies, see Dependencies. Composing XML-based Configuration Metadata It can be useful to have bean definitions span multiple XML files. Often, each individual XML configuration file represents a logical layer or module in your architecture. You can use the application context constructor to load bean definitions from all these XML fragments. This constructor takes multiple Resource locations, as was shown in the previous section. Alternatively, use one or more occurrences of the <import/> element to load bean definitions from another file or files. The following example shows how to do so: <beans> \u00a0  <import resource=\"services.xml\"/> \u00a0  <import resource=\"resources/messageSource.xml\"/> \u00a0  <import resource=\"/resources/themeSource.xml\"/> \u00a0  <bean id=\"bean1\" class=\"...\"/> \u00a0  <bean id=\"bean2\" class=\"...\"/> </beans> In the preceding example, external bean definitions are loaded from three files: services.xml, messageSource.xml, and themeSource.xml.", "chunk_char_count": 1447, "chunk_word_count": 203, "chunk_token_count": 361.75}, {"page_number": 9, "sentence_chunk": "All location paths are relative to the definition file doing the importing, so services.xml must be in the same directory or classpath location as the file doing the importing, while messageSource.xml and themeSource.xml must be in a resources location below the location of the importing file. As you can see, a leading slash is ignored. However, given that these paths are relative, it is better form not to use the slash at all. The contents of the files being imported, including the top level <beans/> element, must be valid XML bean definitions, according to the Spring Schema.9", "chunk_char_count": 584, "chunk_word_count": 97, "chunk_token_count": 146.0}, {"page_number": 10, "sentence_chunk": "\uf05a It is possible, but not recommended, to reference files in parent directories using a relative \"../\" path. Doing so creates a dependency on a file that is outside the current application. In particular, this reference is not recommended for classpath: URLs (for example, classpath:../services.xml), where the runtime resolution process chooses the \u201cnearest\u201d classpath root and then looks into its parent directory. Classpath configuration changes may lead to the choice of a different, incorrect directory. You can always use fully qualified resource locations instead of relative paths: for example, file:C:/config/services.xml or classpath:/config/services.xml. However, be aware that you are coupling your application\u2019s configuration to specific absolute locations. It is generally preferable to keep an indirection for such absolute locations\u2009\u2014\u2009for example, through \"${\u2026}\" placeholders that are resolved against JVM system properties at runtime. The namespace itself provides the import directive feature. Further configuration features beyond plain bean definitions are available in a selection of XML namespaces provided by Spring\u2009\u2014\u2009for example, the context and util namespaces. The Groovy Bean Definition DSL As a further example for externalized configuration metadata, bean definitions can also be expressed in Spring\u2019s Groovy Bean Definition DSL, as known from the Grails framework.", "chunk_char_count": 1394, "chunk_word_count": 194, "chunk_token_count": 348.5}, {"page_number": 10, "sentence_chunk": "Typically, such configuration live in a \".groovy\" file with the structure shown in the following example: beans { \u00a0  dataSource(BasicDataSource) { \u00a0    driverClassName = \"org.hsqldb.jdbcDriver\" \u00a0    url = \"jdbc:hsqldb:mem:grailsDB\" \u00a0    username = \"sa\" \u00a0    password = \"\" \u00a0    settings = [mynew:\"setting\"] \u00a0  } \u00a0  sessionFactory(SessionFactory) { \u00a0    dataSource = dataSource \u00a0  } \u00a0  myService(MyService) { \u00a0    nestedBean = { AnotherBean bean -> \u00a0      dataSource = dataSource \u00a0    } \u00a0  } } This configuration style is largely equivalent to XML bean definitions and even supports Spring\u2019s XML configuration namespaces. It also allows for importing XML bean definition files through an importBeans directive.10", "chunk_char_count": 710, "chunk_word_count": 136, "chunk_token_count": 177.5}, {"page_number": 11, "sentence_chunk": "Using the Container The ApplicationContext is the interface for an advanced factory capable of maintaining a registry of different beans and their dependencies. By using the method T getBean(String name, Class<T> requiredType), you can retrieve instances of your beans. The ApplicationContext lets you read bean definitions and access them, as the following example shows: Java // create and configure beans ApplicationContext context = new ClassPathXmlApplicationContext(\"services.xml\", \"daos.xml\"); // retrieve configured instance PetStoreService service = context.getBean(\"petStore\", PetStoreService.class); // use configured instance List<String> userList = service.getUsernameList(); Kotlin import org.springframework.beans.factory.getBean // create and configure beans val context = ClassPathXmlApplicationContext(\"services.xml\", \"daos.xml\") // retrieve configured instance val service = context.getBean<PetStoreService>(\"petStore\") // use configured instance var userList = service.getUsernameList() With Groovy configuration, bootstrapping looks very similar. It has a different context implementation class which is Groovy-aware (but also understands XML bean definitions). The following example shows Groovy configuration: Java ApplicationContext context = new GenericGroovyApplicationContext(\"services.groovy\", \"daos.groovy\"); Kotlin val context = GenericGroovyApplicationContext(\"services.groovy\", \"daos.groovy\") The most flexible variant is GenericApplicationContext in combination with reader delegates\u2009\u2014\u2009for example, with XmlBeanDefinitionReader for XML files, as the following example shows: 11", "chunk_char_count": 1610, "chunk_word_count": 177, "chunk_token_count": 402.5}, {"page_number": 12, "sentence_chunk": "Java GenericApplicationContext context = new GenericApplicationContext(); new XmlBeanDefinitionReader(context).loadBeanDefinitions(\"services.xml\", \"daos.xml\"); context.refresh(); Kotlin val context = GenericApplicationContext() XmlBeanDefinitionReader(context).loadBeanDefinitions(\"services.xml\", \"daos.xml\") context.refresh() You can also use the GroovyBeanDefinitionReader for Groovy files, as the following example shows: Java GenericApplicationContext context = new GenericApplicationContext(); new GroovyBeanDefinitionReader(context).loadBeanDefinitions(\"services.groovy\", \"daos.groovy\"); context.refresh(); Kotlin val context = GenericApplicationContext() GroovyBeanDefinitionReader(context).loadBeanDefinitions(\"services.groovy\", \"daos.groovy\") context.refresh() You can mix and match such reader delegates on the same ApplicationContext, reading bean definitions from diverse configuration sources. You can then use getBean to retrieve instances of your beans. The ApplicationContext interface has a few other methods for retrieving beans, but, ideally, your application code should never use them. Indeed, your application code should have no calls to the getBean() method at all and thus have no dependency on Spring APIs at all. For example, Spring\u2019s integration with web frameworks provides dependency injection for various web framework components such as controllers and JSF-managed beans, letting you declare a dependency on a specific bean through metadata (such as an autowiring annotation).2.1.3. Bean Overview A Spring IoC container manages one or more beans. These beans are created with the configuration metadata that you supply to the container (for example, in the form of XML <bean/> definitions). Within the container itself, these bean definitions are represented as BeanDefinition objects, which contain (among other information) the following metadata: \u2022 A package-qualified class name: typically, the actual implementation class of the bean being 12", "chunk_char_count": 1979, "chunk_word_count": 230, "chunk_token_count": 494.75}, {"page_number": 13, "sentence_chunk": "defined. \u2022Bean behavioral configuration elements, which state how the bean should behave in the container (scope, lifecycle callbacks, and so forth). \u2022References to other beans that are needed for the bean to do its work. These references are also called collaborators or dependencies. \u2022Other configuration settings to set in the newly created object\u2009\u2014\u2009for example, the size limit of the pool or the number of connections to use in a bean that manages a connection pool. This metadata translates to a set of properties that make up each bean definition. The following table describes these properties: Table 1. The bean definition Property Explained in\u2026 Class Instantiating Beans Name Naming Beans Scope Bean Scopes Constructor arguments Dependency Injection Properties Dependency Injection Autowiring mode Autowiring Collaborators Lazy initialization mode Lazy-initialized Beans Initialization method Initialization Callbacks Destruction method Destruction Callbacks In addition to bean definitions that contain information on how to create a specific bean, the ApplicationContext implementations also permit the registration of existing objects that are created outside the container (by users). This is done by accessing the ApplicationContext\u2019s BeanFactory through the getBeanFactory() method, which returns the DefaultListableBeanFactory implementation. DefaultListableBeanFactory supports this registration through the registerSingleton(..) and registerBeanDefinition(..) methods.", "chunk_char_count": 1486, "chunk_word_count": 196, "chunk_token_count": 371.5}, {"page_number": 13, "sentence_chunk": "However, typical applications work solely with beans defined through regular bean definition metadata.\uf05a Bean metadata and manually supplied singleton instances need to be registered as early as possible, in order for the container to properly reason about them during autowiring and other introspection steps. While overriding existing metadata and existing singleton instances is supported to some degree, the registration of new beans at runtime (concurrently with live access to the factory) is not officially supported and may lead to concurrent access exceptions, inconsistent state in the bean container, or both. Naming Beans Every bean has one or more identifiers. These identifiers must be unique within the container that hosts the bean. A bean usually has only one identifier. However, if it requires more than one, the 13", "chunk_char_count": 833, "chunk_word_count": 127, "chunk_token_count": 208.25}, {"page_number": 14, "sentence_chunk": "extra ones can be considered aliases. In XML-based configuration metadata, you use the id attribute, the name attribute, or both to specify the bean identifiers. The id attribute lets you specify exactly one id. Conventionally, these names are alphanumeric ('myBean', 'someService', etc.),but they can contain special characters as well. If you want to introduce other aliases for the bean, you can also specify them in the name attribute, separated by a comma (,), semicolon (;), or white space. As a historical note, in versions prior to Spring 3.1, the id attribute was defined as an xsd:ID type, which constrained possible characters. As of 3.1, it is defined as an xsd:string type. Note that bean id uniqueness is still enforced by the container, though no longer by XML parsers. You are not required to supply a name or an id for a bean. If you do not supply a name or id explicitly, the container generates a unique name for that bean.", "chunk_char_count": 942, "chunk_word_count": 161, "chunk_token_count": 235.5}, {"page_number": 14, "sentence_chunk": "However, if you want to refer to that bean by name, through the use of the ref element or a Service Locator style lookup, you must provide a name. Motivations for not supplying a name are related to using inner beans and autowiring collaborators. Bean Naming Conventions The convention is to use the standard Java convention for instance field names when naming beans. That is, bean names start with a lowercase letter and are camel-cased from there. Examples of such names include accountManager, accountService, userDao, loginController, and so forth. Naming beans consistently makes your configuration easier to read and understand. Also, if you use Spring AOP, it helps a lot when applying advice to a set of beans related by name.\uf05a With component scanning in the classpath, Spring generates bean names for unnamed components, following the rules described earlier: essentially, taking the simple class name and turning its initial character to lower-case. However, in the (unusual) special case when there is more than one character and both the first and second characters are upper case, the original casing gets preserved. These are the same rules as defined by java.beans. Introspector.decapitalize (which Spring uses here).", "chunk_char_count": 1233, "chunk_word_count": 194, "chunk_token_count": 308.25}, {"page_number": 14, "sentence_chunk": "Aliasing a Bean outside the Bean Definition In a bean definition itself, you can supply more than one name for the bean, by using a combination of up to one name specified by the id attribute and any number of other names in the name attribute. These names can be equivalent aliases to the same bean and are useful for some situations, such as letting each component in an application refer to a common dependency by using a bean name that is specific to that component itself. Specifying all aliases where the bean is actually defined is not always adequate, however. It is sometimes desirable to introduce an alias for a bean that is defined elsewhere. This is commonly the case in large systems where configuration is split amongst each subsystem, with each subsystem having its own set of object definitions. In XML-based configuration metadata, you can use the <alias/> element to accomplish this. The following example shows how to do so: 14", "chunk_char_count": 947, "chunk_word_count": 163, "chunk_token_count": 236.75}, {"page_number": 15, "sentence_chunk": "<alias name=\"fromName\" alias=\"toName\"/> In this case, a bean (in the same container) named fromName may also, after the use of this alias definition, be referred to as toName. For example, the configuration metadata for subsystem A may refer to a DataSource by the name of subsystemA-dataSource. The configuration metadata for subsystem B may refer to a DataSource by the name of subsystemB-dataSource. When composing the main application that uses both these subsystems, the main application refers to the DataSource by the name of myApp-dataSource. To have all three names refer to the same object, you can add the following alias definitions to the configuration metadata: <alias name=\"myApp-dataSource\" alias=\"subsystemA-dataSource\"/> <alias name=\"myApp-dataSource\" alias=\"subsystemB-dataSource\"/> Now each component and the main application can refer to the dataSource through a name that is unique and guaranteed not to clash with any other definition (effectively creating a namespace), yet they refer to the same bean. Java-configuration If you use Javaconfiguration, the @Bean annotation can be used to provide aliases. See Using the @Bean Annotation for details. Instantiating Beans A bean definition is essentially a recipe for creating one or more objects. The container looks at the recipe for a named bean when asked and uses the configuration metadata encapsulated by that bean definition to create (or acquire) an actual object. If you use XML-based configuration metadata, you specify the type (or class) of object that is to be instantiated in the class attribute of the <bean/> element.", "chunk_char_count": 1605, "chunk_word_count": 241, "chunk_token_count": 401.25}, {"page_number": 15, "sentence_chunk": "This class attribute (which, internally, is a Class property on a BeanDefinition instance) is usually mandatory. (For exceptions, see Instantiation by Using an Instance Factory Method and Bean Definition Inheritance.)You can use the Class property in one of two ways: \u2022 Typically, to specify the bean class to be constructed in the case where the container itself directly creates the bean by calling its constructor reflectively, somewhat equivalent to Java code with the new operator. \u2022To specify the actual class containing the static factory method that is invoked to create the object, in the less common case where the container invokes a static factory method on a class to create the bean. The object type returned from the invocation of the static factory method may be the same class or another class entirely.15", "chunk_char_count": 822, "chunk_word_count": 133, "chunk_token_count": 205.5}, {"page_number": 16, "sentence_chunk": "Nested class names If you want to configure a bean definition for a nested class, you may use either the binary name or the source name of the nested class. For example, if you have a class called SomeThing in the com.example package, and this SomeThing class has a static nested class called OtherThing, they can be separated by a dollar sign ($) or a dot (.). So the value of the class attribute in a bean definition would be com.example. SomeThing$OtherThing or com.example. SomeThing. OtherThing. Instantiation with a Constructor When you create a bean by the constructor approach, all normal classes are usable by and compatible with Spring. That is, the class being developed does not need to implement any specific interfaces or to be coded in a specific fashion. Simply specifying the bean class should suffice. However, depending on what type of IoC you use for that specific bean, you may need a default (empty) constructor.", "chunk_char_count": 934, "chunk_word_count": 158, "chunk_token_count": 233.5}, {"page_number": 16, "sentence_chunk": "The Spring IoC container can manage virtually any class you want it to manage. It is not limited to managing true JavaBeans. Most Spring users prefer actual JavaBeans with only a default (no- argument) constructor and appropriate setters and getters modeled after the properties in the container. You can also have more exotic non-bean-style classes in your container. If, for example, you need to use a legacy connection pool that absolutely does not adhere to the JavaBean specification, Spring can manage it as well. With XML-based configuration metadata you can specify your bean class as follows: <bean id=\"exampleBean\" class=\"examples. ExampleBean\"/> <bean name=\"anotherExample\" class=\"examples. ExampleBeanTwo\"/> For details about the mechanism for supplying arguments to the constructor (if required) and setting object instance properties after the object is constructed, see Injecting Dependencies. Instantiation with a Static Factory Method When defining a bean that you create with a static factory method, use the class attribute to specify the class that contains the static factory method and an attribute named factory-method to specify the name of the factory method itself. You should be able to call this method (with optional arguments, as described later) and return a live object, which subsequently is treated as if it had been created through a constructor.", "chunk_char_count": 1381, "chunk_word_count": 208, "chunk_token_count": 345.25}, {"page_number": 16, "sentence_chunk": "One use for such a bean definition is to call static factories in legacy code. The following bean definition specifies that the bean will be created by calling a factory method. The definition does not specify the type (class) of the returned object, but rather the class containing the factory method. In this example, the createInstance() method must be a static method. The following example shows how to specify a factory method: 16", "chunk_char_count": 436, "chunk_word_count": 73, "chunk_token_count": 109.0}, {"page_number": 17, "sentence_chunk": "<bean id=\"clientService\" \u00a0  class=\"examples. ClientService\" \u00a0  factory-method=\"createInstance\"/> The following example shows a class that would work with the preceding bean definition: Java public class ClientService { \u00a0  private static ClientService clientService = new ClientService(); \u00a0  private ClientService() {} \u00a0  public static ClientService createInstance() { \u00a0    return clientService; \u00a0  } } Kotlin class ClientService private constructor() { \u00a0  companion object { \u00a0    private val clientService = ClientService() \u00a0    @JvmStatic \u00a0    fun createInstance() = clientService \u00a0  } } For details about the mechanism for supplying (optional) arguments to the factory method and setting object instance properties after the object is returned from the factory, see Dependencies and Configuration in Detail. Instantiation by Using an Instance Factory Method Similar to instantiation through a static factory method, instantiation with an instance factory method invokes a non-static method of an existing bean from the container to create a new bean. To use this mechanism, leave the class attribute empty and, in the factory-bean attribute, specify the name of a bean in the current (or parent or ancestor) container that contains the instance method that is to be invoked to create the object. Set the name of the factory method itself with the factory-method attribute. The following example shows how to configure such a bean: 17", "chunk_char_count": 1435, "chunk_word_count": 230, "chunk_token_count": 358.75}, {"page_number": 18, "sentence_chunk": "<!--the factory bean, which contains a method called createInstance() --> <bean id=\"serviceLocator\" class=\"examples. DefaultServiceLocator\"> \u00a0  <!--inject any dependencies required by this locator bean --> </bean> <!--the bean to be created via the factory bean --> <bean id=\"clientService\" \u00a0  factory-bean=\"serviceLocator\" \u00a0  factory-method=\"createClientServiceInstance\"/> The following example shows the corresponding class: Java public class DefaultServiceLocator { \u00a0  private static ClientService clientService = new ClientServiceImpl(); \u00a0  public ClientService createClientServiceInstance() { \u00a0    return clientService; \u00a0  } } Kotlin class DefaultServiceLocator { \u00a0  companion object { \u00a0    private val clientService = ClientServiceImpl() \u00a0  } \u00a0  fun createClientServiceInstance(): ClientService { \u00a0    return clientService \u00a0  } } One factory class can also hold more than one factory method, as the following example shows: <bean id=\"serviceLocator\" class=\"examples. DefaultServiceLocator\"> \u00a0  <!--inject any dependencies required by this locator bean --> </bean> <bean id=\"clientService\" \u00a0  factory-bean=\"serviceLocator\" \u00a0  factory-method=\"createClientServiceInstance\"/> <bean id=\"accountService\" \u00a0  factory-bean=\"serviceLocator\" \u00a0  factory-method=\"createAccountServiceInstance\"/> 18", "chunk_char_count": 1290, "chunk_word_count": 167, "chunk_token_count": 322.5}, {"page_number": 19, "sentence_chunk": "The following example shows the corresponding class: Java public class DefaultServiceLocator { \u00a0  private static ClientService clientService = new ClientServiceImpl(); \u00a0  private static AccountService accountService = new AccountServiceImpl(); \u00a0  public ClientService createClientServiceInstance() { \u00a0    return clientService; \u00a0  } \u00a0  public AccountService createAccountServiceInstance() { \u00a0    return accountService; \u00a0  } } Kotlin class DefaultServiceLocator { \u00a0  companion object { \u00a0    private val clientService = ClientServiceImpl() \u00a0    private val accountService = AccountServiceImpl() \u00a0  } \u00a0  fun createClientServiceInstance(): ClientService { \u00a0    return clientService \u00a0  } \u00a0  fun createAccountServiceInstance(): AccountService { \u00a0    return accountService \u00a0  } } This approach shows that the factory bean itself can be managed and configured through dependency injection (DI). See Dependencies and Configuration in Detail.\uf05a In Spring documentation, \"factory bean\" refers to a bean that is configured in the Spring container and that creates objects through an instance or static factory method. By contrast, FactoryBean (notice the capitalization) refers to a Spring- specific FactoryBean implementation class. Determining a Bean\u2019s Runtime Type The runtime type of a specific bean is non-trivial to determine. A specified class in the bean metadata definition is just an initial class reference, potentially combined with a declared factory method or being a FactoryBean class which may lead to a different runtime type of the bean, or not 19", "chunk_char_count": 1551, "chunk_word_count": 242, "chunk_token_count": 387.75}, {"page_number": 20, "sentence_chunk": "being set at all in case of an instance-level factory method (which is resolved via the specified factory-bean name instead). Additionally, AOP proxying may wrap a bean instance with an interface-based proxy with limited exposure of the target bean\u2019s actual type (just its implemented interfaces). The recommended way to find out about the actual runtime type of a particular bean is a BeanFactory.getType call for the specified bean name. This takes all of the above cases into account and returns the type of object that a BeanFactory.getBean call is going to return for the same bean name.2.1.4. Dependencies A typical enterprise application does not consist of a single object (or bean in the Spring parlance). Even the simplest application has a few objects that work together to present what the end-user sees as a coherent application. This next section explains how you go from defining a number of bean definitions that stand alone to a fully realized application where objects collaborate to achieve a goal. Dependency Injection Dependency injection (DI) is a process whereby objects define their dependencies (that is, the other objects with which they work) only through constructor arguments, arguments to a factory method, or properties that are set on the object instance after it is constructed or returned from a factory method. The container then injects those dependencies when it creates the bean.", "chunk_char_count": 1417, "chunk_word_count": 226, "chunk_token_count": 354.25}, {"page_number": 20, "sentence_chunk": "This process is fundamentally the inverse (hence the name, Inversion of Control) of the bean itself controlling the instantiation or location of its dependencies on its own by using direct construction of classes or the Service Locator pattern. Code is cleaner with the DI principle, and decoupling is more effective when objects are provided with their dependencies. The object does not look up its dependencies and does not know the location or class of the dependencies. As a result, your classes become easier to test, particularly when the dependencies are on interfaces or abstract base classes, which allow for stub or mock implementations to be used in unit tests. DI exists in two major variants: Constructor-based dependency injection and Setter-based dependency injection. Constructor-based Dependency Injection Constructor-based DI is accomplished by the container invoking a constructor with a number of arguments, each representing a dependency. Calling a static factory method with specific arguments to construct the bean is nearly equivalent, and this discussion treats arguments to a constructor and to a static factory method similarly. The following example shows a class that can only be dependency-injected with constructor injection: 20", "chunk_char_count": 1259, "chunk_word_count": 189, "chunk_token_count": 314.75}, {"page_number": 21, "sentence_chunk": "Java public class SimpleMovieLister { \u00a0  // the SimpleMovieLister has a dependency on a MovieFinder \u00a0  private final MovieFinder movieFinder; \u00a0  // a constructor so that the Spring container can inject a MovieFinder \u00a0  public SimpleMovieLister(MovieFinder movieFinder) { \u00a0    this.movieFinder = movieFinder; \u00a0  } \u00a0  // business logic that actually uses the injected MovieFinder is omitted... } Kotlin // a constructor so that the Spring container can inject a MovieFinder class SimpleMovieLister(private val movieFinder: MovieFinder) { \u00a0  // business logic that actually uses the injected MovieFinder is omitted... } Notice that there is nothing special about this class. It is a POJO that has no dependencies on container specific interfaces, base classes, or annotations. Constructor Argument Resolution Constructor argument resolution matching occurs by using the argument\u2019s type. If no potential ambiguity exists in the constructor arguments of a bean definition, the order in which the constructor arguments are defined in a bean definition is the order in which those arguments are supplied to the appropriate constructor when the bean is being instantiated. Consider the following class: Java package x.y; public class ThingOne { \u00a0  public ThingOne(ThingTwo thingTwo, ThingThree thingThree) { \u00a0    // ... \u00a0  } } 21", "chunk_char_count": 1321, "chunk_word_count": 212, "chunk_token_count": 330.25}, {"page_number": 22, "sentence_chunk": "Kotlin package x.y class ThingOne(thingTwo: ThingTwo, thingThree: ThingThree) Assuming that the ThingTwo and ThingThree classes are not related by inheritance, no potential ambiguity exists. Thus, the following configuration works fine, and you do not need to specify the constructor argument indexes or types explicitly in the <constructor-arg/> element.<beans> \u00a0  <bean id=\"beanOne\" class=\"x.y. ThingOne\"> \u00a0    <constructor-arg ref=\"beanTwo\"/> \u00a0    <constructor-arg ref=\"beanThree\"/> \u00a0  </bean> \u00a0  <bean id=\"beanTwo\" class=\"x.y. ThingTwo\"/> \u00a0  <bean id=\"beanThree\" class=\"x.y. ThingThree\"/> </beans> When another bean is referenced, the type is known, and matching can occur (as was the case with the preceding example). When a simple type is used, such as <value>true</value>, Spring cannot determine the type of the value, and so cannot match by type without help. Consider the following class: Java package examples; public class ExampleBean { \u00a0  // Number of years to calculate the Ultimate Answer \u00a0  private final int years; \u00a0  // The Answer to Life, the Universe, and Everything \u00a0  private final String ultimateAnswer; \u00a0  public ExampleBean(int years, String ultimateAnswer) { \u00a0    this.years = years; \u00a0    this.ultimateAnswer = ultimateAnswer; \u00a0  } } 22", "chunk_char_count": 1262, "chunk_word_count": 200, "chunk_token_count": 315.5}, {"page_number": 23, "sentence_chunk": "Kotlin package examples class ExampleBean( \u00a0  private val years: Int, // Number of years to calculate the Ultimate Answer \u00a0  private val ultimateAnswer: String // The Answer to Life, the Universe, and Everything ) Constructor argument type matching In the preceding scenario, the container can use type matching with simple types if you explicitly specify the type of the constructor argument by using the type attribute, as the following example shows: <bean id=\"exampleBean\" class=\"examples. ExampleBean\"> \u00a0  <constructor-arg type=\"int\" value=\"7500000\"/> \u00a0  <constructor-arg type=\"java.lang. String\" value=\"42\"/> </bean> Constructor argument index You can use the index attribute to specify explicitly the index of constructor arguments, as the following example shows: <bean id=\"exampleBean\" class=\"examples. ExampleBean\"> \u00a0  <constructor-arg index=\"0\" value=\"7500000\"/> \u00a0  <constructor-arg index=\"1\" value=\"42\"/> </bean> In addition to resolving the ambiguity of multiple simple values, specifying an index resolves ambiguity where a constructor has two arguments of the same type.\uf05a The index is 0-based. Constructor argument name You can also use the constructor parameter name for value disambiguation, as the following example shows: <bean id=\"exampleBean\" class=\"examples. ExampleBean\"> \u00a0  <constructor-arg name=\"years\" value=\"7500000\"/> \u00a0  <constructor-arg name=\"ultimateAnswer\" value=\"42\"/> </bean> Keep in mind that, to make this work out of the box, your code must be compiled with the debug flag enabled so that Spring can look up the parameter name from the constructor. If you cannot or 23", "chunk_char_count": 1604, "chunk_word_count": 228, "chunk_token_count": 401.0}, {"page_number": 24, "sentence_chunk": "do not want to compile your code with the debug flag, you can use the @ConstructorProperties JDK annotation to explicitly name your constructor arguments. The sample class would then have to look as follows: Java package examples; public class ExampleBean { \u00a0  // Fields omitted \u00a0  @ConstructorProperties({\"years\", \"ultimateAnswer\"}) \u00a0  public ExampleBean(int years, String ultimateAnswer) { \u00a0    this.years = years; \u00a0    this.ultimateAnswer = ultimateAnswer; \u00a0  } } Kotlin package examples class ExampleBean @ConstructorProperties(\"years\", \"ultimateAnswer\") constructor(val years: Int, val ultimateAnswer: String) Setter-based Dependency Injection Setter-based DI is accomplished by the container calling setter methods on your beans after invoking a no-argument constructor or a no-argument static factory method to instantiate your bean. The following example shows a class that can only be dependency-injected by using pure setter injection. This class is conventional Java. It is a POJO that has no dependencies on container specific interfaces, base classes, or annotations.24", "chunk_char_count": 1082, "chunk_word_count": 157, "chunk_token_count": 270.5}, {"page_number": 25, "sentence_chunk": "Java public class SimpleMovieLister { \u00a0  // the SimpleMovieLister has a dependency on the MovieFinder \u00a0  private MovieFinder movieFinder; \u00a0  // a setter method so that the Spring container can inject a MovieFinder \u00a0  public void setMovieFinder(MovieFinder movieFinder) { \u00a0    this.movieFinder = movieFinder; \u00a0  } \u00a0  // business logic that actually uses the injected MovieFinder is omitted... } Kotlin class SimpleMovieLister { \u00a0  // a late-initialized property so that the Spring container can inject a MovieFinder \u00a0  lateinit var movieFinder: MovieFinder \u00a0  // business logic that actually uses the injected MovieFinder is omitted... } The ApplicationContext supports constructor-based and setter-based DI for the beans it manages. It also supports setter-based DI after some dependencies have already been injected through the constructor approach. You configure the dependencies in the form of a BeanDefinition, which you use in conjunction with PropertyEditor instances to convert properties from one format to another. However, most Spring users do not work with these classes directly (that is, programmatically) but rather with XML bean definitions, annotated components (that is, classes annotated with @Component, @Controller, and so forth), or @Bean methods in Java-based @Configuration classes. These sources are then converted internally into instances of BeanDefinition and used to load an entire Spring IoC container instance.25", "chunk_char_count": 1442, "chunk_word_count": 219, "chunk_token_count": 360.5}, {"page_number": 26, "sentence_chunk": "Constructor-based or setter-based DI?Since you can mix constructor-based and setter-based DI, it is a good rule of thumb to use constructors for mandatory dependencies and setter methods or configuration methods for optional dependencies. Note that use of the @Autowired annotation on a setter method can be used to make the property be a required dependency; however, constructor injection with programmatic validation of arguments is preferable. The Spring team generally advocates constructor injection, as it lets you implement application components as immutable objects and ensures that required dependencies are not null. Furthermore, constructor-injected components are always returned to the client (calling) code in a fully initialized state. As a side note, a large number of constructor arguments is a bad code smell, implying that the class likely has too many responsibilities and should be refactored to better address proper separation of concerns. Setter injection should primarily only be used for optional dependencies that can be assigned reasonable default values within the class. Otherwise, not-null checks must be performed everywhere the code uses the dependency. One benefit of setter injection is that setter methods make objects of that class amenable to reconfiguration or re-injection later. Management through JMX MBeans is therefore a compelling use case for setter injection.", "chunk_char_count": 1408, "chunk_word_count": 206, "chunk_token_count": 352.0}, {"page_number": 26, "sentence_chunk": "Use the DI style that makes the most sense for a particular class. Sometimes, when dealing with third-party classes for which you do not have the source, the choice is made for you. For example, if a third-party class does not expose any setter methods, then constructor injection may be the only available form of DI. Dependency Resolution Process The container performs bean dependency resolution as follows: \u2022 The ApplicationContext is created and initialized with configuration metadata that describes all the beans. Configuration metadata can be specified by XML, Java code, or annotations. \u2022For each bean, its dependencies are expressed in the form of properties, constructor arguments, or arguments to the static-factory method (if you use that instead of a normal constructor). These dependencies are provided to the bean, when the bean is actually created. \u2022Each property or constructor argument is an actual definition of the value to set, or a reference to another bean in the container. \u2022Each property or constructor argument that is a value is converted from its specified format to the actual type of that property or constructor argument. By default, Spring can convert a value supplied in string format to all built-in types, such as int, long, String, boolean, and so forth.", "chunk_char_count": 1291, "chunk_word_count": 207, "chunk_token_count": 322.75}, {"page_number": 26, "sentence_chunk": "The Spring container validates the configuration of each bean as the container is created. However, the bean properties themselves are not set until the bean is actually created. Beans that are singleton-scoped and set to be pre-instantiated (the default) are created when the container is created. Scopes are defined in Bean Scopes. Otherwise, the bean is created only when it is requested. Creation of a bean potentially causes a graph of beans to be created, as the bean\u2019s dependencies and its dependencies' dependencies (and so on) are created and assigned. Note that 26", "chunk_char_count": 574, "chunk_word_count": 93, "chunk_token_count": 143.5}, {"page_number": 27, "sentence_chunk": "resolution mismatches among those dependencies may show up late\u2009\u2014\u2009that is, on first creation of the affected bean. Circular dependencies If you use predominantly constructor injection, it is possible to create an unresolvable circular dependency scenario. For example: Class A requires an instance of class B through constructor injection, and class B requires an instance of class A through constructor injection. If you configure beans for classes A and B to be injected into each other, the Spring IoC container detects this circular reference at runtime, and throws a BeanCurrentlyInCreationException. One possible solution is to edit the source code of some classes to be configured by setters rather than constructors. Alternatively, avoid constructor injection and use setter injection only. In other words, although it is not recommended, you can configure circular dependencies with setter injection. Unlike the typical case (with no circular dependencies), a circular dependency between bean A and bean B forces one of the beans to be injected into the other prior to being fully initialized itself (a classic chicken-and-egg scenario). You can generally trust Spring to do the right thing. It detects configuration problems, such as references to non-existent beans and circular dependencies, at container load-time.", "chunk_char_count": 1327, "chunk_word_count": 198, "chunk_token_count": 331.75}, {"page_number": 27, "sentence_chunk": "Spring sets properties and resolves dependencies as late as possible, when the bean is actually created. This means that a Spring container that has loaded correctly can later generate an exception when you request an object if there is a problem creating that object or one of its dependencies\u2009\u2014\u2009for example, the bean throws an exception as a result of a missing or invalid property. This potentially delayed visibility of some configuration issues is why ApplicationContext implementations by default pre-instantiate singleton beans. At the cost of some upfront time and memory to create these beans before they are actually needed, you discover configuration issues when the ApplicationContext is created, not later. You can still override this default behavior so that singleton beans initialize lazily, rather than being eagerly pre-instantiated. If no circular dependencies exist, when one or more collaborating beans are being injected into a dependent bean, each collaborating bean is totally configured prior to being injected into the dependent bean. This means that, if bean A has a dependency on bean B, the Spring IoC container completely configures bean B prior to invoking the setter method on bean A. In other words, the bean is instantiated (if it is not a pre-instantiated singleton), its dependencies are set, and the relevant lifecycle methods (such as a configured init method or the InitializingBean callback method) are invoked. Examples of Dependency Injection The following example uses XML-based configuration metadata for setter-based DI. A small part of a Spring XML configuration file specifies some bean definitions as follows: 27", "chunk_char_count": 1660, "chunk_word_count": 255, "chunk_token_count": 415.0}, {"page_number": 28, "sentence_chunk": "<bean id=\"exampleBean\" class=\"examples. ExampleBean\"> \u00a0  <!--setter injection using the nested ref element --> \u00a0  <property name=\"beanOne\"> \u00a0    <ref bean=\"anotherExampleBean\"/> \u00a0  </property> \u00a0  <!--setter injection using the neater ref attribute --> \u00a0  <property name=\"beanTwo\" ref=\"yetAnotherBean\"/> \u00a0  <property name=\"integerProperty\" value=\"1\"/> </bean> <bean id=\"anotherExampleBean\" class=\"examples. AnotherBean\"/> <bean id=\"yetAnotherBean\" class=\"examples. YetAnotherBean\"/> The following example shows the corresponding ExampleBean class: Java public class ExampleBean { \u00a0  private AnotherBean beanOne; \u00a0  private YetAnotherBean beanTwo; \u00a0  private int i; \u00a0  public void setBeanOne(AnotherBean beanOne) { \u00a0    this.beanOne = beanOne; \u00a0  } \u00a0  public void setBeanTwo(YetAnotherBean beanTwo) { \u00a0    this.beanTwo = beanTwo; \u00a0  } \u00a0  public void setIntegerProperty(int i) { \u00a0    this.i = i; \u00a0  } } Kotlin class ExampleBean { \u00a0  lateinit var beanOne: AnotherBean \u00a0  lateinit var beanTwo: YetAnotherBean \u00a0  var i: Int = 0 } In the preceding example, setters are declared to match against the properties specified in the XML 28", "chunk_char_count": 1126, "chunk_word_count": 177, "chunk_token_count": 281.5}, {"page_number": 29, "sentence_chunk": "file. The following example uses constructor-based DI: <bean id=\"exampleBean\" class=\"examples. ExampleBean\"> \u00a0  <!--constructor injection using the nested ref element --> \u00a0  <constructor-arg> \u00a0    <ref bean=\"anotherExampleBean\"/> \u00a0  </constructor-arg> \u00a0  <!--constructor injection using the neater ref attribute --> \u00a0  <constructor-arg ref=\"yetAnotherBean\"/> \u00a0  <constructor-arg type=\"int\" value=\"1\"/> </bean> <bean id=\"anotherExampleBean\" class=\"examples. AnotherBean\"/> <bean id=\"yetAnotherBean\" class=\"examples. YetAnotherBean\"/> The following example shows the corresponding ExampleBean class: Java public class ExampleBean { \u00a0  private AnotherBean beanOne; \u00a0  private YetAnotherBean beanTwo; \u00a0  private int i; \u00a0  public ExampleBean( \u00a0    AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) { \u00a0    this.beanOne = anotherBean; \u00a0    this.beanTwo = yetAnotherBean; \u00a0    this.i = i; \u00a0  } } Kotlin class ExampleBean( \u00a0    private val beanOne: AnotherBean, \u00a0    private val beanTwo: YetAnotherBean, \u00a0    private val i: Int) The constructor arguments specified in the bean definition are used as arguments to the constructor of the ExampleBean. Now consider a variant of this example, where, instead of using a constructor, Spring is told to call a static factory method to return an instance of the object: 29", "chunk_char_count": 1318, "chunk_word_count": 204, "chunk_token_count": 329.5}, {"page_number": 30, "sentence_chunk": "<bean id=\"exampleBean\" class=\"examples. ExampleBean\" factory-method=\"createInstance\"> \u00a0  <constructor-arg ref=\"anotherExampleBean\"/> \u00a0  <constructor-arg ref=\"yetAnotherBean\"/> \u00a0  <constructor-arg value=\"1\"/> </bean> <bean id=\"anotherExampleBean\" class=\"examples. AnotherBean\"/> <bean id=\"yetAnotherBean\" class=\"examples. YetAnotherBean\"/> The following example shows the corresponding ExampleBean class: Java public class ExampleBean { \u00a0  // a private constructor \u00a0  private ExampleBean(...) { \u00a0    ... \u00a0  } \u00a0  // a static factory method; the arguments to this method can be \u00a0  // considered the dependencies of the bean that is returned, \u00a0  // regardless of how those arguments are actually used.\u00a0  public static ExampleBean createInstance ( \u00a0    AnotherBean anotherBean, YetAnotherBean yetAnotherBean, int i) { \u00a0    ExampleBean eb = new ExampleBean (...); \u00a0    // some other operations... \u00a0    return eb; \u00a0  } } Kotlin class ExampleBean private constructor() { \u00a0  companion object { \u00a0    // a static factory method; the arguments to this method can be \u00a0    // considered the dependencies of the bean that is returned, \u00a0    // regardless of how those arguments are actually used.\u00a0    @JvmStatic \u00a0    fun createInstance(anotherBean: AnotherBean, yetAnotherBean: YetAnotherBean, i: Int): ExampleBean { \u00a0      val eb = ExampleBean (...) \u00a0      // some other operations... \u00a0      return eb \u00a0    } \u00a0  } } 30", "chunk_char_count": 1403, "chunk_word_count": 250, "chunk_token_count": 350.75}, {"page_number": 31, "sentence_chunk": "Arguments to the static factory method are supplied by <constructor-arg/> elements, exactly the same as if a constructor had actually been used. The type of the class being returned by the factory method does not have to be of the same type as the class that contains the static factory method (although, in this example, it is). An instance (non-static) factory method can be used in an essentially identical fashion (aside from the use of the factory-bean attribute instead of the class attribute), so we do not discuss those details here. Dependencies and Configuration in Detail As mentioned in the previous section, you can define bean properties and constructor arguments as references to other managed beans (collaborators) or as values defined inline. Spring\u2019s XML-based configuration metadata supports sub-element types within its <property/> and <constructor-arg/> elements for this purpose. Straight Values (Primitives, Strings, and so on) The value attribute of the <property/> element specifies a property or constructor argument as a human-readable string representation. Spring\u2019s conversion service is used to convert these values from a String to the actual type of the property or argument. The following example shows various values being set: <bean id=\"myDataSource\" class=\"org.apache.commons.dbcp. BasicDataSource\" destroy- method=\"close\"> \u00a0  <!--results in a setDriverClassName(String) call --> \u00a0  <property name=\"driverClassName\" value=\"com.mysql.jdbc.", "chunk_char_count": 1474, "chunk_word_count": 211, "chunk_token_count": 368.5}, {"page_number": 31, "sentence_chunk": "Driver\"/> \u00a0  <property name=\"url\" value=\"jdbc:mysql://localhost:3306/mydb\"/> \u00a0  <property name=\"username\" value=\"root\"/> \u00a0  <property name=\"password\" value=\"misterkaoli\"/> </bean> The following example uses the p-namespace for even more succinct XML configuration: <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:p=\"http://www.springframework.org/schema/p\" \u00a0  xsi:schemaLocation=\"http://www.springframework.org/schema/beans \u00a0  https://www.springframework.org/schema/beans/spring-beans.xsd\"> \u00a0  <bean id=\"myDataSource\" class=\"org.apache.commons.dbcp. BasicDataSource\" \u00a0    destroy-method=\"close\" \u00a0    p:driverClassName=\"com.mysql.jdbc. Driver\" \u00a0    p:url=\"jdbc:mysql://localhost:3306/mydb\" \u00a0    p:username=\"root\" \u00a0    p:password=\"misterkaoli\"/> </beans> The preceding XML is more succinct. However, typos are discovered at runtime rather than design 31", "chunk_char_count": 928, "chunk_word_count": 92, "chunk_token_count": 232.0}, {"page_number": 32, "sentence_chunk": "time, unless you use an IDE (such as IntelliJ IDEA or the Spring Tools for Eclipse) that supports automatic property completion when you create bean definitions. Such IDE assistance is highly recommended. You can also configure a java.util. Properties instance, as follows: <bean id=\"mappings\" \u00a0  class=\"org.springframework.context.support. PropertySourcesPlaceholderConfigurer\"> \u00a0  <!--typed as a java.util. Properties --> \u00a0  <property name=\"properties\"> \u00a0    <value> \u00a0      jdbc.driver.className=com.mysql.jdbc. Driver \u00a0      jdbc.url=jdbc:mysql://localhost:3306/mydb \u00a0    </value> \u00a0  </property> </bean> The Spring container converts the text inside the <value/> element into a java.util. Properties instance by using the JavaBeans PropertyEditor mechanism. This is a nice shortcut, and is one of a few places where the Spring team do favor the use of the nested <value/> element over the value attribute style.", "chunk_char_count": 914, "chunk_word_count": 140, "chunk_token_count": 228.5}, {"page_number": 32, "sentence_chunk": "The idref element The idref element is simply an error-proof way to pass the id (a string value - not a reference) of another bean in the container to a <constructor-arg/> or <property/> element. The following example shows how to use it: <bean id=\"theTargetBean\" class=\"...\"/> <bean id=\"theClientBean\" class=\"...\"> \u00a0  <property name=\"targetName\"> \u00a0    <idref bean=\"theTargetBean\"/> \u00a0  </property> </bean> The preceding bean definition snippet is exactly equivalent (at runtime) to the following snippet: <bean id=\"theTargetBean\" class=\"...\" /> <bean id=\"client\" class=\"...\"> \u00a0  <property name=\"targetName\" value=\"theTargetBean\"/> </bean> The first form is preferable to the second, because using the idref tag lets the container validate at deployment time that the referenced, named bean actually exists. In the second variation, no 32", "chunk_char_count": 837, "chunk_word_count": 122, "chunk_token_count": 209.25}, {"page_number": 33, "sentence_chunk": "validation is performed on the value that is passed to the targetName property of the client bean. Typos are only discovered (with most likely fatal results) when the client bean is actually instantiated. If the client bean is a prototype bean, this typo and the resulting exception may only be discovered long after the container is deployed.\uf05a The local attribute on the idref element is no longer supported in the 4.0 beans XSD, since it does not provide value over a regular bean reference any more. Change your existing idref local references to idref bean when upgrading to the 4.0 schema. A common place (at least in versions earlier than Spring 2.0) where the <idref/> element brings value is in the configuration of AOP interceptors in a ProxyFactoryBean bean definition. Using <idref/> elements when you specify the interceptor names prevents you from misspelling an interceptor ID. References to Other Beans (Collaborators) The ref element is the final element inside a <constructor-arg/> or <property/> definition element. Here, you set the value of the specified property of a bean to be a reference to another bean (a collaborator) managed by the container. The referenced bean is a dependency of the bean whose property is to be set, and it is initialized on demand as needed before the property is set. (", "chunk_char_count": 1319, "chunk_word_count": 219, "chunk_token_count": 329.75}, {"page_number": 33, "sentence_chunk": "If the collaborator is a singleton bean, it may already be initialized by the container.)All references are ultimately a reference to another object. Scoping and validation depend on whether you specify the ID or name of the other object through the bean or parent attribute. Specifying the target bean through the bean attribute of the <ref/> tag is the most general form and allows creation of a reference to any bean in the same container or parent container, regardless of whether it is in the same XML file. The value of the bean attribute may be the same as the id attribute of the target bean or be the same as one of the values in the name attribute of the target bean. The following example shows how to use a ref element: <ref bean=\"someBean\"/> Specifying the target bean through the parent attribute creates a reference to a bean that is in a parent container of the current container. The value of the parent attribute may be the same as either the id attribute of the target bean or one of the values in the name attribute of the target bean. The target bean must be in a parent container of the current one. You should use this bean reference variant mainly when you have a hierarchy of containers and you want to wrap an existing bean in a parent container with a proxy that has the same name as the parent bean. The following pair of listings shows how to use the parent attribute: <!--", "chunk_char_count": 1402, "chunk_word_count": 256, "chunk_token_count": 350.5}, {"page_number": 33, "sentence_chunk": "in the parent context --> <bean id=\"accountService\" class=\"com.something. SimpleAccountService\"> \u00a0  <!--insert dependencies as required here --> </bean> 33", "chunk_char_count": 155, "chunk_word_count": 19, "chunk_token_count": 38.75}, {"page_number": 34, "sentence_chunk": "<!--in the child (descendant) context --> <bean id=\"accountService\" <!--bean name is the same as the parent bean --> \u00a0  class=\"org.springframework.aop.framework. ProxyFactoryBean\"> \u00a0  <property name=\"target\"> \u00a0    <ref parent=\"accountService\"/> <!--notice how we refer to the parent bean --> \u00a0  </property> \u00a0  <!--insert other configuration and dependencies as required here --> </bean> \uf05a The local attribute on the ref element is no longer supported in the 4.0 beans XSD, since it does not provide value over a regular bean reference any more. Change your existing ref local references to ref bean when upgrading to the 4.0 schema. Inner Beans A <bean/> element inside the <property/> or <constructor-arg/> elements defines an inner bean, as the following example shows: <bean id=\"outer\" class=\"...\"> \u00a0  <!--instead of using a reference to a target bean, simply define the target bean inline --> \u00a0  <property name=\"target\"> \u00a0    <bean class=\"com.example. Person\"> <!--", "chunk_char_count": 969, "chunk_word_count": 154, "chunk_token_count": 242.25}, {"page_number": 34, "sentence_chunk": "this is the inner bean --> \u00a0      <property name=\"name\" value=\"Fiona Apple\"/> \u00a0      <property name=\"age\" value=\"25\"/> \u00a0    </bean> \u00a0  </property> </bean> An inner bean definition does not require a defined ID or name. If specified, the container does not use such a value as an identifier. The container also ignores the scope flag on creation, because inner beans are always anonymous and are always created with the outer bean. It is not possible to access inner beans independently or to inject them into collaborating beans other than into the enclosing bean. As a corner case, it is possible to receive destruction callbacks from a custom scope\u2009\u2014\u2009for example, for a request-scoped inner bean contained within a singleton bean. The creation of the inner bean instance is tied to its containing bean, but destruction callbacks let it participate in the request scope\u2019s lifecycle. This is not a common scenario. Inner beans typically simply share their containing bean\u2019s scope. Collections The <list/>, <set/>, <map/>, and <props/> elements set the properties and arguments of the Java Collection types List, Set, Map, and Properties, respectively. The following example shows how to use them: 34", "chunk_char_count": 1199, "chunk_word_count": 202, "chunk_token_count": 299.75}, {"page_number": 35, "sentence_chunk": "<bean id=\"moreComplexObject\" class=\"example. ComplexObject\"> \u00a0  <!--results in a setAdminEmails(java.util. Properties) call --> \u00a0  <property name=\"adminEmails\"> \u00a0    <props> \u00a0      <prop key=\"administrator\">administrator@example.org</prop> \u00a0      <prop key=\"support\">support@example.org</prop> \u00a0      <prop key=\"development\">development@example.org</prop> \u00a0    </props> \u00a0  </property> \u00a0  <!--results in a setSomeList(java.util. List) call --> \u00a0  <property name=\"someList\"> \u00a0    <list> \u00a0      <value>a list element followed by a reference</value> \u00a0      <ref bean=\"myDataSource\" /> \u00a0    </list> \u00a0  </property> \u00a0  <!--results in a setSomeMap(java.util. Map) call --> \u00a0  <property name=\"someMap\"> \u00a0    <map> \u00a0      <entry key=\"an entry\" value=\"just some string\"/> \u00a0      <entry key=\"a ref\" value-ref=\"myDataSource\"/> \u00a0    </map> \u00a0  </property> \u00a0  <!--results in a setSomeSet(java.util. Set) call --> \u00a0  <property name=\"someSet\"> \u00a0    <set> \u00a0      <value>just some string</value> \u00a0      <ref bean=\"myDataSource\" /> \u00a0    </set> \u00a0  </property> </bean> The value of a map key or value, or a set value, can also be any of the following elements: bean | ref | idref | list | set | map | props | value | null Collection Merging The Spring container also supports merging collections.", "chunk_char_count": 1273, "chunk_word_count": 241, "chunk_token_count": 318.25}, {"page_number": 35, "sentence_chunk": "An application developer can define a parent <list/>, <map/>, <set/> or <props/> element and have child <list/>, <map/>, <set/> or <props/> elements inherit and override values from the parent collection. That is, the child collection\u2019s values are the result of merging the elements of the parent and child collections, with the child\u2019s collection elements overriding values specified in the parent collection. This section on merging discusses the parent-child bean mechanism. Readers unfamiliar with parent and child bean definitions may wish to read the relevant section before continuing. The following example demonstrates collection merging: 35", "chunk_char_count": 650, "chunk_word_count": 94, "chunk_token_count": 162.5}, {"page_number": 36, "sentence_chunk": "<beans> \u00a0  <bean id=\"parent\" abstract=\"true\" class=\"example. ComplexObject\"> \u00a0    <property name=\"adminEmails\"> \u00a0      <props> \u00a0        <prop key=\"administrator\">administrator@example.com</prop> \u00a0        <prop key=\"support\">support@example.com</prop> \u00a0      </props> \u00a0    </property> \u00a0  </bean> \u00a0  <bean id=\"child\" parent=\"parent\"> \u00a0    <property name=\"adminEmails\"> \u00a0      <!--the merge is specified on the child collection definition --> \u00a0      <props merge=\"true\"> \u00a0        <prop key=\"sales\">sales@example.com</prop> \u00a0        <prop key=\"support\">support@example.co.uk</prop> \u00a0      </props> \u00a0    </property> \u00a0  </bean> <beans> Notice the use of the merge=true attribute on the <props/> element of the adminEmails property of the child bean definition. When the child bean is resolved and instantiated by the container, the resulting instance has an adminEmails Properties collection that contains the result of merging the child\u2019s adminEmails collection with the parent\u2019s adminEmails collection. The following listing shows the result: administrator=administrator@example.com sales=sales@example.com support=support@example.co.uk The child Properties collection\u2019s value set inherits all property elements from the parent <props/>, and the child\u2019s value for the support value overrides the value in the parent collection. This merging behavior applies similarly to the <list/>, <map/>, and <set/> collection types. In the specific case of the <list/> element, the semantics associated with the List collection type (that is, the notion of an ordered collection of values) is maintained. The parent\u2019s values precede all of the child list\u2019s values. In the case of the Map, Set, and Properties collection types, no ordering exists. Hence, no ordering semantics are in effect for the collection types that underlie the associated Map, Set, and Properties implementation types that the container uses internally.", "chunk_char_count": 1909, "chunk_word_count": 310, "chunk_token_count": 477.25}, {"page_number": 36, "sentence_chunk": "Limitations of Collection Merging You cannot merge different collection types (such as a Map and a List). If you do attempt to do so, an appropriate Exception is thrown. The merge attribute must be specified on the lower, inherited, child definition. Specifying the merge attribute on a parent collection definition is redundant and does not result in the desired merging.36", "chunk_char_count": 374, "chunk_word_count": 60, "chunk_token_count": 93.5}, {"page_number": 37, "sentence_chunk": "Strongly-typed collection Thanks to Java\u2019s support for generic types, you can use strongly typed collections. That is, it is possible to declare a Collection type such that it can only contain (for example) String elements. If you use Spring to dependency-inject a strongly-typed Collection into a bean, you can take advantage of Spring\u2019s type-conversion support such that the elements of your strongly-typed Collection instances are converted to the appropriate type prior to being added to the Collection. The following Java class and bean definition show how to do so: Java public class SomeClass { \u00a0  private Map<String, Float> accounts; \u00a0  public void setAccounts(Map<String, Float> accounts) { \u00a0    this.accounts = accounts; \u00a0  } } Kotlin class SomeClass { \u00a0  lateinit var accounts: Map<String, Float> } <beans> \u00a0  <bean id=\"something\" class=\"x.y. SomeClass\"> \u00a0    <property name=\"accounts\"> \u00a0      <map> \u00a0        <entry key=\"one\" value=\"9.99\"/> \u00a0        <entry key=\"two\" value=\"2.75\"/> \u00a0        <entry key=\"six\" value=\"3.99\"/> \u00a0      </map> \u00a0    </property> \u00a0  </bean> </beans> When the accounts property of the something bean is prepared for injection, the generics information about the element type of the strongly-typed Map<String, Float> is available by reflection. Thus, Spring\u2019s type conversion infrastructure recognizes the various value elements as being of type Float, and the string values (9.99, 2.75, and 3.99) are converted into an actual Float type. Null and Empty String Values Spring treats empty arguments for properties and the like as empty Strings. The following XML- based configuration metadata snippet sets the email property to the empty String value (\"\").37", "chunk_char_count": 1690, "chunk_word_count": 292, "chunk_token_count": 422.5}, {"page_number": 38, "sentence_chunk": "<bean class=\"ExampleBean\"> \u00a0  <property name=\"email\" value=\"\"/> </bean> The preceding example is equivalent to the following Java code: Java exampleBean.setEmail(\"\"); Kotlin exampleBean.email = \"\" The <null/> element handles null values. The following listing shows an example: <bean class=\"ExampleBean\"> \u00a0  <property name=\"email\"> \u00a0    <null/> \u00a0  </property> </bean> The preceding configuration is equivalent to the following Java code: Java exampleBean.setEmail(null); Kotlin exampleBean.email = null XML Shortcut with the p-namespace The p-namespace lets you use the bean element\u2019s attributes (instead of nested <property/> elements) to describe your property values collaborating beans, or both. Spring supports extensible configuration formats with namespaces, which are based on an XML Schema definition. The beans configuration format discussed in this chapter is defined in an XML Schema document. However, the p-namespace is not defined in an XSD file and exists only in the core of Spring. The following example shows two XML snippets (the first uses standard XML format and the second uses the p-namespace) that resolve to the same result: 38", "chunk_char_count": 1153, "chunk_word_count": 169, "chunk_token_count": 288.25}, {"page_number": 39, "sentence_chunk": "<beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:p=\"http://www.springframework.org/schema/p\" \u00a0  xsi:schemaLocation=\"http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd\"> \u00a0  <bean name=\"classic\" class=\"com.example. ExampleBean\"> \u00a0    <property name=\"email\" value=\"someone@somewhere.com\"/> \u00a0  </bean> \u00a0  <bean name=\"p-namespace\" class=\"com.example. ExampleBean\" \u00a0    p:email=\"someone@somewhere.com\"/> </beans> The example shows an attribute in the p-namespace called email in the bean definition. This tells Spring to include a property declaration. As previously mentioned, the p-namespace does not have a schema definition, so you can set the name of the attribute to the property name. This next example includes two more bean definitions that both have a reference to another bean: <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:p=\"http://www.springframework.org/schema/p\" \u00a0  xsi:schemaLocation=\"http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd\"> \u00a0  <bean name=\"john-classic\" class=\"com.example. Person\"> \u00a0    <property name=\"name\" value=\"John Doe\"/> \u00a0    <property name=\"spouse\" ref=\"jane\"/> \u00a0  </bean> \u00a0  <bean name=\"john-modern\" \u00a0    class=\"com.example. Person\" \u00a0    p:name=\"John Doe\" \u00a0    p:spouse-ref=\"jane\"/> \u00a0  <bean name=\"jane\" class=\"com.example. Person\"> \u00a0    <property name=\"name\" value=\"Jane Doe\"/> \u00a0  </bean> </beans> This example includes not only a property value using the p-namespace but also uses a special format to declare property references. Whereas the first bean definition uses <property name=\"spouse\" ref=\"jane\"/> to create a reference from bean john to bean jane, the second bean definition uses p:spouse-ref=\"jane\" as an attribute to do the exact same thing.", "chunk_char_count": 1963, "chunk_word_count": 240, "chunk_token_count": 490.75}, {"page_number": 39, "sentence_chunk": "In this case, spouse is the property name, whereas the -ref part indicates that this is not a straight value but rather a reference to another bean.39", "chunk_char_count": 150, "chunk_word_count": 27, "chunk_token_count": 37.5}, {"page_number": 40, "sentence_chunk": "\uf05a The p-namespace is not as flexible as the standard XML format. For example, the format for declaring property references clashes with properties that end in Ref, whereas the standard XML format does not. We recommend that you choose your approach carefully and communicate this to your team members to avoid producing XML documents that use all three approaches at the same time. XML Shortcut with the c-namespace Similar to the XML Shortcut with the p-namespace, the c-namespace, introduced in Spring 3.1, allows inlined attributes for configuring the constructor arguments rather then nested constructor- arg elements. The following example uses the c: namespace to do the same thing as the from Constructor-based Dependency Injection: <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:c=\"http://www.springframework.org/schema/c\" \u00a0  xsi:schemaLocation=\"http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd\"> \u00a0  <bean id=\"beanTwo\" class=\"x.y. ThingTwo\"/> \u00a0  <bean id=\"beanThree\" class=\"x.y. ThingThree\"/> \u00a0  <!--traditional declaration with optional argument names --> \u00a0  <bean id=\"beanOne\" class=\"x.y. ThingOne\"> \u00a0    <constructor-arg name=\"thingTwo\" ref=\"beanTwo\"/> \u00a0    <constructor-arg name=\"thingThree\" ref=\"beanThree\"/> \u00a0    <constructor-arg name=\"email\" value=\"something@somewhere.com\"/> \u00a0  </bean> \u00a0  <!--c-namespace declaration with argument names --> \u00a0  <bean id=\"beanOne\" class=\"x.y.", "chunk_char_count": 1530, "chunk_word_count": 194, "chunk_token_count": 382.5}, {"page_number": 40, "sentence_chunk": "ThingOne\" c:thingTwo-ref=\"beanTwo\" \u00a0    c:thingThree-ref=\"beanThree\" c:email=\"something@somewhere.com\"/> </beans> The c: namespace uses the same conventions as the p: one (a trailing -ref for bean references) for setting the constructor arguments by their names. Similarly, it needs to be declared in the XML file even though it is not defined in an XSD schema (it exists inside the Spring core). For the rare cases where the constructor argument names are not available (usually if the bytecode was compiled without debugging information), you can use fallback to the argument indexes, as follows: 40", "chunk_char_count": 601, "chunk_word_count": 92, "chunk_token_count": 150.25}, {"page_number": 41, "sentence_chunk": "<!--c-namespace index declaration --> <bean id=\"beanOne\" class=\"x.y. ThingOne\" c:_0-ref=\"beanTwo\" c:_1-ref=\"beanThree\" \u00a0  c:_2=\"something@somewhere.com\"/> \uf05a Due to the XML grammar, the index notation requires the presence of the leading _, as XML attribute names cannot start with a number (even though some IDEs allow it). A corresponding index notation is also available for <constructor-arg> elements but not commonly used since the plain order of declaration is usually sufficient there. In practice, the constructor resolution mechanism is quite efficient in matching arguments, so unless you really need to, we recommend using the name notation throughout your configuration. Compound Property Names You can use compound or nested property names when you set bean properties, as long as all components of the path except the final property name are not null. Consider the following bean definition: <bean id=\"something\" class=\"things. ThingOne\"> \u00a0  <property name=\"fred.bob.sammy\" value=\"123\" /> </bean> The something bean has a fred property, which has a bob property, which has a sammy property, and that final sammy property is being set to a value of 123. In order for this to work, the fred property of something and the bob property of fred must not be null after the bean is constructed. Otherwise, a NullPointerException is thrown.", "chunk_char_count": 1345, "chunk_word_count": 204, "chunk_token_count": 336.25}, {"page_number": 41, "sentence_chunk": "Using depends-on If a bean is a dependency of another bean, that usually means that one bean is set as a property of another. Typically you accomplish this with the <ref/> element in XML-based configuration metadata. However, sometimes dependencies between beans are less direct. An example is when a static initializer in a class needs to be triggered, such as for database driver registration. The depends-on attribute can explicitly force one or more beans to be initialized before the bean using this element is initialized. The following example uses the depends-on attribute to express a dependency on a single bean: <bean id=\"beanOne\" class=\"ExampleBean\" depends-on=\"manager\"/> <bean id=\"manager\" class=\"ManagerBean\" /> To express a dependency on multiple beans, supply a list of bean names as the value of the depends- on attribute (commas, whitespace, and semicolons are valid delimiters): 41", "chunk_char_count": 901, "chunk_word_count": 137, "chunk_token_count": 225.25}, {"page_number": 42, "sentence_chunk": "<bean id=\"beanOne\" class=\"ExampleBean\" depends-on=\"manager,accountDao\"> \u00a0  <property name=\"manager\" ref=\"manager\" /> </bean> <bean id=\"manager\" class=\"ManagerBean\" /> <bean id=\"accountDao\" class=\"x.y.jdbc. JdbcAccountDao\" /> \uf05a The depends-on attribute can specify both an initialization-time dependency and, in the case of singleton beans only, a corresponding destruction-time dependency. Dependent beans that define a depends-on relationship with a given bean are destroyed first, prior to the given bean itself being destroyed. Thus, depends-on can also control shutdown order. Lazy-initialized Beans By default, ApplicationContext implementations eagerly create and configure all singleton beans as part of the initialization process. Generally, this pre-instantiation is desirable, because errors in the configuration or surrounding environment are discovered immediately, as opposed to hours or even days later. When this behavior is not desirable, you can prevent pre-instantiation of a singleton bean by marking the bean definition as being lazy-initialized. A lazy-initialized bean tells the IoC container to create a bean instance when it is first requested, rather than at startup. In XML, this behavior is controlled by the lazy-init attribute on the <bean/> element, as the following example shows: <bean id=\"lazy\" class=\"com.something. ExpensiveToCreateBean\" lazy-init=\"true\"/> <bean name=\"not.lazy\" class=\"com.something.", "chunk_char_count": 1435, "chunk_word_count": 184, "chunk_token_count": 358.75}, {"page_number": 42, "sentence_chunk": "AnotherBean\"/> When the preceding configuration is consumed by an ApplicationContext, the lazy bean is not eagerly pre-instantiated when the ApplicationContext starts, whereas the not.lazy bean is eagerly pre-instantiated. However, when a lazy-initialized bean is a dependency of a singleton bean that is not lazy- initialized, the ApplicationContext creates the lazy-initialized bean at startup, because it must satisfy the singleton\u2019s dependencies. The lazy-initialized bean is injected into a singleton bean elsewhere that is not lazy-initialized. You can also control lazy-initialization at the container level by using the default-lazy-init attribute on the <beans/> element, as the following example shows: <beans default-lazy-init=\"true\"> \u00a0  <!--no beans will be pre-instantiated... --> </beans> 42", "chunk_char_count": 805, "chunk_word_count": 109, "chunk_token_count": 201.25}, {"page_number": 43, "sentence_chunk": "Autowiring Collaborators The Spring container can autowire relationships between collaborating beans. You can let Spring resolve collaborators (other beans) automatically for your bean by inspecting the contents of the ApplicationContext. Autowiring has the following advantages: \u2022 Autowiring can significantly reduce the need to specify properties or constructor arguments. (Other mechanisms such as a bean template discussed elsewhere in this chapter are also valuable in this regard.) \u2022Autowiring can update a configuration as your objects evolve. For example, if you need to add a dependency to a class, that dependency can be satisfied automatically without you needing to modify the configuration. Thus autowiring can be especially useful during development, without negating the option of switching to explicit wiring when the code base becomes more stable. When using XML-based configuration metadata (see Dependency Injection), you can specify the autowire mode for a bean definition with the autowire attribute of the <bean/> element. The autowiring functionality has four modes. You specify autowiring per bean and can thus choose which ones to autowire.", "chunk_char_count": 1165, "chunk_word_count": 169, "chunk_token_count": 291.25}, {"page_number": 43, "sentence_chunk": "The following table describes the four autowiring modes: Table 2. Autowiring modes Mode Explanation no (Default) No autowiring. Bean references must be defined by ref elements. Changing the default setting is not recommended for larger deployments, because specifying collaborators explicitly gives greater control and clarity. To some extent, it documents the structure of a system.byName Autowiring by property name. Spring looks for a bean with the same name as the property that needs to be autowired. For example, if a bean definition is set to autowire by name and it contains a master property (that is, it has a setMaster(..) method), Spring looks for a bean definition named master and uses it to set the property.byType Lets a property be autowired if exactly one bean of the property type exists in the container. If more than one exists, a fatal exception is thrown, which indicates that you may not use byType autowiring for that bean.", "chunk_char_count": 948, "chunk_word_count": 155, "chunk_token_count": 237.0}, {"page_number": 43, "sentence_chunk": "If there are no matching beans, nothing happens (the property is not set).constructor Analogous to byType but applies to constructor arguments. If there is not exactly one bean of the constructor argument type in the container, a fatal error is raised. With byType or constructor autowiring mode, you can wire arrays and typed collections. In such cases, all autowire candidates within the container that match the expected type are provided to satisfy the dependency. You can autowire strongly-typed Map instances if the expected key type is String. An autowired Map instance\u2019s values consist of all bean instances that match the expected type, and the Map instance\u2019s keys contain the corresponding bean names.43", "chunk_char_count": 713, "chunk_word_count": 112, "chunk_token_count": 178.25}, {"page_number": 44, "sentence_chunk": "Limitations and Disadvantages of Autowiring Autowiring works best when it is used consistently across a project. If autowiring is not used in general, it might be confusing to developers to use it to wire only one or two bean definitions. Consider the limitations and disadvantages of autowiring: \u2022 Explicit dependencies in property and constructor-arg settings always override autowiring. You cannot autowire simple properties such as primitives, Strings, and Classes (and arrays of such simple properties). This limitation is by-design. \u2022Autowiring is less exact than explicit wiring. Although, as noted in the earlier table, Spring is careful to avoid guessing in case of ambiguity that might have unexpected results. The relationships between your Spring-managed objects are no longer documented explicitly. \u2022Wiring information may not be available to tools that may generate documentation from a Spring container. \u2022Multiple bean definitions within the container may match the type specified by the setter method or constructor argument to be autowired.", "chunk_char_count": 1057, "chunk_word_count": 156, "chunk_token_count": 264.25}, {"page_number": 44, "sentence_chunk": "For arrays, collections, or Map instances, this is not necessarily a problem. However, for dependencies that expect a single value, this ambiguity is not arbitrarily resolved. If no unique bean definition is available, an exception is thrown. In the latter scenario, you have several options: \u2022 Abandon autowiring in favor of explicit wiring. \u2022Avoid autowiring for a bean definition by setting its autowire-candidate attributes to false, as described in the next section. \u2022Designate a single bean definition as the primary candidate by setting the primary attribute of its <bean/> element to true. \u2022Implement the more fine-grained control available with annotation-based configuration, as described in Annotation-based Container Configuration. Excluding a Bean from Autowiring On a per-bean basis, you can exclude a bean from autowiring. In Spring\u2019s XML format, set the autowire-candidate attribute of the <bean/> element to false. The container makes that specific bean definition unavailable to the autowiring infrastructure (including annotation style configurations such as @Autowired).", "chunk_char_count": 1090, "chunk_word_count": 156, "chunk_token_count": 272.5}, {"page_number": 44, "sentence_chunk": "\uf05a The autowire-candidate attribute is designed to only affect type-based autowiring. It does not affect explicit references by name, which get resolved even if the specified bean is not marked as an autowire candidate. As a consequence, autowiring by name nevertheless injects a bean if the name matches. You can also limit autowire candidates based on pattern-matching against bean names. The top- level <beans/> element accepts one or more patterns within its default-autowire-candidates attribute. For example, to limit autowire candidate status to any bean whose name ends with Repository, provide a value of *Repository. To provide multiple patterns, define them in a comma- separated list. An explicit value of true or false for a bean definition\u2019s autowire-candidate attribute 44", "chunk_char_count": 786, "chunk_word_count": 119, "chunk_token_count": 196.5}, {"page_number": 45, "sentence_chunk": "always takes precedence. For such beans, the pattern matching rules do not apply. These techniques are useful for beans that you never want to be injected into other beans by autowiring. It does not mean that an excluded bean cannot itself be configured by using autowiring. Rather, the bean itself is not a candidate for autowiring other beans. Method Injection In most application scenarios, most beans in the container are singletons. When a singleton bean needs to collaborate with another singleton bean or a non-singleton bean needs to collaborate with another non-singleton bean, you typically handle the dependency by defining one bean as a property of the other. A problem arises when the bean lifecycles are different. Suppose singleton bean A needs to use non-singleton (prototype) bean B, perhaps on each method invocation on A. The container creates the singleton bean A only once, and thus only gets one opportunity to set the properties. The container cannot provide bean A with a new instance of bean B every time one is needed.", "chunk_char_count": 1044, "chunk_word_count": 172, "chunk_token_count": 261.0}, {"page_number": 45, "sentence_chunk": "A solution is to forego some inversion of control. You can make bean A aware of the container by implementing the ApplicationContextAware interface, and by making a getBean(\"B\") call to the container ask for (a typically new) bean B instance every time bean A needs it. The following example shows this approach: 45", "chunk_char_count": 315, "chunk_word_count": 53, "chunk_token_count": 78.75}, {"page_number": 46, "sentence_chunk": "Java // a class that uses a stateful Command-style class to perform some processing package fiona.apple; // Spring-API imports import org.springframework.beans. BeansException; import org.springframework.context. ApplicationContext; import org.springframework.context. ApplicationContextAware; public class CommandManager implements ApplicationContextAware { \u00a0  private ApplicationContext applicationContext; \u00a0  public Object process(Map commandState) { \u00a0    // grab a new instance of the appropriate Command \u00a0    Command command = createCommand(); \u00a0    // set the state on the (hopefully brand new) Command instance \u00a0    command.setState(commandState); \u00a0    return command.execute(); \u00a0  } \u00a0  protected Command createCommand() { \u00a0    // notice the Spring API dependency!\u00a0    return this.applicationContext.getBean(\"command\", Command.class); \u00a0  } \u00a0  public void setApplicationContext( \u00a0      ApplicationContext applicationContext) throws BeansException { \u00a0    this.applicationContext = applicationContext; \u00a0  } } 46", "chunk_char_count": 1014, "chunk_word_count": 149, "chunk_token_count": 253.5}, {"page_number": 47, "sentence_chunk": "Kotlin // a class that uses a stateful Command-style class to perform some processing package fiona.apple // Spring-API imports import org.springframework.context. ApplicationContext import org.springframework.context. ApplicationContextAware class CommandManager : ApplicationContextAware { \u00a0  private lateinit var applicationContext: ApplicationContext \u00a0  fun process(commandState: Map<*, *>): Any { \u00a0    // grab a new instance of the appropriate Command \u00a0    val command = createCommand() \u00a0    // set the state on the (hopefully brand new) Command instance \u00a0    command.state = commandState \u00a0    return command.execute() \u00a0  } \u00a0  // notice the Spring API dependency!\u00a0  protected fun createCommand() = \u00a0      applicationContext.getBean(\"command\", Command::class.java) \u00a0  override fun setApplicationContext(applicationContext: ApplicationContext) { \u00a0    this.applicationContext = applicationContext \u00a0  } } The preceding is not desirable, because the business code is aware of and coupled to the Spring Framework. Method Injection, a somewhat advanced feature of the Spring IoC container, lets you handle this use case cleanly. You can read more about the motivation for Method Injection in this blog entry. Lookup Method Injection Lookup method injection is the ability of the container to override methods on container-managed beans and return the lookup result for another named bean in the container. The lookup typically involves a prototype bean, as in the scenario described in the preceding section. The Spring Framework implements this method injection by using bytecode generation from the CGLIB library to dynamically generate a subclass that overrides the method.47", "chunk_char_count": 1676, "chunk_word_count": 256, "chunk_token_count": 419.0}, {"page_number": 48, "sentence_chunk": "\uf05a \u2022 For this dynamic subclassing to work, the class that the Spring bean container subclasses cannot be final, and the method to be overridden cannot be final, either. \u2022Unit-testing a class that has an abstract method requires you to subclass the class yourself and to supply a stub implementation of the abstract method. \u2022Concrete methods are also necessary for component scanning, which requires concrete classes to pick up. \u2022A further key limitation is that lookup methods do not work with factory methods and in particular not with @Bean methods in configuration classes, since, in that case, the container is not in charge of creating the instance and therefore cannot create a runtime-generated subclass on the fly. In the case of the CommandManager class in the previous code snippet, the Spring container dynamically overrides the implementation of the createCommand() method. The CommandManager class does not have any Spring dependencies, as the reworked example shows: Java package fiona.apple; // no more Spring imports!public abstract class CommandManager { \u00a0  public Object process(Object commandState) { \u00a0    // grab a new instance of the appropriate Command interface \u00a0    Command command = createCommand(); \u00a0    // set the state on the (hopefully brand new) Command instance \u00a0    command.setState(commandState); \u00a0    return command.execute(); \u00a0  } \u00a0  // okay... but where is the implementation of this method?\u00a0  protected abstract Command createCommand(); } 48", "chunk_char_count": 1477, "chunk_word_count": 243, "chunk_token_count": 369.25}, {"page_number": 49, "sentence_chunk": "Kotlin package fiona.apple // no more Spring imports!abstract class CommandManager { \u00a0  fun process(commandState: Any): Any { \u00a0    // grab a new instance of the appropriate Command interface \u00a0    val command = createCommand() \u00a0    // set the state on the (hopefully brand new) Command instance \u00a0    command.state = commandState \u00a0    return command.execute() \u00a0  } \u00a0  // okay... but where is the implementation of this method?\u00a0  protected abstract fun createCommand(): Command } In the client class that contains the method to be injected (the CommandManager in this case), the method to be injected requires a signature of the following form: <public|protected> [abstract] <return-type> theMethodName(no-arguments); If the method is abstract, the dynamically-generated subclass implements the method. Otherwise, the dynamically-generated subclass overrides the concrete method defined in the original class. Consider the following example: <!--a stateful bean deployed as a prototype (non-singleton) --> <bean id=\"myCommand\" class=\"fiona.apple. AsyncCommand\" scope=\"prototype\"> \u00a0  <!--inject dependencies here as required --> </bean> <!--commandProcessor uses statefulCommandHelper --> <bean id=\"commandManager\" class=\"fiona.apple. CommandManager\"> \u00a0  <lookup-method name=\"createCommand\" bean=\"myCommand\"/> </bean> The bean identified as commandManager calls its own createCommand() method whenever it needs a new instance of the myCommand bean.", "chunk_char_count": 1444, "chunk_word_count": 207, "chunk_token_count": 361.0}, {"page_number": 49, "sentence_chunk": "You must be careful to deploy the myCommand bean as a prototype if that is actually what is needed. If it is a singleton, the same instance of the myCommand bean is returned each time. Alternatively, within the annotation-based component model, you can declare a lookup method through the @Lookup annotation, as the following example shows: 49", "chunk_char_count": 343, "chunk_word_count": 57, "chunk_token_count": 85.75}, {"page_number": 50, "sentence_chunk": "Java public abstract class CommandManager { \u00a0  public Object process(Object commandState) { \u00a0    Command command = createCommand(); \u00a0    command.setState(commandState); \u00a0    return command.execute(); \u00a0  } \u00a0  @Lookup(\"myCommand\") \u00a0  protected abstract Command createCommand(); } Kotlin abstract class CommandManager { \u00a0  fun process(commandState: Any): Any { \u00a0    val command = createCommand() \u00a0    command.state = commandState \u00a0    return command.execute() \u00a0  } \u00a0  @Lookup(\"myCommand\") \u00a0  protected abstract fun createCommand(): Command } Or, more idiomatically, you can rely on the target bean getting resolved against the declared return type of the lookup method: Java public abstract class CommandManager { \u00a0  public Object process(Object commandState) { \u00a0    Command command = createCommand(); \u00a0    command.setState(commandState); \u00a0    return command.execute(); \u00a0  } \u00a0  @Lookup \u00a0  protected abstract Command createCommand(); } 50", "chunk_char_count": 934, "chunk_word_count": 159, "chunk_token_count": 233.5}, {"page_number": 51, "sentence_chunk": "Kotlin abstract class CommandManager { \u00a0  fun process(commandState: Any): Any { \u00a0    val command = createCommand() \u00a0    command.state = commandState \u00a0    return command.execute() \u00a0  } \u00a0  @Lookup \u00a0  protected abstract fun createCommand(): Command } Note that you should typically declare such annotated lookup methods with a concrete stub implementation, in order for them to be compatible with Spring\u2019s component scanning rules where abstract classes get ignored by default. This limitation does not apply to explicitly registered or explicitly imported bean classes.\uf0eb Another way of accessing differently scoped target beans is an ObjectFactory/ Provider injection point. See Scoped Beans as Dependencies. You may also find the ServiceLocatorFactoryBean (in the org.springframework.beans.factory.config package) to be useful. Arbitrary Method Replacement A less useful form of method injection than lookup method injection is the ability to replace arbitrary methods in a managed bean with another method implementation. You can safely skip the rest of this section until you actually need this functionality. With XML-based configuration metadata, you can use the replaced-method element to replace an existing method implementation with another, for a deployed bean. Consider the following class, which has a method called computeValue that we want to override: Java public class MyValueCalculator { \u00a0  public String computeValue(String input) { \u00a0    // some real code... \u00a0  } \u00a0  // some other methods... } 51", "chunk_char_count": 1512, "chunk_word_count": 238, "chunk_token_count": 378.0}, {"page_number": 52, "sentence_chunk": "Kotlin class MyValueCalculator { \u00a0  fun computeValue(input: String): String { \u00a0    // some real code... \u00a0  } \u00a0  // some other methods... } A class that implements the org.springframework.beans.factory.support. MethodReplacer interface provides the new method definition, as the following example shows: Java /** \u00a0* meant to be used to override the existing computeValue(String) \u00a0* implementation in MyValueCalculator \u00a0*/ public class ReplacementComputeValue implements MethodReplacer { \u00a0  public Object reimplement(Object o, Method m, Object[] args) throws Throwable { \u00a0    // get the input value, work with it, and return a computed result \u00a0    String input = (String) args[0]; \u00a0    ... \u00a0    return ...; \u00a0  } } Kotlin /** \u00a0* meant to be used to override the existing computeValue(String) \u00a0* implementation in MyValueCalculator \u00a0*/ class ReplacementComputeValue : MethodReplacer { \u00a0  override fun reimplement(obj: Any, method: Method, args: Array<out Any>): Any { \u00a0    // get the input value, work with it, and return a computed result \u00a0    val input = args[0] as String; \u00a0    ... \u00a0    return ...; \u00a0  } } The bean definition to deploy the original class and specify the method override would resemble the following example: 52", "chunk_char_count": 1226, "chunk_word_count": 220, "chunk_token_count": 306.5}, {"page_number": 53, "sentence_chunk": "<bean id=\"myValueCalculator\" class=\"x.y.z. MyValueCalculator\"> \u00a0  <!--arbitrary method replacement --> \u00a0  <replaced-method name=\"computeValue\" replacer=\"replacementComputeValue\"> \u00a0    <arg-type>String</arg-type> \u00a0  </replaced-method> </bean> <bean id=\"replacementComputeValue\" class=\"a.b.c. ReplacementComputeValue\"/> You can use one or more <arg-type/> elements within the <replaced-method/> element to indicate the method signature of the method being overridden. The signature for the arguments is necessary only if the method is overloaded and multiple variants exist within the class. For convenience, the type string for an argument may be a substring of the fully qualified type name. For example, the following all match java.lang. String: java.lang. String String Str Because the number of arguments is often enough to distinguish between each possible choice, this shortcut can save a lot of typing, by letting you type only the shortest string that matches an argument type.2.1.5.", "chunk_char_count": 991, "chunk_word_count": 135, "chunk_token_count": 247.75}, {"page_number": 53, "sentence_chunk": "Bean Scopes When you create a bean definition, you create a recipe for creating actual instances of the class defined by that bean definition. The idea that a bean definition is a recipe is important, because it means that, as with a class, you can create many object instances from a single recipe. You can control not only the various dependencies and configuration values that are to be plugged into an object that is created from a particular bean definition but also control the scope of the objects created from a particular bean definition. This approach is powerful and flexible, because you can choose the scope of the objects you create through configuration instead of having to bake in the scope of an object at the Java class level. Beans can be defined to be deployed in one of a number of scopes. The Spring Framework supports six scopes, four of which are available only if you use a web-aware ApplicationContext. You can also create a custom scope. The following table describes the supported scopes: Table 3. Bean scopes Scope Description singleton (Default) Scopes a single bean definition to a single object instance for each Spring IoC container.prototype Scopes a single bean definition to any number of object instances.", "chunk_char_count": 1243, "chunk_word_count": 209, "chunk_token_count": 310.75}, {"page_number": 54, "sentence_chunk": "Scope Description request Scopes a single bean definition to the lifecycle of a single HTTP request. That is, each HTTP request has its own instance of a bean created off the back of a single bean definition. Only valid in the context of a web-aware Spring ApplicationContext.session Scopes a single bean definition to the lifecycle of an HTTP Session. Only valid in the context of a web-aware Spring ApplicationContext.application Scopes a single bean definition to the lifecycle of a ServletContext. Only valid in the context of a web-aware Spring ApplicationContext.websocket Scopes a single bean definition to the lifecycle of a WebSocket. Only valid in the context of a web-aware Spring ApplicationContext.\uf05a As of Spring 3.0, a thread scope is available but is not registered by default.", "chunk_char_count": 792, "chunk_word_count": 126, "chunk_token_count": 198.0}, {"page_number": 54, "sentence_chunk": "For more information, see the documentation for SimpleThreadScope. For instructions on how to register this or any other custom scope, see Using a Custom Scope. The Singleton Scope Only one shared instance of a singleton bean is managed, and all requests for beans with an ID or IDs that match that bean definition result in that one specific bean instance being returned by the Spring container. To put it another way, when you define a bean definition and it is scoped as a singleton, the Spring IoC container creates exactly one instance of the object defined by that bean definition. This single instance is stored in a cache of such singleton beans, and all subsequent requests and references for that named bean return the cached object. The following image shows how the singleton scope works: Spring\u2019s concept of a singleton bean differs from the singleton pattern as defined in the Gang of Four (GoF) patterns book. The GoF singleton hard-codes the scope of an object such that one and 54", "chunk_char_count": 997, "chunk_word_count": 170, "chunk_token_count": 249.25}, {"page_number": 55, "sentence_chunk": "only one instance of a particular class is created per ClassLoader. The scope of the Spring singleton is best described as being per-container and per-bean. This means that, if you define one bean for a particular class in a single Spring container, the Spring container creates one and only one instance of the class defined by that bean definition. The singleton scope is the default scope in Spring. To define a bean as a singleton in XML, you can define a bean as shown in the following example: <bean id=\"accountService\" class=\"com.something. DefaultAccountService\"/> <!--the following is equivalent, though redundant (singleton scope is the default) --> <bean id=\"accountService\" class=\"com.something. DefaultAccountService\" scope=\"singleton\"/> The Prototype Scope The non-singleton prototype scope of bean deployment results in the creation of a new bean instance every time a request for that specific bean is made. That is, the bean is injected into another bean or you request it through a getBean() method call on the container. As a rule, you should use the prototype scope for all stateful beans and the singleton scope for stateless beans.", "chunk_char_count": 1153, "chunk_word_count": 179, "chunk_token_count": 288.25}, {"page_number": 55, "sentence_chunk": "The following diagram illustrates the Spring prototype scope: (A data access object (DAO) is not typically configured as a prototype, because a typical DAO does not hold any conversational state. It was easier for us to reuse the core of the singleton diagram.)The following example defines a bean as a prototype in XML: <bean id=\"accountService\" class=\"com.something. DefaultAccountService\" scope=\"prototype\"/> In contrast to the other scopes, Spring does not manage the complete lifecycle of a prototype bean.55", "chunk_char_count": 513, "chunk_word_count": 75, "chunk_token_count": 128.25}, {"page_number": 56, "sentence_chunk": "The container instantiates, configures, and otherwise assembles a prototype object and hands it to the client, with no further record of that prototype instance. Thus, although initialization lifecycle callback methods are called on all objects regardless of scope, in the case of prototypes, configured destruction lifecycle callbacks are not called. The client code must clean up prototype-scoped objects and release expensive resources that the prototype beans hold. To get the Spring container to release resources held by prototype-scoped beans, try using a custom bean post-processor, which holds a reference to beans that need to be cleaned up. In some respects, the Spring container\u2019s role in regard to a prototype-scoped bean is a replacement for the Java new operator. All lifecycle management past that point must be handled by the client. (For details on the lifecycle of a bean in the Spring container, see Lifecycle Callbacks.)Singleton Beans with Prototype-bean Dependencies When you use singleton-scoped beans with dependencies on prototype beans, be aware that dependencies are resolved at instantiation time. Thus, if you dependency-inject a prototype-scoped bean into a singleton-scoped bean, a new prototype bean is instantiated and then dependency- injected into the singleton bean. The prototype instance is the sole instance that is ever supplied to the singleton-scoped bean.", "chunk_char_count": 1399, "chunk_word_count": 208, "chunk_token_count": 349.75}, {"page_number": 56, "sentence_chunk": "However, suppose you want the singleton-scoped bean to acquire a new instance of the prototype- scoped bean repeatedly at runtime. You cannot dependency-inject a prototype-scoped bean into your singleton bean, because that injection occurs only once, when the Spring container instantiates the singleton bean and resolves and injects its dependencies. If you need a new instance of a prototype bean at runtime more than once, see Method Injection. Request, Session, Application, and WebSocket Scopes The request, session, application, and websocket scopes are available only if you use a web-aware Spring ApplicationContext implementation (such as XmlWebApplicationContext). If you use these scopes with regular Spring IoC containers, such as the ClassPathXmlApplicationContext, an IllegalStateException that complains about an unknown bean scope is thrown. Initial Web Configuration To support the scoping of beans at the request, session, application, and websocket levels (web- scoped beans), some minor initial configuration is required before you define your beans. (This initial setup is not required for the standard scopes: singleton and prototype.)How you accomplish this initial setup depends on your particular Servlet environment. If you access scoped beans within Spring Web MVC, in effect, within a request that is processed by the Spring DispatcherServlet, no special setup is necessary. DispatcherServlet already exposes all relevant state.", "chunk_char_count": 1456, "chunk_word_count": 207, "chunk_token_count": 364.0}, {"page_number": 56, "sentence_chunk": "If you use a Servlet web container, with requests processed outside of Spring\u2019s DispatcherServlet (for example, when using JSF or Struts), you need to register the org.springframework.web.context.request. RequestContextListener ServletRequestListener. This can be done programmatically by using the WebApplicationInitializer interface. Alternatively, add the following declaration to your web application\u2019s web.xml file: 56", "chunk_char_count": 423, "chunk_word_count": 51, "chunk_token_count": 105.75}, {"page_number": 57, "sentence_chunk": "<web-app> \u00a0  ... \u00a0  <listener> \u00a0    <listener-class> \u00a0      org.springframework.web.context.request. RequestContextListener \u00a0    </listener-class> \u00a0  </listener> \u00a0  ... </web-app> Alternatively, if there are issues with your listener setup, consider using Spring\u2019s RequestContextFilter. The filter mapping depends on the surrounding web application configuration, so you have to change it as appropriate. The following listing shows the filter part of a web application: <web-app> \u00a0  ... \u00a0  <filter> \u00a0    <filter-name>requestContextFilter</filter-name> \u00a0    <filter-class>org.springframework.web.filter. RequestContextFilter</filter- class> \u00a0  </filter> \u00a0  <filter-mapping> \u00a0    <filter-name>requestContextFilter</filter-name> \u00a0    <url-pattern>/*</url-pattern> \u00a0  </filter-mapping> \u00a0  ... </web-app> DispatcherServlet, RequestContextListener, and RequestContextFilter all do exactly the same thing, namely bind the HTTP request object to the Thread that is servicing that request. This makes beans that are request- and session-scoped available further down the call chain. Request scope Consider the following XML configuration for a bean definition: <bean id=\"loginAction\" class=\"com.something. LoginAction\" scope=\"request\"/> The Spring container creates a new instance of the LoginAction bean by using the loginAction bean definition for each and every HTTP request. That is, the loginAction bean is scoped at the HTTP request level. You can change the internal state of the instance that is created as much as you want, because other instances created from the same loginAction bean definition do not see these changes in state.", "chunk_char_count": 1633, "chunk_word_count": 239, "chunk_token_count": 408.25}, {"page_number": 57, "sentence_chunk": "They are particular to an individual request. When the request completes processing, the bean that is scoped to the request is discarded. When using annotation-driven components or Java configuration, the @RequestScope annotation can 57", "chunk_char_count": 236, "chunk_word_count": 34, "chunk_token_count": 59.0}, {"page_number": 58, "sentence_chunk": "be used to assign a component to the request scope. The following example shows how to do so: Java @RequestScope @Component public class LoginAction { \u00a0  // ... } Kotlin @RequestScope @Component class LoginAction { \u00a0  // ... } Session Scope Consider the following XML configuration for a bean definition: <bean id=\"userPreferences\" class=\"com.something. UserPreferences\" scope=\"session\"/> The Spring container creates a new instance of the UserPreferences bean by using the userPreferences bean definition for the lifetime of a single HTTP Session. In other words, the userPreferences bean is effectively scoped at the HTTP Session level. As with request-scoped beans, you can change the internal state of the instance that is created as much as you want, knowing that other HTTP Session instances that are also using instances created from the same userPreferences bean definition do not see these changes in state, because they are particular to an individual HTTP Session. When the HTTP Session is eventually discarded, the bean that is scoped to that particular HTTP Session is also discarded. When using annotation-driven components or Java configuration, you can use the @SessionScope annotation to assign a component to the session scope. Java @SessionScope @Component public class UserPreferences { \u00a0  // ... } 58", "chunk_char_count": 1321, "chunk_word_count": 205, "chunk_token_count": 330.25}, {"page_number": 59, "sentence_chunk": "Kotlin @SessionScope @Component class UserPreferences { \u00a0  // ... } Application Scope Consider the following XML configuration for a bean definition: <bean id=\"appPreferences\" class=\"com.something. AppPreferences\" scope=\"application\"/> The Spring container creates a new instance of the AppPreferences bean by using the appPreferences bean definition once for the entire web application. That is, the appPreferences bean is scoped at the ServletContext level and stored as a regular ServletContext attribute. This is somewhat similar to a Spring singleton bean but differs in two important ways: It is a singleton per ServletContext, not per Spring ApplicationContext (for which there may be several in any given web application), and it is actually exposed and therefore visible as a ServletContext attribute. When using annotation-driven components or Java configuration, you can use the @ApplicationScope annotation to assign a component to the application scope. The following example shows how to do so: Java @ApplicationScope @Component public class AppPreferences { \u00a0  // ... } Kotlin @ApplicationScope @Component class AppPreferences { \u00a0  // ... } WebSocket Scope WebSocket scope is associated with the lifecycle of a WebSocket session and applies to STOMP over WebSocket applications, see WebSocket scope for more details.59", "chunk_char_count": 1333, "chunk_word_count": 194, "chunk_token_count": 333.25}, {"page_number": 60, "sentence_chunk": "Scoped Beans as Dependencies The Spring IoC container manages not only the instantiation of your objects (beans), but also the wiring up of collaborators (or dependencies). If you want to inject (for example) an HTTP request- scoped bean into another bean of a longer-lived scope, you may choose to inject an AOP proxy in place of the scoped bean. That is, you need to inject a proxy object that exposes the same public interface as the scoped object but that can also retrieve the real target object from the relevant scope (such as an HTTP request) and delegate method calls onto the real object.\uf05a You may also use <aop:scoped-proxy/> between beans that are scoped as singleton, with the reference then going through an intermediate proxy that is serializable and therefore able to re-obtain the target singleton bean on deserialization. When declaring <aop:scoped-proxy/> against a bean of scope prototype, every method call on the shared proxy leads to the creation of a new target instance to which the call is then being forwarded. Also, scoped proxies are not the only way to access beans from shorter scopes in a lifecycle-safe fashion. You may also declare your injection point (that is, the constructor or setter argument or autowired field) as ObjectFactory<MyTargetBean>, allowing for a getObject() call to retrieve the current instance on demand every time it is needed\u2009\u2014\u2009without holding on to the instance or storing it separately. As an extended variant, you may declare ObjectProvider<MyTargetBean> which delivers several additional access variants, including getIfAvailable and getIfUnique. The JSR-330 variant of this is called Provider and is used with a Provider<MyTargetBean> declaration and a corresponding get() call for every retrieval attempt. See here for more details on JSR-330 overall.", "chunk_char_count": 1814, "chunk_word_count": 285, "chunk_token_count": 453.5}, {"page_number": 60, "sentence_chunk": "The configuration in the following example is only one line, but it is important to understand the \u201cwhy\u201d as well as the \u201chow\u201d behind it: 60", "chunk_char_count": 139, "chunk_word_count": 26, "chunk_token_count": 34.75}, {"page_number": 61, "sentence_chunk": "<?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:aop=\"http://www.springframework.org/schema/aop\" \u00a0  xsi:schemaLocation=\"http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/aop \u00a0    https://www.springframework.org/schema/aop/spring-aop.xsd\"> \u00a0  <!--an HTTP Session-scoped bean exposed as a proxy --> \u00a0  <bean id=\"userPreferences\" class=\"com.something. UserPreferences\" scope=\"session\"> \u00a0    <!--instructs the container to proxy the surrounding bean --> \u00a0    <aop:scoped-proxy/> \u2460 \u00a0  </bean> \u00a0  <!--a singleton-scoped bean injected with a proxy to the above bean --> \u00a0  <bean id=\"userService\" class=\"com.something. SimpleUserService\"> \u00a0    <!--a reference to the proxied userPreferences bean --> \u00a0    <property name=\"userPreferences\" ref=\"userPreferences\"/> \u00a0  </bean> </beans> \u2460 The line that defines the proxy. To create such a proxy, you insert a child <aop:scoped-proxy/> element into a scoped bean definition (see Choosing the Type of Proxy to Create and XML Schema-based configuration).", "chunk_char_count": 1207, "chunk_word_count": 147, "chunk_token_count": 301.75}, {"page_number": 61, "sentence_chunk": "Why do definitions of beans scoped at the request, session and custom-scope levels require the <aop:scoped- proxy/> element?Consider the following singleton bean definition and contrast it with what you need to define for the aforementioned scopes (note that the following userPreferences bean definition as it stands is incomplete): <bean id=\"userPreferences\" class=\"com.something. UserPreferences\" scope=\"session\"/> <bean id=\"userManager\" class=\"com.something. UserManager\"> \u00a0  <property name=\"userPreferences\" ref=\"userPreferences\"/> </bean> In the preceding example, the singleton bean (userManager) is injected with a reference to the HTTP Session-scoped bean (userPreferences). The salient point here is that the userManager bean is a singleton: it is instantiated exactly once per container, and its dependencies (in this case only one, the userPreferences bean) are also injected only once. This means that the userManager bean operates only on the exact same userPreferences object (that is, the one with which it was originally injected). This is not the behavior you want when injecting a shorter-lived scoped bean into a longer-lived scoped bean (for example, injecting an HTTP Session-scoped collaborating bean as a dependency into singleton bean). Rather, you need a single userManager object, and, for the lifetime of an HTTP Session, you need a userPreferences object that is specific to the HTTP Session. Thus, the container 61", "chunk_char_count": 1444, "chunk_word_count": 204, "chunk_token_count": 361.0}, {"page_number": 62, "sentence_chunk": "creates an object that exposes the exact same public interface as the UserPreferences class (ideally an object that is a UserPreferences instance), which can fetch the real UserPreferences object from the scoping mechanism (HTTP request, Session, and so forth). The container injects this proxy object into the userManager bean, which is unaware that this UserPreferences reference is a proxy. In this example, when a UserManager instance invokes a method on the dependency-injected UserPreferences object, it is actually invoking a method on the proxy. The proxy then fetches the real UserPreferences object from (in this case) the HTTP Session and delegates the method invocation onto the retrieved real UserPreferences object. Thus, you need the following (correct and complete) configuration when injecting request- and session-scoped beans into collaborating objects, as the following example shows: <bean id=\"userPreferences\" class=\"com.something. UserPreferences\" scope=\"session\"> \u00a0  <aop:scoped-proxy/> </bean> <bean id=\"userManager\" class=\"com.something. UserManager\"> \u00a0  <property name=\"userPreferences\" ref=\"userPreferences\"/> </bean> Choosing the Type of Proxy to Create By default, when the Spring container creates a proxy for a bean that is marked up with the <aop:scoped-proxy/> element, a CGLIB-based class proxy is created.\uf05a CGLIB proxies intercept only public method calls!Do not call non-public methods on such a proxy. They are not delegated to the actual scoped target object.", "chunk_char_count": 1498, "chunk_word_count": 209, "chunk_token_count": 374.5}, {"page_number": 62, "sentence_chunk": "Alternatively, you can configure the Spring container to create standard JDK interface-based proxies for such scoped beans, by specifying false for the value of the proxy-target-class attribute of the <aop:scoped-proxy/> element. Using JDK interface-based proxies means that you do not need additional libraries in your application classpath to affect such proxying. However, it also means that the class of the scoped bean must implement at least one interface and that all collaborators into which the scoped bean is injected must reference the bean through one of its interfaces. The following example shows a proxy based on an interface: <!--DefaultUserPreferences implements the UserPreferences interface --> <bean id=\"userPreferences\" class=\"com.stuff. DefaultUserPreferences\" scope=\"session\"> \u00a0  <aop:scoped-proxy proxy-target-class=\"false\"/> </bean> <bean id=\"userManager\" class=\"com.stuff. UserManager\"> \u00a0  <property name=\"userPreferences\" ref=\"userPreferences\"/> </bean> For more detailed information about choosing class-based or interface-based proxying, see Proxying Mechanisms.62", "chunk_char_count": 1093, "chunk_word_count": 137, "chunk_token_count": 273.25}, {"page_number": 63, "sentence_chunk": "Custom Scopes The bean scoping mechanism is extensible. You can define your own scopes or even redefine existing scopes, although the latter is considered bad practice and you cannot override the built-in singleton and prototype scopes. Creating a Custom Scope To integrate your custom scopes into the Spring container, you need to implement the org.springframework.beans.factory.config. Scope interface, which is described in this section. For an idea of how to implement your own scopes, see the Scope implementations that are supplied with the Spring Framework itself and the Scope javadoc, which explains the methods you need to implement in more detail. The Scope interface has four methods to get objects from the scope, remove them from the scope, and let them be destroyed. The session scope implementation, for example, returns the session-scoped bean (if it does not exist, the method returns a new instance of the bean, after having bound it to the session for future reference). The following method returns the object from the underlying scope: Java Object get(String name, ObjectFactory<?> objectFactory) Kotlin fun get(name: String, objectFactory: ObjectFactory<*>): Any The session scope implementation, for example, removes the session-scoped bean from the underlying session. The object should be returned, but you can return null if the object with the specified name is not found.", "chunk_char_count": 1400, "chunk_word_count": 213, "chunk_token_count": 350.0}, {"page_number": 63, "sentence_chunk": "The following method removes the object from the underlying scope: Java Object remove(String name) Kotlin fun remove(name: String): Any The following method registers a callback that the scope should invoke when it is destroyed or when the specified object in the scope is destroyed: Java void registerDestructionCallback(String name, Runnable destructionCallback) 63", "chunk_char_count": 367, "chunk_word_count": 51, "chunk_token_count": 91.75}, {"page_number": 64, "sentence_chunk": "Kotlin fun registerDestructionCallback(name: String, destructionCallback: Runnable) See the javadoc or a Spring scope implementation for more information on destruction callbacks. The following method obtains the conversation identifier for the underlying scope: Java String getConversationId() Kotlin fun getConversationId(): String This identifier is different for each scope. For a session scoped implementation, this identifier can be the session identifier. Using a Custom Scope After you write and test one or more custom Scope implementations, you need to make the Spring container aware of your new scopes. The following method is the central method to register a new Scope with the Spring container: Java void registerScope(String scopeName, Scope scope); Kotlin fun registerScope(scopeName: String, scope: Scope) This method is declared on the ConfigurableBeanFactory interface, which is available through the BeanFactory property on most of the concrete ApplicationContext implementations that ship with Spring. The first argument to the registerScope(..) method is the unique name associated with a scope. Examples of such names in the Spring container itself are singleton and prototype. The second argument to the registerScope(..) method is an actual instance of the custom Scope implementation that you wish to register and use. Suppose that you write your custom Scope implementation, and then register it as shown in the next example.64", "chunk_char_count": 1454, "chunk_word_count": 207, "chunk_token_count": 363.5}, {"page_number": 65, "sentence_chunk": "\uf05a The next example uses SimpleThreadScope, which is included with Spring but is not registered by default. The instructions would be the same for your own custom Scope implementations. Java Scope threadScope = new SimpleThreadScope(); beanFactory.registerScope(\"thread\", threadScope); Kotlin val threadScope = SimpleThreadScope() beanFactory.registerScope(\"thread\", threadScope) You can then create bean definitions that adhere to the scoping rules of your custom Scope, as follows: <bean id=\"...\" class=\"...\" scope=\"thread\"> With a custom Scope implementation, you are not limited to programmatic registration of the scope. You can also do the Scope registration declaratively, by using the CustomScopeConfigurer class, as the following example shows: 65", "chunk_char_count": 755, "chunk_word_count": 100, "chunk_token_count": 188.75}, {"page_number": 66, "sentence_chunk": "<?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:aop=\"http://www.springframework.org/schema/aop\" \u00a0  xsi:schemaLocation=\"http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/aop \u00a0    https://www.springframework.org/schema/aop/spring-aop.xsd\"> \u00a0  <bean class=\"org.springframework.beans.factory.config. CustomScopeConfigurer\"> \u00a0    <property name=\"scopes\"> \u00a0      <map> \u00a0        <entry key=\"thread\"> \u00a0          <bean class=\"org.springframework.context.support. SimpleThreadScope\"/> \u00a0        </entry> \u00a0      </map> \u00a0    </property> \u00a0  </bean> \u00a0  <bean id=\"thing2\" class=\"x.y. Thing2\" scope=\"thread\"> \u00a0    <property name=\"name\" value=\"Rick\"/> \u00a0    <aop:scoped-proxy/> \u00a0  </bean> \u00a0  <bean id=\"thing1\" class=\"x.y. Thing1\"> \u00a0    <property name=\"thing2\" ref=\"thing2\"/> \u00a0  </bean> </beans> \uf05a When you place <aop:scoped-proxy/> within a <bean> declaration for a FactoryBean implementation, it is the factory bean itself that is scoped, not the object returned from getObject().2.1.6. Customizing the Nature of a Bean The Spring Framework provides a number of interfaces you can use to customize the nature of a bean. This section groups them as follows: \u2022 Lifecycle Callbacks \u2022 ApplicationContextAware and BeanNameAware \u2022 Other Aware Interfaces Lifecycle Callbacks To interact with the container\u2019s management of the bean lifecycle, you can implement the Spring InitializingBean and DisposableBean interfaces.", "chunk_char_count": 1613, "chunk_word_count": 223, "chunk_token_count": 403.25}, {"page_number": 67, "sentence_chunk": "former and destroy() for the latter to let the bean perform certain actions upon initialization and destruction of your beans.\uf0eb The JSR-250 @PostConstruct and @PreDestroy annotations are generally considered best practice for receiving lifecycle callbacks in a modern Spring application. Using these annotations means that your beans are not coupled to Spring-specific interfaces. For details, see Using @PostConstruct and @PreDestroy. If you do not want to use the JSR-250 annotations but you still want to remove coupling, consider init-method and destroy-method bean definition metadata. Internally, the Spring Framework uses BeanPostProcessor implementations to process any callback interfaces it can find and call the appropriate methods. If you need custom features or other lifecycle behavior Spring does not by default offer, you can implement a BeanPostProcessor yourself. For more information, see Container Extension Points. In addition to the initialization and destruction callbacks, Spring-managed objects may also implement the Lifecycle interface so that those objects can participate in the startup and shutdown process, as driven by the container\u2019s own lifecycle. The lifecycle callback interfaces are described in this section.", "chunk_char_count": 1246, "chunk_word_count": 176, "chunk_token_count": 311.5}, {"page_number": 67, "sentence_chunk": "Initialization Callbacks The org.springframework.beans.factory. InitializingBean interface lets a bean perform initialization work after the container has set all necessary properties on the bean. The InitializingBean interface specifies a single method: void afterPropertiesSet() throws Exception; We recommend that you do not use the InitializingBean interface, because it unnecessarily couples the code to Spring. Alternatively, we suggest using the @PostConstruct annotation or specifying a POJO initialization method. In the case of XML-based configuration metadata, you can use the init- method attribute to specify the name of the method that has a void no-argument signature. With Java configuration, you can use the initMethod attribute of @Bean. See Receiving Lifecycle Callbacks. Consider the following example: <bean id=\"exampleInitBean\" class=\"examples. ExampleBean\" init-method=\"init\"/> Java public class ExampleBean { \u00a0  public void init() { \u00a0    // do some initialization work \u00a0  } } 67", "chunk_char_count": 1002, "chunk_word_count": 141, "chunk_token_count": 250.5}, {"page_number": 68, "sentence_chunk": "Kotlin class ExampleBean { \u00a0  fun init() { \u00a0    // do some initialization work \u00a0  } } The preceding example has almost exactly the same effect as the following example (which consists of two listings): <bean id=\"exampleInitBean\" class=\"examples. AnotherExampleBean\"/> Java public class AnotherExampleBean implements InitializingBean { \u00a0  @Override \u00a0  public void afterPropertiesSet() { \u00a0    // do some initialization work \u00a0  } } Kotlin class AnotherExampleBean : InitializingBean { \u00a0  override fun afterPropertiesSet() { \u00a0    // do some initialization work \u00a0  } } However, the first of the two preceding examples does not couple the code to Spring. Destruction Callbacks Implementing the org.springframework.beans.factory. DisposableBean interface lets a bean get a callback when the container that contains it is destroyed. The DisposableBean interface specifies a single method: void destroy() throws Exception; We recommend that you do not use the DisposableBean callback interface, because it unnecessarily couples the code to Spring. Alternatively, we suggest using the @PreDestroy annotation or specifying a generic method that is supported by bean definitions. With XML-based configuration metadata, you can use the destroy-method attribute on the <bean/>. With Java configuration, you can use the 68", "chunk_char_count": 1307, "chunk_word_count": 203, "chunk_token_count": 326.75}, {"page_number": 69, "sentence_chunk": "destroyMethod attribute of @Bean. See Receiving Lifecycle Callbacks. Consider the following definition: <bean id=\"exampleInitBean\" class=\"examples. ExampleBean\" destroy-method=\"cleanup\"/> Java public class ExampleBean { \u00a0  public void cleanup() { \u00a0    // do some destruction work (like releasing pooled connections) \u00a0  } } Kotlin class ExampleBean { \u00a0  fun cleanup() { \u00a0    // do some destruction work (like releasing pooled connections) \u00a0  } } The preceding definition has almost exactly the same effect as the following definition: <bean id=\"exampleInitBean\" class=\"examples. AnotherExampleBean\"/> Java public class AnotherExampleBean implements DisposableBean { \u00a0  @Override \u00a0  public void destroy() { \u00a0    // do some destruction work (like releasing pooled connections) \u00a0  } } Kotlin class AnotherExampleBean : DisposableBean { \u00a0  override fun destroy() { \u00a0    // do some destruction work (like releasing pooled connections) \u00a0  } } 69", "chunk_char_count": 938, "chunk_word_count": 151, "chunk_token_count": 234.5}, {"page_number": 70, "sentence_chunk": "However, the first of the two preceding definitions does not couple the code to Spring.\uf0eb You can assign the destroy-method attribute of a <bean> element a special (inferred) value, which instructs Spring to automatically detect a public close or shutdown method on the specific bean class. (Any class that implements java.lang. AutoCloseable or java.io. Closeable would therefore match.)You can also set this special (inferred) value on the default-destroy-method attribute of a <beans> element to apply this behavior to an entire set of beans (see Default Initialization and Destroy Methods). Note that this is the default behavior with Java configuration. Default Initialization and Destroy Methods When you write initialization and destroy method callbacks that do not use the Spring-specific InitializingBean and DisposableBean callback interfaces, you typically write methods with names such as init(), initialize(), dispose(), and so on. Ideally, the names of such lifecycle callback methods are standardized across a project so that all developers use the same method names and ensure consistency. You can configure the Spring container to \u201clook\u201d for named initialization and destroy callback method names on every bean.", "chunk_char_count": 1227, "chunk_word_count": 181, "chunk_token_count": 306.75}, {"page_number": 70, "sentence_chunk": "This means that you, as an application developer, can write your application classes and use an initialization callback called init(), without having to configure an init-method=\"init\" attribute with each bean definition. The Spring IoC container calls that method when the bean is created (and in accordance with the standard lifecycle callback contract described previously). This feature also enforces a consistent naming convention for initialization and destroy method callbacks. Suppose that your initialization callback methods are named init() and your destroy callback methods are named destroy(). Your class then resembles the class in the following example: Java public class DefaultBlogService implements BlogService { \u00a0  private BlogDao blogDao; \u00a0  public void setBlogDao(BlogDao blogDao) { \u00a0    this.blogDao = blogDao; \u00a0  } \u00a0  // this is (unsurprisingly) the initialization callback method \u00a0  public void init() { \u00a0    if (this.blogDao == null) { \u00a0      throw new IllegalStateException(\"The [blogDao] property must be set.\");\u00a0    } \u00a0  } } 70", "chunk_char_count": 1055, "chunk_word_count": 172, "chunk_token_count": 263.75}, {"page_number": 71, "sentence_chunk": "Kotlin class DefaultBlogService : BlogService { \u00a0  private var blogDao: BlogDao?= null \u00a0  // this is (unsurprisingly) the initialization callback method \u00a0  fun init() { \u00a0    if (blogDao == null) { \u00a0      throw IllegalStateException(\"The [blogDao] property must be set.\")\u00a0    } \u00a0  } } You could then use that class in a bean resembling the following: <beans default-init-method=\"init\"> \u00a0  <bean id=\"blogService\" class=\"com.something. DefaultBlogService\"> \u00a0    <property name=\"blogDao\" ref=\"blogDao\" /> \u00a0  </bean> </beans> The presence of the default-init-method attribute on the top-level <beans/> element attribute causes the Spring IoC container to recognize a method called init on the bean class as the initialization method callback. When a bean is created and assembled, if the bean class has such a method, it is invoked at the appropriate time. You can configure destroy method callbacks similarly (in XML, that is) by using the default- destroy-method attribute on the top-level <beans/> element. Where existing bean classes already have callback methods that are named at variance with the convention, you can override the default by specifying (in XML, that is) the method name by using the init-method and destroy-method attributes of the <bean/> itself. The Spring container guarantees that a configured initialization callback is called immediately after a bean is supplied with all dependencies. Thus, the initialization callback is called on the raw bean reference, which means that AOP interceptors and so forth are not yet applied to the bean. A target bean is fully created first and then an AOP proxy (for example) with its interceptor chain is applied.", "chunk_char_count": 1672, "chunk_word_count": 273, "chunk_token_count": 418.0}, {"page_number": 71, "sentence_chunk": "If the target bean and the proxy are defined separately, your code can even interact with the raw target bean, bypassing the proxy. Hence, it would be inconsistent to apply the interceptors to the init method, because doing so would couple the lifecycle of the target bean to its proxy or interceptors and leave strange semantics when your code interacts directly with the raw target bean.71", "chunk_char_count": 391, "chunk_word_count": 66, "chunk_token_count": 97.75}, {"page_number": 72, "sentence_chunk": "Combining Lifecycle Mechanisms As of Spring 2.5, you have three options for controlling bean lifecycle behavior: \u2022 The InitializingBean and DisposableBean callback interfaces \u2022 Custom init() and destroy() methods \u2022 The @PostConstruct and @PreDestroy annotations. You can combine these mechanisms to control a given bean.\uf05a If multiple lifecycle mechanisms are configured for a bean and each mechanism is configured with a different method name, then each configured method is run in the order listed after this note. However, if the same method name is configured\u2009\u2014\u2009for example, init() for an initialization method\u2009\u2014\u2009for more than one of these lifecycle mechanisms, that method is run once, as explained in the preceding section. Multiple lifecycle mechanisms configured for the same bean, with different initialization methods, are called as follows: 1. Methods annotated with @PostConstruct 2.afterPropertiesSet() as defined by the InitializingBean callback interface 3. A custom configured init() method Destroy methods are called in the same order: 1. Methods annotated with @PreDestroy 2.destroy() as defined by the DisposableBean callback interface 3.", "chunk_char_count": 1156, "chunk_word_count": 166, "chunk_token_count": 289.0}, {"page_number": 72, "sentence_chunk": "A custom configured destroy() method Startup and Shutdown Callbacks The Lifecycle interface defines the essential methods for any object that has its own lifecycle requirements (such as starting and stopping some background process): public interface Lifecycle { \u00a0  void start(); \u00a0  void stop(); \u00a0  boolean isRunning(); } Any Spring-managed object may implement the Lifecycle interface. Then, when the ApplicationContext itself receives start and stop signals (for example, for a stop/restart scenario at runtime), it cascades those calls to all Lifecycle implementations defined within that context. It does this by delegating to a LifecycleProcessor, shown in the following listing: 72", "chunk_char_count": 687, "chunk_word_count": 102, "chunk_token_count": 171.75}, {"page_number": 73, "sentence_chunk": "public interface LifecycleProcessor extends Lifecycle { \u00a0  void onRefresh(); \u00a0  void onClose(); } Notice that the LifecycleProcessor is itself an extension of the Lifecycle interface. It also adds two other methods for reacting to the context being refreshed and closed.\uf0eb Note that the regular org.springframework.context. Lifecycle interface is a plain contract for explicit start and stop notifications and does not imply auto-startup at context refresh time. For fine-grained control over auto-startup of a specific bean (including startup phases), consider implementing org.springframework.context. SmartLifecycle instead. Also, please note that stop notifications are not guaranteed to come before destruction. On regular shutdown, all Lifecycle beans first receive a stop notification before the general destruction callbacks are being propagated. However, on hot refresh during a context\u2019s lifetime or on stopped refresh attempts, only destroy methods are called. The order of startup and shutdown invocations can be important.", "chunk_char_count": 1034, "chunk_word_count": 145, "chunk_token_count": 258.5}, {"page_number": 73, "sentence_chunk": "If a \u201cdepends-on\u201d relationship exists between any two objects, the dependent side starts after its dependency, and it stops before its dependency. However, at times, the direct dependencies are unknown. You may only know that objects of a certain type should start prior to objects of another type. In those cases, the SmartLifecycle interface defines another option, namely the getPhase() method as defined on its super-interface, Phased. The following listing shows the definition of the Phased interface: public interface Phased { \u00a0  int getPhase(); } The following listing shows the definition of the SmartLifecycle interface: public interface SmartLifecycle extends Lifecycle, Phased { \u00a0  boolean isAutoStartup(); \u00a0  void stop(Runnable callback); } When starting, the objects with the lowest phase start first. When stopping, the reverse order is followed. Therefore, an object that implements SmartLifecycle and whose getPhase() method returns Integer. MIN_VALUE would be among the first to start and the last to stop. At the other end of 73", "chunk_char_count": 1047, "chunk_word_count": 161, "chunk_token_count": 261.75}, {"page_number": 74, "sentence_chunk": "the spectrum, a phase value of Integer. MAX_VALUE would indicate that the object should be started last and stopped first (likely because it depends on other processes to be running). When considering the phase value, it is also important to know that the default phase for any \u201cnormal\u201d Lifecycle object that does not implement SmartLifecycle is 0. Therefore, any negative phase value indicates that an object should start before those standard components (and stop after them). The reverse is true for any positive phase value. The stop method defined by SmartLifecycle accepts a callback. Any implementation must invoke that callback\u2019s run() method after that implementation\u2019s shutdown process is complete. That enables asynchronous shutdown where necessary, since the default implementation of the LifecycleProcessor interface, DefaultLifecycleProcessor, waits up to its timeout value for the group of objects within each phase to invoke that callback. The default per-phase timeout is 30 seconds. You can override the default lifecycle processor instance by defining a bean named lifecycleProcessor within the context.", "chunk_char_count": 1122, "chunk_word_count": 166, "chunk_token_count": 280.5}, {"page_number": 74, "sentence_chunk": "If you want only to modify the timeout, defining the following would suffice: <bean id=\"lifecycleProcessor\" class=\"org.springframework.context.support. DefaultLifecycleProcessor\"> \u00a0  <!--timeout value in milliseconds --> \u00a0  <property name=\"timeoutPerShutdownPhase\" value=\"10000\"/> </bean> As mentioned earlier, the LifecycleProcessor interface defines callback methods for the refreshing and closing of the context as well. The latter drives the shutdown process as if stop() had been called explicitly, but it happens when the context is closing. The 'refresh' callback, on the other hand, enables another feature of SmartLifecycle beans. When the context is refreshed (after all objects have been instantiated and initialized), that callback is invoked. At that point, the default lifecycle processor checks the boolean value returned by each SmartLifecycle object\u2019s isAutoStartup() method. If true, that object is started at that point rather than waiting for an explicit invocation of the context\u2019s or its own start() method (unlike the context refresh, the context start does not happen automatically for a standard context implementation). The phase value and any \u201cdepends-on\u201d relationships determine the startup order as described earlier. Shutting Down the Spring IoC Container Gracefully in Non-Web Applications \uf05a This section applies only to non-web applications.", "chunk_char_count": 1373, "chunk_word_count": 190, "chunk_token_count": 343.25}, {"page_number": 74, "sentence_chunk": "Spring\u2019s web-based ApplicationContext implementations already have code in place to gracefully shut down the Spring IoC container when the relevant web application is shut down. If you use Spring\u2019s IoC container in a non-web application environment (for example, in a rich client desktop environment), register a shutdown hook with the JVM. Doing so ensures a graceful shutdown and calls the relevant destroy methods on your singleton beans so that all resources are released. You must still configure and implement these destroy callbacks correctly. To register a shutdown hook, call the registerShutdownHook() method that is declared on the ConfigurableApplicationContext interface, as the following example shows: 74", "chunk_char_count": 719, "chunk_word_count": 105, "chunk_token_count": 179.75}, {"page_number": 75, "sentence_chunk": "Java import org.springframework.context. ConfigurableApplicationContext; import org.springframework.context.support. ClassPathXmlApplicationContext; public final class Boot { \u00a0  public static void main(final String[] args) throws Exception { \u00a0    ConfigurableApplicationContext ctx = new ClassPathXmlApplicationContext(\"beans.xml\"); \u00a0    // add a shutdown hook for the above context... \u00a0    ctx.registerShutdownHook(); \u00a0    // app runs here... \u00a0    // main method exits, hook is called prior to the app shutting down... \u00a0  } } Kotlin import org.springframework.context.support. ClassPathXmlApplicationContext fun main() { \u00a0  val ctx = ClassPathXmlApplicationContext(\"beans.xml\") \u00a0  // add a shutdown hook for the above context... \u00a0  ctx.registerShutdownHook() \u00a0  // app runs here... \u00a0  // main method exits, hook is called prior to the app shutting down... } ApplicationContextAware and BeanNameAware When an ApplicationContext creates an object instance that implements the org.springframework.context. ApplicationContextAware interface, the instance is provided with a reference to that ApplicationContext. The following listing shows the definition of the ApplicationContextAware interface: public interface ApplicationContextAware { \u00a0  void setApplicationContext(ApplicationContext applicationContext) throws BeansException; } 75", "chunk_char_count": 1333, "chunk_word_count": 177, "chunk_token_count": 333.25}, {"page_number": 76, "sentence_chunk": "Thus, beans can programmatically manipulate the ApplicationContext that created them, through the ApplicationContext interface or by casting the reference to a known subclass of this interface (such as ConfigurableApplicationContext, which exposes additional functionality). One use would be the programmatic retrieval of other beans. Sometimes this capability is useful. However, in general, you should avoid it, because it couples the code to Spring and does not follow the Inversion of Control style, where collaborators are provided to beans as properties. Other methods of the ApplicationContext provide access to file resources, publishing application events, and accessing a MessageSource. These additional features are described in Additional Capabilities of the ApplicationContext. Autowiring is another alternative to obtain a reference to the ApplicationContext. The traditional constructor and byType autowiring modes (as described in Autowiring Collaborators) can provide a dependency of type ApplicationContext for a constructor argument or a setter method parameter, respectively. For more flexibility, including the ability to autowire fields and multiple parameter methods, use the annotation-based autowiring features. If you do, the ApplicationContext is autowired into a field, constructor argument, or method parameter that expects the ApplicationContext type if the field, constructor, or method in question carries the @Autowired annotation.", "chunk_char_count": 1464, "chunk_word_count": 197, "chunk_token_count": 366.0}, {"page_number": 76, "sentence_chunk": "For more information, see Using @Autowired. When an ApplicationContext creates a class that implements the org.springframework.beans.factory. BeanNameAware interface, the class is provided with a reference to the name defined in its associated object definition. The following listing shows the definition of the BeanNameAware interface: public interface BeanNameAware { \u00a0  void setBeanName(String name) throws BeansException; } The callback is invoked after population of normal bean properties but before an initialization callback such as InitializingBean.afterPropertiesSet() or a custom init-method. Other Aware Interfaces Besides ApplicationContextAware and BeanNameAware (discussed earlier), Spring offers a wide range of Aware callback interfaces that let beans indicate to the container that they require a certain infrastructure dependency. As a general rule, the name indicates the dependency type. The following table summarizes the most important Aware interfaces: Table 4. Aware interfaces Name Injected Dependency Explained in\u2026 ApplicationContextAware Declaring ApplicationContext. ApplicationContextAware and BeanNameAware ApplicationEventPublisherAware Event publisher of the enclosing ApplicationContext. Additional Capabilities of the ApplicationContext 76", "chunk_char_count": 1275, "chunk_word_count": 157, "chunk_token_count": 318.75}, {"page_number": 77, "sentence_chunk": "Name Injected Dependency Explained in\u2026 BeanClassLoaderAware Class loader used to load the bean classes. Instantiating Beans BeanFactoryAware Declaring BeanFactory. The BeanFactory API BeanNameAware Name of the declaring bean. ApplicationContextAware and BeanNameAware LoadTimeWeaverAware Defined weaver for processing class definition at load time. Load-time Weaving with AspectJ in the Spring Framework MessageSourceAware Configured strategy for resolving messages (with support for parametrization and internationalization). Additional Capabilities of the ApplicationContext NotificationPublisherAware Spring JMX notification publisher. Notifications ResourceLoaderAware Configured loader for low-level access to resources. Resources ServletConfigAware Current ServletConfig the container runs in. Valid only in a web-aware Spring ApplicationContext. Spring MVC ServletContextAware Current ServletContext the container runs in.", "chunk_char_count": 929, "chunk_word_count": 104, "chunk_token_count": 232.25}, {"page_number": 77, "sentence_chunk": "Valid only in a web-aware Spring ApplicationContext. Spring MVC Note again that using these interfaces ties your code to the Spring API and does not follow the Inversion of Control style. As a result, we recommend them for infrastructure beans that require programmatic access to the container.2.1.7. Bean Definition Inheritance A bean definition can contain a lot of configuration information, including constructor arguments, property values, and container-specific information, such as the initialization method, a static factory method name, and so on. A child bean definition inherits configuration data from a parent definition. The child definition can override some values or add others as needed. Using parent and child bean definitions can save a lot of typing. Effectively, this is a form of templating. If you work with an ApplicationContext interface programmatically, child bean definitions are represented by the ChildBeanDefinition class.", "chunk_char_count": 954, "chunk_word_count": 140, "chunk_token_count": 238.5}, {"page_number": 77, "sentence_chunk": "Most users do not work with them on this level. Instead, they configure bean definitions declaratively in a class such as the ClassPathXmlApplicationContext. When you use XML-based configuration metadata, you can indicate a child bean definition by using the parent attribute, specifying the parent bean as the value of this attribute. The following example shows how to do so: 77", "chunk_char_count": 380, "chunk_word_count": 60, "chunk_token_count": 95.0}, {"page_number": 78, "sentence_chunk": "<bean id=\"inheritedTestBean\" abstract=\"true\" \u00a0    class=\"org.springframework.beans. TestBean\"> \u00a0  <property name=\"name\" value=\"parent\"/> \u00a0  <property name=\"age\" value=\"1\"/> </bean> <bean id=\"inheritsWithDifferentClass\" \u00a0    class=\"org.springframework.beans. DerivedTestBean\" \u00a0    parent=\"inheritedTestBean\" init-method=\"initialize\"> \u2460 \u00a0  <property name=\"name\" value=\"override\"/> \u00a0  <!--the age property value of 1 will be inherited from parent --> </bean> \u2460 Note the parent attribute. A child bean definition uses the bean class from the parent definition if none is specified but can also override it. In the latter case, the child bean class must be compatible with the parent (that is, it must accept the parent\u2019s property values). A child bean definition inherits scope, constructor argument values, property values, and method overrides from the parent, with the option to add new values. Any scope, initialization method, destroy method, or static factory method settings that you specify override the corresponding parent settings. The remaining settings are always taken from the child definition: depends on, autowire mode, dependency check, singleton, and lazy init. The preceding example explicitly marks the parent bean definition as abstract by using the abstract attribute.", "chunk_char_count": 1287, "chunk_word_count": 183, "chunk_token_count": 321.75}, {"page_number": 78, "sentence_chunk": "If the parent definition does not specify a class, explicitly marking the parent bean definition as abstract is required, as the following example shows: <bean id=\"inheritedTestBeanWithoutClass\" abstract=\"true\"> \u00a0  <property name=\"name\" value=\"parent\"/> \u00a0  <property name=\"age\" value=\"1\"/> </bean> <bean id=\"inheritsWithClass\" class=\"org.springframework.beans. DerivedTestBean\" \u00a0    parent=\"inheritedTestBeanWithoutClass\" init-method=\"initialize\"> \u00a0  <property name=\"name\" value=\"override\"/> \u00a0  <!--age will inherit the value of 1 from the parent bean definition--> </bean> The parent bean cannot be instantiated on its own because it is incomplete, and it is also explicitly marked as abstract. When a definition is abstract, it is usable only as a pure template bean definition that serves as a parent definition for child definitions. Trying to use such an abstract parent bean on its own, by referring to it as a ref property of another bean or doing an explicit getBean() call with the parent bean ID returns an error. Similarly, the container\u2019s internal preInstantiateSingletons() method ignores bean definitions that are defined as abstract.78", "chunk_char_count": 1150, "chunk_word_count": 163, "chunk_token_count": 287.5}, {"page_number": 79, "sentence_chunk": "\uf05a ApplicationContext pre-instantiates all singletons by default. Therefore, it is important (at least for singleton beans) that if you have a (parent) bean definition which you intend to use only as a template, and this definition specifies a class, you must make sure to set the abstract attribute to true, otherwise the application context will actually (attempt to) pre-instantiate the abstract bean.2.1.8. Container Extension Points Typically, an application developer does not need to subclass ApplicationContext implementation classes. Instead, the Spring IoC container can be extended by plugging in implementations of special integration interfaces. The next few sections describe these integration interfaces. Customizing Beans by Using a BeanPostProcessor The BeanPostProcessor interface defines callback methods that you can implement to provide your own (or override the container\u2019s default) instantiation logic, dependency resolution logic, and so forth. If you want to implement some custom logic after the Spring container finishes instantiating, configuring, and initializing a bean, you can plug in one or more custom BeanPostProcessor implementations. You can configure multiple BeanPostProcessor instances, and you can control the order in which these BeanPostProcessor instances run by setting the order property. You can set this property only if the BeanPostProcessor implements the Ordered interface.", "chunk_char_count": 1423, "chunk_word_count": 199, "chunk_token_count": 355.75}, {"page_number": 79, "sentence_chunk": "If you write your own BeanPostProcessor, you should consider implementing the Ordered interface, too. For further details, see the javadoc of the BeanPostProcessor and Ordered interfaces. See also the note on programmatic registration of BeanPostProcessor instances.\uf05a BeanPostProcessor instances operate on bean (or object) instances. That is, the Spring IoC container instantiates a bean instance and then BeanPostProcessor instances do their work. BeanPostProcessor instances are scoped per-container. This is relevant only if you use container hierarchies. If you define a BeanPostProcessor in one container, it post-processes only the beans in that container. In other words, beans that are defined in one container are not post-processed by a BeanPostProcessor defined in another container, even if both containers are part of the same hierarchy. To change the actual bean definition (that is, the blueprint that defines the bean), you instead need to use a BeanFactoryPostProcessor, as described in Customizing Configuration Metadata with a BeanFactoryPostProcessor.", "chunk_char_count": 1072, "chunk_word_count": 151, "chunk_token_count": 268.0}, {"page_number": 79, "sentence_chunk": "The org.springframework.beans.factory.config. BeanPostProcessor interface consists of exactly two callback methods. When such a class is registered as a post-processor with the container, for each bean instance that is created by the container, the post-processor gets a callback from the container both before container initialization methods (such as InitializingBean.afterPropertiesSet() or any declared init method) are called, and after any bean initialization callbacks. The post-processor can take any action with the bean instance, including ignoring the callback completely. A bean post- processor typically checks for callback interfaces, or it may wrap a bean with a proxy. Some Spring 79", "chunk_char_count": 699, "chunk_word_count": 97, "chunk_token_count": 174.75}, {"page_number": 80, "sentence_chunk": "AOP infrastructure classes are implemented as bean post-processors in order to provide proxy- wrapping logic. An ApplicationContext automatically detects any beans that are defined in the configuration metadata that implement the BeanPostProcessor interface. The ApplicationContext registers these beans as post-processors so that they can be called later, upon bean creation. Bean post-processors can be deployed in the container in the same fashion as any other beans. Note that, when declaring a BeanPostProcessor by using an @Bean factory method on a configuration class, the return type of the factory method should be the implementation class itself or at least the org.springframework.beans.factory.config. BeanPostProcessor interface, clearly indicating the post- processor nature of that bean. Otherwise, the ApplicationContext cannot autodetect it by type before fully creating it. Since a BeanPostProcessor needs to be instantiated early in order to apply to the initialization of other beans in the context, this early type detection is critical.\uf05a Programmatically registering BeanPostProcessor instances While the recommended approach for BeanPostProcessor registration is through ApplicationContext auto-detection (as described earlier), you can register them programmatically against a ConfigurableBeanFactory by using the addBeanPostProcessor method. This can be useful when you need to evaluate conditional logic before registration or even for copying bean post processors across contexts in a hierarchy.", "chunk_char_count": 1522, "chunk_word_count": 206, "chunk_token_count": 380.5}, {"page_number": 80, "sentence_chunk": "Note, however, that BeanPostProcessor instances added programmatically do not respect the Ordered interface. Here, it is the order of registration that dictates the order of execution. Note also that BeanPostProcessor instances registered programmatically are always processed before those registered through auto-detection, regardless of any explicit ordering.\uf05a BeanPostProcessor instances and AOP auto-proxying Classes that implement the BeanPostProcessor interface are special and are treated differently by the container. All BeanPostProcessor instances and beans that they directly reference are instantiated on startup, as part of the special startup phase of the ApplicationContext. Next, all BeanPostProcessor instances are registered in a sorted fashion and applied to all further beans in the container. Because AOP auto- proxying is implemented as a BeanPostProcessor itself, neither BeanPostProcessor instances nor the beans they directly reference are eligible for auto-proxying and, thus, do not have aspects woven into them. For any such bean, you should see an informational log message: Bean someBean is not eligible for getting processed by all BeanPostProcessor interfaces (for example: not eligible for auto-proxying). If you have beans wired into your BeanPostProcessor by using autowiring or @Resource (which may fall back to autowiring), Spring might access unexpected beans when searching for type-matching dependency candidates and, therefore, make them ineligible for auto-proxying or other kinds of bean post-processing. For example, if you have a dependency annotated with @Resource where the field or setter name does not directly correspond to the declared name of a bean and no name attribute is used, Spring accesses other beans for matching them by type.", "chunk_char_count": 1787, "chunk_word_count": 254, "chunk_token_count": 446.75}, {"page_number": 81, "sentence_chunk": "The following examples show how to write, register, and use BeanPostProcessor instances in an ApplicationContext. Example: Hello World, BeanPostProcessor-style This first example illustrates basic usage. The example shows a custom BeanPostProcessor implementation that invokes the toString() method of each bean as it is created by the container and prints the resulting string to the system console. The following listing shows the custom BeanPostProcessor implementation class definition: Java package scripting; import org.springframework.beans.factory.config. BeanPostProcessor; public class InstantiationTracingBeanPostProcessor implements BeanPostProcessor { \u00a0  // simply return the instantiated bean as-is \u00a0  public Object postProcessBeforeInitialization(Object bean, String beanName) { \u00a0    return bean; // we could potentially return any object reference here... \u00a0  } \u00a0  public Object postProcessAfterInitialization(Object bean, String beanName) { \u00a0    System.out.println(\"Bean '\" + beanName + \"' created : \" + bean.toString()); \u00a0    return bean; \u00a0  } } Kotlin import org.springframework.beans.factory.config. BeanPostProcessor class InstantiationTracingBeanPostProcessor : BeanPostProcessor { \u00a0  // simply return the instantiated bean as-is \u00a0  override fun postProcessBeforeInitialization(bean: Any, beanName: String): Any? {\u00a0    return bean // we could potentially return any object reference here... \u00a0  } \u00a0  override fun postProcessAfterInitialization(bean: Any, beanName: String): Any? {\u00a0    println(\"Bean '$beanName' created : $bean\") \u00a0    return bean \u00a0  } } The following beans element uses the InstantiationTracingBeanPostProcessor: 81", "chunk_char_count": 1651, "chunk_word_count": 229, "chunk_token_count": 412.75}, {"page_number": 82, "sentence_chunk": "<?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:lang=\"http://www.springframework.org/schema/lang\" \u00a0  xsi:schemaLocation=\"http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/lang \u00a0    https://www.springframework.org/schema/lang/spring-lang.xsd\"> \u00a0  <lang:groovy id=\"messenger\" \u00a0      script- source=\"classpath:org/springframework/scripting/groovy/Messenger.groovy\"> \u00a0    <lang:property name=\"message\" value=\"Fiona Apple Is Just So Dreamy.\"/> \u00a0  </lang:groovy> \u00a0  <!--\u00a0  when the above bean (messenger) is instantiated, this custom \u00a0  BeanPostProcessor implementation will output the fact to the system console \u00a0  --> \u00a0  <bean class=\"scripting. InstantiationTracingBeanPostProcessor\"/> </beans> Notice how the InstantiationTracingBeanPostProcessor is merely defined. It does not even have a name, and, because it is a bean, it can be dependency-injected as you would any other bean. (The preceding configuration also defines a bean that is backed by a Groovy script. The Spring dynamic language support is detailed in the chapter entitled Dynamic Language Support.)The following Java application runs the preceding code and configuration: Java import org.springframework.context.", "chunk_char_count": 1395, "chunk_word_count": 160, "chunk_token_count": 348.75}, {"page_number": 82, "sentence_chunk": "ApplicationContext; import org.springframework.context.support. ClassPathXmlApplicationContext; import org.springframework.scripting. Messenger; public final class Boot { \u00a0  public static void main(final String[] args) throws Exception { \u00a0    ApplicationContext ctx = new ClassPathXmlApplicationContext(\"scripting/beans.xml\"); \u00a0    Messenger messenger = ctx.getBean(\"messenger\", Messenger.class); \u00a0    System.out.println(messenger); \u00a0  } } 82", "chunk_char_count": 442, "chunk_word_count": 51, "chunk_token_count": 110.5}, {"page_number": 83, "sentence_chunk": "Kotlin import org.springframework.beans.factory.getBean fun main() { \u00a0  val ctx = ClassPathXmlApplicationContext(\"scripting/beans.xml\") \u00a0  val messenger = ctx.getBean<Messenger>(\"messenger\") \u00a0  println(messenger) } The output of the preceding application resembles the following: Bean 'messenger' created : org.springframework.scripting.groovy. GroovyMessenger@272961 org.springframework.scripting.groovy. GroovyMessenger@272961 Example: The AutowiredAnnotationBeanPostProcessor Using callback interfaces or annotations in conjunction with a custom BeanPostProcessor implementation is a common means of extending the Spring IoC container. An example is Spring\u2019s AutowiredAnnotationBeanPostProcessor\u2009\u2014\u2009a BeanPostProcessor implementation that ships with the Spring distribution and autowires annotated fields, setter methods, and arbitrary config methods. Customizing Configuration Metadata with a BeanFactoryPostProcessor The next extension point that we look at is the org.springframework.beans.factory.config. BeanFactoryPostProcessor. The semantics of this interface are similar to those of the BeanPostProcessor, with one major difference: BeanFactoryPostProcessor operates on the bean configuration metadata. That is, the Spring IoC container lets a BeanFactoryPostProcessor read the configuration metadata and potentially change it before the container instantiates any beans other than BeanFactoryPostProcessor instances. You can configure multiple BeanFactoryPostProcessor instances, and you can control the order in which these BeanFactoryPostProcessor instances run by setting the order property. However, you can only set this property if the BeanFactoryPostProcessor implements the Ordered interface.", "chunk_char_count": 1711, "chunk_word_count": 192, "chunk_token_count": 427.75}, {"page_number": 83, "sentence_chunk": "If you write your own BeanFactoryPostProcessor, you should consider implementing the Ordered interface, too. See the javadoc of the BeanFactoryPostProcessor and Ordered interfaces for more details.83", "chunk_char_count": 199, "chunk_word_count": 26, "chunk_token_count": 49.75}, {"page_number": 84, "sentence_chunk": "\uf05a If you want to change the actual bean instances (that is, the objects that are created from the configuration metadata), then you instead need to use a BeanPostProcessor (described earlier in Customizing Beans by Using a BeanPostProcessor). While it is technically possible to work with bean instances within a BeanFactoryPostProcessor (for example, by using BeanFactory.getBean()), doing so causes premature bean instantiation, violating the standard container lifecycle. This may cause negative side effects, such as bypassing bean post processing. Also, BeanFactoryPostProcessor instances are scoped per-container. This is only relevant if you use container hierarchies. If you define a BeanFactoryPostProcessor in one container, it is applied only to the bean definitions in that container. Bean definitions in one container are not post-processed by BeanFactoryPostProcessor instances in another container, even if both containers are part of the same hierarchy. A bean factory post-processor is automatically run when it is declared inside an ApplicationContext, in order to apply changes to the configuration metadata that define the container. Spring includes a number of predefined bean factory post-processors, such as PropertyOverrideConfigurer and PropertySourcesPlaceholderConfigurer. You can also use a custom BeanFactoryPostProcessor\u2009\u2014\u2009for example, to register custom property editors.", "chunk_char_count": 1402, "chunk_word_count": 191, "chunk_token_count": 350.5}, {"page_number": 84, "sentence_chunk": "An ApplicationContext automatically detects any beans that are deployed into it that implement the BeanFactoryPostProcessor interface. It uses these beans as bean factory post-processors, at the appropriate time. You can deploy these post-processor beans as you would any other bean.\uf05a As with BeanPostProcessors , you typically do not want to configure BeanFactoryPostProcessors for lazy initialization. If no other bean references a Bean(Factory)PostProcessor, that post-processor will not get instantiated at all. Thus, marking it for lazy initialization will be ignored, and the Bean(Factory)PostProcessor will be instantiated eagerly even if you set the default- lazy-init attribute to true on the declaration of your <beans /> element. Example: The Class Name Substitution PropertySourcesPlaceholderConfigurer You can use the PropertySourcesPlaceholderConfigurer to externalize property values from a bean definition in a separate file by using the standard Java Properties format. Doing so enables the person deploying an application to customize environment-specific properties, such as database URLs and passwords, without the complexity or risk of modifying the main XML definition file or files for the container. Consider the following XML-based configuration metadata fragment, where a DataSource with placeholder values is defined: 84", "chunk_char_count": 1347, "chunk_word_count": 185, "chunk_token_count": 336.75}, {"page_number": 85, "sentence_chunk": "<bean class=\"org.springframework.context.support. PropertySourcesPlaceholderConfigurer\"> \u00a0  <property name=\"locations\" value=\"classpath:com/something/jdbc.properties\"/> </bean> <bean id=\"dataSource\" destroy-method=\"close\" \u00a0    class=\"org.apache.commons.dbcp. BasicDataSource\"> \u00a0  <property name=\"driverClassName\" value=\"${jdbc.driverClassName}\"/> \u00a0  <property name=\"url\" value=\"${jdbc.url}\"/> \u00a0  <property name=\"username\" value=\"${jdbc.username}\"/> \u00a0  <property name=\"password\" value=\"${jdbc.password}\"/> </bean> The example shows properties configured from an external Properties file. At runtime, a PropertySourcesPlaceholderConfigurer is applied to the metadata that replaces some properties of the DataSource. The values to replace are specified as placeholders of the form ${property-name}, which follows the Ant and log4j and JSP EL style. The actual values come from another file in the standard Java Properties format: jdbc.driverClassName=org.hsqldb.jdbcDriver jdbc.url=jdbc:hsqldb:hsql://production:9002 jdbc.username=sa jdbc.password=root Therefore, the ${jdbc.username} string is replaced at runtime with the value, 'sa', and the same applies for other placeholder values that match keys in the properties file. The PropertySourcesPlaceholderConfigurer checks for placeholders in most properties and attributes of a bean definition. Furthermore, you can customize the placeholder prefix and suffix. With the context namespace introduced in Spring 2.5, you can configure property placeholders with a dedicated configuration element. You can provide one or more locations as a comma- separated list in the location attribute, as the following example shows: <context:property-placeholder location=\"classpath:com/something/jdbc.properties\"/> The PropertySourcesPlaceholderConfigurer not only looks for properties in the Properties file you specify.", "chunk_char_count": 1857, "chunk_word_count": 208, "chunk_token_count": 464.25}, {"page_number": 85, "sentence_chunk": "By default, if it cannot find a property in the specified properties files, it checks against Spring Environment properties and regular Java System properties.85", "chunk_char_count": 161, "chunk_word_count": 24, "chunk_token_count": 40.25}, {"page_number": 86, "sentence_chunk": "\uf0eb You can use the PropertySourcesPlaceholderConfigurer to substitute class names, which is sometimes useful when you have to pick a particular implementation class at runtime. The following example shows how to do so: <bean class=\"org.springframework.beans.factory.config. PropertySourcesPlacehol derConfigurer\"> \u00a0  <property name=\"locations\"> \u00a0    <value>classpath:com/something/strategy.properties</value> \u00a0  </property> \u00a0  <property name=\"properties\"> \u00a0 <value>custom.strategy.class=com.something. DefaultStrategy</value> \u00a0  </property> </bean> <bean id=\"serviceStrategy\" class=\"${custom.strategy.class}\"/> If the class cannot be resolved at runtime to a valid class, resolution of the bean fails when it is about to be created, which is during the preInstantiateSingletons() phase of an ApplicationContext for a non-lazy-init bean. Example: The PropertyOverrideConfigurer The PropertyOverrideConfigurer, another bean factory post-processor, resembles the PropertySourcesPlaceholderConfigurer, but unlike the latter, the original definitions can have default values or no values at all for bean properties. If an overriding Properties file does not have an entry for a certain bean property, the default context definition is used. Note that the bean definition is not aware of being overridden, so it is not immediately obvious from the XML definition file that the override configurer is being used. In case of multiple PropertyOverrideConfigurer instances that define different values for the same bean property, the last one wins, due to the overriding mechanism. Properties file configuration lines take the following format: beanName.property=value The following listing shows an example of the format: dataSource.driverClassName=com.mysql.jdbc. Driver dataSource.url=jdbc:mysql:mydb This example file can be used with a container definition that contains a bean called dataSource that has driver and url properties.", "chunk_char_count": 1925, "chunk_word_count": 248, "chunk_token_count": 481.25}, {"page_number": 87, "sentence_chunk": "final property being overridden is already non-null (presumably initialized by the constructors). In the following example, the sammy property of the bob property of the fred property of the tom bean is set to the scalar value 123: tom.fred.bob.sammy=123 \uf05a Specified override values are always literal values. They are not translated into bean references. This convention also applies when the original value in the XML bean definition specifies a bean reference. With the context namespace introduced in Spring 2.5, it is possible to configure property overriding with a dedicated configuration element, as the following example shows: <context:property-override location=\"classpath:override.properties\"/> Customizing Instantiation Logic with a FactoryBean You can implement the org.springframework.beans.factory. FactoryBean interface for objects that are themselves factories. The FactoryBean interface is a point of pluggability into the Spring IoC container\u2019s instantiation logic. If you have complex initialization code that is better expressed in Java as opposed to a (potentially) verbose amount of XML, you can create your own FactoryBean, write the complex initialization inside that class, and then plug your custom FactoryBean into the container. The FactoryBean<T> interface provides three methods: \u2022 T getObject(): Returns an instance of the object this factory creates. The instance can possibly be shared, depending on whether this factory returns singletons or prototypes. \u2022", "chunk_char_count": 1491, "chunk_word_count": 209, "chunk_token_count": 372.75}, {"page_number": 87, "sentence_chunk": "boolean isSingleton(): Returns true if this FactoryBean returns singletons or false otherwise. The default implementation of this method returns true. \u2022Class<?> getObjectType(): Returns the object type returned by the getObject() method or null if the type is not known in advance. The FactoryBean concept and interface are used in a number of places within the Spring Framework. More than 50 implementations of the FactoryBean interface ship with Spring itself. When you need to ask a container for an actual FactoryBean instance itself instead of the bean it produces, prefix the bean\u2019s id with the ampersand symbol (&) when calling the getBean() method of the ApplicationContext. So, for a given FactoryBean with an id of myBean, invoking getBean(\"myBean\") on the container returns the product of the FactoryBean, whereas invoking getBean(\"&myBean\") returns the FactoryBean instance itself.2.1.9. Annotation-based Container Configuration 87", "chunk_char_count": 943, "chunk_word_count": 138, "chunk_token_count": 235.75}, {"page_number": 88, "sentence_chunk": "Are annotations better than XML for configuring Spring?The introduction of annotation-based configuration raised the question of whether this approach is \u201cbetter\u201d than XML. The short answer is \u201cit depends.\u201dThe long answer is that each approach has its pros and cons, and, usually, it is up to the developer to decide which strategy suits them better. Due to the way they are defined, annotations provide a lot of context in their declaration, leading to shorter and more concise configuration. However, XML excels at wiring up components without touching their source code or recompiling them. Some developers prefer having the wiring close to the source while others argue that annotated classes are no longer POJOs and, furthermore, that the configuration becomes decentralized and harder to control. No matter the choice, Spring can accommodate both styles and even mix them together. It is worth pointing out that through its JavaConfig option, Spring lets annotations be used in a non-invasive way, without touching the target components source code and that, in terms of tooling, all configuration styles are supported by the Spring Tools for Eclipse. An alternative to XML setup is provided by annotation-based configuration, which relies on the bytecode metadata for wiring up components instead of angle-bracket declarations.", "chunk_char_count": 1334, "chunk_word_count": 205, "chunk_token_count": 333.5}, {"page_number": 88, "sentence_chunk": "Instead of using XML to describe a bean wiring, the developer moves the configuration into the component class itself by using annotations on the relevant class, method, or field declaration. As mentioned in Example: The AutowiredAnnotationBeanPostProcessor, using a BeanPostProcessor in conjunction with annotations is a common means of extending the Spring IoC container. For example, Spring 2.5 introduced an annotation-based approach to drive Spring\u2019s dependency injection. Essentially, the @Autowired annotation provides the same capabilities as described in Autowiring Collaborators but with more fine-grained control and wider applicability. Spring 2.5 also added support for JSR-250 annotations, such as @PostConstruct and @PreDestroy. Spring 3.0 added support for JSR-330 (Dependency Injection for Java) annotations contained in the jakarta.inject package such as @Inject and @Named. Details about those annotations can be found in the relevant section.\uf05a Annotation injection is performed before XML injection. Thus, the XML configuration overrides the annotations for properties wired through both approaches. As always, you can register the post-processors as individual bean definitions, but they can also be implicitly registered by including the following tag in an XML-based Spring configuration (notice the inclusion of the context namespace): 88", "chunk_char_count": 1362, "chunk_word_count": 188, "chunk_token_count": 340.5}, {"page_number": 89, "sentence_chunk": "<?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:context=\"http://www.springframework.org/schema/context\" \u00a0  xsi:schemaLocation=\"http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/context \u00a0    https://www.springframework.org/schema/context/spring-context.xsd\"> \u00a0  <context:annotation-config/> </beans> The <context:annotation-config/> element implicitly registers the following post-processors: \u2022 ConfigurationClassPostProcessor \u2022 AutowiredAnnotationBeanPostProcessor \u2022 CommonAnnotationBeanPostProcessor \u2022 PersistenceAnnotationBeanPostProcessor \u2022 EventListenerMethodProcessor \uf05a <context:annotation-config/> only looks for annotations on beans in the same application context in which it is defined. This means that, if you put <context:annotation-config/> in a WebApplicationContext for a DispatcherServlet, it only checks for @Autowired beans in your controllers, and not your services. See The DispatcherServlet for more information. Using @Autowired \uf05a JSR 330\u2019s @Inject annotation can be used in place of Spring\u2019s @Autowired annotation in the examples included in this section. See here for more details. You can apply the @Autowired annotation to constructors, as the following example shows: 89", "chunk_char_count": 1416, "chunk_word_count": 143, "chunk_token_count": 354.0}, {"page_number": 90, "sentence_chunk": "Java public class MovieRecommender { \u00a0  private final CustomerPreferenceDao customerPreferenceDao; \u00a0  @Autowired \u00a0  public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) { \u00a0    this.customerPreferenceDao = customerPreferenceDao; \u00a0  } \u00a0  // ... } Kotlin class MovieRecommender @Autowired constructor( \u00a0  private val customerPreferenceDao: CustomerPreferenceDao) \uf05a As of Spring Framework 4.3, an @Autowired annotation on such a constructor is no longer necessary if the target bean defines only one constructor to begin with. However, if several constructors are available and there is no primary/default constructor, at least one of the constructors must be annotated with @Autowired in order to instruct the container which one to use. See the discussion on constructor resolution for details. You can also apply the @Autowired annotation to traditional setter methods, as the following example shows: Java public class SimpleMovieLister { \u00a0  private MovieFinder movieFinder; \u00a0  @Autowired \u00a0  public void setMovieFinder(MovieFinder movieFinder) { \u00a0    this.movieFinder = movieFinder; \u00a0  } \u00a0  // ... } 90", "chunk_char_count": 1118, "chunk_word_count": 167, "chunk_token_count": 279.5}, {"page_number": 91, "sentence_chunk": "Kotlin class SimpleMovieLister { \u00a0  @set:Autowired \u00a0  lateinit var movieFinder: MovieFinder \u00a0  // ... } You can also apply the annotation to methods with arbitrary names and multiple arguments, as the following example shows: Java public class MovieRecommender { \u00a0  private MovieCatalog movieCatalog; \u00a0  private CustomerPreferenceDao customerPreferenceDao; \u00a0  @Autowired \u00a0  public void prepare(MovieCatalog movieCatalog, \u00a0      CustomerPreferenceDao customerPreferenceDao) { \u00a0    this.movieCatalog = movieCatalog; \u00a0    this.customerPreferenceDao = customerPreferenceDao; \u00a0  } \u00a0  // ... } Kotlin class MovieRecommender { \u00a0  private lateinit var movieCatalog: MovieCatalog \u00a0  private lateinit var customerPreferenceDao: CustomerPreferenceDao \u00a0  @Autowired \u00a0  fun prepare(movieCatalog: MovieCatalog, \u00a0        customerPreferenceDao: CustomerPreferenceDao) { \u00a0    this.movieCatalog = movieCatalog \u00a0    this.customerPreferenceDao = customerPreferenceDao \u00a0  } \u00a0  // ... } 91", "chunk_char_count": 967, "chunk_word_count": 152, "chunk_token_count": 241.75}, {"page_number": 92, "sentence_chunk": "You can apply @Autowired to fields as well and even mix it with constructors, as the following example shows: Java public class MovieRecommender { \u00a0  private final CustomerPreferenceDao customerPreferenceDao; \u00a0  @Autowired \u00a0  private MovieCatalog movieCatalog; \u00a0  @Autowired \u00a0  public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) { \u00a0    this.customerPreferenceDao = customerPreferenceDao; \u00a0  } \u00a0  // ... } Kotlin class MovieRecommender @Autowired constructor( \u00a0  private val customerPreferenceDao: CustomerPreferenceDao) { \u00a0  @Autowired \u00a0  private lateinit var movieCatalog: MovieCatalog \u00a0  // ... } \uf0eb Make sure that your target components (for example, MovieCatalog or CustomerPreferenceDao) are consistently declared by the type that you use for your @Autowired-annotated injection points. Otherwise, injection may fail due to a \"no type match found\" error at runtime. For XML-defined beans or component classes found via classpath scanning, the container usually knows the concrete type up front. However, for @Bean factory methods, you need to make sure that the declared return type is sufficiently expressive. For components that implement several interfaces or for components potentially referred to by their implementation type, consider declaring the most specific return type on your factory method (at least as specific as required by the injection points referring to your bean). You can also instruct Spring to provide all beans of a particular type from the ApplicationContext by adding the @Autowired annotation to a field or method that expects an array of that type, as the following example shows: 92", "chunk_char_count": 1635, "chunk_word_count": 246, "chunk_token_count": 408.75}, {"page_number": 93, "sentence_chunk": "Java public class MovieRecommender { \u00a0  @Autowired \u00a0  private MovieCatalog[] movieCatalogs; \u00a0  // ... } Kotlin class MovieRecommender { \u00a0  @Autowired \u00a0  private lateinit var movieCatalogs: Array<MovieCatalog> \u00a0  // ... } The same applies for typed collections, as the following example shows: Java public class MovieRecommender { \u00a0  private Set<MovieCatalog> movieCatalogs; \u00a0  @Autowired \u00a0  public void setMovieCatalogs(Set<MovieCatalog> movieCatalogs) { \u00a0    this.movieCatalogs = movieCatalogs; \u00a0  } \u00a0  // ... } Kotlin class MovieRecommender { \u00a0  @Autowired \u00a0  lateinit var movieCatalogs: Set<MovieCatalog> \u00a0  // ... } 93", "chunk_char_count": 622, "chunk_word_count": 102, "chunk_token_count": 155.5}, {"page_number": 94, "sentence_chunk": "\uf0eb Your target beans can implement the org.springframework.core. Ordered interface or use the @Order or standard @Priority annotation if you want items in the array or list to be sorted in a specific order. Otherwise, their order follows the registration order of the corresponding target bean definitions in the container. You can declare the @Order annotation at the target class level and on @Bean methods, potentially for individual bean definitions (in case of multiple definitions that use the same bean class).@Order values may influence priorities at injection points, but be aware that they do not influence singleton startup order, which is an orthogonal concern determined by dependency relationships and @DependsOn declarations. Note that the standard jakarta.annotation. Priority annotation is not available at the @Bean level, since it cannot be declared on methods. Its semantics can be modeled through @Order values in combination with @Primary on a single bean for each type. Even typed Map instances can be autowired as long as the expected key type is String. The map values contain all beans of the expected type, and the keys contain the corresponding bean names, as the following example shows: Java public class MovieRecommender { \u00a0  private Map<String, MovieCatalog> movieCatalogs; \u00a0  @Autowired \u00a0  public void setMovieCatalogs(Map<String, MovieCatalog> movieCatalogs) { \u00a0    this.movieCatalogs = movieCatalogs; \u00a0  } \u00a0  // ... } Kotlin class MovieRecommender { \u00a0  @Autowired \u00a0  lateinit var movieCatalogs: Map<String, MovieCatalog> \u00a0  // ... } By default, autowiring fails when no matching candidate beans are available for a given injection point.", "chunk_char_count": 1671, "chunk_word_count": 262, "chunk_token_count": 417.75}, {"page_number": 94, "sentence_chunk": "In the case of a declared array, collection, or map, at least one matching element is expected. The default behavior is to treat annotated methods and fields as indicating required dependencies.94", "chunk_char_count": 196, "chunk_word_count": 31, "chunk_token_count": 49.0}, {"page_number": 95, "sentence_chunk": "You can change this behavior as demonstrated in the following example, enabling the framework to skip a non-satisfiable injection point through marking it as non-required (i.e., by setting the required attribute in @Autowired to false): Java public class SimpleMovieLister { \u00a0  private MovieFinder movieFinder; \u00a0  @Autowired(required = false) \u00a0  public void setMovieFinder(MovieFinder movieFinder) { \u00a0    this.movieFinder = movieFinder; \u00a0  } \u00a0  // ... } Kotlin class SimpleMovieLister { \u00a0  @Autowired(required = false) \u00a0  var movieFinder: MovieFinder?= null \u00a0  // ... } \uf05a A non-required method will not be called at all if its dependency (or one of its dependencies, in case of multiple arguments) is not available. A non-required field will not get populated at all in such cases, leaving its default value in place. In other words, setting the required attribute to false indicates that the corresponding property is optional for autowiring purposes, and the property will be ignored if it cannot be autowired. This allows properties to be assigned default values that can be optionally overridden via dependency injection. Injected constructor and factory method arguments are a special case since the required attribute in @Autowired has a somewhat different meaning due to Spring\u2019s constructor resolution algorithm that may potentially deal with multiple constructors. Constructor and factory method arguments are effectively required by default but with a few special rules in a single-constructor scenario, such as multi-element injection points (arrays, collections, maps) resolving to empty instances if no matching beans are available. This allows for a common implementation pattern where all dependencies can be declared in a unique multi-argument constructor \u2014 for example, declared as a single public constructor without an @Autowired annotation.95", "chunk_char_count": 1862, "chunk_word_count": 285, "chunk_token_count": 465.5}, {"page_number": 96, "sentence_chunk": "\uf05a Only one constructor of any given bean class may declare @Autowired with the required attribute set to true, indicating the constructor to autowire when used as a Spring bean. As a consequence, if the required attribute is left at its default value true, only a single constructor may be annotated with @Autowired. If multiple constructors declare the annotation, they will all have to declare required=false in order to be considered as candidates for autowiring (analogous to autowire=constructor in XML). The constructor with the greatest number of dependencies that can be satisfied by matching beans in the Spring container will be chosen. If none of the candidates can be satisfied, then a primary/default constructor (if present) will be used. Similarly, if a class declares multiple constructors but none of them is annotated with @Autowired, then a primary/default constructor (if present) will be used. If a class only declares a single constructor to begin with, it will always be used, even if not annotated. Note that an annotated constructor does not have to be public. Alternatively, you can express the non-required nature of a particular dependency through Java 8\u2019s java.util. Optional, as the following example shows: public class SimpleMovieLister { \u00a0  @Autowired \u00a0  public void setMovieFinder(Optional<MovieFinder> movieFinder) { \u00a0    ... \u00a0  } } As of Spring Framework 5.0, you can also use a @Nullable annotation (of any kind in any package\u2009\u2014\u2009for example, javax.annotation.", "chunk_char_count": 1496, "chunk_word_count": 238, "chunk_token_count": 374.0}, {"page_number": 96, "sentence_chunk": "Nullable from JSR-305) or just leverage Kotlin builtin null- safety support: Java public class SimpleMovieLister { \u00a0  @Autowired \u00a0  public void setMovieFinder(@Nullable MovieFinder movieFinder) { \u00a0    ... \u00a0  } } 96", "chunk_char_count": 214, "chunk_word_count": 37, "chunk_token_count": 53.5}, {"page_number": 97, "sentence_chunk": "Kotlin class SimpleMovieLister { \u00a0  @Autowired \u00a0  var movieFinder: MovieFinder?= null \u00a0  // ... } You can also use @Autowired for interfaces that are well-known resolvable dependencies: BeanFactory, ApplicationContext, Environment, ResourceLoader, ApplicationEventPublisher, and MessageSource. These interfaces and their extended interfaces, such as ConfigurableApplicationContext or ResourcePatternResolver, are automatically resolved, with no special setup necessary. The following example autowires an ApplicationContext object: Java public class MovieRecommender { \u00a0  @Autowired \u00a0  private ApplicationContext context; \u00a0  public MovieRecommender() { \u00a0  } \u00a0  // ... } Kotlin class MovieRecommender { \u00a0  @Autowired \u00a0  lateinit var context: ApplicationContext \u00a0  // ... } \uf05a The @Autowired, @Inject, @Value, and @Resource annotations are handled by Spring BeanPostProcessor implementations. This means that you cannot apply these annotations within your own BeanPostProcessor or BeanFactoryPostProcessor types (if any). These types must be 'wired up' explicitly by using XML or a Spring @Bean method. Fine-tuning Annotation-based Autowiring with @Primary Because autowiring by type may lead to multiple candidates, it is often necessary to have more 97", "chunk_char_count": 1251, "chunk_word_count": 175, "chunk_token_count": 312.75}, {"page_number": 98, "sentence_chunk": "control over the selection process. One way to accomplish this is with Spring\u2019s @Primary annotation.@Primary indicates that a particular bean should be given preference when multiple beans are candidates to be autowired to a single-valued dependency. If exactly one primary bean exists among the candidates, it becomes the autowired value. Consider the following configuration that defines firstMovieCatalog as the primary MovieCatalog: Java @Configuration public class MovieConfiguration { \u00a0  @Bean \u00a0  @Primary \u00a0  public MovieCatalog firstMovieCatalog() { ... } \u00a0  @Bean \u00a0  public MovieCatalog secondMovieCatalog() { ... } \u00a0  // ... } Kotlin @Configuration class MovieConfiguration { \u00a0  @Bean \u00a0  @Primary \u00a0  fun firstMovieCatalog(): MovieCatalog { ... } \u00a0  @Bean \u00a0  fun secondMovieCatalog(): MovieCatalog { ... } \u00a0  // ... } With the preceding configuration, the following MovieRecommender is autowired with the firstMovieCatalog: Java public class MovieRecommender { \u00a0  @Autowired \u00a0  private MovieCatalog movieCatalog; \u00a0  // ... } 98", "chunk_char_count": 1035, "chunk_word_count": 163, "chunk_token_count": 258.75}, {"page_number": 99, "sentence_chunk": "Kotlin class MovieRecommender { \u00a0  @Autowired \u00a0  private lateinit var movieCatalog: MovieCatalog \u00a0  // ... } The corresponding bean definitions follow: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:context=\"http://www.springframework.org/schema/context\" \u00a0  xsi:schemaLocation=\"http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/context \u00a0    https://www.springframework.org/schema/context/spring-context.xsd\"> \u00a0  <context:annotation-config/> \u00a0  <bean class=\"example. SimpleMovieCatalog\" primary=\"true\"> \u00a0    <!--inject any dependencies required by this bean --> \u00a0  </bean> \u00a0  <bean class=\"example. SimpleMovieCatalog\"> \u00a0    <!--inject any dependencies required by this bean --> \u00a0  </bean> \u00a0  <bean id=\"movieRecommender\" class=\"example. MovieRecommender\"/> </beans> Fine-tuning Annotation-based Autowiring with Qualifiers @Primary is an effective way to use autowiring by type with several instances when one primary candidate can be determined. When you need more control over the selection process, you can use Spring\u2019s @Qualifier annotation. You can associate qualifier values with specific arguments, narrowing the set of type matches so that a specific bean is chosen for each argument.", "chunk_char_count": 1410, "chunk_word_count": 168, "chunk_token_count": 352.5}, {"page_number": 100, "sentence_chunk": "Java public class MovieRecommender { \u00a0  @Autowired \u00a0  @Qualifier(\"main\") \u00a0  private MovieCatalog movieCatalog; \u00a0  // ... } Kotlin class MovieRecommender { \u00a0  @Autowired \u00a0  @Qualifier(\"main\") \u00a0  private lateinit var movieCatalog: MovieCatalog \u00a0  // ... } You can also specify the @Qualifier annotation on individual constructor arguments or method parameters, as shown in the following example: Java public class MovieRecommender { \u00a0  private MovieCatalog movieCatalog; \u00a0  private CustomerPreferenceDao customerPreferenceDao; \u00a0  @Autowired \u00a0  public void prepare(@Qualifier(\"main\") MovieCatalog movieCatalog, \u00a0      CustomerPreferenceDao customerPreferenceDao) { \u00a0    this.movieCatalog = movieCatalog; \u00a0    this.customerPreferenceDao = customerPreferenceDao; \u00a0  } \u00a0  // ... } 100", "chunk_char_count": 778, "chunk_word_count": 120, "chunk_token_count": 194.5}, {"page_number": 101, "sentence_chunk": "Kotlin class MovieRecommender { \u00a0  private lateinit var movieCatalog: MovieCatalog \u00a0  private lateinit var customerPreferenceDao: CustomerPreferenceDao \u00a0  @Autowired \u00a0  fun prepare(@Qualifier(\"main\") movieCatalog: MovieCatalog, \u00a0        customerPreferenceDao: CustomerPreferenceDao) { \u00a0    this.movieCatalog = movieCatalog \u00a0    this.customerPreferenceDao = customerPreferenceDao \u00a0  } \u00a0  // ... } The following example shows corresponding bean definitions.<?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:context=\"http://www.springframework.org/schema/context\" \u00a0  xsi:schemaLocation=\"http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/context \u00a0    https://www.springframework.org/schema/context/spring-context.xsd\"> \u00a0  <context:annotation-config/> \u00a0  <bean class=\"example. SimpleMovieCatalog\"> \u00a0    <qualifier value=\"main\"/> \u2460 \u00a0    <!--inject any dependencies required by this bean --> \u00a0  </bean> \u00a0  <bean class=\"example. SimpleMovieCatalog\"> \u00a0    <qualifier value=\"action\"/> \u2461 \u00a0    <!--inject any dependencies required by this bean --> \u00a0  </bean> \u00a0  <bean id=\"movieRecommender\" class=\"example. MovieRecommender\"/> </beans> \u2460 The bean with the main qualifier value is wired with the constructor argument that is qualified with the same value.101", "chunk_char_count": 1462, "chunk_word_count": 180, "chunk_token_count": 365.5}, {"page_number": 102, "sentence_chunk": "\u2461 The bean with the action qualifier value is wired with the constructor argument that is qualified with the same value. For a fallback match, the bean name is considered a default qualifier value. Thus, you can define the bean with an id of main instead of the nested qualifier element, leading to the same matching result. However, although you can use this convention to refer to specific beans by name, @Autowired is fundamentally about type-driven injection with optional semantic qualifiers. This means that qualifier values, even with the bean name fallback, always have narrowing semantics within the set of type matches. They do not semantically express a reference to a unique bean id. Good qualifier values are main or EMEA or persistent, expressing characteristics of a specific component that are independent from the bean id, which may be auto-generated in case of an anonymous bean definition such as the one in the preceding example. Qualifiers also apply to typed collections, as discussed earlier\u2009\u2014\u2009for example, to Set<MovieCatalog>. In this case, all matching beans, according to the declared qualifiers, are injected as a collection. This implies that qualifiers do not have to be unique. Rather, they constitute filtering criteria.", "chunk_char_count": 1252, "chunk_word_count": 198, "chunk_token_count": 313.0}, {"page_number": 102, "sentence_chunk": "For example, you can define multiple MovieCatalog beans with the same qualifier value \u201caction\u201d, all of which are injected into a Set<MovieCatalog> annotated with @Qualifier(\"action\").\uf0eb Letting qualifier values select against target bean names, within the type-matching candidates, does not require a @Qualifier annotation at the injection point. If there is no other resolution indicator (such as a qualifier or a primary marker), for a non-unique dependency situation, Spring matches the injection point name (that is, the field name or parameter name) against the target bean names and chooses the same-named candidate, if any. That said, if you intend to express annotation-driven injection by name, do not primarily use @Autowired, even if it is capable of selecting by bean name among type-matching candidates. Instead, use the JSR-250 @Resource annotation, which is semantically defined to identify a specific target component by its unique name, with the declared type being irrelevant for the matching process.@Autowired has rather different semantics: After selecting candidate beans by type, the specified String qualifier value is considered within those type-selected candidates only (for example, matching an account qualifier against beans marked with the same qualifier label). For beans that are themselves defined as a collection, Map, or array type, @Resource is a fine solution, referring to the specific collection or array bean by unique name. That said, as of 4.3, you can match collection, Map, and array types through Spring\u2019s @Autowired type matching algorithm as well, as long as the element type information is preserved in @Bean return type signatures or collection inheritance hierarchies. In this case, you can use qualifier values to select among same-typed collections, as outlined in the previous paragraph. As of 4.3, @Autowired also considers self references for injection (that is, references back to the bean that is currently injected).", "chunk_char_count": 1974, "chunk_word_count": 296, "chunk_token_count": 493.5}, {"page_number": 102, "sentence_chunk": "Note that self injection is a fallback. Regular dependencies on other components always have precedence. In that sense, self references do not participate in regular candidate selection and are therefore in particular never primary. On the contrary, they always end up as lowest precedence. In practice, you should use self references as a last resort only (for example, for calling other methods on the same instance through the bean\u2019s transactional proxy). Consider factoring out the affected methods to a separate delegate bean in such a scenario.102", "chunk_char_count": 553, "chunk_word_count": 86, "chunk_token_count": 138.25}, {"page_number": 103, "sentence_chunk": "Alternatively, you can use @Resource, which may obtain a proxy back to the current bean by its unique name.\uf05a Trying to inject the results from @Bean methods on the same configuration class is effectively a self-reference scenario as well. Either lazily resolve such references in the method signature where it is actually needed (as opposed to an autowired field in the configuration class) or declare the affected @Bean methods as static, decoupling them from the containing configuration class instance and its lifecycle. Otherwise, such beans are only considered in the fallback phase, with matching beans on other configuration classes selected as primary candidates instead (if available).@Autowired applies to fields, constructors, and multi-argument methods, allowing for narrowing through qualifier annotations at the parameter level. In contrast, @Resource is supported only for fields and bean property setter methods with a single argument. As a consequence, you should stick with qualifiers if your injection target is a constructor or a multi-argument method. You can create your own custom qualifier annotations. To do so, define an annotation and provide the @Qualifier annotation within your definition, as the following example shows: Java @Target({ElementType. FIELD, ElementType.", "chunk_char_count": 1298, "chunk_word_count": 190, "chunk_token_count": 324.5}, {"page_number": 103, "sentence_chunk": "PARAMETER}) @Retention(RetentionPolicy. RUNTIME) @Qualifier public @interface Genre { \u00a0  String value(); } Kotlin @Target(AnnotationTarget. FIELD, AnnotationTarget. VALUE_PARAMETER) @Retention(AnnotationRetention. RUNTIME) @Qualifier annotation class Genre(val value: String) Then you can provide the custom qualifier on autowired fields and parameters, as the following example shows: 103", "chunk_char_count": 389, "chunk_word_count": 44, "chunk_token_count": 97.25}, {"page_number": 104, "sentence_chunk": "Java public class MovieRecommender { \u00a0  @Autowired \u00a0  @Genre(\"Action\") \u00a0  private MovieCatalog actionCatalog; \u00a0  private MovieCatalog comedyCatalog; \u00a0  @Autowired \u00a0  public void setComedyCatalog(@Genre(\"Comedy\") MovieCatalog comedyCatalog) { \u00a0    this.comedyCatalog = comedyCatalog; \u00a0  } \u00a0  // ... } Kotlin class MovieRecommender { \u00a0  @Autowired \u00a0  @Genre(\"Action\") \u00a0  private lateinit var actionCatalog: MovieCatalog \u00a0  private lateinit var comedyCatalog: MovieCatalog \u00a0  @Autowired \u00a0  fun setComedyCatalog(@Genre(\"Comedy\") comedyCatalog: MovieCatalog) { \u00a0    this.comedyCatalog = comedyCatalog \u00a0  } \u00a0  // ... } Next, you can provide the information for the candidate bean definitions. You can add <qualifier/> tags as sub-elements of the <bean/> tag and then specify the type and value to match your custom qualifier annotations. The type is matched against the fully-qualified class name of the annotation. Alternately, as a convenience if no risk of conflicting names exists, you can use the short class name. The following example demonstrates both approaches: 104", "chunk_char_count": 1069, "chunk_word_count": 168, "chunk_token_count": 267.25}, {"page_number": 105, "sentence_chunk": "<?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:context=\"http://www.springframework.org/schema/context\" \u00a0  xsi:schemaLocation=\"http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/context \u00a0    https://www.springframework.org/schema/context/spring-context.xsd\"> \u00a0  <context:annotation-config/> \u00a0  <bean class=\"example. SimpleMovieCatalog\"> \u00a0    <qualifier type=\"Genre\" value=\"Action\"/> \u00a0    <!--inject any dependencies required by this bean --> \u00a0  </bean> \u00a0  <bean class=\"example. SimpleMovieCatalog\"> \u00a0    <qualifier type=\"example. Genre\" value=\"Comedy\"/> \u00a0    <!--inject any dependencies required by this bean --> \u00a0  </bean> \u00a0  <bean id=\"movieRecommender\" class=\"example. MovieRecommender\"/> </beans> In Classpath Scanning and Managed Components, you can see an annotation-based alternative to providing the qualifier metadata in XML. Specifically, see Providing Qualifier Metadata with Annotations.", "chunk_char_count": 1117, "chunk_word_count": 120, "chunk_token_count": 279.25}, {"page_number": 105, "sentence_chunk": "In some cases, using an annotation without a value may suffice. This can be useful when the annotation serves a more generic purpose and can be applied across several different types of dependencies. For example, you may provide an offline catalog that can be searched when no Internet connection is available. First, define the simple annotation, as the following example shows: Java @Target({ElementType. FIELD, ElementType. PARAMETER}) @Retention(RetentionPolicy. RUNTIME) @Qualifier public @interface Offline { } 105", "chunk_char_count": 520, "chunk_word_count": 75, "chunk_token_count": 130.0}, {"page_number": 106, "sentence_chunk": "Kotlin @Target(AnnotationTarget. FIELD, AnnotationTarget. VALUE_PARAMETER) @Retention(AnnotationRetention. RUNTIME) @Qualifier annotation class Offline Then add the annotation to the field or property to be autowired, as shown in the following example: Java public class MovieRecommender { \u00a0  @Autowired \u00a0  @Offline \u2460 \u00a0  private MovieCatalog offlineCatalog; \u00a0  // ... } \u2460 This line adds the @Offline annotation. Kotlin class MovieRecommender { \u00a0  @Autowired \u00a0  @Offline \u2460 \u00a0  private lateinit var offlineCatalog: MovieCatalog \u00a0  // ... } \u2460 This line adds the @Offline annotation. Now the bean definition only needs a qualifier type, as shown in the following example: <bean class=\"example. SimpleMovieCatalog\"> \u00a0  <qualifier type=\"Offline\"/> \u2460 \u00a0  <!--inject any dependencies required by this bean --> </bean> \u2460 This element specifies the qualifier. You can also define custom qualifier annotations that accept named attributes in addition to or instead of the simple value attribute. If multiple attribute values are then specified on a field or parameter to be autowired, a bean definition must match all such attribute values to be considered an autowire candidate.", "chunk_char_count": 1166, "chunk_word_count": 179, "chunk_token_count": 291.5}, {"page_number": 107, "sentence_chunk": "Java @Target({ElementType. FIELD, ElementType. PARAMETER}) @Retention(RetentionPolicy. RUNTIME) @Qualifier public @interface MovieQualifier { \u00a0  String genre(); \u00a0  Format format(); } Kotlin @Target(AnnotationTarget. FIELD, AnnotationTarget. VALUE_PARAMETER) @Retention(AnnotationRetention. RUNTIME) @Qualifier annotation class MovieQualifier(val genre: String, val format: Format) In this case Format is an enum, defined as follows: Java public enum Format { \u00a0  VHS, DVD, BLURAY } Kotlin enum class Format { \u00a0  VHS, DVD, BLURAY } The fields to be autowired are annotated with the custom qualifier and include values for both attributes: genre and format, as the following example shows: 107", "chunk_char_count": 690, "chunk_word_count": 95, "chunk_token_count": 172.5}, {"page_number": 108, "sentence_chunk": "Java public class MovieRecommender { \u00a0  @Autowired \u00a0  @MovieQualifier(format=Format. VHS, genre=\"Action\") \u00a0  private MovieCatalog actionVhsCatalog; \u00a0  @Autowired \u00a0  @MovieQualifier(format=Format. VHS, genre=\"Comedy\") \u00a0  private MovieCatalog comedyVhsCatalog; \u00a0  @Autowired \u00a0  @MovieQualifier(format=Format. DVD, genre=\"Action\") \u00a0  private MovieCatalog actionDvdCatalog; \u00a0  @Autowired \u00a0  @MovieQualifier(format=Format. BLURAY, genre=\"Comedy\") \u00a0  private MovieCatalog comedyBluRayCatalog; \u00a0  // ... } Kotlin class MovieRecommender { \u00a0  @Autowired \u00a0  @MovieQualifier(format = Format. VHS, genre = \"Action\") \u00a0  private lateinit var actionVhsCatalog: MovieCatalog \u00a0  @Autowired \u00a0  @MovieQualifier(format = Format. VHS, genre = \"Comedy\") \u00a0  private lateinit var comedyVhsCatalog: MovieCatalog \u00a0  @Autowired \u00a0  @MovieQualifier(format = Format. DVD, genre = \"Action\") \u00a0  private lateinit var actionDvdCatalog: MovieCatalog \u00a0  @Autowired \u00a0  @MovieQualifier(format = Format. BLURAY, genre = \"Comedy\") \u00a0  private lateinit var comedyBluRayCatalog: MovieCatalog \u00a0  // ... } Finally, the bean definitions should contain matching qualifier values. This example also demonstrates that you can use bean meta attributes instead of the <qualifier/> elements.", "chunk_char_count": 1239, "chunk_word_count": 172, "chunk_token_count": 309.75}, {"page_number": 109, "sentence_chunk": "mechanism falls back on the values provided within the <meta/> tags if no such qualifier is present, as in the last two bean definitions in the following example: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:context=\"http://www.springframework.org/schema/context\" \u00a0  xsi:schemaLocation=\"http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/context \u00a0    https://www.springframework.org/schema/context/spring-context.xsd\"> \u00a0  <context:annotation-config/> \u00a0  <bean class=\"example. SimpleMovieCatalog\"> \u00a0    <qualifier type=\"MovieQualifier\"> \u00a0      <attribute key=\"format\" value=\"VHS\"/> \u00a0      <attribute key=\"genre\" value=\"Action\"/> \u00a0    </qualifier> \u00a0    <!--inject any dependencies required by this bean --> \u00a0  </bean> \u00a0  <bean class=\"example. SimpleMovieCatalog\"> \u00a0    <qualifier type=\"MovieQualifier\"> \u00a0      <attribute key=\"format\" value=\"VHS\"/> \u00a0      <attribute key=\"genre\" value=\"Comedy\"/> \u00a0    </qualifier> \u00a0    <!--inject any dependencies required by this bean --> \u00a0  </bean> \u00a0  <bean class=\"example. SimpleMovieCatalog\"> \u00a0    <meta key=\"format\" value=\"DVD\"/> \u00a0    <meta key=\"genre\" value=\"Action\"/> \u00a0    <!--inject any dependencies required by this bean --> \u00a0  </bean> \u00a0  <bean class=\"example. SimpleMovieCatalog\"> \u00a0    <meta key=\"format\" value=\"BLURAY\"/> \u00a0    <meta key=\"genre\" value=\"Comedy\"/> \u00a0    <!--", "chunk_char_count": 1533, "chunk_word_count": 216, "chunk_token_count": 383.25}, {"page_number": 109, "sentence_chunk": "inject any dependencies required by this bean --> \u00a0  </bean> </beans> Using Generics as Autowiring Qualifiers In addition to the @Qualifier annotation, you can use Java generic types as an implicit form of qualification. For example, suppose you have the following configuration: 109", "chunk_char_count": 283, "chunk_word_count": 44, "chunk_token_count": 70.75}, {"page_number": 110, "sentence_chunk": "Java @Configuration public class MyConfiguration { \u00a0  @Bean \u00a0  public StringStore stringStore() { \u00a0    return new StringStore(); \u00a0  } \u00a0  @Bean \u00a0  public IntegerStore integerStore() { \u00a0    return new IntegerStore(); \u00a0  } } Kotlin @Configuration class MyConfiguration { \u00a0  @Bean \u00a0  fun stringStore() = StringStore() \u00a0  @Bean \u00a0  fun integerStore() = IntegerStore() } Assuming that the preceding beans implement a generic interface, (that is, Store<String> and Store<Integer>), you can @Autowire the Store interface and the generic is used as a qualifier, as the following example shows: Java @Autowired private Store<String> s1; // <String> qualifier, injects the stringStore bean @Autowired private Store<Integer> s2; // <Integer> qualifier, injects the integerStore bean 110", "chunk_char_count": 773, "chunk_word_count": 126, "chunk_token_count": 193.25}, {"page_number": 111, "sentence_chunk": "Kotlin @Autowired private lateinit var s1: Store<String> // <String> qualifier, injects the stringStore bean @Autowired private lateinit var s2: Store<Integer> // <Integer> qualifier, injects the integerStore bean Generic qualifiers also apply when autowiring lists, Map instances and arrays. The following example autowires a generic List: Java // Inject all Store beans as long as they have an <Integer> generic // Store<String> beans will not appear in this list @Autowired private List<Store<Integer>> s; Kotlin // Inject all Store beans as long as they have an <Integer> generic // Store<String> beans will not appear in this list @Autowired private lateinit var s: List<Store<Integer>> Using CustomAutowireConfigurer CustomAutowireConfigurer is a BeanFactoryPostProcessor that lets you register your own custom qualifier annotation types, even if they are not annotated with Spring\u2019s @Qualifier annotation. The following example shows how to use CustomAutowireConfigurer: <bean id=\"customAutowireConfigurer\" \u00a0    class=\"org.springframework.beans.factory.annotation. CustomAutowireConfigurer\"> \u00a0  <property name=\"customQualifierTypes\"> \u00a0    <set> \u00a0      <value>example. CustomQualifier</value> \u00a0    </set> \u00a0  </property> </bean> The AutowireCandidateResolver determines autowire candidates by: \u2022 The autowire-candidate value of each bean definition \u2022 Any default-autowire-candidates patterns available on the <beans/> element \u2022 The presence of @Qualifier annotations and any custom annotations registered with the 111", "chunk_char_count": 1522, "chunk_word_count": 206, "chunk_token_count": 380.5}, {"page_number": 112, "sentence_chunk": "CustomAutowireConfigurer When multiple beans qualify as autowire candidates, the determination of a \u201cprimary\u201d is as follows: If exactly one bean definition among the candidates has a primary attribute set to true, it is selected. Injection with @Resource Spring also supports injection by using the JSR-250 @Resource annotation (jakarta.annotation. Resource) on fields or bean property setter methods. This is a common pattern in Jakarta EE: for example, in JSF-managed beans and JAX-WS endpoints. Spring supports this pattern for Spring-managed objects as well.@Resource takes a name attribute. By default, Spring interprets that value as the bean name to be injected. In other words, it follows by-name semantics, as demonstrated in the following example: Java public class SimpleMovieLister { \u00a0  private MovieFinder movieFinder; \u00a0  @Resource(name=\"myMovieFinder\") \u2460 \u00a0  public void setMovieFinder(MovieFinder movieFinder) { \u00a0    this.movieFinder = movieFinder; \u00a0  } } \u2460 This line injects a @Resource. Kotlin class SimpleMovieLister { \u00a0  @Resource(name=\"myMovieFinder\") \u2460 \u00a0  private lateinit var movieFinder:MovieFinder } \u2460 This line injects a @Resource. If no name is explicitly specified, the default name is derived from the field name or setter method.", "chunk_char_count": 1257, "chunk_word_count": 188, "chunk_token_count": 314.25}, {"page_number": 112, "sentence_chunk": "In case of a field, it takes the field name. In case of a setter method, it takes the bean property name. The following example is going to have the bean named movieFinder injected into its setter method: 112", "chunk_char_count": 208, "chunk_word_count": 39, "chunk_token_count": 52.0}, {"page_number": 113, "sentence_chunk": "Java public class SimpleMovieLister { \u00a0  private MovieFinder movieFinder; \u00a0  @Resource \u00a0  public void setMovieFinder(MovieFinder movieFinder) { \u00a0    this.movieFinder = movieFinder; \u00a0  } } Kotlin class SimpleMovieLister { \u00a0  @set:Resource \u00a0  private lateinit var movieFinder: MovieFinder } \uf05a The name provided with the annotation is resolved as a bean name by the ApplicationContext of which the CommonAnnotationBeanPostProcessor is aware. The names can be resolved through JNDI if you configure Spring\u2019s SimpleJndiBeanFactory explicitly. However, we recommend that you rely on the default behavior and use Spring\u2019s JNDI lookup capabilities to preserve the level of indirection. In the exclusive case of @Resource usage with no explicit name specified, and similar to @Autowired, @Resource finds a primary type match instead of a specific named bean and resolves well known resolvable dependencies: the BeanFactory, ApplicationContext, ResourceLoader, ApplicationEventPublisher, and MessageSource interfaces. Thus, in the following example, the customerPreferenceDao field first looks for a bean named \"customerPreferenceDao\" and then falls back to a primary type match for the type CustomerPreferenceDao: 113", "chunk_char_count": 1208, "chunk_word_count": 174, "chunk_token_count": 302.0}, {"page_number": 114, "sentence_chunk": "Java public class MovieRecommender { \u00a0  @Resource \u00a0  private CustomerPreferenceDao customerPreferenceDao; \u00a0  @Resource \u00a0  private ApplicationContext context; \u2460 \u00a0  public MovieRecommender() { \u00a0  } \u00a0  // ... } \u2460 The context field is injected based on the known resolvable dependency type: ApplicationContext. Kotlin class MovieRecommender { \u00a0  @Resource \u00a0  private lateinit var customerPreferenceDao: CustomerPreferenceDao \u00a0  @Resource \u00a0  private lateinit var context: ApplicationContext \u2460 \u00a0  // ... } \u2460 The context field is injected based on the known resolvable dependency type: ApplicationContext. Using @Value @Value is typically used to inject externalized properties: 114", "chunk_char_count": 675, "chunk_word_count": 104, "chunk_token_count": 168.75}, {"page_number": 115, "sentence_chunk": "Java @Component public class MovieRecommender { \u00a0  private final String catalog; \u00a0  public MovieRecommender(@Value(\"${catalog.name}\") String catalog) { \u00a0    this.catalog = catalog; \u00a0  } } Kotlin @Component class MovieRecommender(@Value(\"\\${catalog.name}\") private val catalog: String) With the following configuration: Java @Configuration @PropertySource(\"classpath:application.properties\") public class AppConfig { } Kotlin @Configuration @PropertySource(\"classpath:application.properties\") class AppConfig And the following application.properties file: catalog.name=MovieCatalog In that case, the catalog parameter and field will be equal to the MovieCatalog value. A default lenient embedded value resolver is provided by Spring. It will try to resolve the property value and if it cannot be resolved, the property name (for example ${catalog.name}) will be injected as the value. If you want to maintain strict control over nonexistent values, you should declare a PropertySourcesPlaceholderConfigurer bean, as the following example shows: 115", "chunk_char_count": 1047, "chunk_word_count": 134, "chunk_token_count": 261.75}, {"page_number": 116, "sentence_chunk": "Java @Configuration public class AppConfig { \u00a0  @Bean \u00a0  public static PropertySourcesPlaceholderConfigurer propertyPlaceholderConfigurer() { \u00a0    return new PropertySourcesPlaceholderConfigurer(); \u00a0  } } Kotlin @Configuration class AppConfig { \u00a0  @Bean \u00a0  fun propertyPlaceholderConfigurer() = PropertySourcesPlaceholderConfigurer() } \uf05a When configuring a PropertySourcesPlaceholderConfigurer using JavaConfig, the @Bean method must be static. Using the above configuration ensures Spring initialization failure if any ${} placeholder could not be resolved. It is also possible to use methods like setPlaceholderPrefix, setPlaceholderSuffix, or setValueSeparator to customize placeholders.\uf05a Spring Boot configures by default a PropertySourcesPlaceholderConfigurer bean that will get properties from application.properties and application.yml files. Built-in converter support provided by Spring allows simple type conversion (to Integer or int for example) to be automatically handled. Multiple comma-separated values can be automatically converted to String array without extra effort. It is possible to provide a default value as following: Java @Component public class MovieRecommender { \u00a0  private final String catalog; \u00a0  public MovieRecommender(@Value(\"${catalog.name:defaultCatalog}\") String catalog) { \u00a0    this.catalog = catalog; \u00a0  } } 116", "chunk_char_count": 1350, "chunk_word_count": 177, "chunk_token_count": 337.5}, {"page_number": 117, "sentence_chunk": "Kotlin @Component class MovieRecommender(@Value(\"\\${catalog.name:defaultCatalog}\") private val catalog: String) A Spring BeanPostProcessor uses a ConversionService behind the scenes to handle the process for converting the String value in @Value to the target type. If you want to provide conversion support for your own custom type, you can provide your own ConversionService bean instance as the following example shows: Java @Configuration public class AppConfig { \u00a0  @Bean \u00a0  public ConversionService conversionService() { \u00a0    DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService(); \u00a0    conversionService.addConverter(new MyCustomConverter()); \u00a0    return conversionService; \u00a0  } } Kotlin @Configuration class AppConfig { \u00a0  @Bean \u00a0  fun conversionService(): ConversionService { \u00a0    return DefaultFormattingConversionService().apply { \u00a0      addConverter(MyCustomConverter()) \u00a0    } \u00a0  } } When @Value contains a SpEL expression the value will be dynamically computed at runtime as the following example shows: 117", "chunk_char_count": 1062, "chunk_word_count": 154, "chunk_token_count": 265.5}, {"page_number": 118, "sentence_chunk": "Java @Component public class MovieRecommender { \u00a0  private final String catalog; \u00a0  public MovieRecommender(@Value(\"#{systemProperties['user.catalog'] + 'Catalog' }\") String catalog) { \u00a0    this.catalog = catalog; \u00a0  } } Kotlin @Component class MovieRecommender( \u00a0  @Value(\"#{systemProperties['user.catalog'] + 'Catalog' }\") private val catalog: String) SpEL also enables the use of more complex data structures: Java @Component public class MovieRecommender { \u00a0  private final Map<String, Integer> countOfMoviesPerCatalog; \u00a0  public MovieRecommender( \u00a0      @Value(\"#{{'Thriller': 100, 'Comedy': 300}}\") Map<String, Integer> countOfMoviesPerCatalog) { \u00a0    this.countOfMoviesPerCatalog = countOfMoviesPerCatalog; \u00a0  } } Kotlin @Component class MovieRecommender( \u00a0  @Value(\"#{{'Thriller': 100, 'Comedy': 300}}\") private val countOfMoviesPerCatalog: Map<String, Int>) Using @PostConstruct and @PreDestroy The CommonAnnotationBeanPostProcessor not only recognizes the @Resource annotation but also the JSR-250 lifecycle annotations: jakarta.annotation. PostConstruct and jakarta.annotation. PreDestroy. Introduced in Spring 2.5, the support for these annotations offers an alternative to the lifecycle 118", "chunk_char_count": 1203, "chunk_word_count": 153, "chunk_token_count": 300.75}, {"page_number": 119, "sentence_chunk": "callback mechanism described in initialization callbacks and destruction callbacks. Provided that the CommonAnnotationBeanPostProcessor is registered within the Spring ApplicationContext, a method carrying one of these annotations is invoked at the same point in the lifecycle as the corresponding Spring lifecycle interface method or explicitly declared callback method. In the following example, the cache is pre-populated upon initialization and cleared upon destruction: Java public class CachingMovieLister { \u00a0  @PostConstruct \u00a0  public void populateMovieCache() { \u00a0    // populates the movie cache upon initialization... \u00a0  } \u00a0  @PreDestroy \u00a0  public void clearMovieCache() { \u00a0    // clears the movie cache upon destruction... \u00a0  } } Kotlin class CachingMovieLister { \u00a0  @PostConstruct \u00a0  fun populateMovieCache() { \u00a0    // populates the movie cache upon initialization... \u00a0  } \u00a0  @PreDestroy \u00a0  fun clearMovieCache() { \u00a0    // clears the movie cache upon destruction... \u00a0  } } For details about the effects of combining various lifecycle mechanisms, see Combining Lifecycle Mechanisms.\uf05a Like @Resource, the @PostConstruct and @PreDestroy annotation types were a part of the standard Java libraries from JDK 6 to 8. However, the entire javax.annotation package got separated from the core Java modules in JDK 9 and eventually removed in JDK 11. As of Jakarta EE 9, the package lives in jakarta.annotation now. If needed, the jakarta.annotation-api artifact needs to be obtained via Maven Central now, simply to be added to the application\u2019s classpath like any other library.119", "chunk_char_count": 1583, "chunk_word_count": 254, "chunk_token_count": 395.75}, {"page_number": 120, "sentence_chunk": "2.1.10. Classpath Scanning and Managed Components Most examples in this chapter use XML to specify the configuration metadata that produces each BeanDefinition within the Spring container. The previous section (Annotation-based Container Configuration) demonstrates how to provide a lot of the configuration metadata through source- level annotations. Even in those examples, however, the \u201cbase\u201d bean definitions are explicitly defined in the XML file, while the annotations drive only the dependency injection. This section describes an option for implicitly detecting the candidate components by scanning the classpath. Candidate components are classes that match against a filter criteria and have a corresponding bean definition registered with the container. This removes the need to use XML to perform bean registration. Instead, you can use annotations (for example, @Component), AspectJ type expressions, or your own custom filter criteria to select which classes have bean definitions registered with the container.\uf05a Starting with Spring 3.0, many features provided by the Spring JavaConfig project are part of the core Spring Framework. This allows you to define beans using Java rather than using the traditional XML files.", "chunk_char_count": 1234, "chunk_word_count": 178, "chunk_token_count": 308.5}, {"page_number": 120, "sentence_chunk": "Take a look at the @Configuration, @Bean, @Import, and @DependsOn annotations for examples of how to use these new features.@Component and Further Stereotype Annotations The @Repository annotation is a marker for any class that fulfills the role or stereotype of a repository (also known as Data Access Object or DAO). Among the uses of this marker is the automatic translation of exceptions, as described in Exception Translation. Spring provides further stereotype annotations: @Component, @Service, and @Controller.@Component is a generic stereotype for any Spring-managed component.@Repository, @Service, and @Controller are specializations of @Component for more specific use cases (in the persistence, service, and presentation layers, respectively). Therefore, you can annotate your component classes with @Component, but, by annotating them with @Repository, @Service, or @Controller instead, your classes are more properly suited for processing by tools or associating with aspects. For example, these stereotype annotations make ideal targets for pointcuts.@Repository, @Service, and @Controller can also carry additional semantics in future releases of the Spring Framework. Thus, if you are choosing between using @Component or @Service for your service layer, @Service is clearly the better choice.", "chunk_char_count": 1311, "chunk_word_count": 182, "chunk_token_count": 327.75}, {"page_number": 120, "sentence_chunk": "Similarly, as stated earlier, @Repository is already supported as a marker for automatic exception translation in your persistence layer. Using Meta-annotations and Composed Annotations Many of the annotations provided by Spring can be used as meta-annotations in your own code. A meta-annotation is an annotation that can be applied to another annotation. For example, the @Service annotation mentioned earlier is meta-annotated with @Component, as the following example shows: 120", "chunk_char_count": 482, "chunk_word_count": 69, "chunk_token_count": 120.5}, {"page_number": 121, "sentence_chunk": "Java @Target(ElementType. TYPE) @Retention(RetentionPolicy. RUNTIME) @Documented @Component \u2460 public @interface Service { \u00a0  // ... } \u2460 The @Component causes @Service to be treated in the same way as @Component. Kotlin @Target(AnnotationTarget. TYPE) @Retention(AnnotationRetention. RUNTIME) @MustBeDocumented @Component \u2460 annotation class Service { \u00a0  // ... } \u2460 The @Component causes @Service to be treated in the same way as @Component. You can also combine meta-annotations to create \u201ccomposed annotations\u201d. For example, the @RestController annotation from Spring MVC is composed of @Controller and @ResponseBody. In addition, composed annotations can optionally redeclare attributes from meta-annotations to allow customization. This can be particularly useful when you want to only expose a subset of the meta-annotation\u2019s attributes.", "chunk_char_count": 840, "chunk_word_count": 115, "chunk_token_count": 210.0}, {"page_number": 121, "sentence_chunk": "For example, Spring\u2019s @SessionScope annotation hardcodes the scope name to session but still allows customization of the proxyMode. The following listing shows the definition of the SessionScope annotation: 121", "chunk_char_count": 210, "chunk_word_count": 29, "chunk_token_count": 52.5}, {"page_number": 122, "sentence_chunk": "Java @Target({ElementType. TYPE, ElementType. METHOD}) @Retention(RetentionPolicy. RUNTIME) @Documented @Scope(WebApplicationContext. SCOPE_SESSION) public @interface SessionScope { \u00a0  /** \u00a0  * Alias for {@link Scope#proxyMode}.\u00a0  * <p>Defaults to {@link ScopedProxyMode#TARGET_CLASS}.\u00a0  */ \u00a0  @AliasFor(annotation = Scope.class) \u00a0  ScopedProxyMode proxyMode() default ScopedProxyMode. TARGET_CLASS; } Kotlin @Target(AnnotationTarget. TYPE, AnnotationTarget. FUNCTION) @Retention(AnnotationRetention.", "chunk_char_count": 500, "chunk_word_count": 51, "chunk_token_count": 125.0}, {"page_number": 122, "sentence_chunk": "RUNTIME) @MustBeDocumented @Scope(WebApplicationContext. SCOPE_SESSION) annotation class SessionScope( \u00a0    @get:AliasFor(annotation = Scope::class) \u00a0    val proxyMode: ScopedProxyMode = ScopedProxyMode. TARGET_CLASS ) You can then use @SessionScope without declaring the proxyMode as follows: Java @Service @SessionScope public class SessionScopedService { \u00a0  // ... } Kotlin @Service @SessionScope class SessionScopedService { \u00a0  // ... } You can also override the value for the proxyMode, as the following example shows: 122", "chunk_char_count": 527, "chunk_word_count": 74, "chunk_token_count": 131.75}, {"page_number": 123, "sentence_chunk": "Java @Service @SessionScope(proxyMode = ScopedProxyMode. INTERFACES) public class SessionScopedUserService implements UserService { \u00a0  // ... } Kotlin @Service @SessionScope(proxyMode = ScopedProxyMode. INTERFACES) class SessionScopedUserService : UserService { \u00a0  // ... } For further details, see the Spring Annotation Programming Model wiki page. Automatically Detecting Classes and Registering Bean Definitions Spring can automatically detect stereotyped classes and register corresponding BeanDefinition instances with the ApplicationContext. For example, the following two classes are eligible for such autodetection: Java @Service public class SimpleMovieLister { \u00a0  private MovieFinder movieFinder; \u00a0  public SimpleMovieLister(MovieFinder movieFinder) { \u00a0    this.movieFinder = movieFinder; \u00a0  } } Kotlin @Service class SimpleMovieLister(private val movieFinder: MovieFinder) Java @Repository public class JpaMovieFinder implements MovieFinder { \u00a0  // implementation elided for clarity } 123", "chunk_char_count": 999, "chunk_word_count": 128, "chunk_token_count": 249.75}, {"page_number": 124, "sentence_chunk": "Kotlin @Repository class JpaMovieFinder : MovieFinder { \u00a0  // implementation elided for clarity } To autodetect these classes and register the corresponding beans, you need to add @ComponentScan to your @Configuration class, where the basePackages attribute is a common parent package for the two classes. (Alternatively, you can specify a comma- or semicolon- or space-separated list that includes the parent package of each class.)Java @Configuration @ComponentScan(basePackages = \"org.example\") public class AppConfig { \u00a0  // ... } Kotlin @Configuration @ComponentScan(basePackages = [\"org.example\"]) class AppConfig { \u00a0  // ... } \uf05a For brevity, the preceding example could have used the value attribute of the annotation (that is, @ComponentScan(\"org.example\")). The following alternative uses XML: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:context=\"http://www.springframework.org/schema/context\" \u00a0  xsi:schemaLocation=\"http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/context \u00a0    https://www.springframework.org/schema/context/spring-context.xsd\"> \u00a0  <context:component-scan base-package=\"org.example\"/> </beans> 124", "chunk_char_count": 1349, "chunk_word_count": 149, "chunk_token_count": 337.25}, {"page_number": 125, "sentence_chunk": "\uf0eb The use of <context:component-scan> implicitly enables the functionality of <context:annotation-config>. There is usually no need to include the <context:annotation-config> element when using <context:component-scan>.\uf05a The scanning of classpath packages requires the presence of corresponding directory entries in the classpath. When you build JARs with Ant, make sure that you do not activate the files-only switch of the JAR task. Also, classpath directories may not be exposed based on security policies in some environments\u2009\u2014\u2009for example, standalone apps on JDK 1.7.0_45 and higher (which requires 'Trusted- Library' setup in your manifests\u2009\u2014\u2009see https://stackoverflow.com/questions/ 19394570/java-jre-7u45-breaks-classloader-getresources). On JDK 9\u2019s module path (Jigsaw), Spring\u2019s classpath scanning generally works as expected. However, make sure that your component classes are exported in your module-info descriptors. If you expect Spring to invoke non-public members of your classes, make sure that they are 'opened' (that is, that they use an opens declaration instead of an exports declaration in your module-info descriptor). Furthermore, the AutowiredAnnotationBeanPostProcessor and CommonAnnotationBeanPostProcessor are both implicitly included when you use the component-scan element. That means that the two components are autodetected and wired together\u2009\u2014\u2009all without any bean configuration metadata provided in XML.", "chunk_char_count": 1437, "chunk_word_count": 185, "chunk_token_count": 359.25}, {"page_number": 125, "sentence_chunk": "\uf05a You can disable the registration of AutowiredAnnotationBeanPostProcessor and CommonAnnotationBeanPostProcessor by including the annotation-config attribute with a value of false. Using Filters to Customize Scanning By default, classes annotated with @Component, @Repository, @Service, @Controller, @Configuration, or a custom annotation that itself is annotated with @Component are the only detected candidate components. However, you can modify and extend this behavior by applying custom filters. Add them as includeFilters or excludeFilters attributes of the @ComponentScan annotation (or as <context:include-filter /> or <context:exclude-filter /> child elements of the <context:component- scan> element in XML configuration). Each filter element requires the type and expression attributes. The following table describes the filtering options: Table 5. Filter Types Filter Type Example Expression Description annotation (default) org.example. SomeAnnotation An annotation to be present or meta-present at the type level in target components.assignable org.example. SomeClass A class (or interface) that the target components are assignable to (extend or implement).", "chunk_char_count": 1172, "chunk_word_count": 150, "chunk_token_count": 293.0}, {"page_number": 126, "sentence_chunk": "Filter Type Example Expression Description aspectj org.example..*Service+ An AspectJ type expression to be matched by the target components.regex org\\.example\\. Default.*A regex expression to be matched by the target components' class names.custom org.example. MyTypeFilter A custom implementation of the org.springframework.core.type. TypeFilter interface. The following example shows the configuration ignoring all @Repository annotations and using \u201cstub\u201d repositories instead: Java @Configuration @ComponentScan(basePackages = \"org.example\", \u00a0    includeFilters = @Filter(type = FilterType. REGEX, pattern = \".*Stub.*Repository\"), \u00a0    excludeFilters = @Filter(Repository.class)) public class AppConfig { \u00a0  // ... } Kotlin @Configuration @ComponentScan(basePackages = [\"org.example\"], \u00a0    includeFilters = [Filter(type = FilterType. REGEX, pattern = [\".*Stub.*Repository\"])], \u00a0    excludeFilters = [Filter(Repository::class)]) class AppConfig { \u00a0  // ... } The following listing shows the equivalent XML: <beans> \u00a0  <context:component-scan base-package=\"org.example\"> \u00a0    <context:include-filter type=\"regex\" \u00a0        expression=\".*Stub.*Repository\"/> \u00a0    <context:exclude-filter type=\"annotation\" \u00a0        expression=\"org.springframework.stereotype. Repository\"/> \u00a0  </context:component-scan> </beans> 126", "chunk_char_count": 1313, "chunk_word_count": 171, "chunk_token_count": 328.25}, {"page_number": 127, "sentence_chunk": "\uf05a You can also disable the default filters by setting useDefaultFilters=false on the annotation or by providing use-default-filters=\"false\" as an attribute of the <component-scan/> element. This effectively disables automatic detection of classes annotated or meta-annotated with @Component, @Repository, @Service, @Controller, @RestController, or @Configuration. Defining Bean Metadata within Components Spring components can also contribute bean definition metadata to the container. You can do this with the same @Bean annotation used to define bean metadata within @Configuration annotated classes. The following example shows how to do so: Java @Component public class FactoryMethodComponent { \u00a0  @Bean \u00a0  @Qualifier(\"public\") \u00a0  public TestBean publicInstance() { \u00a0    return new TestBean(\"publicInstance\"); \u00a0  } \u00a0  public void doWork() { \u00a0    // Component method implementation omitted \u00a0  } } Kotlin @Component class FactoryMethodComponent { \u00a0  @Bean \u00a0  @Qualifier(\"public\") \u00a0  fun publicInstance() = TestBean(\"publicInstance\") \u00a0  fun doWork() { \u00a0    // Component method implementation omitted \u00a0  } } The preceding class is a Spring component that has application-specific code in its doWork() method. However, it also contributes a bean definition that has a factory method referring to the method publicInstance(). The @Bean annotation identifies the factory method and other bean definition properties, such as a qualifier value through the @Qualifier annotation. Other method-level annotations that can be specified are @Scope, @Lazy, and custom qualifier annotations.127", "chunk_char_count": 1582, "chunk_word_count": 234, "chunk_token_count": 395.5}, {"page_number": 128, "sentence_chunk": "\uf0eb In addition to its role for component initialization, you can also place the @Lazy annotation on injection points marked with @Autowired or @Inject. In this context, it leads to the injection of a lazy-resolution proxy. However, such a proxy approach is rather limited. For sophisticated lazy interactions, in particular in combination with optional dependencies, we recommend ObjectProvider<MyTargetBean> instead. Autowired fields and methods are supported, as previously discussed, with additional support for autowiring of @Bean methods. The following example shows how to do so: Java @Component public class FactoryMethodComponent { \u00a0  private static int i; \u00a0  @Bean \u00a0  @Qualifier(\"public\") \u00a0  public TestBean publicInstance() { \u00a0    return new TestBean(\"publicInstance\"); \u00a0  } \u00a0  // use of a custom qualifier and autowiring of method parameters \u00a0  @Bean \u00a0  protected TestBean protectedInstance( \u00a0      @Qualifier(\"public\") TestBean spouse, \u00a0      @Value(\"#{privateInstance.age}\") String country) { \u00a0    TestBean tb = new TestBean(\"protectedInstance\", 1); \u00a0    tb.setSpouse(spouse); \u00a0    tb.setCountry(country); \u00a0    return tb; \u00a0  } \u00a0  @Bean \u00a0  private TestBean privateInstance() { \u00a0    return new TestBean(\"privateInstance\", i++); \u00a0  } \u00a0  @Bean \u00a0  @RequestScope \u00a0  public TestBean requestScopedInstance() { \u00a0    return new TestBean(\"requestScopedInstance\", 3); \u00a0  } } 128", "chunk_char_count": 1378, "chunk_word_count": 232, "chunk_token_count": 344.5}, {"page_number": 129, "sentence_chunk": "Kotlin @Component class FactoryMethodComponent { \u00a0  companion object { \u00a0    private var i: Int = 0 \u00a0  } \u00a0  @Bean \u00a0  @Qualifier(\"public\") \u00a0  fun publicInstance() = TestBean(\"publicInstance\") \u00a0  // use of a custom qualifier and autowiring of method parameters \u00a0  @Bean \u00a0  protected fun protectedInstance( \u00a0      @Qualifier(\"public\") spouse: TestBean, \u00a0      @Value(\"#{privateInstance.age}\") country: String) = TestBean(\"protectedInstance\", 1).apply { \u00a0    this.spouse = spouse \u00a0    this.country = country \u00a0  } \u00a0  @Bean \u00a0  private fun privateInstance() = TestBean(\"privateInstance\", i++) \u00a0  @Bean \u00a0  @RequestScope \u00a0  fun requestScopedInstance() = TestBean(\"requestScopedInstance\", 3) } The example autowires the String method parameter country to the value of the age property on another bean named privateInstance. A Spring Expression Language element defines the value of the property through the notation #{ <expression> }. For @Value annotations, an expression resolver is preconfigured to look for bean names when resolving expression text. As of Spring Framework 4.3, you may also declare a factory method parameter of type InjectionPoint (or its more specific subclass: DependencyDescriptor) to access the requesting injection point that triggers the creation of the current bean. Note that this applies only to the actual creation of bean instances, not to the injection of existing instances. As a consequence, this feature makes most sense for beans of prototype scope. For other scopes, the factory method only ever sees the injection point that triggered the creation of a new bean instance in the given scope (for example, the dependency that triggered the creation of a lazy singleton bean). You can use the provided injection point metadata with semantic care in such scenarios. The following example shows how to use InjectionPoint: 129", "chunk_char_count": 1849, "chunk_word_count": 303, "chunk_token_count": 462.25}, {"page_number": 130, "sentence_chunk": "Java @Component public class FactoryMethodComponent { \u00a0  @Bean @Scope(\"prototype\") \u00a0  public TestBean prototypeInstance(InjectionPoint injectionPoint) { \u00a0    return new TestBean(\"prototypeInstance for \" + injectionPoint.getMember()); \u00a0  } } Kotlin @Component class FactoryMethodComponent { \u00a0  @Bean \u00a0  @Scope(\"prototype\") \u00a0  fun prototypeInstance(injectionPoint: InjectionPoint) = \u00a0      TestBean(\"prototypeInstance for ${injectionPoint.member}\") } The @Bean methods in a regular Spring component are processed differently than their counterparts inside a Spring @Configuration class. The difference is that @Component classes are not enhanced with CGLIB to intercept the invocation of methods and fields. CGLIB proxying is the means by which invoking methods or fields within @Bean methods in @Configuration classes creates bean metadata references to collaborating objects. Such methods are not invoked with normal Java semantics but rather go through the container in order to provide the usual lifecycle management and proxying of Spring beans, even when referring to other beans through programmatic calls to @Bean methods. In contrast, invoking a method or field in a @Bean method within a plain @Component class has standard Java semantics, with no special CGLIB processing or other constraints applying.130", "chunk_char_count": 1314, "chunk_word_count": 190, "chunk_token_count": 328.5}, {"page_number": 131, "sentence_chunk": "\uf05a You may declare @Bean methods as static, allowing for them to be called without creating their containing configuration class as an instance. This makes particular sense when defining post-processor beans (for example, of type BeanFactoryPostProcessor or BeanPostProcessor), since such beans get initialized early in the container lifecycle and should avoid triggering other parts of the configuration at that point. Calls to static @Bean methods never get intercepted by the container, not even within @Configuration classes (as described earlier in this section), due to technical limitations: CGLIB subclassing can override only non-static methods. As a consequence, a direct call to another @Bean method has standard Java semantics, resulting in an independent instance being returned straight from the factory method itself. The Java language visibility of @Bean methods does not have an immediate impact on the resulting bean definition in Spring\u2019s container. You can freely declare your factory methods as you see fit in non-@Configuration classes and also for static methods anywhere. However, regular @Bean methods in @Configuration classes need to be overridable\u2009\u2014\u2009that is, they must not be declared as private or final.@Bean methods are also discovered on base classes of a given component or configuration class, as well as on Java 8 default methods declared in interfaces implemented by the component or configuration class. This allows for a lot of flexibility in composing complex configuration arrangements, with even multiple inheritance being possible through Java 8 default methods as of Spring 4.2. Finally, a single class may hold multiple @Bean methods for the same bean, as an arrangement of multiple factory methods to use depending on available dependencies at runtime.", "chunk_char_count": 1796, "chunk_word_count": 269, "chunk_token_count": 449.0}, {"page_number": 131, "sentence_chunk": "This is the same algorithm as for choosing the \u201cgreediest\u201d constructor or factory method in other configuration scenarios: The variant with the largest number of satisfiable dependencies is picked at construction time, analogous to how the container selects between multiple @Autowired constructors. Naming Autodetected Components When a component is autodetected as part of the scanning process, its bean name is generated by the BeanNameGenerator strategy known to that scanner. By default, any Spring stereotype annotation (@Component, @Repository, @Service, and @Controller) that contains a name value thereby provides that name to the corresponding bean definition. If such an annotation contains no name value or for any other detected component (such as those discovered by custom filters), the default bean name generator returns the uncapitalized non- qualified class name. For example, if the following component classes were detected, the names would be myMovieLister and movieFinderImpl: 131", "chunk_char_count": 1003, "chunk_word_count": 144, "chunk_token_count": 250.75}, {"page_number": 132, "sentence_chunk": "Java @Service(\"myMovieLister\") public class SimpleMovieLister { \u00a0  // ... } Kotlin @Service(\"myMovieLister\") class SimpleMovieLister { \u00a0  // ... } Java @Repository public class MovieFinderImpl implements MovieFinder { \u00a0  // ... } Kotlin @Repository class MovieFinderImpl : MovieFinder { \u00a0  // ... } If you do not want to rely on the default bean-naming strategy, you can provide a custom bean- naming strategy. First, implement the BeanNameGenerator interface, and be sure to include a default no-arg constructor. Then, provide the fully qualified class name when configuring the scanner, as the following example annotation and bean definition show.\uf0eb If you run into naming conflicts due to multiple autodetected components having the same non-qualified class name (i.e., classes with identical names but residing in different packages), you may need to configure a BeanNameGenerator that defaults to the fully qualified class name for the generated bean name. As of Spring Framework 5.2.3, the FullyQualifiedAnnotationBeanNameGenerator located in package org.springframework.context.annotation can be used for such purposes. Java @Configuration @ComponentScan(basePackages = \"org.example\", nameGenerator = MyNameGenerator.class) public class AppConfig { \u00a0  // ... } 132", "chunk_char_count": 1271, "chunk_word_count": 182, "chunk_token_count": 317.75}, {"page_number": 133, "sentence_chunk": "Kotlin @Configuration @ComponentScan(basePackages = [\"org.example\"], nameGenerator = MyNameGenerator::class) class AppConfig { \u00a0  // ... } <beans> \u00a0  <context:component-scan base-package=\"org.example\" \u00a0    name-generator=\"org.example. MyNameGenerator\" /> </beans> As a general rule, consider specifying the name with the annotation whenever other components may be making explicit references to it. On the other hand, the auto-generated names are adequate whenever the container is responsible for wiring. Providing a Scope for Autodetected Components As with Spring-managed components in general, the default and most common scope for autodetected components is singleton. However, sometimes you need a different scope that can be specified by the @Scope annotation. You can provide the name of the scope within the annotation, as the following example shows: Java @Scope(\"prototype\") @Repository public class MovieFinderImpl implements MovieFinder { \u00a0  // ... } Kotlin @Scope(\"prototype\") @Repository class MovieFinderImpl : MovieFinder { \u00a0  // ... } \uf05a @Scope annotations are only introspected on the concrete bean class (for annotated components) or the factory method (for @Bean methods). In contrast to XML bean definitions, there is no notion of bean definition inheritance, and inheritance hierarchies at the class level are irrelevant for metadata purposes. For details on web-specific scopes such as \u201crequest\u201d or \u201csession\u201d in a Spring context, see Request, Session, Application, and WebSocket Scopes. As with the pre-built annotations for those scopes, you 133", "chunk_char_count": 1569, "chunk_word_count": 225, "chunk_token_count": 392.25}, {"page_number": 134, "sentence_chunk": "may also compose your own scoping annotations by using Spring\u2019s meta-annotation approach: for example, a custom annotation meta-annotated with @Scope(\"prototype\"), possibly also declaring a custom scoped-proxy mode.\uf05a To provide a custom strategy for scope resolution rather than relying on the annotation-based approach, you can implement the ScopeMetadataResolver interface. Be sure to include a default no-arg constructor. Then you can provide the fully qualified class name when configuring the scanner, as the following example of both an annotation and a bean definition shows: Java @Configuration @ComponentScan(basePackages = \"org.example\", scopeResolver = MyScopeResolver.class) public class AppConfig { \u00a0  // ... } Kotlin @Configuration @ComponentScan(basePackages = [\"org.example\"], scopeResolver = MyScopeResolver::class) class AppConfig { \u00a0  // ... } <beans> \u00a0  <context:component-scan base-package=\"org.example\" scope- resolver=\"org.example. MyScopeResolver\"/> </beans> When using certain non-singleton scopes, it may be necessary to generate proxies for the scoped objects. The reasoning is described in Scoped Beans as Dependencies. For this purpose, a scoped- proxy attribute is available on the component-scan element. The three possible values are: no, interfaces, and targetClass. For example, the following configuration results in standard JDK dynamic proxies: Java @Configuration @ComponentScan(basePackages = \"org.example\", scopedProxy = ScopedProxyMode. INTERFACES) public class AppConfig { \u00a0  // ... } 134", "chunk_char_count": 1530, "chunk_word_count": 201, "chunk_token_count": 382.5}, {"page_number": 135, "sentence_chunk": "Kotlin @Configuration @ComponentScan(basePackages = [\"org.example\"], scopedProxy = ScopedProxyMode. INTERFACES) class AppConfig { \u00a0  // ... } <beans> \u00a0  <context:component-scan base-package=\"org.example\" scoped-proxy=\"interfaces\"/> </beans> Providing Qualifier Metadata with Annotations The @Qualifier annotation is discussed in Fine-tuning Annotation-based Autowiring with Qualifiers. The examples in that section demonstrate the use of the @Qualifier annotation and custom qualifier annotations to provide fine-grained control when you resolve autowire candidates. Because those examples were based on XML bean definitions, the qualifier metadata was provided on the candidate bean definitions by using the qualifier or meta child elements of the bean element in the XML. When relying upon classpath scanning for auto-detection of components, you can provide the qualifier metadata with type-level annotations on the candidate class. The following three examples demonstrate this technique: Java @Component @Qualifier(\"Action\") public class ActionMovieCatalog implements MovieCatalog { \u00a0  // ... } Kotlin @Component @Qualifier(\"Action\") class ActionMovieCatalog : MovieCatalog Java @Component @Genre(\"Action\") public class ActionMovieCatalog implements MovieCatalog { \u00a0  // ... } 135", "chunk_char_count": 1285, "chunk_word_count": 164, "chunk_token_count": 321.25}, {"page_number": 136, "sentence_chunk": "Kotlin @Component @Genre(\"Action\") class ActionMovieCatalog : MovieCatalog { \u00a0  // ... } Java @Component @Offline public class CachingMovieCatalog implements MovieCatalog { \u00a0  // ... } Kotlin @Component @Offline class CachingMovieCatalog : MovieCatalog { \u00a0  // ... } \uf05a As with most annotation-based alternatives, keep in mind that the annotation metadata is bound to the class definition itself, while the use of XML allows for multiple beans of the same type to provide variations in their qualifier metadata, because that metadata is provided per-instance rather than per-class. Generating an Index of Candidate Components While classpath scanning is very fast, it is possible to improve the startup performance of large applications by creating a static list of candidates at compilation time. In this mode, all modules that are targets of component scanning must use this mechanism.\uf05a Your existing @ComponentScan or <context:component-scan/> directives must remain unchanged to request the context to scan candidates in certain packages. When the ApplicationContext detects such an index, it automatically uses it rather than scanning the classpath. To generate the index, add an additional dependency to each module that contains components that are targets for component scan directives. The following example shows how to do so with Maven: 136", "chunk_char_count": 1350, "chunk_word_count": 204, "chunk_token_count": 337.5}, {"page_number": 137, "sentence_chunk": "<dependencies> \u00a0  <dependency> \u00a0    <groupId>org.springframework</groupId> \u00a0    <artifactId>spring-context-indexer</artifactId> \u00a0    <version>6.0.0</version> \u00a0    <optional>true</optional> \u00a0  </dependency> </dependencies> With Gradle 4.5 and earlier, the dependency should be declared in the compileOnly configuration, as shown in the following example: dependencies { \u00a0  compileOnly \"org.springframework:spring-context-indexer:6.0.0\" } With Gradle 4.6 and later, the dependency should be declared in the annotationProcessor configuration, as shown in the following example: dependencies { \u00a0  annotationProcessor \"org.springframework:spring-context-indexer:6.0.0\" } The spring-context-indexer artifact generates a META-INF/spring.components file that is included in the jar file.\uf05a When working with this mode in your IDE, the spring-context-indexer must be registered as an annotation processor to make sure the index is up-to-date when candidate components are updated.\uf0eb The index is enabled automatically when a META-INF/spring.components file is found on the classpath. If an index is partially available for some libraries (or use cases) but could not be built for the whole application, you can fall back to a regular classpath arrangement (as though no index were present at all) by setting spring.index.ignore to true, either as a JVM system property or via the SpringProperties mechanism.2.1.11. Using JSR 330 Standard Annotations Starting with Spring 3.0, Spring offers support for JSR-330 standard annotations (Dependency Injection). Those annotations are scanned in the same way as the Spring annotations. To use them, you need to have the relevant jars in your classpath.137", "chunk_char_count": 1686, "chunk_word_count": 236, "chunk_token_count": 421.5}, {"page_number": 138, "sentence_chunk": "\uf05a If you use Maven, the jakarta.inject artifact is available in the standard Maven repository ( https://repo1.maven.org/maven2/jakarta/inject/jakarta.inject- api/2.0.0/). You can add the following dependency to your file pom.xml: <dependency> \u00a0  <groupId>jakarta.inject</groupId> \u00a0  <artifactId>jakarta.inject-api</artifactId> \u00a0  <version>1</version> </dependency> Dependency Injection with @Inject and @Named Instead of @Autowired, you can use @jakarta.inject. Inject as follows: Java import jakarta.inject. Inject; public class SimpleMovieLister { \u00a0  private MovieFinder movieFinder; \u00a0  @Inject \u00a0  public void setMovieFinder(MovieFinder movieFinder) { \u00a0    this.movieFinder = movieFinder; \u00a0  } \u00a0  public void listMovies() { \u00a0    this.movieFinder.findMovies(...); \u00a0    // ... \u00a0  } } Kotlin import jakarta.inject. Inject class SimpleMovieLister { \u00a0  @Inject \u00a0  lateinit var movieFinder: MovieFinder \u00a0  fun listMovies() { \u00a0    movieFinder.findMovies(...) \u00a0    // ... \u00a0  } } 138", "chunk_char_count": 976, "chunk_word_count": 146, "chunk_token_count": 244.0}, {"page_number": 139, "sentence_chunk": "As with @Autowired, you can use @Inject at the field level, method level and constructor-argument level. Furthermore, you may declare your injection point as a Provider, allowing for on-demand access to beans of shorter scopes or lazy access to other beans through a Provider.get() call. The following example offers a variant of the preceding example: Java import jakarta.inject. Inject; import jakarta.inject. Provider; public class SimpleMovieLister { \u00a0  private Provider<MovieFinder> movieFinder; \u00a0  @Inject \u00a0  public void setMovieFinder(Provider<MovieFinder> movieFinder) { \u00a0    this.movieFinder = movieFinder; \u00a0  } \u00a0  public void listMovies() { \u00a0    this.movieFinder.get().findMovies(...); \u00a0    // ... \u00a0  } } Kotlin import jakarta.inject. Inject class SimpleMovieLister { \u00a0  @Inject \u00a0  lateinit var movieFinder: Provider<MovieFinder> \u00a0  fun listMovies() { \u00a0    movieFinder.get().findMovies(...) \u00a0    // ... \u00a0  } } If you would like to use a qualified name for the dependency that should be injected, you should use the @Named annotation, as the following example shows: 139", "chunk_char_count": 1079, "chunk_word_count": 176, "chunk_token_count": 269.75}, {"page_number": 140, "sentence_chunk": "Java import jakarta.inject. Inject; import jakarta.inject. Named; public class SimpleMovieLister { \u00a0  private MovieFinder movieFinder; \u00a0  @Inject \u00a0  public void setMovieFinder(@Named(\"main\") MovieFinder movieFinder) { \u00a0    this.movieFinder = movieFinder; \u00a0  } \u00a0  // ... } Kotlin import jakarta.inject. Inject import jakarta.inject. Named class SimpleMovieLister { \u00a0  private lateinit var movieFinder: MovieFinder \u00a0  @Inject \u00a0  fun setMovieFinder(@Named(\"main\") movieFinder: MovieFinder) { \u00a0    this.movieFinder = movieFinder \u00a0  } \u00a0  // ... } As with @Autowired, @Inject can also be used with java.util. Optional or @Nullable. This is even more applicable here, since @Inject does not have a required attribute. The following pair of examples show how to use @Inject and @Nullable: public class SimpleMovieLister { \u00a0  @Inject \u00a0  public void setMovieFinder(Optional<MovieFinder> movieFinder) { \u00a0    // ... \u00a0  } } 140", "chunk_char_count": 914, "chunk_word_count": 148, "chunk_token_count": 228.5}, {"page_number": 141, "sentence_chunk": "Java public class SimpleMovieLister { \u00a0  @Inject \u00a0  public void setMovieFinder(@Nullable MovieFinder movieFinder) { \u00a0    // ... \u00a0  } } Kotlin class SimpleMovieLister { \u00a0  @Inject \u00a0  var movieFinder: MovieFinder?= null } @Named and @ManagedBean: Standard Equivalents to the @Component Annotation Instead of @Component, you can use @jakarta.inject. Named or jakarta.annotation. ManagedBean, as the following example shows: Java import jakarta.inject. Inject; import jakarta.inject. Named; @Named(\"movieListener\") // @ManagedBean(\"movieListener\") could be used as well public class SimpleMovieLister { \u00a0  private MovieFinder movieFinder; \u00a0  @Inject \u00a0  public void setMovieFinder(MovieFinder movieFinder) { \u00a0    this.movieFinder = movieFinder; \u00a0  } \u00a0  // ... } 141", "chunk_char_count": 760, "chunk_word_count": 115, "chunk_token_count": 190.0}, {"page_number": 142, "sentence_chunk": "Kotlin import jakarta.inject. Inject import jakarta.inject. Named @Named(\"movieListener\") // @ManagedBean(\"movieListener\") could be used as well class SimpleMovieLister { \u00a0  @Inject \u00a0  lateinit var movieFinder: MovieFinder \u00a0  // ... } It is very common to use @Component without specifying a name for the component.@Named can be used in a similar fashion, as the following example shows: Java import jakarta.inject. Inject; import jakarta.inject. Named; @Named public class SimpleMovieLister { \u00a0  private MovieFinder movieFinder; \u00a0  @Inject \u00a0  public void setMovieFinder(MovieFinder movieFinder) { \u00a0    this.movieFinder = movieFinder; \u00a0  } \u00a0  // ... } Kotlin import jakarta.inject. Inject import jakarta.inject. Named @Named class SimpleMovieLister { \u00a0  @Inject \u00a0  lateinit var movieFinder: MovieFinder \u00a0  // ... } 142", "chunk_char_count": 818, "chunk_word_count": 126, "chunk_token_count": 204.5}, {"page_number": 143, "sentence_chunk": "When you use @Named or @ManagedBean, you can use component scanning in the exact same way as when you use Spring annotations, as the following example shows: Java @Configuration @ComponentScan(basePackages = \"org.example\") public class AppConfig { \u00a0  // ... } Kotlin @Configuration @ComponentScan(basePackages = [\"org.example\"]) class AppConfig { \u00a0  // ... } \uf05a In contrast to @Component, the JSR-330 @Named and the JSR-250 @ManagedBean annotations are not composable. You should use Spring\u2019s stereotype model for building custom component annotations. Limitations of JSR-330 Standard Annotations When you work with standard annotations, you should know that some significant features are not available, as the following table shows: Table 6. Spring component model elements versus JSR-330 variants Spring jakarta.inject.*jakarta.inject restrictions / comments @Autowired @Inject @Inject has no 'required' attribute. Can be used with Java 8\u2019s Optional instead.@Component @Named / @ManagedBean JSR-330 does not provide a composable model, only a way to identify named components.143", "chunk_char_count": 1080, "chunk_word_count": 153, "chunk_token_count": 270.0}, {"page_number": 144, "sentence_chunk": "Spring jakarta.inject.*jakarta.inject restrictions / comments @Scope(\"singleton\") @Singleton The JSR-330 default scope is like Spring\u2019s prototype. However, in order to keep it consistent with Spring\u2019s general defaults, a JSR- 330 bean declared in the Spring container is a singleton by default. In order to use a scope other than singleton, you should use Spring\u2019s @Scope annotation.jakarta.inject also provides a jakarta.inject. Scope annotation: however, this one is only intended to be used for creating custom annotations.@Qualifier @Qualifier / @Named jakarta.inject. Qualifier is just a meta-annotation for building custom qualifiers. Concrete String qualifiers (like Spring\u2019s @Qualifier with a value) can be associated through jakarta.inject. Named.", "chunk_char_count": 756, "chunk_word_count": 102, "chunk_token_count": 189.0}, {"page_number": 144, "sentence_chunk": "@Value - no equivalent @Lazy - no equivalent ObjectFactory Provider jakarta.inject. Provider is a direct alternative to Spring\u2019s ObjectFactory, only with a shorter get() method name. It can also be used in combination with Spring\u2019s @Autowired or with non-annotated constructors and setter methods.2.1.12. Java-based Container Configuration This section covers how to use annotations in your Java code to configure the Spring container. It includes the following topics: \u2022 Basic Concepts: @Bean and @Configuration \u2022 Instantiating the Spring Container by Using AnnotationConfigApplicationContext \u2022 Using the @Bean Annotation \u2022 Using the @Configuration annotation \u2022 Composing Java-based Configurations 144", "chunk_char_count": 702, "chunk_word_count": 96, "chunk_token_count": 175.5}, {"page_number": 145, "sentence_chunk": "\u2022 Bean Definition Profiles \u2022 PropertySource Abstraction \u2022 Using @PropertySource \u2022 Placeholder Resolution in Statements Basic Concepts: @Bean and @Configuration The central artifacts in Spring\u2019s new Java-configuration support are @Configuration-annotated classes and @Bean-annotated methods. The @Bean annotation is used to indicate that a method instantiates, configures, and initializes a new object to be managed by the Spring IoC container. For those familiar with Spring\u2019s <beans/> XML configuration, the @Bean annotation plays the same role as the <bean/> element. You can use @Bean -annotated methods with any Spring @Component. However, they are most often used with @Configuration beans. Annotating a class with @Configuration indicates that its primary purpose is as a source of bean definitions. Furthermore, @Configuration classes let inter-bean dependencies be defined by calling other @Bean methods in the same class. The simplest possible @Configuration class reads as follows: Java @Configuration public class AppConfig { \u00a0  @Bean \u00a0  public MyService myService() { \u00a0    return new MyServiceImpl(); \u00a0  } } Kotlin @Configuration class AppConfig { \u00a0  @Bean \u00a0  fun myService(): MyService { \u00a0    return MyServiceImpl() \u00a0  } } The preceding AppConfig class is equivalent to the following Spring <beans/> XML: <beans> \u00a0  <bean id=\"myService\" class=\"com.acme.services. MyServiceImpl\"/> </beans> 145", "chunk_char_count": 1405, "chunk_word_count": 210, "chunk_token_count": 351.25}, {"page_number": 146, "sentence_chunk": "Full @Configuration vs \u201clite\u201d @Bean mode?When @Bean methods are declared within classes that are not annotated with @Configuration, they are referred to as being processed in a \u201clite\u201d mode. Bean methods declared in a @Component or even in a plain old class are considered to be \u201clite\u201d, with a different primary purpose of the containing class and a @Bean method being a sort of bonus there. For example, service components may expose management views to the container through an additional @Bean method on each applicable component class. In such scenarios, @Bean methods are a general-purpose factory method mechanism. Unlike full @Configuration, lite @Bean methods cannot declare inter-bean dependencies. Instead, they operate on their containing component\u2019s internal state and, optionally, on arguments that they may declare. Such a @Bean method should therefore not invoke other @Bean methods. Each such method is literally only a factory method for a particular bean reference, without any special runtime semantics. The positive side-effect here is that no CGLIB subclassing has to be applied at runtime, so there are no limitations in terms of class design (that is, the containing class may be final and so forth).", "chunk_char_count": 1222, "chunk_word_count": 191, "chunk_token_count": 305.5}, {"page_number": 146, "sentence_chunk": "In common scenarios, @Bean methods are to be declared within @Configuration classes, ensuring that \u201cfull\u201d mode is always used and that cross-method references therefore get redirected to the container\u2019s lifecycle management. This prevents the same @Bean method from accidentally being invoked through a regular Java call, which helps to reduce subtle bugs that can be hard to track down when operating in \u201clite\u201d mode. The @Bean and @Configuration annotations are discussed in depth in the following sections. First, however, we cover the various ways of creating a spring container by using Java-based configuration. Instantiating the Spring Container by Using AnnotationConfigApplicationContext The following sections document Spring\u2019s AnnotationConfigApplicationContext, introduced in Spring 3.0. This versatile ApplicationContext implementation is capable of accepting not only @Configuration classes as input but also plain @Component classes and classes annotated with JSR-330 metadata. When @Configuration classes are provided as input, the @Configuration class itself is registered as a bean definition and all declared @Bean methods within the class are also registered as bean definitions. When @Component and JSR-330 classes are provided, they are registered as bean definitions, and it is assumed that DI metadata such as @Autowired or @Inject are used within those classes where necessary. Simple Construction In much the same way that Spring XML files are used as input when instantiating a ClassPathXmlApplicationContext, you can use @Configuration classes as input when instantiating an AnnotationConfigApplicationContext. This allows for completely XML-free usage of the Spring 146", "chunk_char_count": 1697, "chunk_word_count": 238, "chunk_token_count": 424.25}, {"page_number": 147, "sentence_chunk": "container, as the following example shows: Java public static void main(String[] args) { \u00a0  ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class); \u00a0  MyService myService = ctx.getBean(MyService.class); \u00a0  myService.doStuff(); } Kotlin import org.springframework.beans.factory.getBean fun main() { \u00a0  val ctx = AnnotationConfigApplicationContext(AppConfig::class.java) \u00a0  val myService = ctx.getBean<MyService>() \u00a0  myService.doStuff() } As mentioned earlier, AnnotationConfigApplicationContext is not limited to working only with @Configuration classes. Any @Component or JSR-330 annotated class may be supplied as input to the constructor, as the following example shows: Java public static void main(String[] args) { \u00a0  ApplicationContext ctx = new AnnotationConfigApplicationContext(MyServiceImpl.class, Dependency1.class, Dependency2.class); \u00a0  MyService myService = ctx.getBean(MyService.class); \u00a0  myService.doStuff(); } Kotlin import org.springframework.beans.factory.getBean fun main() { \u00a0  val ctx = AnnotationConfigApplicationContext(MyServiceImpl::class.java, Dependency1::class.java, Dependency2::class.java) \u00a0  val myService = ctx.getBean<MyService>() \u00a0  myService.doStuff() } The preceding example assumes that MyServiceImpl, Dependency1, and Dependency2 use Spring dependency injection annotations such as @Autowired.147", "chunk_char_count": 1362, "chunk_word_count": 151, "chunk_token_count": 340.5}, {"page_number": 148, "sentence_chunk": "Building the Container Programmatically by Using register(Class<?>\u2026) You can instantiate an AnnotationConfigApplicationContext by using a no-arg constructor and then configure it by using the register() method. This approach is particularly useful when programmatically building an AnnotationConfigApplicationContext. The following example shows how to do so: Java public static void main(String[] args) { \u00a0  AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(); \u00a0  ctx.register(AppConfig.class, OtherConfig.class); \u00a0  ctx.register(AdditionalConfig.class); \u00a0  ctx.refresh(); \u00a0  MyService myService = ctx.getBean(MyService.class); \u00a0  myService.doStuff(); } Kotlin import org.springframework.beans.factory.getBean fun main() { \u00a0  val ctx = AnnotationConfigApplicationContext() \u00a0  ctx.register(AppConfig::class.java, OtherConfig::class.java) \u00a0  ctx.register(AdditionalConfig::class.java) \u00a0  ctx.refresh() \u00a0  val myService = ctx.getBean<MyService>() \u00a0  myService.doStuff() } Enabling Component Scanning with scan(String\u2026) To enable component scanning, you can annotate your @Configuration class as follows: Java @Configuration @ComponentScan(basePackages = \"com.acme\") \u2460 public class AppConfig { \u00a0  // ... } \u2460 This annotation enables component scanning.148", "chunk_char_count": 1281, "chunk_word_count": 148, "chunk_token_count": 320.25}, {"page_number": 149, "sentence_chunk": "Kotlin @Configuration @ComponentScan(basePackages = [\"com.acme\"]) \u2460 class AppConfig { \u00a0  // ... } \u2460 This annotation enables component scanning.\uf0eb Experienced Spring users may be familiar with the XML declaration equivalent from Spring\u2019s context: namespace, shown in the following example: <beans> \u00a0  <context:component-scan base-package=\"com.acme\"/> </beans> In the preceding example, the com.acme package is scanned to look for any @Component-annotated classes, and those classes are registered as Spring bean definitions within the container. AnnotationConfigApplicationContext exposes the scan(String\u2026) method to allow for the same component-scanning functionality, as the following example shows: Java public static void main(String[] args) { \u00a0  AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(); \u00a0  ctx.scan(\"com.acme\"); \u00a0  ctx.refresh(); \u00a0  MyService myService = ctx.getBean(MyService.class); } Kotlin fun main() { \u00a0  val ctx = AnnotationConfigApplicationContext() \u00a0  ctx.scan(\"com.acme\") \u00a0  ctx.refresh() \u00a0  val myService = ctx.getBean<MyService>() } \uf05a Remember that @Configuration classes are meta-annotated with @Component, so they are candidates for component-scanning. In the preceding example, assuming that AppConfig is declared within the com.acme package (or any package underneath), it is picked up during the call to scan(). Upon refresh(), all its @Bean methods are processed and registered as bean definitions within the container.149", "chunk_char_count": 1484, "chunk_word_count": 197, "chunk_token_count": 371.0}, {"page_number": 150, "sentence_chunk": "Support for Web Applications with AnnotationConfigWebApplicationContext A WebApplicationContext variant of AnnotationConfigApplicationContext is available with AnnotationConfigWebApplicationContext. You can use this implementation when configuring the Spring ContextLoaderListener servlet listener, Spring MVC DispatcherServlet, and so forth. The following web.xml snippet configures a typical Spring MVC web application (note the use of the contextClass context-param and init-param): <web-app> \u00a0  <!--Configure ContextLoaderListener to use AnnotationConfigWebApplicationContext \u00a0    instead of the default XmlWebApplicationContext --> \u00a0  <context-param> \u00a0    <param-name>contextClass</param-name> \u00a0    <param-value> \u00a0 org.springframework.web.context.support. AnnotationConfigWebApplicationContext \u00a0    </param-value> \u00a0  </context-param> \u00a0  <!--Configuration locations must consist of one or more comma- or space-delimited \u00a0    fully-qualified @Configuration classes. Fully-qualified packages may also be \u00a0    specified for component-scanning --> \u00a0  <context-param> \u00a0    <param-name>contextConfigLocation</param-name> \u00a0    <param-value>com.acme. AppConfig</param-value> \u00a0  </context-param> \u00a0  <!--Bootstrap the root application context as usual using ContextLoaderListener --> \u00a0  <listener> \u00a0    <listener- class>org.springframework.web.context. ContextLoaderListener</listener-class> \u00a0  </listener> \u00a0  <!--", "chunk_char_count": 1408, "chunk_word_count": 173, "chunk_token_count": 352.0}, {"page_number": 150, "sentence_chunk": "Declare a Spring MVC DispatcherServlet as usual --> \u00a0  <servlet> \u00a0    <servlet-name>dispatcher</servlet-name> \u00a0    <servlet-class>org.springframework.web.servlet. DispatcherServlet</servlet- class> \u00a0    <!--Configure DispatcherServlet to use AnnotationConfigWebApplicationContext \u00a0      instead of the default XmlWebApplicationContext --> \u00a0    <init-param> \u00a0      <param-name>contextClass</param-name> \u00a0      <param-value> \u00a0 org.springframework.web.context.support. AnnotationConfigWebApplicationContext \u00a0      </param-value> \u00a0    </init-param> \u00a0    <!--Again, config locations must consist of one or more comma- or space- delimited \u00a0      and fully-qualified @Configuration classes --> 150", "chunk_char_count": 690, "chunk_word_count": 107, "chunk_token_count": 172.5}, {"page_number": 151, "sentence_chunk": "<init-param> \u00a0      <param-name>contextConfigLocation</param-name> \u00a0      <param-value>com.acme.web. MvcConfig</param-value> \u00a0    </init-param> \u00a0  </servlet> \u00a0  <!--map all requests for /app/* to the dispatcher servlet --> \u00a0  <servlet-mapping> \u00a0    <servlet-name>dispatcher</servlet-name> \u00a0    <url-pattern>/app/*</url-pattern> \u00a0  </servlet-mapping> </web-app> \uf05a For programmatic use cases, a GenericWebApplicationContext can be used as an alternative to AnnotationConfigWebApplicationContext. See the GenericWebApplicationContext javadoc for details. Using the @Bean Annotation @Bean is a method-level annotation and a direct analog of the XML <bean/> element. The annotation supports some of the attributes offered by <bean/>, such as: \u2022 init-method \u2022 destroy-method \u2022 autowiring \u2022 name. You can use the @Bean annotation in a @Configuration-annotated or in a @Component-annotated class. Declaring a Bean To declare a bean, you can annotate a method with the @Bean annotation. You use this method to register a bean definition within an ApplicationContext of the type specified as the method\u2019s return value. By default, the bean name is the same as the method name.", "chunk_char_count": 1166, "chunk_word_count": 175, "chunk_token_count": 291.5}, {"page_number": 151, "sentence_chunk": "The following example shows a @Bean method declaration: Java @Configuration public class AppConfig { \u00a0  @Bean \u00a0  public TransferServiceImpl transferService() { \u00a0    return new TransferServiceImpl(); \u00a0  } } 151", "chunk_char_count": 209, "chunk_word_count": 35, "chunk_token_count": 52.25}, {"page_number": 152, "sentence_chunk": "Kotlin @Configuration class AppConfig { \u00a0  @Bean \u00a0  fun transferService() = TransferServiceImpl() } The preceding configuration is exactly equivalent to the following Spring XML: <beans> \u00a0  <bean id=\"transferService\" class=\"com.acme. TransferServiceImpl\"/> </beans> Both declarations make a bean named transferService available in the ApplicationContext, bound to an object instance of type TransferServiceImpl, as the following text image shows: transferService -> com.acme. TransferServiceImpl You can also use default methods to define beans. This allows composition of bean configurations by implementing interfaces with bean definitions on default methods. Java public interface BaseConfig { \u00a0  @Bean \u00a0  default TransferServiceImpl transferService() { \u00a0    return new TransferServiceImpl(); \u00a0  } } @Configuration public class AppConfig implements BaseConfig { } You can also declare your @Bean method with an interface (or base class) return type, as the following example shows: 152", "chunk_char_count": 988, "chunk_word_count": 141, "chunk_token_count": 247.0}, {"page_number": 153, "sentence_chunk": "Java @Configuration public class AppConfig { \u00a0  @Bean \u00a0  public TransferService transferService() { \u00a0    return new TransferServiceImpl(); \u00a0  } } Kotlin @Configuration class AppConfig { \u00a0  @Bean \u00a0  fun transferService(): TransferService { \u00a0    return TransferServiceImpl() \u00a0  } } However, this limits the visibility for advance type prediction to the specified interface type (TransferService). Then, with the full type (TransferServiceImpl) known to the container only once the affected singleton bean has been instantiated. Non-lazy singleton beans get instantiated according to their declaration order, so you may see different type matching results depending on when another component tries to match by a non-declared type (such as @Autowired TransferServiceImpl, which resolves only once the transferService bean has been instantiated).\uf0eb If you consistently refer to your types by a declared service interface, your @Bean return types may safely join that design decision. However, for components that implement several interfaces or for components potentially referred to by their implementation type, it is safer to declare the most specific return type possible (at least as specific as required by the injection points that refer to your bean). Bean Dependencies A @Bean-annotated method can have an arbitrary number of parameters that describe the dependencies required to build that bean. For instance, if our TransferService requires an AccountRepository, we can materialize that dependency with a method parameter, as the following example shows: 153", "chunk_char_count": 1563, "chunk_word_count": 237, "chunk_token_count": 390.75}, {"page_number": 154, "sentence_chunk": "Java @Configuration public class AppConfig { \u00a0  @Bean \u00a0  public TransferService transferService(AccountRepository accountRepository) { \u00a0    return new TransferServiceImpl(accountRepository); \u00a0  } } Kotlin @Configuration class AppConfig { \u00a0  @Bean \u00a0  fun transferService(accountRepository: AccountRepository): TransferService { \u00a0    return TransferServiceImpl(accountRepository) \u00a0  } } The resolution mechanism is pretty much identical to constructor-based dependency injection. See the relevant section for more details. Receiving Lifecycle Callbacks Any classes defined with the @Bean annotation support the regular lifecycle callbacks and can use the @PostConstruct and @PreDestroy annotations from JSR-250. See JSR-250 annotations for further details. The regular Spring lifecycle callbacks are fully supported as well. If a bean implements InitializingBean, DisposableBean, or Lifecycle, their respective methods are called by the container. The standard set of *Aware interfaces (such as BeanFactoryAware, BeanNameAware, MessageSourceAware, ApplicationContextAware, and so on) are also fully supported. The @Bean annotation supports specifying arbitrary initialization and destruction callback methods, much like Spring XML\u2019s init-method and destroy-method attributes on the bean element, as the following example shows: 154", "chunk_char_count": 1329, "chunk_word_count": 175, "chunk_token_count": 332.25}, {"page_number": 155, "sentence_chunk": "Java public class BeanOne { \u00a0  public void init() { \u00a0    // initialization logic \u00a0  } } public class BeanTwo { \u00a0  public void cleanup() { \u00a0    // destruction logic \u00a0  } } @Configuration public class AppConfig { \u00a0  @Bean(initMethod = \"init\") \u00a0  public BeanOne beanOne() { \u00a0    return new BeanOne(); \u00a0  } \u00a0  @Bean(destroyMethod = \"cleanup\") \u00a0  public BeanTwo beanTwo() { \u00a0    return new BeanTwo(); \u00a0  } } 155", "chunk_char_count": 406, "chunk_word_count": 92, "chunk_token_count": 101.5}, {"page_number": 156, "sentence_chunk": "Kotlin class BeanOne { \u00a0  fun init() { \u00a0    // initialization logic \u00a0  } } class BeanTwo { \u00a0  fun cleanup() { \u00a0    // destruction logic \u00a0  } } @Configuration class AppConfig { \u00a0  @Bean(initMethod = \"init\") \u00a0  fun beanOne() = BeanOne() \u00a0  @Bean(destroyMethod = \"cleanup\") \u00a0  fun beanTwo() = BeanTwo() } 156", "chunk_char_count": 305, "chunk_word_count": 67, "chunk_token_count": 76.25}, {"page_number": 157, "sentence_chunk": "\uf05a By default, beans defined with Java configuration that have a public close or shutdown method are automatically enlisted with a destruction callback. If you have a public close or shutdown method and you do not wish for it to be called when the container shuts down, you can add @Bean(destroyMethod=\"\") to your bean definition to disable the default (inferred) mode. You may want to do that by default for a resource that you acquire with JNDI, as its lifecycle is managed outside the application. In particular, make sure to always do it for a DataSource, as it is known to be problematic on Jakarta EE application servers. The following example shows how to prevent an automatic destruction callback for a DataSource: Java @Bean(destroyMethod=\"\") public DataSource dataSource() throws NamingException { \u00a0  return (DataSource) jndiTemplate.lookup(\"MyDS\"); } Kotlin @Bean(destroyMethod = \"\") fun dataSource(): DataSource { \u00a0  return jndiTemplate.lookup(\"MyDS\") as DataSource } Also, with @Bean methods, you typically use programmatic JNDI lookups, either by using Spring\u2019s JndiTemplate or JndiLocatorDelegate helpers or straight JNDI InitialContext usage but not the JndiObjectFactoryBean variant (which would force you to declare the return type as the FactoryBean type instead of the actual target type, making it harder to use for cross-reference calls in other @Bean methods that intend to refer to the provided resource here). In the case of BeanOne from the example above the preceding note, it would be equally valid to call the init() method directly during construction, as the following example shows: 157", "chunk_char_count": 1617, "chunk_word_count": 250, "chunk_token_count": 404.25}, {"page_number": 158, "sentence_chunk": "Java @Configuration public class AppConfig { \u00a0  @Bean \u00a0  public BeanOne beanOne() { \u00a0    BeanOne beanOne = new BeanOne(); \u00a0    beanOne.init(); \u00a0    return beanOne; \u00a0  } \u00a0  // ... } Kotlin @Configuration class AppConfig { \u00a0  @Bean \u00a0  fun beanOne() = BeanOne().apply { \u00a0    init() \u00a0  } \u00a0  // ... } \uf0eb When you work directly in Java, you can do anything you like with your objects and do not always need to rely on the container lifecycle. Specifying Bean Scope Spring includes the @Scope annotation so that you can specify the scope of a bean. Using the @Scope Annotation You can specify that your beans defined with the @Bean annotation should have a specific scope. You can use any of the standard scopes specified in the Bean Scopes section. The default scope is singleton, but you can override this with the @Scope annotation, as the following example shows: 158", "chunk_char_count": 863, "chunk_word_count": 170, "chunk_token_count": 215.75}, {"page_number": 159, "sentence_chunk": "Java @Configuration public class MyConfiguration { \u00a0  @Bean \u00a0  @Scope(\"prototype\") \u00a0  public Encryptor encryptor() { \u00a0    // ... \u00a0  } } Kotlin @Configuration class MyConfiguration { \u00a0  @Bean \u00a0  @Scope(\"prototype\") \u00a0  fun encryptor(): Encryptor { \u00a0    // ... \u00a0  } } @Scope and scoped-proxy Spring offers a convenient way of working with scoped dependencies through scoped proxies. The easiest way to create such a proxy when using the XML configuration is the <aop:scoped-proxy/> element. Configuring your beans in Java with a @Scope annotation offers equivalent support with the proxyMode attribute. The default is ScopedProxyMode. DEFAULT, which typically indicates that no scoped proxy should be created unless a different default has been configured at the component- scan instruction level. You can specify ScopedProxyMode. TARGET_CLASS, ScopedProxyMode. INTERFACES or ScopedProxyMode. NO. If you port the scoped proxy example from the XML reference documentation (see scoped proxies) to our @Bean using Java, it resembles the following: 159", "chunk_char_count": 1045, "chunk_word_count": 167, "chunk_token_count": 261.25}, {"page_number": 160, "sentence_chunk": "Java // an HTTP Session-scoped bean exposed as a proxy @Bean @SessionScope public UserPreferences userPreferences() { \u00a0  return new UserPreferences(); } @Bean public Service userService() { \u00a0  UserService service = new SimpleUserService(); \u00a0  // a reference to the proxied userPreferences bean \u00a0  service.setUserPreferences(userPreferences()); \u00a0  return service; } Kotlin // an HTTP Session-scoped bean exposed as a proxy @Bean @SessionScope fun userPreferences() = UserPreferences() @Bean fun userService(): Service { \u00a0  return SimpleUserService().apply { \u00a0    // a reference to the proxied userPreferences bean \u00a0    setUserPreferences(userPreferences()) \u00a0  } } Customizing Bean Naming By default, configuration classes use a @Bean method\u2019s name as the name of the resulting bean. This functionality can be overridden, however, with the name attribute, as the following example shows: Java @Configuration public class AppConfig { \u00a0  @Bean(\"myThing\") \u00a0  public Thing thing() { \u00a0    return new Thing(); \u00a0  } } 160", "chunk_char_count": 1012, "chunk_word_count": 160, "chunk_token_count": 253.0}, {"page_number": 161, "sentence_chunk": "Kotlin @Configuration class AppConfig { \u00a0  @Bean(\"myThing\") \u00a0  fun thing() = Thing() } Bean Aliasing As discussed in Naming Beans, it is sometimes desirable to give a single bean multiple names, otherwise known as bean aliasing. The name attribute of the @Bean annotation accepts a String array for this purpose. The following example shows how to set a number of aliases for a bean: Java @Configuration public class AppConfig { \u00a0  @Bean({\"dataSource\", \"subsystemA-dataSource\", \"subsystemB-dataSource\"}) \u00a0  public DataSource dataSource() { \u00a0    // instantiate, configure and return DataSource bean... \u00a0  } } Kotlin @Configuration class AppConfig { \u00a0  @Bean(\"dataSource\", \"subsystemA-dataSource\", \"subsystemB-dataSource\") \u00a0  fun dataSource(): DataSource { \u00a0    // instantiate, configure and return DataSource bean... \u00a0  } } Bean Description Sometimes, it is helpful to provide a more detailed textual description of a bean. This can be particularly useful when beans are exposed (perhaps through JMX) for monitoring purposes. To add a description to a @Bean, you can use the @Description annotation, as the following example shows: 161", "chunk_char_count": 1134, "chunk_word_count": 179, "chunk_token_count": 283.5}, {"page_number": 162, "sentence_chunk": "Java @Configuration public class AppConfig { \u00a0  @Bean \u00a0  @Description(\"Provides a basic example of a bean\") \u00a0  public Thing thing() { \u00a0    return new Thing(); \u00a0  } } Kotlin @Configuration class AppConfig { \u00a0  @Bean \u00a0  @Description(\"Provides a basic example of a bean\") \u00a0  fun thing() = Thing() } Using the @Configuration annotation @Configuration is a class-level annotation indicating that an object is a source of bean definitions.@Configuration classes declare beans through @Bean-annotated methods. Calls to @Bean methods on @Configuration classes can also be used to define inter-bean dependencies. See Basic Concepts: @Bean and @Configuration for a general introduction. Injecting Inter-bean Dependencies When beans have dependencies on one another, expressing that dependency is as simple as having one bean method call another, as the following example shows: Java @Configuration public class AppConfig { \u00a0  @Bean \u00a0  public BeanOne beanOne() { \u00a0    return new BeanOne(beanTwo()); \u00a0  } \u00a0  @Bean \u00a0  public BeanTwo beanTwo() { \u00a0    return new BeanTwo(); \u00a0  } } 162", "chunk_char_count": 1069, "chunk_word_count": 183, "chunk_token_count": 267.25}, {"page_number": 163, "sentence_chunk": "Kotlin @Configuration class AppConfig { \u00a0  @Bean \u00a0  fun beanOne() = BeanOne(beanTwo()) \u00a0  @Bean \u00a0  fun beanTwo() = BeanTwo() } In the preceding example, beanOne receives a reference to beanTwo through constructor injection.\uf05a This method of declaring inter-bean dependencies works only when the @Bean method is declared within a @Configuration class. You cannot declare inter-bean dependencies by using plain @Component classes. Lookup Method Injection As noted earlier, lookup method injection is an advanced feature that you should use rarely. It is useful in cases where a singleton-scoped bean has a dependency on a prototype-scoped bean. Using Java for this type of configuration provides a natural means for implementing this pattern. The following example shows how to use lookup method injection: Java public abstract class CommandManager { \u00a0  public Object process(Object commandState) { \u00a0    // grab a new instance of the appropriate Command interface \u00a0    Command command = createCommand(); \u00a0    // set the state on the (hopefully brand new) Command instance \u00a0    command.setState(commandState); \u00a0    return command.execute(); \u00a0  } \u00a0  // okay... but where is the implementation of this method?\u00a0  protected abstract Command createCommand(); } 163", "chunk_char_count": 1255, "chunk_word_count": 207, "chunk_token_count": 313.75}, {"page_number": 164, "sentence_chunk": "Kotlin abstract class CommandManager { \u00a0  fun process(commandState: Any): Any { \u00a0    // grab a new instance of the appropriate Command interface \u00a0    val command = createCommand() \u00a0    // set the state on the (hopefully brand new) Command instance \u00a0    command.setState(commandState) \u00a0    return command.execute() \u00a0  } \u00a0  // okay... but where is the implementation of this method?\u00a0  protected abstract fun createCommand(): Command } By using Java configuration, you can create a subclass of CommandManager where the abstract createCommand() method is overridden in such a way that it looks up a new (prototype) command object. The following example shows how to do so: Java @Bean @Scope(\"prototype\") public AsyncCommand asyncCommand() { \u00a0  AsyncCommand command = new AsyncCommand(); \u00a0  // inject dependencies here as required \u00a0  return command; } @Bean public CommandManager commandManager() { \u00a0  // return new anonymous implementation of CommandManager with createCommand() \u00a0  // overridden to return a new prototype Command object \u00a0  return new CommandManager() { \u00a0    protected Command createCommand() { \u00a0      return asyncCommand(); \u00a0    } \u00a0  } } 164", "chunk_char_count": 1154, "chunk_word_count": 207, "chunk_token_count": 288.5}, {"page_number": 165, "sentence_chunk": "Kotlin @Bean @Scope(\"prototype\") fun asyncCommand(): AsyncCommand { \u00a0  val command = AsyncCommand() \u00a0  // inject dependencies here as required \u00a0  return command } @Bean fun commandManager(): CommandManager { \u00a0  // return new anonymous implementation of CommandManager with createCommand() \u00a0  // overridden to return a new prototype Command object \u00a0  return object : CommandManager() { \u00a0    override fun createCommand(): Command { \u00a0      return asyncCommand() \u00a0    } \u00a0  } } Further Information About How Java-based Configuration Works Internally Consider the following example, which shows a @Bean annotated method being called twice: Java @Configuration public class AppConfig { \u00a0  @Bean \u00a0  public ClientService clientService1() { \u00a0    ClientServiceImpl clientService = new ClientServiceImpl(); \u00a0    clientService.setClientDao(clientDao()); \u00a0    return clientService; \u00a0  } \u00a0  @Bean \u00a0  public ClientService clientService2() { \u00a0    ClientServiceImpl clientService = new ClientServiceImpl(); \u00a0    clientService.setClientDao(clientDao()); \u00a0    return clientService; \u00a0  } \u00a0  @Bean \u00a0  public ClientDao clientDao() { \u00a0    return new ClientDaoImpl(); \u00a0  } } 165", "chunk_char_count": 1153, "chunk_word_count": 198, "chunk_token_count": 288.25}, {"page_number": 166, "sentence_chunk": "Kotlin @Configuration class AppConfig { \u00a0  @Bean \u00a0  fun clientService1(): ClientService { \u00a0    return ClientServiceImpl().apply { \u00a0      clientDao = clientDao() \u00a0    } \u00a0  } \u00a0  @Bean \u00a0  fun clientService2(): ClientService { \u00a0    return ClientServiceImpl().apply { \u00a0      clientDao = clientDao() \u00a0    } \u00a0  } \u00a0  @Bean \u00a0  fun clientDao(): ClientDao { \u00a0    return ClientDaoImpl() \u00a0  } } clientDao() has been called once in clientService1() and once in clientService2(). Since this method creates a new instance of ClientDaoImpl and returns it, you would normally expect to have two instances (one for each service). That definitely would be problematic: In Spring, instantiated beans have a singleton scope by default. This is where the magic comes in: All @Configuration classes are subclassed at startup-time with CGLIB. In the subclass, the child method checks the container first for any cached (scoped) beans before it calls the parent method and creates a new instance.\uf05a The behavior could be different according to the scope of your bean. We are talking about singletons here.\uf05a As of Spring 3.2, it is no longer necessary to add CGLIB to your classpath because CGLIB classes have been repackaged under org.springframework.cglib and included directly within the spring-core JAR.166", "chunk_char_count": 1282, "chunk_word_count": 230, "chunk_token_count": 320.5}, {"page_number": 167, "sentence_chunk": "\uf0eb There are a few restrictions due to the fact that CGLIB dynamically adds features at startup-time. In particular, configuration classes must not be final. However, as of 4.3, any constructors are allowed on configuration classes, including the use of @Autowired or a single non-default constructor declaration for default injection. If you prefer to avoid any CGLIB-imposed limitations, consider declaring your @Bean methods on non-@Configuration classes (for example, on plain @Component classes instead). Cross-method calls between @Bean methods are not then intercepted, so you have to exclusively rely on dependency injection at the constructor or method level there. Composing Java-based Configurations Spring\u2019s Java-based configuration feature lets you compose annotations, which can reduce the complexity of your configuration. Using the @Import Annotation Much as the <import/> element is used within Spring XML files to aid in modularizing configurations, the @Import annotation allows for loading @Bean definitions from another configuration class, as the following example shows: Java @Configuration public class ConfigA { \u00a0  @Bean \u00a0  public A a() { \u00a0    return new A(); \u00a0  } } @Configuration @Import(ConfigA.class) public class ConfigB { \u00a0  @Bean \u00a0  public B b() { \u00a0    return new B(); \u00a0  } } 167", "chunk_char_count": 1310, "chunk_word_count": 207, "chunk_token_count": 327.5}, {"page_number": 168, "sentence_chunk": "Kotlin @Configuration class ConfigA { \u00a0  @Bean \u00a0  fun a() = A() } @Configuration @Import(ConfigA::class) class ConfigB { \u00a0  @Bean \u00a0  fun b() = B() } Now, rather than needing to specify both ConfigA.class and ConfigB.class when instantiating the context, only ConfigB needs to be supplied explicitly, as the following example shows: Java public static void main(String[] args) { \u00a0  ApplicationContext ctx = new AnnotationConfigApplicationContext(ConfigB.class); \u00a0  // now both beans A and B will be available... \u00a0  A a = ctx.getBean(A.class); \u00a0  B b = ctx.getBean(B.class); } Kotlin import org.springframework.beans.factory.getBean fun main() { \u00a0  val ctx = AnnotationConfigApplicationContext(ConfigB::class.java) \u00a0  // now both beans A and B will be available... \u00a0  val a = ctx.getBean<A>() \u00a0  val b = ctx.getBean<B>() } This approach simplifies container instantiation, as only one class needs to be dealt with, rather than requiring you to remember a potentially large number of @Configuration classes during construction.168", "chunk_char_count": 1027, "chunk_word_count": 161, "chunk_token_count": 256.75}, {"page_number": 169, "sentence_chunk": "\uf0eb As of Spring Framework 4.2, @Import also supports references to regular component classes, analogous to the AnnotationConfigApplicationContext.register method. This is particularly useful if you want to avoid component scanning, by using a few configuration classes as entry points to explicitly define all your components. Injecting Dependencies on Imported @Bean Definitions The preceding example works but is simplistic. In most practical scenarios, beans have dependencies on one another across configuration classes. When using XML, this is not an issue, because no compiler is involved, and you can declare ref=\"someBean\" and trust Spring to work it out during container initialization. When using @Configuration classes, the Java compiler places constraints on the configuration model, in that references to other beans must be valid Java syntax. Fortunately, solving this problem is simple. As we already discussed, a @Bean method can have an arbitrary number of parameters that describe the bean dependencies. Consider the following more real-world scenario with several @Configuration classes, each depending on beans declared in the others: 169", "chunk_char_count": 1157, "chunk_word_count": 167, "chunk_token_count": 289.25}, {"page_number": 170, "sentence_chunk": "Java @Configuration public class ServiceConfig { \u00a0  @Bean \u00a0  public TransferService transferService(AccountRepository accountRepository) { \u00a0    return new TransferServiceImpl(accountRepository); \u00a0  } } @Configuration public class RepositoryConfig { \u00a0  @Bean \u00a0  public AccountRepository accountRepository(DataSource dataSource) { \u00a0    return new JdbcAccountRepository(dataSource); \u00a0  } } @Configuration @Import({ServiceConfig.class, RepositoryConfig.class}) public class SystemTestConfig { \u00a0  @Bean \u00a0  public DataSource dataSource() { \u00a0    // return new DataSource \u00a0  } } public static void main(String[] args) { \u00a0  ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class); \u00a0  // everything wires up across configuration classes... \u00a0  TransferService transferService = ctx.getBean(TransferService.class); \u00a0  transferService.transfer(100.00, \"A123\", \"C456\"); } 170", "chunk_char_count": 893, "chunk_word_count": 116, "chunk_token_count": 223.25}, {"page_number": 171, "sentence_chunk": "Kotlin import org.springframework.beans.factory.getBean @Configuration class ServiceConfig { \u00a0  @Bean \u00a0  fun transferService(accountRepository: AccountRepository): TransferService { \u00a0    return TransferServiceImpl(accountRepository) \u00a0  } } @Configuration class RepositoryConfig { \u00a0  @Bean \u00a0  fun accountRepository(dataSource: DataSource): AccountRepository { \u00a0    return JdbcAccountRepository(dataSource) \u00a0  } } @Configuration @Import(ServiceConfig::class, RepositoryConfig::class) class SystemTestConfig { \u00a0  @Bean \u00a0  fun dataSource(): DataSource { \u00a0    // return new DataSource \u00a0  } } fun main() { \u00a0  val ctx = AnnotationConfigApplicationContext(SystemTestConfig::class.java) \u00a0  // everything wires up across configuration classes... \u00a0  val transferService = ctx.getBean<TransferService>() \u00a0  transferService.transfer(100.00, \"A123\", \"C456\") } There is another way to achieve the same result. Remember that @Configuration classes are ultimately only another bean in the container: This means that they can take advantage of @Autowired and @Value injection and other features the same as any other bean.171", "chunk_char_count": 1107, "chunk_word_count": 150, "chunk_token_count": 276.75}, {"page_number": 172, "sentence_chunk": "\uf071 Make sure that the dependencies you inject that way are of the simplest kind only.@Configuration classes are processed quite early during the initialization of the context, and forcing a dependency to be injected this way may lead to unexpected early initialization. Whenever possible, resort to parameter-based injection, as in the preceding example. Also, be particularly careful with BeanPostProcessor and BeanFactoryPostProcessor definitions through @Bean. Those should usually be declared as static @Bean methods, not triggering the instantiation of their containing configuration class. Otherwise, @Autowired and @Value may not work on the configuration class itself, since it is possible to create it as a bean instance earlier than AutowiredAnnotationBeanPostProcessor. The following example shows how one bean can be autowired to another bean: 172", "chunk_char_count": 858, "chunk_word_count": 122, "chunk_token_count": 214.5}, {"page_number": 173, "sentence_chunk": "Java @Configuration public class ServiceConfig { \u00a0  @Autowired \u00a0  private AccountRepository accountRepository; \u00a0  @Bean \u00a0  public TransferService transferService() { \u00a0    return new TransferServiceImpl(accountRepository); \u00a0  } } @Configuration public class RepositoryConfig { \u00a0  private final DataSource dataSource; \u00a0  public RepositoryConfig(DataSource dataSource) { \u00a0    this.dataSource = dataSource; \u00a0  } \u00a0  @Bean \u00a0  public AccountRepository accountRepository() { \u00a0    return new JdbcAccountRepository(dataSource); \u00a0  } } @Configuration @Import({ServiceConfig.class, RepositoryConfig.class}) public class SystemTestConfig { \u00a0  @Bean \u00a0  public DataSource dataSource() { \u00a0    // return new DataSource \u00a0  } } public static void main(String[] args) { \u00a0  ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class); \u00a0  // everything wires up across configuration classes... \u00a0  TransferService transferService = ctx.getBean(TransferService.class); \u00a0  transferService.transfer(100.00, \"A123\", \"C456\"); } 173", "chunk_char_count": 1031, "chunk_word_count": 144, "chunk_token_count": 257.75}, {"page_number": 174, "sentence_chunk": "Kotlin import org.springframework.beans.factory.getBean @Configuration class ServiceConfig { \u00a0  @Autowired \u00a0  lateinit var accountRepository: AccountRepository \u00a0  @Bean \u00a0  fun transferService(): TransferService { \u00a0    return TransferServiceImpl(accountRepository) \u00a0  } } @Configuration class RepositoryConfig(private val dataSource: DataSource) { \u00a0  @Bean \u00a0  fun accountRepository(): AccountRepository { \u00a0    return JdbcAccountRepository(dataSource) \u00a0  } } @Configuration @Import(ServiceConfig::class, RepositoryConfig::class) class SystemTestConfig { \u00a0  @Bean \u00a0  fun dataSource(): DataSource { \u00a0    // return new DataSource \u00a0  } } fun main() { \u00a0  val ctx = AnnotationConfigApplicationContext(SystemTestConfig::class.java) \u00a0  // everything wires up across configuration classes... \u00a0  val transferService = ctx.getBean<TransferService>() \u00a0  transferService.transfer(100.00, \"A123\", \"C456\") } \uf0eb Constructor injection in @Configuration classes is only supported as of Spring Framework 4.3. Note also that there is no need to specify @Autowired if the target bean defines only one constructor. Fully-qualifying imported beans for ease of navigation In the preceding scenario, using @Autowired works well and provides the desired modularity, but determining exactly where the autowired bean definitions are declared is still somewhat 174", "chunk_char_count": 1332, "chunk_word_count": 184, "chunk_token_count": 333.0}, {"page_number": 175, "sentence_chunk": "ambiguous. For example, as a developer looking at ServiceConfig, how do you know exactly where the @Autowired AccountRepository bean is declared?It is not explicit in the code, and this may be just fine. Remember that the Spring Tools for Eclipse provides tooling that can render graphs showing how everything is wired, which may be all you need. Also, your Java IDE can easily find all declarations and uses of the AccountRepository type and quickly show you the location of @Bean methods that return that type. In cases where this ambiguity is not acceptable and you wish to have direct navigation from within your IDE from one @Configuration class to another, consider autowiring the configuration classes themselves. The following example shows how to do so: Java @Configuration public class ServiceConfig { \u00a0  @Autowired \u00a0  private RepositoryConfig repositoryConfig; \u00a0  @Bean \u00a0  public TransferService transferService() { \u00a0    // navigate 'through' the config class to the @Bean method!\u00a0    return new TransferServiceImpl(repositoryConfig.accountRepository()); \u00a0  } } Kotlin @Configuration class ServiceConfig { \u00a0  @Autowired \u00a0  private lateinit var repositoryConfig: RepositoryConfig \u00a0  @Bean \u00a0  fun transferService(): TransferService { \u00a0    // navigate 'through' the config class to the @Bean method!\u00a0    return TransferServiceImpl(repositoryConfig.accountRepository()) \u00a0  } } In the preceding situation, where AccountRepository is defined is completely explicit. However, ServiceConfig is now tightly coupled to RepositoryConfig.", "chunk_char_count": 1537, "chunk_word_count": 237, "chunk_token_count": 384.25}, {"page_number": 175, "sentence_chunk": "That is the tradeoff. This tight coupling can be somewhat mitigated by using interface-based or abstract class-based @Configuration classes. Consider the following example: 175", "chunk_char_count": 176, "chunk_word_count": 24, "chunk_token_count": 44.0}, {"page_number": 176, "sentence_chunk": "Java @Configuration public class ServiceConfig { \u00a0  @Autowired \u00a0  private RepositoryConfig repositoryConfig; \u00a0  @Bean \u00a0  public TransferService transferService() { \u00a0    return new TransferServiceImpl(repositoryConfig.accountRepository()); \u00a0  } } @Configuration public interface RepositoryConfig { \u00a0  @Bean \u00a0  AccountRepository accountRepository(); } @Configuration public class DefaultRepositoryConfig implements RepositoryConfig { \u00a0  @Bean \u00a0  public AccountRepository accountRepository() { \u00a0    return new JdbcAccountRepository(...); \u00a0  } } @Configuration @Import({ServiceConfig.class, DefaultRepositoryConfig.class}) // import the concrete config!public class SystemTestConfig { \u00a0  @Bean \u00a0  public DataSource dataSource() { \u00a0    // return DataSource \u00a0  } } public static void main(String[] args) { \u00a0  ApplicationContext ctx = new AnnotationConfigApplicationContext(SystemTestConfig.class); \u00a0  TransferService transferService = ctx.getBean(TransferService.class); \u00a0  transferService.transfer(100.00, \"A123\", \"C456\"); } 176", "chunk_char_count": 1023, "chunk_word_count": 131, "chunk_token_count": 255.75}, {"page_number": 177, "sentence_chunk": "Kotlin import org.springframework.beans.factory.getBean @Configuration class ServiceConfig { \u00a0  @Autowired \u00a0  private lateinit var repositoryConfig: RepositoryConfig \u00a0  @Bean \u00a0  fun transferService(): TransferService { \u00a0    return TransferServiceImpl(repositoryConfig.accountRepository()) \u00a0  } } @Configuration interface RepositoryConfig { \u00a0  @Bean \u00a0  fun accountRepository(): AccountRepository } @Configuration class DefaultRepositoryConfig : RepositoryConfig { \u00a0  @Bean \u00a0  fun accountRepository(): AccountRepository { \u00a0    return JdbcAccountRepository(...) \u00a0  } } @Configuration @Import(ServiceConfig::class, DefaultRepositoryConfig::class) // import the concrete config!class SystemTestConfig { \u00a0  @Bean \u00a0  fun dataSource(): DataSource { \u00a0    // return DataSource \u00a0  } } fun main() { \u00a0  val ctx = AnnotationConfigApplicationContext(SystemTestConfig::class.java) \u00a0  val transferService = ctx.getBean<TransferService>() \u00a0  transferService.transfer(100.00, \"A123\", \"C456\") } 177", "chunk_char_count": 978, "chunk_word_count": 126, "chunk_token_count": 244.5}, {"page_number": 178, "sentence_chunk": "Now ServiceConfig is loosely coupled with respect to the concrete DefaultRepositoryConfig, and built-in IDE tooling is still useful: You can easily get a type hierarchy of RepositoryConfig implementations. In this way, navigating @Configuration classes and their dependencies becomes no different than the usual process of navigating interface-based code.\uf0eb If you want to influence the startup creation order of certain beans, consider declaring some of them as @Lazy (for creation on first access instead of on startup) or as @DependsOn certain other beans (making sure that specific other beans are created before the current bean, beyond what the latter\u2019s direct dependencies imply). Conditionally Include @Configuration Classes or @Bean Methods It is often useful to conditionally enable or disable a complete @Configuration class or even individual @Bean methods, based on some arbitrary system state. One common example of this is to use the @Profile annotation to activate beans only when a specific profile has been enabled in the Spring Environment (see Bean Definition Profiles for details). The @Profile annotation is actually implemented by using a much more flexible annotation called @Conditional. The @Conditional annotation indicates specific org.springframework.context.annotation. Condition implementations that should be consulted before a @Bean is registered. Implementations of the Condition interface provide a matches(\u2026) method that returns true or false. For example, the following listing shows the actual Condition implementation used for @Profile: Java @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { \u00a0  // Read the @Profile annotation attributes \u00a0  MultiValueMap<String, Object> attrs = metadata.getAllAnnotationAttributes(Profile.class.getName()); \u00a0  if (attrs !", "chunk_char_count": 1836, "chunk_word_count": 252, "chunk_token_count": 459.0}, {"page_number": 178, "sentence_chunk": "= null) { \u00a0    for (Object value : attrs.get(\"value\")) { \u00a0      if (context.getEnvironment().acceptsProfiles(((String[]) value))) { \u00a0        return true; \u00a0      } \u00a0    } \u00a0    return false; \u00a0  } \u00a0  return true; } 178", "chunk_char_count": 215, "chunk_word_count": 60, "chunk_token_count": 53.75}, {"page_number": 179, "sentence_chunk": "Kotlin override fun matches(context: ConditionContext, metadata: AnnotatedTypeMetadata): Boolean { \u00a0  // Read the @Profile annotation attributes \u00a0  val attrs = metadata.getAllAnnotationAttributes(Profile::class.java.name) \u00a0  if (attrs != null) { \u00a0    for (value in attrs[\"value\"]!!) {\u00a0      if (context.environment.acceptsProfiles(Profiles.of(*value as Array<String>))) { \u00a0        return true \u00a0      } \u00a0    } \u00a0    return false \u00a0  } \u00a0  return true } See the @Conditional javadoc for more detail. Combining Java and XML Configuration Spring\u2019s @Configuration class support does not aim to be a 100% complete replacement for Spring XML. Some facilities, such as Spring XML namespaces, remain an ideal way to configure the container. In cases where XML is convenient or necessary, you have a choice: either instantiate the container in an \u201cXML-centric\u201d way by using, for example, ClassPathXmlApplicationContext, or instantiate it in a \u201cJava-centric\u201d way by using AnnotationConfigApplicationContext and the @ImportResource annotation to import XML as needed. XML-centric Use of @Configuration Classes It may be preferable to bootstrap the Spring container from XML and include @Configuration classes in an ad-hoc fashion. For example, in a large existing codebase that uses Spring XML, it is easier to create @Configuration classes on an as-needed basis and include them from the existing XML files. Later in this section, we cover the options for using @Configuration classes in this kind of \u201cXML- centric\u201d situation. Declaring @Configuration classes as plain Spring <bean/> elements Remember that @Configuration classes are ultimately bean definitions in the container.", "chunk_char_count": 1665, "chunk_word_count": 264, "chunk_token_count": 416.25}, {"page_number": 179, "sentence_chunk": "In this series examples, we create a @Configuration class named AppConfig and include it within system- test-config.xml as a <bean/> definition. Because <context:annotation-config/> is switched on, the container recognizes the @Configuration annotation and processes the @Bean methods declared in AppConfig properly. The following example shows an ordinary configuration class in Java: 179", "chunk_char_count": 389, "chunk_word_count": 52, "chunk_token_count": 97.25}, {"page_number": 180, "sentence_chunk": "Java @Configuration public class AppConfig { \u00a0  @Autowired \u00a0  private DataSource dataSource; \u00a0  @Bean \u00a0  public AccountRepository accountRepository() { \u00a0    return new JdbcAccountRepository(dataSource); \u00a0  } \u00a0  @Bean \u00a0  public TransferService transferService() { \u00a0    return new TransferService(accountRepository()); \u00a0  } } Kotlin @Configuration class AppConfig { \u00a0  @Autowired \u00a0  private lateinit var dataSource: DataSource \u00a0  @Bean \u00a0  fun accountRepository(): AccountRepository { \u00a0    return JdbcAccountRepository(dataSource) \u00a0  } \u00a0  @Bean \u00a0  fun transferService() = TransferService(accountRepository()) } The following example shows part of a sample system-test-config.xml file: 180", "chunk_char_count": 685, "chunk_word_count": 107, "chunk_token_count": 171.25}, {"page_number": 181, "sentence_chunk": "<beans> \u00a0  <!--enable processing of annotations such as @Autowired and @Configuration --> \u00a0  <context:annotation-config/> \u00a0  <context:property-placeholder location=\"classpath:/com/acme/jdbc.properties\"/> \u00a0  <bean class=\"com.acme. AppConfig\"/> \u00a0  <bean class=\"org.springframework.jdbc.datasource. DriverManagerDataSource\"> \u00a0    <property name=\"url\" value=\"${jdbc.url}\"/> \u00a0    <property name=\"username\" value=\"${jdbc.username}\"/> \u00a0    <property name=\"password\" value=\"${jdbc.password}\"/> \u00a0  </bean> </beans> The following example shows a possible jdbc.properties file: jdbc.url=jdbc:hsqldb:hsql://localhost/xdb jdbc.username=sa jdbc.password= Java public static void main(String[] args) { \u00a0  ApplicationContext ctx = new ClassPathXmlApplicationContext(\"classpath:/com/acme/system-test-config.xml\"); \u00a0  TransferService transferService = ctx.getBean(TransferService.class); \u00a0  // ... } Kotlin fun main() { \u00a0  val ctx = ClassPathXmlApplicationContext(\"classpath:/com/acme/system-test- config.xml\") \u00a0  val transferService = ctx.getBean<TransferService>() \u00a0  // ... } \uf05a In system-test-config.xml file, the AppConfig <bean/> does not declare an id element. While it would be acceptable to do so, it is unnecessary, given that no other bean ever refers to it, and it is unlikely to be explicitly fetched from the container by name. Similarly, the DataSource bean is only ever autowired by type, so an explicit bean id is not strictly required. Using <context:component-scan/> to pick up @Configuration classes Because @Configuration is meta-annotated with @Component, @Configuration-annotated classes are 181", "chunk_char_count": 1599, "chunk_word_count": 195, "chunk_token_count": 399.75}, {"page_number": 182, "sentence_chunk": "automatically candidates for component scanning. Using the same scenario as described in the previous example, we can redefine system-test-config.xml to take advantage of component- scanning. Note that, in this case, we need not explicitly declare <context:annotation-config/>, because <context:component-scan/> enables the same functionality. The following example shows the modified system-test-config.xml file: <beans> \u00a0  <!--picks up and registers AppConfig as a bean definition --> \u00a0  <context:component-scan base-package=\"com.acme\"/> \u00a0  <context:property-placeholder location=\"classpath:/com/acme/jdbc.properties\"/> \u00a0  <bean class=\"org.springframework.jdbc.datasource. DriverManagerDataSource\"> \u00a0    <property name=\"url\" value=\"${jdbc.url}\"/> \u00a0    <property name=\"username\" value=\"${jdbc.username}\"/> \u00a0    <property name=\"password\" value=\"${jdbc.password}\"/> \u00a0  </bean> </beans> @Configuration Class-centric Use of XML with @ImportResource In applications where @Configuration classes are the primary mechanism for configuring the container, it is still likely necessary to use at least some XML. In these scenarios, you can use @ImportResource and define only as much XML as you need. Doing so achieves a \u201cJava-centric\u201d approach to configuring the container and keeps XML to a bare minimum. The following example (which includes a configuration class, an XML file that defines a bean, a properties file, and the main class) shows how to use the @ImportResource annotation to achieve \u201cJava-centric\u201d configuration that uses XML as needed: Java @Configuration @ImportResource(\"classpath:/com/acme/properties-config.xml\") public class AppConfig { \u00a0  @Value(\"${jdbc.url}\") \u00a0  private String url; \u00a0  @Value(\"${jdbc.username}\") \u00a0  private String username; \u00a0  @Value(\"${jdbc.password}\") \u00a0  private String password; \u00a0  @Bean \u00a0  public DataSource dataSource() { \u00a0    return new DriverManagerDataSource(url, username, password); \u00a0  } } 182", "chunk_char_count": 1935, "chunk_word_count": 257, "chunk_token_count": 483.75}, {"page_number": 183, "sentence_chunk": "Kotlin @Configuration @ImportResource(\"classpath:/com/acme/properties-config.xml\") class AppConfig { \u00a0  @Value(\"\\${jdbc.url}\") \u00a0  private lateinit var url: String \u00a0  @Value(\"\\${jdbc.username}\") \u00a0  private lateinit var username: String \u00a0  @Value(\"\\${jdbc.password}\") \u00a0  private lateinit var password: String \u00a0  @Bean \u00a0  fun dataSource(): DataSource { \u00a0    return DriverManagerDataSource(url, username, password) \u00a0  } } properties-config.xml <beans> \u00a0  <context:property-placeholder location=\"classpath:/com/acme/jdbc.properties\"/> </beans> jdbc.properties jdbc.url=jdbc:hsqldb:hsql://localhost/xdb jdbc.username=sa jdbc.password= Java public static void main(String[] args) { \u00a0  ApplicationContext ctx = new AnnotationConfigApplicationContext(AppConfig.class); \u00a0  TransferService transferService = ctx.getBean(TransferService.class); \u00a0  // ... } 183", "chunk_char_count": 848, "chunk_word_count": 94, "chunk_token_count": 212.0}, {"page_number": 184, "sentence_chunk": "Kotlin import org.springframework.beans.factory.getBean fun main() { \u00a0  val ctx = AnnotationConfigApplicationContext(AppConfig::class.java) \u00a0  val transferService = ctx.getBean<TransferService>() \u00a0  // ... } 2.1.13. Environment Abstraction The Environment interface is an abstraction integrated in the container that models two key aspects of the application environment: profiles and properties. A profile is a named, logical group of bean definitions to be registered with the container only if the given profile is active. Beans may be assigned to a profile whether defined in XML or with annotations. The role of the Environment object with relation to profiles is in determining which profiles (if any) are currently active, and which profiles (if any) should be active by default. Properties play an important role in almost all applications and may originate from a variety of sources: properties files, JVM system properties, system environment variables, JNDI, servlet context parameters, ad-hoc Properties objects, Map objects, and so on. The role of the Environment object with relation to properties is to provide the user with a convenient service interface for configuring property sources and resolving properties from them. Bean Definition Profiles Bean definition profiles provide a mechanism in the core container that allows for registration of different beans in different environments. The word, \u201cenvironment,\u201d can mean different things to different users, and this feature can help with many use cases, including: \u2022 Working against an in-memory datasource in development versus looking up that same datasource from JNDI when in QA or production. \u2022Registering monitoring infrastructure only when deploying an application into a performance environment. \u2022", "chunk_char_count": 1775, "chunk_word_count": 258, "chunk_token_count": 443.75}, {"page_number": 184, "sentence_chunk": "Registering customized implementations of beans for customer A versus customer B deployments. Consider the first use case in a practical application that requires a DataSource. In a test environment, the configuration might resemble the following: 184", "chunk_char_count": 251, "chunk_word_count": 36, "chunk_token_count": 62.75}, {"page_number": 185, "sentence_chunk": "Java @Bean public DataSource dataSource() { \u00a0  return new EmbeddedDatabaseBuilder() \u00a0    .setType(EmbeddedDatabaseType. HSQL) \u00a0    .addScript(\"my-schema.sql\") \u00a0    .addScript(\"my-test-data.sql\") \u00a0    .build(); } Kotlin @Bean fun dataSource(): DataSource { \u00a0  return EmbeddedDatabaseBuilder() \u00a0      .setType(EmbeddedDatabaseType. HSQL) \u00a0      .addScript(\"my-schema.sql\") \u00a0      .addScript(\"my-test-data.sql\") \u00a0      .build() } Now consider how this application can be deployed into a QA or production environment, assuming that the datasource for the application is registered with the production application server\u2019s JNDI directory. Our dataSource bean now looks like the following listing: Java @Bean(destroyMethod=\"\") public DataSource dataSource() throws Exception { \u00a0  Context ctx = new InitialContext(); \u00a0  return (DataSource) ctx.lookup(\"java:comp/env/jdbc/datasource\"); } Kotlin @Bean(destroyMethod = \"\") fun dataSource(): DataSource { \u00a0  val ctx = InitialContext() \u00a0  return ctx.lookup(\"java:comp/env/jdbc/datasource\") as DataSource } The problem is how to switch between using these two variations based on the current environment. Over time, Spring users have devised a number of ways to get this done, usually relying on a combination of system environment variables and XML <import/> statements containing ${placeholder} tokens that resolve to the correct configuration file path depending on the value of an environment variable. Bean definition profiles is a core container feature that provides a solution to this problem.185", "chunk_char_count": 1541, "chunk_word_count": 231, "chunk_token_count": 385.25}, {"page_number": 186, "sentence_chunk": "If we generalize the use case shown in the preceding example of environment-specific bean definitions, we end up with the need to register certain bean definitions in certain contexts but not in others. You could say that you want to register a certain profile of bean definitions in situation A and a different profile in situation B. We start by updating our configuration to reflect this need. Using @Profile The @Profile annotation lets you indicate that a component is eligible for registration when one or more specified profiles are active. Using our preceding example, we can rewrite the dataSource configuration as follows: Java @Configuration @Profile(\"development\") public class StandaloneDataConfig { \u00a0  @Bean \u00a0  public DataSource dataSource() { \u00a0    return new EmbeddedDatabaseBuilder() \u00a0      .setType(EmbeddedDatabaseType. HSQL) \u00a0      .addScript(\"classpath:com/bank/config/sql/schema.sql\") \u00a0      .addScript(\"classpath:com/bank/config/sql/test-data.sql\") \u00a0      .build(); \u00a0  } } Kotlin @Configuration @Profile(\"development\") class StandaloneDataConfig { \u00a0  @Bean \u00a0  fun dataSource(): DataSource { \u00a0    return EmbeddedDatabaseBuilder() \u00a0        .setType(EmbeddedDatabaseType. HSQL) \u00a0        .addScript(\"classpath:com/bank/config/sql/schema.sql\") \u00a0        .addScript(\"classpath:com/bank/config/sql/test-data.sql\") \u00a0        .build() \u00a0  } } 186", "chunk_char_count": 1356, "chunk_word_count": 221, "chunk_token_count": 339.0}, {"page_number": 187, "sentence_chunk": "Java @Configuration @Profile(\"production\") public class JndiDataConfig { \u00a0  @Bean(destroyMethod=\"\") \u00a0  public DataSource dataSource() throws Exception { \u00a0    Context ctx = new InitialContext(); \u00a0    return (DataSource) ctx.lookup(\"java:comp/env/jdbc/datasource\"); \u00a0  } } Kotlin @Configuration @Profile(\"production\") class JndiDataConfig { \u00a0  @Bean(destroyMethod = \"\") \u00a0  fun dataSource(): DataSource { \u00a0    val ctx = InitialContext() \u00a0    return ctx.lookup(\"java:comp/env/jdbc/datasource\") as DataSource \u00a0  } } \uf05a As mentioned earlier, with @Bean methods, you typically choose to use programmatic JNDI lookups, by using either Spring\u2019s JndiTemplate /JndiLocatorDelegate helpers or the straight JNDI InitialContext usage shown earlier but not the JndiObjectFactoryBean variant, which would force you to declare the return type as the FactoryBean type. The profile string may contain a simple profile name (for example, production) or a profile expression. A profile expression allows for more complicated profile logic to be expressed (for example, production & us-east). The following operators are supported in profile expressions: \u2022 !:A logical \u201cnot\u201d of the profile \u2022 &: A logical \u201cand\u201d of the profiles \u2022 |: A logical \u201cor\u201d of the profiles \uf05a You cannot mix the & and | operators without using parentheses. For example, production & us-east | eu-central is not a valid expression. It must be expressed as production & (us-east | eu-central). You can use @Profile as a meta-annotation for the purpose of creating a custom composed annotation. The following example defines a custom @Production annotation that you can use as a drop-in replacement for @Profile(\"production\"): 187", "chunk_char_count": 1676, "chunk_word_count": 256, "chunk_token_count": 419.0}, {"page_number": 188, "sentence_chunk": "Java @Target(ElementType. TYPE) @Retention(RetentionPolicy. RUNTIME) @Profile(\"production\") public @interface Production { } Kotlin @Target(AnnotationTarget. CLASS) @Retention(AnnotationRetention. RUNTIME) @Profile(\"production\") annotation class Production \uf0eb If a @Configuration class is marked with @Profile, all of the @Bean methods and @Import annotations associated with that class are bypassed unless one or more of the specified profiles are active. If a @Component or @Configuration class is marked with @Profile({\"p1\", \"p2\"}), that class is not registered or processed unless profiles 'p1' or 'p2' have been activated. If a given profile is prefixed with the NOT operator (!),the annotated element is registered only if the profile is not active. For example, given @Profile({\"p1\", \"!p2\"}), registration will occur if profile 'p1' is active or if profile 'p2' is not active.", "chunk_char_count": 882, "chunk_word_count": 121, "chunk_token_count": 220.5}, {"page_number": 188, "sentence_chunk": "@Profile can also be declared at the method level to include only one particular bean of a configuration class (for example, for alternative variants of a particular bean), as the following example shows: 188", "chunk_char_count": 208, "chunk_word_count": 34, "chunk_token_count": 52.0}, {"page_number": 189, "sentence_chunk": "Java @Configuration public class AppConfig { \u00a0  @Bean(\"dataSource\") \u00a0  @Profile(\"development\") \u2460 \u00a0  public DataSource standaloneDataSource() { \u00a0    return new EmbeddedDatabaseBuilder() \u00a0      .setType(EmbeddedDatabaseType. HSQL) \u00a0      .addScript(\"classpath:com/bank/config/sql/schema.sql\") \u00a0      .addScript(\"classpath:com/bank/config/sql/test-data.sql\") \u00a0      .build(); \u00a0  } \u00a0  @Bean(\"dataSource\") \u00a0  @Profile(\"production\") \u2461 \u00a0  public DataSource jndiDataSource() throws Exception { \u00a0    Context ctx = new InitialContext(); \u00a0    return (DataSource) ctx.lookup(\"java:comp/env/jdbc/datasource\"); \u00a0  } } \u2460 The standaloneDataSource method is available only in the development profile.\u2461 The jndiDataSource method is available only in the production profile. Kotlin @Configuration class AppConfig { \u00a0  @Bean(\"dataSource\") \u00a0  @Profile(\"development\") \u2460 \u00a0  fun standaloneDataSource(): DataSource { \u00a0    return EmbeddedDatabaseBuilder() \u00a0        .setType(EmbeddedDatabaseType. HSQL) \u00a0        .addScript(\"classpath:com/bank/config/sql/schema.sql\") \u00a0        .addScript(\"classpath:com/bank/config/sql/test-data.sql\") \u00a0        .build() \u00a0  } \u00a0  @Bean(\"dataSource\") \u00a0  @Profile(\"production\") \u2461 \u00a0  fun jndiDataSource() = \u00a0    InitialContext().lookup(\"java:comp/env/jdbc/datasource\") as DataSource } \u2460 The standaloneDataSource method is available only in the development profile.\u2461 The jndiDataSource method is available only in the production profile.189", "chunk_char_count": 1439, "chunk_word_count": 219, "chunk_token_count": 359.75}, {"page_number": 190, "sentence_chunk": "\uf05a With @Profile on @Bean methods, a special scenario may apply: In the case of overloaded @Bean methods of the same Java method name (analogous to constructor overloading), a @Profile condition needs to be consistently declared on all overloaded methods. If the conditions are inconsistent, only the condition on the first declaration among the overloaded methods matters. Therefore, @Profile can not be used to select an overloaded method with a particular argument signature over another. Resolution between all factory methods for the same bean follows Spring\u2019s constructor resolution algorithm at creation time. If you want to define alternative beans with different profile conditions, use distinct Java method names that point to the same bean name by using the @Bean name attribute, as shown in the preceding example. If the argument signatures are all the same (for example, all of the variants have no-arg factory methods), this is the only way to represent such an arrangement in a valid Java class in the first place (since there can only be one method of a particular name and argument signature). XML Bean Definition Profiles The XML counterpart is the profile attribute of the <beans> element. Our preceding sample configuration can be rewritten in two XML files, as follows: <beans profile=\"development\" \u00a0  xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\" \u00a0  xsi:schemaLocation=\"...\"> \u00a0  <jdbc:embedded-database id=\"dataSource\"> \u00a0    <jdbc:script location=\"classpath:com/bank/config/sql/schema.sql\"/> \u00a0    <jdbc:script location=\"classpath:com/bank/config/sql/test-data.sql\"/> \u00a0  </jdbc:embedded-database> </beans> <beans profile=\"production\" \u00a0  xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:jee=\"http://www.springframework.org/schema/jee\" \u00a0  xsi:schemaLocation=\"...\"> \u00a0  <jee:jndi-lookup id=\"dataSource\" jndi-name=\"java:comp/env/jdbc/datasource\"/> </beans> It is also possible to avoid that split and nest <beans/> elements within the same file, as the following example shows: 190", "chunk_char_count": 2187, "chunk_word_count": 282, "chunk_token_count": 546.75}, {"page_number": 191, "sentence_chunk": "<beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\" \u00a0  xmlns:jee=\"http://www.springframework.org/schema/jee\" \u00a0  xsi:schemaLocation=\"...\"> \u00a0  <!--other bean definitions --> \u00a0  <beans profile=\"development\"> \u00a0    <jdbc:embedded-database id=\"dataSource\"> \u00a0      <jdbc:script location=\"classpath:com/bank/config/sql/schema.sql\"/> \u00a0      <jdbc:script location=\"classpath:com/bank/config/sql/test-data.sql\"/> \u00a0    </jdbc:embedded-database> \u00a0  </beans> \u00a0  <beans profile=\"production\"> \u00a0    <jee:jndi-lookup id=\"dataSource\" jndi-name=\"java:comp/env/jdbc/datasource\"/> \u00a0  </beans> </beans> The spring-bean.xsd has been constrained to allow such elements only as the last ones in the file. This should help provide flexibility without incurring clutter in the XML files.\uf05a The XML counterpart does not support the profile expressions described earlier. It is possible, however, to negate a profile by using the !operator. It is also possible to apply a logical \u201cand\u201d by nesting the profiles, as the following example shows: <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\" \u00a0  xmlns:jee=\"http://www.springframework.org/schema/jee\" \u00a0  xsi:schemaLocation=\"...\"> \u00a0  <!--other bean definitions --> \u00a0  <beans profile=\"production\"> \u00a0    <beans profile=\"us-east\"> \u00a0      <jee:jndi-lookup id=\"dataSource\" jndi- name=\"java:comp/env/jdbc/datasource\"/> \u00a0    </beans> \u00a0  </beans> </beans> In the preceding example, the dataSource bean is exposed if both the production and us-east profiles are active.191", "chunk_char_count": 1728, "chunk_word_count": 206, "chunk_token_count": 432.0}, {"page_number": 192, "sentence_chunk": "Activating a Profile Now that we have updated our configuration, we still need to instruct Spring which profile is active. If we started our sample application right now, we would see a NoSuchBeanDefinitionException thrown, because the container could not find the Spring bean named dataSource. Activating a profile can be done in several ways, but the most straightforward is to do it programmatically against the Environment API which is available through an ApplicationContext. The following example shows how to do so: Java AnnotationConfigApplicationContext ctx = new AnnotationConfigApplicationContext(); ctx.getEnvironment().setActiveProfiles(\"development\"); ctx.register(SomeConfig.class, StandaloneDataConfig.class, JndiDataConfig.class); ctx.refresh(); Kotlin val ctx = AnnotationConfigApplicationContext().apply { \u00a0  environment.setActiveProfiles(\"development\") \u00a0  register(SomeConfig::class.java, StandaloneDataConfig::class.java, JndiDataConfig::class.java) \u00a0  refresh() } In addition, you can also declaratively activate profiles through the spring.profiles.active property, which may be specified through system environment variables, JVM system properties, servlet context parameters in web.xml, or even as an entry in JNDI (see PropertySource Abstraction). In integration tests, active profiles can be declared by using the @ActiveProfiles annotation in the spring-test module (see context configuration with environment profiles). Note that profiles are not an \u201ceither-or\u201d proposition. You can activate multiple profiles at once. Programmatically, you can provide multiple profile names to the setActiveProfiles() method, which accepts String\u2026 varargs. The following example activates multiple profiles: Java ctx.getEnvironment().setActiveProfiles(\"profile1\", \"profile2\"); Kotlin ctx.getEnvironment().setActiveProfiles(\"profile1\", \"profile2\") Declaratively, spring.profiles.active may accept a comma-separated list of profile names, as the following example shows: 192", "chunk_char_count": 1986, "chunk_word_count": 229, "chunk_token_count": 496.5}, {"page_number": 193, "sentence_chunk": "-Dspring.profiles.active=\"profile1,profile2\" Default Profile The default profile represents the profile that is enabled by default. Consider the following example: Java @Configuration @Profile(\"default\") public class DefaultDataConfig { \u00a0  @Bean \u00a0  public DataSource dataSource() { \u00a0    return new EmbeddedDatabaseBuilder() \u00a0      .setType(EmbeddedDatabaseType. HSQL) \u00a0      .addScript(\"classpath:com/bank/config/sql/schema.sql\") \u00a0      .build(); \u00a0  } } Kotlin @Configuration @Profile(\"default\") class DefaultDataConfig { \u00a0  @Bean \u00a0  fun dataSource(): DataSource { \u00a0    return EmbeddedDatabaseBuilder() \u00a0        .setType(EmbeddedDatabaseType. HSQL) \u00a0        .addScript(\"classpath:com/bank/config/sql/schema.sql\") \u00a0        .build() \u00a0  } } If no profile is active, the dataSource is created. You can see this as a way to provide a default definition for one or more beans. If any profile is enabled, the default profile does not apply. You can change the name of the default profile by using setDefaultProfiles() on the Environment or, declaratively, by using the spring.profiles.default property. PropertySource Abstraction Spring\u2019s Environment abstraction provides search operations over a configurable hierarchy of property sources. Consider the following listing: 193", "chunk_char_count": 1269, "chunk_word_count": 199, "chunk_token_count": 317.25}, {"page_number": 194, "sentence_chunk": "Java ApplicationContext ctx = new GenericApplicationContext(); Environment env = ctx.getEnvironment(); boolean containsMyProperty = env.containsProperty(\"my-property\"); System.out.println(\"Does my environment contain the 'my-property' property? \"+ containsMyProperty); Kotlin val ctx = GenericApplicationContext() val env = ctx.environment val containsMyProperty = env.containsProperty(\"my-property\") println(\"Does my environment contain the 'my-property' property?$containsMyProperty\") In the preceding snippet, we see a high-level way of asking Spring whether the my-property property is defined for the current environment. To answer this question, the Environment object performs a search over a set of PropertySource objects. A PropertySource is a simple abstraction over any source of key-value pairs, and Spring\u2019s StandardEnvironment is configured with two PropertySource objects\u2009\u2014\u2009one representing the set of JVM system properties (System.getProperties()) and one representing the set of system environment variables (System.getenv()).\uf05a These default property sources are present for StandardEnvironment, for use in standalone applications. StandardServletEnvironment is populated with additional default property sources including servlet config, servlet context parameters, and a JndiPropertySource if JNDI is available. Concretely, when you use the StandardEnvironment, the call to env.containsProperty(\"my-property\") returns true if a my-property system property or my-property environment variable is present at runtime.194", "chunk_char_count": 1536, "chunk_word_count": 179, "chunk_token_count": 384.0}, {"page_number": 195, "sentence_chunk": "\uf0eb The search performed is hierarchical. By default, system properties have precedence over environment variables. So, if the my-property property happens to be set in both places during a call to env.getProperty(\"my-property\"), the system property value \u201cwins\u201d and is returned. Note that property values are not merged but rather completely overridden by a preceding entry. For a common StandardServletEnvironment, the full hierarchy is as follows, with the highest-precedence entries at the top: 1. ServletConfig parameters (if applicable\u2009\u2014\u2009for example, in case of a DispatcherServlet context) 2. ServletContext parameters (web.xml context-param entries) 3. JNDI environment variables (java:comp/env/ entries) 4. JVM system properties (-D command-line arguments) 5. JVM system environment (operating system environment variables) Most importantly, the entire mechanism is configurable.", "chunk_char_count": 886, "chunk_word_count": 118, "chunk_token_count": 221.5}, {"page_number": 195, "sentence_chunk": "Perhaps you have a custom source of properties that you want to integrate into this search. To do so, implement and instantiate your own PropertySource and add it to the set of PropertySources for the current Environment. The following example shows how to do so: Java ConfigurableApplicationContext ctx = new GenericApplicationContext(); MutablePropertySources sources = ctx.getEnvironment().getPropertySources(); sources.addFirst(new MyPropertySource()); Kotlin val ctx = GenericApplicationContext() val sources = ctx.environment.propertySources sources.addFirst(MyPropertySource()) In the preceding code, MyPropertySource has been added with highest precedence in the search. If it contains a my-property property, the property is detected and returned, in favor of any my-property property in any other PropertySource. The MutablePropertySources API exposes a number of methods that allow for precise manipulation of the set of property sources. Using @PropertySource The @PropertySource annotation provides a convenient and declarative mechanism for adding a PropertySource to Spring\u2019s Environment. Given a file called app.properties that contains the key-value pair testbean.name=myTestBean, the following @Configuration class uses @PropertySource in such a way that a call to testBean.getName() returns myTestBean: 195", "chunk_char_count": 1325, "chunk_word_count": 169, "chunk_token_count": 331.25}, {"page_number": 196, "sentence_chunk": "Java @Configuration @PropertySource(\"classpath:/com/myco/app.properties\") public class AppConfig { \u00a0  @Autowired \u00a0  Environment env; \u00a0  @Bean \u00a0  public TestBean testBean() { \u00a0    TestBean testBean = new TestBean(); \u00a0    testBean.setName(env.getProperty(\"testbean.name\")); \u00a0    return testBean; \u00a0  } } Kotlin @Configuration @PropertySource(\"classpath:/com/myco/app.properties\") class AppConfig { \u00a0  @Autowired \u00a0  private lateinit var env: Environment \u00a0  @Bean \u00a0  fun testBean() = TestBean().apply { \u00a0    name = env.getProperty(\"testbean.name\")!!\u00a0  } } Any ${\u2026} placeholders present in a @PropertySource resource location are resolved against the set of property sources already registered against the environment, as the following example shows: 196", "chunk_char_count": 748, "chunk_word_count": 111, "chunk_token_count": 187.0}, {"page_number": 197, "sentence_chunk": "Java @Configuration @PropertySource(\"classpath:/com/${my.placeholder:default/path}/app.properties\") public class AppConfig { \u00a0  @Autowired \u00a0  Environment env; \u00a0  @Bean \u00a0  public TestBean testBean() { \u00a0    TestBean testBean = new TestBean(); \u00a0    testBean.setName(env.getProperty(\"testbean.name\")); \u00a0    return testBean; \u00a0  } } Kotlin @Configuration @PropertySource(\"classpath:/com/\\${my.placeholder:default/path}/app.properties\") class AppConfig { \u00a0  @Autowired \u00a0  private lateinit var env: Environment \u00a0  @Bean \u00a0  fun testBean() = TestBean().apply { \u00a0    name = env.getProperty(\"testbean.name\")!!\u00a0  } } Assuming that my.placeholder is present in one of the property sources already registered (for example, system properties or environment variables), the placeholder is resolved to the corresponding value. If not, then default/path is used as a default. If no default is specified and a property cannot be resolved, an IllegalArgumentException is thrown.\uf05a The @PropertySource annotation is repeatable, according to Java 8 conventions. However, all such @PropertySource annotations need to be declared at the same level, either directly on the configuration class or as meta-annotations within the same custom annotation. Mixing direct annotations and meta-annotations is not recommended, since direct annotations effectively override meta-annotations. Placeholder Resolution in Statements Historically, the value of placeholders in elements could be resolved only against JVM system properties or environment variables. This is no longer the case. Because the Environment abstraction is integrated throughout the container, it is easy to route resolution of placeholders through it.", "chunk_char_count": 1685, "chunk_word_count": 233, "chunk_token_count": 421.25}, {"page_number": 198, "sentence_chunk": "precedence of searching through system properties and environment variables or remove them entirely. You can also add your own property sources to the mix, as appropriate. Concretely, the following statement works regardless of where the customer property is defined, as long as it is available in the Environment: <beans> \u00a0  <import resource=\"com/bank/service/${customer}-config.xml\"/> </beans> 2.1.14. Registering a LoadTimeWeaver The LoadTimeWeaver is used by Spring to dynamically transform classes as they are loaded into the Java virtual machine (JVM). To enable load-time weaving, you can add the @EnableLoadTimeWeaving to one of your @Configuration classes, as the following example shows: Java @Configuration @EnableLoadTimeWeaving public class AppConfig { } Kotlin @Configuration @EnableLoadTimeWeaving class AppConfig Alternatively, for XML configuration, you can use the context:load-time-weaver element: <beans> \u00a0  <context:load-time-weaver/> </beans> Once configured for the ApplicationContext, any bean within that ApplicationContext may implement LoadTimeWeaverAware, thereby receiving a reference to the load-time weaver instance. This is particularly useful in combination with Spring\u2019s JPA support where load-time weaving may be necessary for JPA class transformation. Consult the LocalContainerEntityManagerFactoryBean javadoc for more detail. For more on AspectJ load-time weaving, see Load-time Weaving with AspectJ in the Spring Framework.198", "chunk_char_count": 1465, "chunk_word_count": 190, "chunk_token_count": 366.25}, {"page_number": 199, "sentence_chunk": "2.1.15. Additional Capabilities of the ApplicationContext As discussed in the chapter introduction, the org.springframework.beans.factory package provides basic functionality for managing and manipulating beans, including in a programmatic way. The org.springframework.context package adds the ApplicationContext interface, which extends the BeanFactory interface, in addition to extending other interfaces to provide additional functionality in a more application framework-oriented style. Many people use the ApplicationContext in a completely declarative fashion, not even creating it programmatically, but instead relying on support classes such as ContextLoader to automatically instantiate an ApplicationContext as part of the normal startup process of a Jakarta EE web application. To enhance BeanFactory functionality in a more framework-oriented style, the context package also provides the following functionality: \u2022 Access to messages in i18n-style, through the MessageSource interface. \u2022Access to resources, such as URLs and files, through the ResourceLoader interface. \u2022Event publication, namely to beans that implement the ApplicationListener interface, through the use of the ApplicationEventPublisher interface. \u2022Loading of multiple (hierarchical) contexts, letting each be focused on one particular layer, such as the web layer of an application, through the HierarchicalBeanFactory interface. Internationalization using MessageSource The ApplicationContext interface extends an interface called MessageSource and, therefore, provides internationalization (\u201ci18n\u201d) functionality. Spring also provides the HierarchicalMessageSource interface, which can resolve messages hierarchically.", "chunk_char_count": 1701, "chunk_word_count": 207, "chunk_token_count": 425.25}, {"page_number": 199, "sentence_chunk": "Together, these interfaces provide the foundation upon which Spring effects message resolution. The methods defined on these interfaces include: \u2022 String getMessage(String code, Object[] args, String default, Locale loc): The basic method used to retrieve a message from the MessageSource. When no message is found for the specified locale, the default message is used. Any arguments passed in become replacement values, using the MessageFormat functionality provided by the standard library. \u2022String getMessage(String code, Object[] args, Locale loc): Essentially the same as the previous method but with one difference: No default message can be specified. If the message cannot be found, a NoSuchMessageException is thrown. \u2022String getMessage(MessageSourceResolvable resolvable, Locale locale): All properties used in the preceding methods are also wrapped in a class named MessageSourceResolvable, which you can use with this method. When an ApplicationContext is loaded, it automatically searches for a MessageSource bean defined in the context. The bean must have the name messageSource. If such a bean is found, all calls to the preceding methods are delegated to the message source.", "chunk_char_count": 1190, "chunk_word_count": 172, "chunk_token_count": 297.5}, {"page_number": 199, "sentence_chunk": "If no message source is found, the ApplicationContext attempts to find a parent containing a bean with the same name. If it does, it uses that bean as the MessageSource. If the ApplicationContext cannot find any source for messages, an empty DelegatingMessageSource is instantiated in order to be able to accept calls to the methods defined above.199", "chunk_char_count": 350, "chunk_word_count": 57, "chunk_token_count": 87.5}, {"page_number": 200, "sentence_chunk": "Spring provides three MessageSource implementations, ResourceBundleMessageSource, ReloadableResourceBundleMessageSource and StaticMessageSource. All of them implement HierarchicalMessageSource in order to do nested messaging. The StaticMessageSource is rarely used but provides programmatic ways to add messages to the source. The following example shows ResourceBundleMessageSource: <beans> \u00a0  <bean id=\"messageSource\" \u00a0      class=\"org.springframework.context.support. ResourceBundleMessageSource\"> \u00a0    <property name=\"basenames\"> \u00a0      <list> \u00a0        <value>format</value> \u00a0        <value>exceptions</value> \u00a0        <value>windows</value> \u00a0      </list> \u00a0    </property> \u00a0  </bean> </beans> The example assumes that you have three resource bundles called format, exceptions and windows defined in your classpath. Any request to resolve a message is handled in the JDK-standard way of resolving messages through ResourceBundle objects. For the purposes of the example, assume the contents of two of the above resource bundle files are as follows: \u00a0  # in format.properties \u00a0  message=Alligators rock!\u00a0  # in exceptions.properties \u00a0  argument.required=The {0} argument is required. The next example shows a program to run the MessageSource functionality. Remember that all ApplicationContext implementations are also MessageSource implementations and so can be cast to the MessageSource interface.", "chunk_char_count": 1402, "chunk_word_count": 214, "chunk_token_count": 350.5}, {"page_number": 200, "sentence_chunk": "Java public static void main(String[] args) { \u00a0  MessageSource resources = new ClassPathXmlApplicationContext(\"beans.xml\"); \u00a0  String message = resources.getMessage(\"message\", null, \"Default\", Locale. ENGLISH); \u00a0  System.out.println(message); } 200", "chunk_char_count": 248, "chunk_word_count": 29, "chunk_token_count": 62.0}, {"page_number": 201, "sentence_chunk": "Kotlin fun main() { \u00a0  val resources = ClassPathXmlApplicationContext(\"beans.xml\") \u00a0  val message = resources.getMessage(\"message\", null, \"Default\", Locale. ENGLISH) \u00a0  println(message) } The resulting output from the above program is as follows: Alligators rock!To summarize, the MessageSource is defined in a file called beans.xml, which exists at the root of your classpath. The messageSource bean definition refers to a number of resource bundles through its basenames property. The three files that are passed in the list to the basenames property exist as files at the root of your classpath and are called format.properties, exceptions.properties, and windows.properties, respectively. The next example shows arguments passed to the message lookup. These arguments are converted into String objects and inserted into placeholders in the lookup message.<beans> \u00a0  <!--this MessageSource is being used in a web application --> \u00a0  <bean id=\"messageSource\" class=\"org.springframework.context.support. ResourceBundleMessageSource\"> \u00a0    <property name=\"basename\" value=\"exceptions\"/> \u00a0  </bean> \u00a0  <!--", "chunk_char_count": 1104, "chunk_word_count": 155, "chunk_token_count": 276.0}, {"page_number": 201, "sentence_chunk": "lets inject the above MessageSource into this POJO --> \u00a0  <bean id=\"example\" class=\"com.something. Example\"> \u00a0    <property name=\"messages\" ref=\"messageSource\"/> \u00a0  </bean> </beans> 201", "chunk_char_count": 185, "chunk_word_count": 27, "chunk_token_count": 46.25}, {"page_number": 202, "sentence_chunk": "Java public class Example { \u00a0  private MessageSource messages; \u00a0  public void setMessages(MessageSource messages) { \u00a0    this.messages = messages; \u00a0  } \u00a0  public void execute() { \u00a0    String message = this.messages.getMessage(\"argument.required\", \u00a0      new Object [] {\"userDao\"}, \"Required\", Locale. ENGLISH); \u00a0    System.out.println(message); \u00a0  } } Kotlin \u00a0  class Example { \u00a0  lateinit var messages: MessageSource \u00a0  fun execute() { \u00a0    val message = messages.getMessage(\"argument.required\", \u00a0        arrayOf(\"userDao\"), \"Required\", Locale. ENGLISH) \u00a0    println(message) \u00a0  } } The resulting output from the invocation of the execute() method is as follows: The userDao argument is required. With regard to internationalization (\u201ci18n\u201d), Spring\u2019s various MessageSource implementations follow the same locale resolution and fallback rules as the standard JDK ResourceBundle. In short, and continuing with the example messageSource defined previously, if you want to resolve messages against the British (en-GB) locale, you would create files called format_en_GB.properties, exceptions_en_GB.properties, and windows_en_GB.properties, respectively. Typically, locale resolution is managed by the surrounding environment of the application. In the following example, the locale against which (British) messages are resolved is specified manually: # in exceptions_en_GB.properties argument.required=Ebagum lad, the ''{0}'' argument is required, I say, required.202", "chunk_char_count": 1465, "chunk_word_count": 220, "chunk_token_count": 366.25}, {"page_number": 203, "sentence_chunk": "Java public static void main(final String[] args) { \u00a0  MessageSource resources = new ClassPathXmlApplicationContext(\"beans.xml\"); \u00a0  String message = resources.getMessage(\"argument.required\", \u00a0    new Object [] {\"userDao\"}, \"Required\", Locale. UK); \u00a0  System.out.println(message); } Kotlin fun main() { \u00a0  val resources = ClassPathXmlApplicationContext(\"beans.xml\") \u00a0  val message = resources.getMessage(\"argument.required\", \u00a0      arrayOf(\"userDao\"), \"Required\", Locale. UK) \u00a0  println(message) } The resulting output from the running of the above program is as follows: Ebagum lad, the 'userDao' argument is required, I say, required. You can also use the MessageSourceAware interface to acquire a reference to any MessageSource that has been defined. Any bean that is defined in an ApplicationContext that implements the MessageSourceAware interface is injected with the application context\u2019s MessageSource when the bean is created and configured.\uf05a Because Spring\u2019s MessageSource is based on Java\u2019s ResourceBundle, it does not merge bundles with the same base name, but will only use the first bundle found. Subsequent message bundles with the same base name are ignored.\uf05a As an alternative to ResourceBundleMessageSource, Spring provides a ReloadableResourceBundleMessageSource class. This variant supports the same bundle file format but is more flexible than the standard JDK based ResourceBundleMessageSource implementation. In particular, it allows for reading files from any Spring resource location (not only from the classpath) and supports hot reloading of bundle property files (while efficiently caching them in between).", "chunk_char_count": 1635, "chunk_word_count": 230, "chunk_token_count": 408.75}, {"page_number": 203, "sentence_chunk": "See the ReloadableResourceBundleMessageSource javadoc for details. Standard and Custom Events Event handling in the ApplicationContext is provided through the ApplicationEvent class and the ApplicationListener interface. If a bean that implements the ApplicationListener interface is deployed into the context, every time an ApplicationEvent gets published to the ApplicationContext, that bean is notified. Essentially, this is the standard Observer design pattern.203", "chunk_char_count": 468, "chunk_word_count": 59, "chunk_token_count": 117.0}, {"page_number": 204, "sentence_chunk": "\uf0eb As of Spring 4.2, the event infrastructure has been significantly improved and offers an annotation-based model as well as the ability to publish any arbitrary event (that is, an object that does not necessarily extend from ApplicationEvent). When such an object is published, we wrap it in an event for you. The following table describes the standard events that Spring provides: Table 7. Built-in Events Event Explanation ContextRefreshedEvent Published when the ApplicationContext is initialized or refreshed (for example, by using the refresh() method on the ConfigurableApplicationContext interface). Here, \u201cinitialized\u201d means that all beans are loaded, post-processor beans are detected and activated, singletons are pre-instantiated, and the ApplicationContext object is ready for use. As long as the context has not been closed, a refresh can be triggered multiple times, provided that the chosen ApplicationContext actually supports such \u201chot\u201d refreshes. For example, XmlWebApplicationContext supports hot refreshes, but GenericApplicationContext does not. ContextStartedEvent Published when the ApplicationContext is started by using the start() method on the ConfigurableApplicationContext interface. Here, \u201cstarted\u201d means that all Lifecycle beans receive an explicit start signal. Typically, this signal is used to restart beans after an explicit stop, but it may also be used to start components that have not been configured for autostart (for example, components that have not already started on initialization).", "chunk_char_count": 1529, "chunk_word_count": 215, "chunk_token_count": 382.25}, {"page_number": 204, "sentence_chunk": "ContextStoppedEvent Published when the ApplicationContext is stopped by using the stop() method on the ConfigurableApplicationContext interface. Here, \u201cstopped\u201d means that all Lifecycle beans receive an explicit stop signal. A stopped context may be restarted through a start() call. ContextClosedEvent Published when the ApplicationContext is being closed by using the close() method on the ConfigurableApplicationContext interface or via a JVM shutdown hook. Here, \"closed\" means that all singleton beans will be destroyed. Once the context is closed, it reaches its end of life and cannot be refreshed or restarted. RequestHandledEvent A web-specific event telling all beans that an HTTP request has been serviced. This event is published after the request is complete. This event is only applicable to web applications that use Spring\u2019s DispatcherServlet. ServletRequestHandledEvent A subclass of RequestHandledEvent that adds Servlet-specific context information.", "chunk_char_count": 968, "chunk_word_count": 133, "chunk_token_count": 242.0}, {"page_number": 204, "sentence_chunk": "You can also create and publish your own custom events. The following example shows a simple class that extends Spring\u2019s ApplicationEvent base class: 204", "chunk_char_count": 153, "chunk_word_count": 24, "chunk_token_count": 38.25}, {"page_number": 205, "sentence_chunk": "Java public class BlockedListEvent extends ApplicationEvent { \u00a0  private final String address; \u00a0  private final String content; \u00a0  public BlockedListEvent(Object source, String address, String content) { \u00a0    super(source); \u00a0    this.address = address; \u00a0    this.content = content; \u00a0  } \u00a0  // accessor and other methods... } Kotlin class BlockedListEvent(source: Any, \u00a0          val address: String, \u00a0          val content: String) : ApplicationEvent(source) To publish a custom ApplicationEvent, call the publishEvent() method on an ApplicationEventPublisher. Typically, this is done by creating a class that implements ApplicationEventPublisherAware and registering it as a Spring bean. The following example shows such a class: 205", "chunk_char_count": 734, "chunk_word_count": 129, "chunk_token_count": 183.5}, {"page_number": 206, "sentence_chunk": "Java public class EmailService implements ApplicationEventPublisherAware { \u00a0  private List<String> blockedList; \u00a0  private ApplicationEventPublisher publisher; \u00a0  public void setBlockedList(List<String> blockedList) { \u00a0    this.blockedList = blockedList; \u00a0  } \u00a0  public void setApplicationEventPublisher(ApplicationEventPublisher publisher) { \u00a0    this.publisher = publisher; \u00a0  } \u00a0  public void sendEmail(String address, String content) { \u00a0    if (blockedList.contains(address)) { \u00a0      publisher.publishEvent(new BlockedListEvent(this, address, content)); \u00a0      return; \u00a0    } \u00a0    // send email... \u00a0  } } Kotlin class EmailService : ApplicationEventPublisherAware { \u00a0  private lateinit var blockedList: List<String> \u00a0  private lateinit var publisher: ApplicationEventPublisher \u00a0  fun setBlockedList(blockedList: List<String>) { \u00a0    this.blockedList = blockedList \u00a0  } \u00a0  override fun setApplicationEventPublisher(publisher: ApplicationEventPublisher) { \u00a0    this.publisher = publisher \u00a0  } \u00a0  fun sendEmail(address: String, content: String) { \u00a0    if (blockedList!!.contains(address)) { \u00a0      publisher!!.publishEvent(BlockedListEvent(this, address, content)) \u00a0      return \u00a0    } \u00a0    // send email... \u00a0  } } At configuration time, the Spring container detects that EmailService implements ApplicationEventPublisherAware and automatically calls setApplicationEventPublisher(). In reality, 206", "chunk_char_count": 1400, "chunk_word_count": 218, "chunk_token_count": 350.0}, {"page_number": 207, "sentence_chunk": "the parameter passed in is the Spring container itself. You are interacting with the application context through its ApplicationEventPublisher interface. To receive the custom ApplicationEvent, you can create a class that implements ApplicationListener and register it as a Spring bean. The following example shows such a class: Java public class BlockedListNotifier implements ApplicationListener<BlockedListEvent> { \u00a0  private String notificationAddress; \u00a0  public void setNotificationAddress(String notificationAddress) { \u00a0    this.notificationAddress = notificationAddress; \u00a0  } \u00a0  public void onApplicationEvent(BlockedListEvent event) { \u00a0    // notify appropriate parties via notificationAddress... \u00a0  } } Kotlin class BlockedListNotifier : ApplicationListener<BlockedListEvent> { \u00a0  lateinit var notificationAddress: String \u00a0  override fun onApplicationEvent(event: BlockedListEvent) { \u00a0    // notify appropriate parties via notificationAddress... \u00a0  } } Notice that ApplicationListener is generically parameterized with the type of your custom event (BlockedListEvent in the preceding example). This means that the onApplicationEvent() method can remain type-safe, avoiding any need for downcasting. You can register as many event listeners as you wish, but note that, by default, event listeners receive events synchronously. This means that the publishEvent() method blocks until all listeners have finished processing the event. One advantage of this synchronous and single-threaded approach is that, when a listener receives an event, it operates inside the transaction context of the publisher if a transaction context is available. If another strategy for event publication becomes necessary, see the javadoc for Spring\u2019s ApplicationEventMulticaster interface and SimpleApplicationEventMulticaster implementation for configuration options. The following example shows the bean definitions used to register and configure each of the classes above: 207", "chunk_char_count": 1964, "chunk_word_count": 267, "chunk_token_count": 491.0}, {"page_number": 208, "sentence_chunk": "<bean id=\"emailService\" class=\"example. EmailService\"> \u00a0  <property name=\"blockedList\"> \u00a0    <list> \u00a0      <value>known.spammer@example.org</value> \u00a0      <value>known.hacker@example.org</value> \u00a0      <value>john.doe@example.org</value> \u00a0    </list> \u00a0  </property> </bean> <bean id=\"blockedListNotifier\" class=\"example. BlockedListNotifier\"> \u00a0  <property name=\"notificationAddress\" value=\"blockedlist@example.org\"/> </bean> Putting it all together, when the sendEmail() method of the emailService bean is called, if there are any email messages that should be blocked, a custom event of type BlockedListEvent is published. The blockedListNotifier bean is registered as an ApplicationListener and receives the BlockedListEvent, at which point it can notify appropriate parties.\uf05a Spring\u2019s eventing mechanism is designed for simple communication between Spring beans within the same application context. However, for more sophisticated enterprise integration needs, the separately maintained Spring Integration project provides complete support for building lightweight, pattern- oriented, event-driven architectures that build upon the well-known Spring programming model. Annotation-based Event Listeners You can register an event listener on any method of a managed bean by using the @EventListener annotation. The BlockedListNotifier can be rewritten as follows: Java public class BlockedListNotifier { \u00a0  private String notificationAddress; \u00a0  public void setNotificationAddress(String notificationAddress) { \u00a0    this.notificationAddress = notificationAddress; \u00a0  } \u00a0  @EventListener \u00a0  public void processBlockedListEvent(BlockedListEvent event) { \u00a0    // notify appropriate parties via notificationAddress... \u00a0  } } 208", "chunk_char_count": 1725, "chunk_word_count": 232, "chunk_token_count": 431.25}, {"page_number": 209, "sentence_chunk": "Kotlin class BlockedListNotifier { \u00a0  lateinit var notificationAddress: String \u00a0  @EventListener \u00a0  fun processBlockedListEvent(event: BlockedListEvent) { \u00a0    // notify appropriate parties via notificationAddress... \u00a0  } } The method signature once again declares the event type to which it listens, but, this time, with a flexible name and without implementing a specific listener interface. The event type can also be narrowed through generics as long as the actual event type resolves your generic parameter in its implementation hierarchy. If your method should listen to several events or if you want to define it with no parameter at all, the event types can also be specified on the annotation itself. The following example shows how to do so: Java @EventListener({ContextStartedEvent.class, ContextRefreshedEvent.class}) public void handleContextStart() { \u00a0  // ... } Kotlin @EventListener(ContextStartedEvent::class, ContextRefreshedEvent::class) fun handleContextStart() { \u00a0  // ... } It is also possible to add additional runtime filtering by using the condition attribute of the annotation that defines a SpEL expression, which should match to actually invoke the method for a particular event. The following example shows how our notifier can be rewritten to be invoked only if the content attribute of the event is equal to my-event: Java @EventListener(condition = \"#blEvent.content == 'my-event'\") public void processBlockedListEvent(BlockedListEvent blEvent) { \u00a0  // notify appropriate parties via notificationAddress... } 209", "chunk_char_count": 1544, "chunk_word_count": 226, "chunk_token_count": 386.0}, {"page_number": 210, "sentence_chunk": "Kotlin @EventListener(condition = \"#blEvent.content == 'my-event'\") fun processBlockedListEvent(blEvent: BlockedListEvent) { \u00a0  // notify appropriate parties via notificationAddress... } Each SpEL expression evaluates against a dedicated context. The following table lists the items made available to the context so that you can use them for conditional event processing: Table 8. Event SpEL available metadata Name Location Description Example Event root object The actual ApplicationEvent. #root.event or event Arguments array root object The arguments (as an object array) used to invoke the method. #root.args or args; args[0] to access the first argument, etc. Argument name evaluation context The name of any of the method arguments. If, for some reason, the names are not available (for example, because there is no debug information in the compiled byte code), individual arguments are also available using the #a<#arg> syntax where <#arg> stands for the argument index (starting from 0). #blEvent or #a0 (you can also use #p0 or #p<#arg> parameter notation as an alias) Note that #root.event gives you access to the underlying event, even if your method signature actually refers to an arbitrary object that was published. If you need to publish an event as the result of processing another event, you can change the method signature to return the event that should be published, as the following example shows: Java @EventListener public ListUpdateEvent handleBlockedListEvent(BlockedListEvent event) { \u00a0  // notify appropriate parties via notificationAddress and \u00a0  // then publish a ListUpdateEvent... } 210", "chunk_char_count": 1619, "chunk_word_count": 242, "chunk_token_count": 404.75}, {"page_number": 211, "sentence_chunk": "Kotlin @EventListener fun handleBlockedListEvent(event: BlockedListEvent): ListUpdateEvent { \u00a0  // notify appropriate parties via notificationAddress and \u00a0  // then publish a ListUpdateEvent... } \uf05a This feature is not supported for asynchronous listeners. The handleBlockedListEvent() method publishes a new ListUpdateEvent for every BlockedListEvent that it handles. If you need to publish several events, you can return a Collection or an array of events instead. Asynchronous Listeners If you want a particular listener to process events asynchronously, you can reuse the regular @Async support. The following example shows how to do so: Java @EventListener @Async public void processBlockedListEvent(BlockedListEvent event) { \u00a0  // BlockedListEvent is processed in a separate thread } Kotlin @EventListener @Async fun processBlockedListEvent(event: BlockedListEvent) { \u00a0  // BlockedListEvent is processed in a separate thread } Be aware of the following limitations when using asynchronous events: \u2022 If an asynchronous event listener throws an Exception, it is not propagated to the caller. See AsyncUncaughtExceptionHandler for more details. \u2022Asynchronous event listener methods cannot publish a subsequent event by returning a value. If you need to publish another event as the result of the processing, inject an ApplicationEventPublisher to publish the event manually. Ordering Listeners If you need one listener to be invoked before another one, you can add the @Order annotation to the method declaration, as the following example shows: 211", "chunk_char_count": 1551, "chunk_word_count": 222, "chunk_token_count": 387.75}, {"page_number": 212, "sentence_chunk": "Java @EventListener @Order(42) public void processBlockedListEvent(BlockedListEvent event) { \u00a0  // notify appropriate parties via notificationAddress... } Kotlin @EventListener @Order(42) fun processBlockedListEvent(event: BlockedListEvent) { \u00a0  // notify appropriate parties via notificationAddress... } Generic Events You can also use generics to further define the structure of your event. Consider using an EntityCreatedEvent<T> where T is the type of the actual entity that got created. For example, you can create the following listener definition to receive only EntityCreatedEvent for a Person: Java @EventListener public void onPersonCreated(EntityCreatedEvent<Person> event) { \u00a0  // ... } Kotlin @EventListener fun onPersonCreated(event: EntityCreatedEvent<Person>) { \u00a0  // ... } Due to type erasure, this works only if the event that is fired resolves the generic parameters on which the event listener filters (that is, something like class PersonCreatedEvent extends EntityCreatedEvent<Person> { \u2026 }). In certain circumstances, this may become quite tedious if all events follow the same structure (as should be the case for the event in the preceding example). In such a case, you can implement ResolvableTypeProvider to guide the framework beyond what the runtime environment provides. The following event shows how to do so: 212", "chunk_char_count": 1344, "chunk_word_count": 191, "chunk_token_count": 336.0}, {"page_number": 213, "sentence_chunk": "Java public class EntityCreatedEvent<T> extends ApplicationEvent implements ResolvableTypeProvider { \u00a0  public EntityCreatedEvent(T entity) { \u00a0    super(entity); \u00a0  } \u00a0  @Override \u00a0  public ResolvableType getResolvableType() { \u00a0    return ResolvableType.forClassWithGenerics(getClass(), ResolvableType.forInstance(getSource())); \u00a0  } } Kotlin class EntityCreatedEvent<T>(entity: T) : ApplicationEvent(entity), ResolvableTypeProvider { \u00a0  override fun getResolvableType(): ResolvableType? {\u00a0    return ResolvableType.forClassWithGenerics(javaClass, ResolvableType.forInstance(getSource())) \u00a0  } } \uf0eb This works not only for ApplicationEvent but any arbitrary object that you send as an event. Convenient Access to Low-level Resources For optimal usage and understanding of application contexts, you should familiarize yourself with Spring\u2019s Resource abstraction, as described in Resources. An application context is a ResourceLoader, which can be used to load Resource objects. A Resource is essentially a more feature rich version of the JDK java.net. URL class. In fact, the implementations of the Resource wrap an instance of java.net. URL, where appropriate. A Resource can obtain low-level resources from almost any location in a transparent fashion, including from the classpath, a filesystem location, anywhere describable with a standard URL, and some other variations. If the resource location string is a simple path without any special prefixes, where those resources come from is specific and appropriate to the actual application context type.", "chunk_char_count": 1554, "chunk_word_count": 213, "chunk_token_count": 388.5}, {"page_number": 213, "sentence_chunk": "You can configure a bean deployed into the application context to implement the special callback interface, ResourceLoaderAware, to be automatically called back at initialization time with the application context itself passed in as the ResourceLoader. You can also expose properties of type Resource, to be used to access static resources. They are injected into it like any other properties. You can specify those Resource properties as simple String paths and rely on automatic conversion from those text strings to actual Resource objects when the bean is deployed.213", "chunk_char_count": 572, "chunk_word_count": 87, "chunk_token_count": 143.0}, {"page_number": 214, "sentence_chunk": "The location path or paths supplied to an ApplicationContext constructor are actually resource strings and, in simple form, are treated appropriately according to the specific context implementation. For example ClassPathXmlApplicationContext treats a simple location path as a classpath location. You can also use location paths (resource strings) with special prefixes to force loading of definitions from the classpath or a URL, regardless of the actual context type. Application Startup Tracking The ApplicationContext manages the lifecycle of Spring applications and provides a rich programming model around components. As a result, complex applications can have equally complex component graphs and startup phases. Tracking the application startup steps with specific metrics can help understand where time is being spent during the startup phase, but it can also be used as a way to better understand the context lifecycle as a whole. The AbstractApplicationContext (and its subclasses) is instrumented with an ApplicationStartup, which collects StartupStep data about various startup phases: \u2022 application context lifecycle (base packages scanning, config classes management) \u2022 beans lifecycle (instantiation, smart initialization, post processing) \u2022 application events processing Here is an example of instrumentation in the AnnotationConfigApplicationContext: Java // create a startup step and start recording StartupStep scanPackages = this.getApplicationStartup().start(\"spring.context.base- packages.scan\"); // add tagging information to the current step scanPackages.tag(\"packages\", () -> Arrays.toString(basePackages)); // perform the actual phase we're instrumenting this.scanner.scan(basePackages); // end the current step scanPackages.end(); Kotlin // create a startup step and start recording val scanPackages = this.getApplicationStartup().start(\"spring.context.base- packages.scan\") // add tagging information to the current step scanPackages.tag(\"packages\", () -> Arrays.toString(basePackages)) // perform the actual phase we're instrumenting this.scanner.scan(basePackages) // end the current step scanPackages.end() 214", "chunk_char_count": 2143, "chunk_word_count": 268, "chunk_token_count": 535.75}, {"page_number": 215, "sentence_chunk": "The application context is already instrumented with multiple steps. Once recorded, these startup steps can be collected, displayed and analyzed with specific tools. For a complete list of existing startup steps, you can check out the dedicated appendix section. The default ApplicationStartup implementation is a no-op variant, for minimal overhead. This means no metrics will be collected during application startup by default. Spring Framework ships with an implementation for tracking startup steps with Java Flight Recorder: FlightRecorderApplicationStartup. To use this variant, you must configure an instance of it to the ApplicationContext as soon as it\u2019s been created. Developers can also use the ApplicationStartup infrastructure if they\u2019re providing their own AbstractApplicationContext subclass, or if they wish to collect more precise data.\uf071 ApplicationStartup is meant to be only used during application startup and for the core container; this is by no means a replacement for Java profilers or metrics libraries like Micrometer. To start collecting custom StartupStep, components can either get the ApplicationStartup instance from the application context directly, make their component implement ApplicationStartupAware, or ask for the ApplicationStartup type on any injection point.", "chunk_char_count": 1300, "chunk_word_count": 182, "chunk_token_count": 325.0}, {"page_number": 215, "sentence_chunk": "\uf05a Developers should not use the \"spring.*\"namespace when creating custom startup steps. This namespace is reserved for internal Spring usage and is subject to change. Convenient ApplicationContext Instantiation for Web Applications You can create ApplicationContext instances declaratively by using, for example, a ContextLoader. Of course, you can also create ApplicationContext instances programmatically by using one of the ApplicationContext implementations. You can register an ApplicationContext by using the ContextLoaderListener, as the following example shows: <context-param> \u00a0  <param-name>contextConfigLocation</param-name> \u00a0  <param-value>/WEB-INF/daoContext.xml /WEB-INF/applicationContext.xml</param-value> </context-param> <listener> \u00a0  <listener-class>org.springframework.web.context. ContextLoaderListener</listener- class> </listener> The listener inspects the contextConfigLocation parameter. If the parameter does not exist, the listener uses /WEB-INF/applicationContext.xml as a default. When the parameter does exist, the listener separates the String by using predefined delimiters (comma, semicolon, and whitespace) and uses the values as locations where application contexts are searched. Ant-style path patterns 215", "chunk_char_count": 1242, "chunk_word_count": 141, "chunk_token_count": 310.5}, {"page_number": 216, "sentence_chunk": "are supported as well. Examples are /WEB-INF/*Context.xml (for all files with names that end with Context.xml and that reside in the WEB-INF directory) and /WEB-INF/**/*Context.xml (for all such files in any subdirectory of WEB-INF). Deploying a Spring ApplicationContext as a Jakarta EE RAR File It is possible to deploy a Spring ApplicationContext as a RAR file, encapsulating the context and all of its required bean classes and library JARs in a Jakarta EE RAR deployment unit. This is the equivalent of bootstrapping a stand-alone ApplicationContext (only hosted in Jakarta EE environment) being able to access the Jakarta EE servers facilities. RAR deployment is a more natural alternative to a scenario of deploying a headless WAR file\u2009\u2014\u2009in effect, a WAR file without any HTTP entry points that is used only for bootstrapping a Spring ApplicationContext in a Jakarta EE environment. RAR deployment is ideal for application contexts that do not need HTTP entry points but rather consist only of message endpoints and scheduled jobs. Beans in such a context can use application server resources such as the JTA transaction manager and JNDI-bound JDBC DataSource instances and JMS ConnectionFactory instances and can also register with the platform\u2019s JMX server\u2009\u2014\u2009all through Spring\u2019s standard transaction management and JNDI and JMX support facilities. Application components can also interact with the application server\u2019s JCA WorkManager through Spring\u2019s TaskExecutor abstraction. See the javadoc of the SpringContextResourceAdapter class for the configuration details involved in RAR deployment. For a simple deployment of a Spring ApplicationContext as a Jakarta EE RAR file: 1.", "chunk_char_count": 1687, "chunk_word_count": 253, "chunk_token_count": 421.75}, {"page_number": 216, "sentence_chunk": "Package all application classes into a RAR file (which is a standard JAR file with a different file extension).2. Add all required library JARs into the root of the RAR archive.3. Add a META-INF/ra.xml deployment descriptor (as shown in the javadoc for SpringContextResourceAdapter) and the corresponding Spring XML bean definition file(s) (typically META-INF/applicationContext.xml).4. Drop the resulting RAR file into your application server\u2019s deployment directory.\uf05a Such RAR deployment units are usually self-contained. They do not expose components to the outside world, not even to other modules of the same application. Interaction with a RAR-based ApplicationContext usually occurs through JMS destinations that it shares with other modules.", "chunk_char_count": 748, "chunk_word_count": 105, "chunk_token_count": 187.0}, {"page_number": 216, "sentence_chunk": "A RAR-based ApplicationContext may also, for example, schedule some jobs or react to new files in the file system (or the like). If it needs to allow synchronous access from the outside, it could (for example) export RMI endpoints, which may be used by other application modules on the same machine.2.1.16. The BeanFactory API The BeanFactory API provides the underlying basis for Spring\u2019s IoC functionality. Its specific contracts are mostly used in integration with other parts of Spring and related third-party 216", "chunk_char_count": 517, "chunk_word_count": 82, "chunk_token_count": 129.25}, {"page_number": 217, "sentence_chunk": "frameworks, and its DefaultListableBeanFactory implementation is a key delegate within the higher-level GenericApplicationContext container. BeanFactory and related interfaces (such as BeanFactoryAware, InitializingBean, DisposableBean) are important integration points for other framework components. By not requiring any annotations or even reflection, they allow for very efficient interaction between the container and its components. Application-level beans may use the same callback interfaces but typically prefer declarative dependency injection instead, either through annotations or through programmatic configuration. Note that the core BeanFactory API level and its DefaultListableBeanFactory implementation do not make assumptions about the configuration format or any component annotations to be used. All of these flavors come in through extensions (such as XmlBeanDefinitionReader and AutowiredAnnotationBeanPostProcessor) and operate on shared BeanDefinition objects as a core metadata representation. This is the essence of what makes Spring\u2019s container so flexible and extensible. BeanFactory or ApplicationContext?This section explains the differences between the BeanFactory and ApplicationContext container levels and the implications on bootstrapping. You should use an ApplicationContext unless you have a good reason for not doing so, with GenericApplicationContext and its subclass AnnotationConfigApplicationContext as the common implementations for custom bootstrapping.", "chunk_char_count": 1498, "chunk_word_count": 183, "chunk_token_count": 374.5}, {"page_number": 217, "sentence_chunk": "These are the primary entry points to Spring\u2019s core container for all common purposes: loading of configuration files, triggering a classpath scan, programmatically registering bean definitions and annotated classes, and (as of 5.0) registering functional bean definitions. Because an ApplicationContext includes all the functionality of a BeanFactory, it is generally recommended over a plain BeanFactory, except for scenarios where full control over bean processing is needed. Within an ApplicationContext (such as the GenericApplicationContext implementation), several kinds of beans are detected by convention (that is, by bean name or by bean type\u2009\u2014\u2009in particular, post-processors), while a plain DefaultListableBeanFactory is agnostic about any special beans. For many extended container features, such as annotation processing and AOP proxying, the BeanPostProcessor extension point is essential. If you use only a plain DefaultListableBeanFactory, such post-processors do not get detected and activated by default. This situation could be confusing, because nothing is actually wrong with your bean configuration. Rather, in such a scenario, the container needs to be fully bootstrapped through additional setup. The following table lists features provided by the BeanFactory and ApplicationContext interfaces and implementations. Table 9. Feature Matrix Feature BeanFactory ApplicationContext Bean instantiation/wiring Yes Yes Integrated lifecycle management No Yes 217", "chunk_char_count": 1478, "chunk_word_count": 198, "chunk_token_count": 369.5}, {"page_number": 218, "sentence_chunk": "Feature BeanFactory ApplicationContext Automatic BeanPostProcessor registration No Yes Automatic BeanFactoryPostProcessor registration No Yes Convenient MessageSource access (for internationalization) No Yes Built-in ApplicationEvent publication mechanism No Yes To explicitly register a bean post-processor with a DefaultListableBeanFactory, you need to programmatically call addBeanPostProcessor, as the following example shows: Java DefaultListableBeanFactory factory = new DefaultListableBeanFactory(); // populate the factory with bean definitions // now register any needed BeanPostProcessor instances factory.addBeanPostProcessor(new AutowiredAnnotationBeanPostProcessor()); factory.addBeanPostProcessor(new MyBeanPostProcessor()); // now start using the factory Kotlin val factory = DefaultListableBeanFactory() // populate the factory with bean definitions // now register any needed BeanPostProcessor instances factory.addBeanPostProcessor(AutowiredAnnotationBeanPostProcessor()) factory.addBeanPostProcessor(MyBeanPostProcessor()) // now start using the factory To apply a BeanFactoryPostProcessor to a plain DefaultListableBeanFactory, you need to call its postProcessBeanFactory method, as the following example shows: 218", "chunk_char_count": 1235, "chunk_word_count": 124, "chunk_token_count": 308.75}, {"page_number": 219, "sentence_chunk": "Java DefaultListableBeanFactory factory = new DefaultListableBeanFactory(); XmlBeanDefinitionReader reader = new XmlBeanDefinitionReader(factory); reader.loadBeanDefinitions(new FileSystemResource(\"beans.xml\")); // bring in some property values from a Properties file PropertySourcesPlaceholderConfigurer cfg = new PropertySourcesPlaceholderConfigurer(); cfg.setLocation(new FileSystemResource(\"jdbc.properties\")); // now actually do the replacement cfg.postProcessBeanFactory(factory); Kotlin val factory = DefaultListableBeanFactory() val reader = XmlBeanDefinitionReader(factory) reader.loadBeanDefinitions(FileSystemResource(\"beans.xml\")) // bring in some property values from a Properties file val cfg = PropertySourcesPlaceholderConfigurer() cfg.setLocation(FileSystemResource(\"jdbc.properties\")) // now actually do the replacement cfg.postProcessBeanFactory(factory) In both cases, the explicit registration steps are inconvenient, which is why the various ApplicationContext variants are preferred over a plain DefaultListableBeanFactory in Spring-backed applications, especially when relying on BeanFactoryPostProcessor and BeanPostProcessor instances for extended container functionality in a typical enterprise setup.\uf05a An AnnotationConfigApplicationContext has all common annotation post- processors registered and may bring in additional processors underneath the covers through configuration annotations, such as @EnableTransactionManagement. At the abstraction level of Spring\u2019s annotation-based configuration model, the notion of bean post-processors becomes a mere internal container detail.2.2. Resources This chapter covers how Spring handles resources and how you can work with resources in Spring. It includes the following topics: \u2022 Introduction \u2022 The Resource Interface \u2022 Built-in Resource Implementations \u2022 The ResourceLoader Interface 219", "chunk_char_count": 1862, "chunk_word_count": 192, "chunk_token_count": 465.5}, {"page_number": 220, "sentence_chunk": "\u2022 The ResourcePatternResolver Interface \u2022 The ResourceLoaderAware Interface \u2022 Resources as Dependencies \u2022 Application Contexts and Resource Paths 2.2.1. Introduction Java\u2019s standard java.net. URL class and standard handlers for various URL prefixes, unfortunately, are not quite adequate enough for all access to low-level resources. For example, there is no standardized URL implementation that may be used to access a resource that needs to be obtained from the classpath or relative to a ServletContext. While it is possible to register new handlers for specialized URL prefixes (similar to existing handlers for prefixes such as http:), this is generally quite complicated, and the URL interface still lacks some desirable functionality, such as a method to check for the existence of the resource being pointed to.2.2.2. The Resource Interface Spring\u2019s Resource interface located in the org.springframework.core.io.package is meant to be a more capable interface for abstracting access to low-level resources. The following listing provides an overview of the Resource interface. See the Resource javadoc for further details.", "chunk_char_count": 1130, "chunk_word_count": 164, "chunk_token_count": 282.5}, {"page_number": 221, "sentence_chunk": "public interface Resource extends InputStreamSource { \u00a0  boolean exists(); \u00a0  boolean isReadable(); \u00a0  boolean isOpen(); \u00a0  boolean isFile(); \u00a0  URL getURL() throws IOException; \u00a0  URI getURI() throws IOException; \u00a0  File getFile() throws IOException; \u00a0  ReadableByteChannel readableChannel() throws IOException; \u00a0  long contentLength() throws IOException; \u00a0  long lastModified() throws IOException; \u00a0  Resource createRelative(String relativePath) throws IOException; \u00a0  String getFilename(); \u00a0  String getDescription(); } As the definition of the Resource interface shows, it extends the InputStreamSource interface. The following listing shows the definition of the InputStreamSource interface: public interface InputStreamSource { \u00a0  InputStream getInputStream() throws IOException; } Some of the most important methods from the Resource interface are: \u2022 getInputStream(): Locates and opens the resource, returning an InputStream for reading from the resource. It is expected that each invocation returns a fresh InputStream. It is the responsibility of the caller to close the stream. \u2022exists(): Returns a boolean indicating whether this resource actually exists in physical form. \u2022isOpen(): Returns a boolean indicating whether this resource represents a handle with an open stream. If true, the InputStream cannot be read multiple times and must be read once only and then closed to avoid resource leaks. Returns false for all usual resource implementations, with the exception of InputStreamResource.221", "chunk_char_count": 1510, "chunk_word_count": 217, "chunk_token_count": 377.5}, {"page_number": 222, "sentence_chunk": "\u2022 getDescription(): Returns a description for this resource, to be used for error output when working with the resource. This is often the fully qualified file name or the actual URL of the resource. Other methods let you obtain an actual URL or File object representing the resource (if the underlying implementation is compatible and supports that functionality). Some implementations of the Resource interface also implement the extended WritableResource interface for a resource that supports writing to it. Spring itself uses the Resource abstraction extensively, as an argument type in many method signatures when a resource is needed. Other methods in some Spring APIs (such as the constructors to various ApplicationContext implementations) take a String which in unadorned or simple form is used to create a Resource appropriate to that context implementation or, via special prefixes on the String path, let the caller specify that a specific Resource implementation must be created and used. While the Resource interface is used a lot with Spring and by Spring, it is actually very convenient to use as a general utility class by itself in your own code, for access to resources, even when your code does not know or care about any other parts of Spring. While this couples your code to Spring, it really only couples it to this small set of utility classes, which serves as a more capable replacement for URL and can be considered equivalent to any other library you would use for this purpose.\uf05a The Resource abstraction does not replace functionality. It wraps it where possible.", "chunk_char_count": 1592, "chunk_word_count": 259, "chunk_token_count": 398.0}, {"page_number": 222, "sentence_chunk": "For example, a UrlResource wraps a URL and uses the wrapped URL to do its work.2.2.3. Built-in Resource Implementations Spring includes several built-in Resource implementations: \u2022 UrlResource \u2022 ClassPathResource \u2022 FileSystemResource \u2022 PathResource \u2022 ServletContextResource \u2022 InputStreamResource \u2022 ByteArrayResource For a complete list of Resource implementations available in Spring, consult the \"All Known Implementing Classes\" section of the Resource javadoc. UrlResource UrlResource wraps a java.net. URL and can be used to access any object that is normally accessible with a URL, such as files, an HTTPS target, an FTP target, and others. All URLs have a standardized String representation, such that appropriate standardized prefixes are used to indicate one URL type from another. This includes file: for accessing filesystem paths, https: for accessing resources 222", "chunk_char_count": 875, "chunk_word_count": 125, "chunk_token_count": 218.75}, {"page_number": 223, "sentence_chunk": "through the HTTPS protocol, ftp: for accessing resources through FTP, and others. A UrlResource is created by Java code by explicitly using the UrlResource constructor but is often created implicitly when you call an API method that takes a String argument meant to represent a path. For the latter case, a JavaBeans PropertyEditor ultimately decides which type of Resource to create. If the path string contains a well-known (to property editor, that is) prefix (such as classpath:), it creates an appropriate specialized Resource for that prefix. However, if it does not recognize the prefix, it assumes the string is a standard URL string and creates a UrlResource. ClassPathResource This class represents a resource that should be obtained from the classpath. It uses either the thread context class loader, a given class loader, or a given class for loading resources. This Resource implementation supports resolution as a java.io. File if the class path resource resides in the file system but not for classpath resources that reside in a jar and have not been expanded (by the servlet engine or whatever the environment is) to the filesystem. To address this, the various Resource implementations always support resolution as a java.net.", "chunk_char_count": 1244, "chunk_word_count": 198, "chunk_token_count": 311.0}, {"page_number": 223, "sentence_chunk": "URL. A ClassPathResource is created by Java code by explicitly using the ClassPathResource constructor but is often created implicitly when you call an API method that takes a String argument meant to represent a path. For the latter case, a JavaBeans PropertyEditor recognizes the special prefix, classpath:, on the string path and creates a ClassPathResource in that case. FileSystemResource This is a Resource implementation for java.io. File handles. It also supports java.nio.file. Path handles, applying Spring\u2019s standard String-based path transformations but performing all operations via the java.nio.file. Files API. For pure java.nio.path. Path based support use a PathResource instead.", "chunk_char_count": 696, "chunk_word_count": 99, "chunk_token_count": 174.0}, {"page_number": 223, "sentence_chunk": "FileSystemResource supports resolution as a File and as a URL. PathResource This is a Resource implementation for java.nio.file. Path handles, performing all operations and transformations via the Path API. It supports resolution as a File and as a URL and also implements the extended WritableResource interface. PathResource is effectively a pure java.nio.path. Path based alternative to FileSystemResource with different createRelative behavior. ServletContextResource This is a Resource implementation for ServletContext resources that interprets relative paths within the relevant web application\u2019s root directory. It always supports stream access and URL access but allows java.io. File access only when the web application archive is expanded and the resource is physically on the filesystem. Whether or not it is expanded and on the filesystem or accessed directly from the JAR or somewhere else like a database (which is conceivable) is actually dependent on the Servlet container.", "chunk_char_count": 990, "chunk_word_count": 142, "chunk_token_count": 247.5}, {"page_number": 223, "sentence_chunk": "InputStreamResource An InputStreamResource is a Resource implementation for a given InputStream. It should be used only 223", "chunk_char_count": 123, "chunk_word_count": 17, "chunk_token_count": 30.75}, {"page_number": 224, "sentence_chunk": "if no specific Resource implementation is applicable. In particular, prefer ByteArrayResource or any of the file-based Resource implementations where possible. In contrast to other Resource implementations, this is a descriptor for an already-opened resource. Therefore, it returns true from isOpen(). Do not use it if you need to keep the resource descriptor somewhere or if you need to read a stream multiple times. ByteArrayResource This is a Resource implementation for a given byte array. It creates a ByteArrayInputStream for the given byte array. It is useful for loading content from any given byte array without having to resort to a single-use InputStreamResource.2.2.4. The ResourceLoader Interface The ResourceLoader interface is meant to be implemented by objects that can return (that is, load) Resource instances.", "chunk_char_count": 828, "chunk_word_count": 123, "chunk_token_count": 207.0}, {"page_number": 224, "sentence_chunk": "The following listing shows the ResourceLoader interface definition: public interface ResourceLoader { \u00a0  Resource getResource(String location); \u00a0  ClassLoader getClassLoader(); } All application contexts implement the ResourceLoader interface. Therefore, all application contexts may be used to obtain Resource instances. When you call getResource() on a specific application context, and the location path specified doesn\u2019t have a specific prefix, you get back a Resource type that is appropriate to that particular application context. For example, assume the following snippet of code was run against a ClassPathXmlApplicationContext instance: Java Resource template = ctx.getResource(\"some/resource/path/myTemplate.txt\"); Kotlin val template = ctx.getResource(\"some/resource/path/myTemplate.txt\") Against a ClassPathXmlApplicationContext, that code returns a ClassPathResource. If the same method were run against a FileSystemXmlApplicationContext instance, it would return a FileSystemResource. For a WebApplicationContext, it would return a ServletContextResource. It would similarly return appropriate objects for each context.224", "chunk_char_count": 1138, "chunk_word_count": 137, "chunk_token_count": 284.5}, {"page_number": 225, "sentence_chunk": "As a result, you can load resources in a fashion appropriate to the particular application context. On the other hand, you may also force ClassPathResource to be used, regardless of the application context type, by specifying the special classpath: prefix, as the following example shows: Java Resource template = ctx.getResource(\"classpath:some/resource/path/myTemplate.txt\"); Kotlin val template = ctx.getResource(\"classpath:some/resource/path/myTemplate.txt\") Similarly, you can force a UrlResource to be used by specifying any of the standard java.net. URL prefixes. The following examples use the file and https prefixes: Java Resource template = ctx.getResource(\"file:///some/resource/path/myTemplate.txt\"); Kotlin val template = ctx.getResource(\"file:///some/resource/path/myTemplate.txt\") Java Resource template = ctx.getResource(\"https://myhost.com/resource/path/myTemplate.txt\"); Kotlin val template = ctx.getResource(\"https://myhost.com/resource/path/myTemplate.txt\") The following table summarizes the strategy for converting String objects to Resource objects: Table 10. Resource strings Prefix Example Explanation classpath: classpath:com/myapp/config.xml Loaded from the classpath.file: file:///data/config.xml Loaded as a URL from the filesystem. See also FileSystemResource Caveats.https: https://myserver/logo.png Loaded as a URL. (none) /data/config.xml Depends on the underlying ApplicationContext.225", "chunk_char_count": 1421, "chunk_word_count": 152, "chunk_token_count": 355.25}, {"page_number": 226, "sentence_chunk": "2.2.5. The ResourcePatternResolver Interface The ResourcePatternResolver interface is an extension to the ResourceLoader interface which defines a strategy for resolving a location pattern (for example, an Ant-style path pattern) into Resource objects.public interface ResourcePatternResolver extends ResourceLoader { \u00a0  String CLASSPATH_ALL_URL_PREFIX = \"classpath*:\"; \u00a0  Resource[] getResources(String locationPattern) throws IOException; } As can be seen above, this interface also defines a special classpath*: resource prefix for all matching resources from the class path. Note that the resource location is expected to be a path without placeholders in this case\u2009\u2014\u2009for example, classpath*:/config/beans.xml. JAR files or different directories in the class path can contain multiple files with the same path and the same name. See Wildcards in Application Context Constructor Resource Paths and its subsections for further details on wildcard support with the classpath*: resource prefix. A passed-in ResourceLoader (for example, one supplied via ResourceLoaderAware semantics) can be checked whether it implements this extended interface too. PathMatchingResourcePatternResolver is a standalone implementation that is usable outside an ApplicationContext and is also used by ResourceArrayPropertyEditor for populating Resource[] bean properties. PathMatchingResourcePatternResolver is able to resolve a specified resource location path into one or more matching Resource objects. The source path may be a simple path which has a one- to-one mapping to a target Resource, or alternatively may contain the special classpath*: prefix and/or internal Ant-style regular expressions (matched using Spring\u2019s org.springframework.util.", "chunk_char_count": 1733, "chunk_word_count": 228, "chunk_token_count": 433.25}, {"page_number": 226, "sentence_chunk": "AntPathMatcher utility). Both of the latter are effectively wildcards.\uf05a The default ResourceLoader in any standard ApplicationContext is in fact an instance of PathMatchingResourcePatternResolver which implements the ResourcePatternResolver interface. The same is true for the ApplicationContext instance itself which also implements the ResourcePatternResolver interface and delegates to the default PathMatchingResourcePatternResolver.2.2.6. The ResourceLoaderAware Interface The ResourceLoaderAware interface is a special callback interface which identifies components that expect to be provided a ResourceLoader reference. The following listing shows the definition of the ResourceLoaderAware interface: public interface ResourceLoaderAware { \u00a0  void setResourceLoader(ResourceLoader resourceLoader); } 226", "chunk_char_count": 810, "chunk_word_count": 92, "chunk_token_count": 202.5}, {"page_number": 227, "sentence_chunk": "When a class implements ResourceLoaderAware and is deployed into an application context (as a Spring-managed bean), it is recognized as ResourceLoaderAware by the application context. The application context then invokes setResourceLoader(ResourceLoader), supplying itself as the argument (remember, all application contexts in Spring implement the ResourceLoader interface). Since an ApplicationContext is a ResourceLoader, the bean could also implement the ApplicationContextAware interface and use the supplied application context directly to load resources. However, in general, it is better to use the specialized ResourceLoader interface if that is all you need. The code would be coupled only to the resource loading interface (which can be considered a utility interface) and not to the whole Spring ApplicationContext interface. In application components, you may also rely upon autowiring of the ResourceLoader as an alternative to implementing the ResourceLoaderAware interface. The traditional constructor and byType autowiring modes (as described in Autowiring Collaborators) are capable of providing a ResourceLoader for either a constructor argument or a setter method parameter, respectively. For more flexibility (including the ability to autowire fields and multiple parameter methods), consider using the annotation-based autowiring features. In that case, the ResourceLoader is autowired into a field, constructor argument, or method parameter that expects the ResourceLoader type as long as the field, constructor, or method in question carries the @Autowired annotation. For more information, see Using @Autowired.", "chunk_char_count": 1636, "chunk_word_count": 222, "chunk_token_count": 409.0}, {"page_number": 227, "sentence_chunk": "\uf05a To load one or more Resource objects for a resource path that contains wildcards or makes use of the special classpath*: resource prefix, consider having an instance of ResourcePatternResolver autowired into your application components instead of ResourceLoader.2.2.7. Resources as Dependencies If the bean itself is going to determine and supply the resource path through some sort of dynamic process, it probably makes sense for the bean to use the ResourceLoader or ResourcePatternResolver interface to load resources. For example, consider the loading of a template of some sort, where the specific resource that is needed depends on the role of the user. If the resources are static, it makes sense to eliminate the use of the ResourceLoader interface (or ResourcePatternResolver interface) completely, have the bean expose the Resource properties it needs, and expect them to be injected into it. What makes it trivial to then inject these properties is that all application contexts register and use a special JavaBeans PropertyEditor, which can convert String paths to Resource objects. For example, the following MyBean class has a template property of type Resource.227", "chunk_char_count": 1181, "chunk_word_count": 181, "chunk_token_count": 295.25}, {"page_number": 228, "sentence_chunk": "Java package example; public class MyBean { \u00a0  private Resource template; \u00a0  public setTemplate(Resource template) { \u00a0    this.template = template; \u00a0  } \u00a0  // ... } Kotlin class MyBean(var template: Resource) In an XML configuration file, the template property can be configured with a simple string for that resource, as the following example shows: <bean id=\"myBean\" class=\"example. MyBean\"> \u00a0  <property name=\"template\" value=\"some/resource/path/myTemplate.txt\"/> </bean> Note that the resource path has no prefix. Consequently, because the application context itself is going to be used as the ResourceLoader, the resource is loaded through a ClassPathResource, a FileSystemResource, or a ServletContextResource, depending on the exact type of the application context. If you need to force a specific Resource type to be used, you can use a prefix. The following two examples show how to force a ClassPathResource and a UrlResource (the latter being used to access a file in the filesystem): <property name=\"template\" value=\"classpath:some/resource/path/myTemplate.txt\"> <property name=\"template\" value=\"file:///some/resource/path/myTemplate.txt\"/> If the MyBean class is refactored for use with annotation-driven configuration, the path to myTemplate.txt can be stored under a key named template.path\u2009\u2014\u2009for example, in a properties file made available to the Spring Environment (see Environment Abstraction). The template path can then be referenced via the @Value annotation using a property placeholder (see Using @Value). Spring will retrieve the value of the template path as a string, and a special PropertyEditor will convert the string to a Resource object to be injected into the MyBean constructor. The following 228", "chunk_char_count": 1730, "chunk_word_count": 250, "chunk_token_count": 432.5}, {"page_number": 229, "sentence_chunk": "example demonstrates how to achieve this. Java @Component public class MyBean { \u00a0  private final Resource template; \u00a0  public MyBean(@Value(\"${template.path}\") Resource template) { \u00a0    this.template = template; \u00a0  } \u00a0  // ... } Kotlin @Component class MyBean(@Value(\"\\${template.path}\") private val template: Resource) If we want to support multiple templates discovered under the same path in multiple locations in the classpath\u2009\u2014\u2009for example, in multiple jars in the classpath\u2009\u2014\u2009we can use the special classpath*: prefix and wildcarding to define a templates.path key as classpath*:/config/templates/*.txt. If we redefine the MyBean class as follows, Spring will convert the template path pattern into an array of Resource objects that can be injected into the MyBean constructor. Java @Component public class MyBean { \u00a0  private final Resource[] templates; \u00a0  public MyBean(@Value(\"${templates.path}\") Resource[] templates) { \u00a0    this.templates = templates; \u00a0  } \u00a0  // ... } Kotlin @Component class MyBean(@Value(\"\\${templates.path}\") private val templates: Resource[]) 229", "chunk_char_count": 1078, "chunk_word_count": 160, "chunk_token_count": 269.5}, {"page_number": 230, "sentence_chunk": "2.2.8. Application Contexts and Resource Paths This section covers how to create application contexts with resources, including shortcuts that work with XML, how to use wildcards, and other details. Constructing Application Contexts An application context constructor (for a specific application context type) generally takes a string or array of strings as the location paths of the resources, such as XML files that make up the definition of the context. When such a location path does not have a prefix, the specific Resource type built from that path and used to load the bean definitions depends on and is appropriate to the specific application context. For example, consider the following example, which creates a ClassPathXmlApplicationContext: Java ApplicationContext ctx = new ClassPathXmlApplicationContext(\"conf/appContext.xml\"); Kotlin val ctx = ClassPathXmlApplicationContext(\"conf/appContext.xml\") The bean definitions are loaded from the classpath, because a ClassPathResource is used. However, consider the following example, which creates a FileSystemXmlApplicationContext: Java ApplicationContext ctx = \u00a0  new FileSystemXmlApplicationContext(\"conf/appContext.xml\"); Kotlin val ctx = FileSystemXmlApplicationContext(\"conf/appContext.xml\") Now the bean definitions are loaded from a filesystem location (in this case, relative to the current working directory). Note that the use of the special classpath prefix or a standard URL prefix on the location path overrides the default type of Resource created to load the bean definitions. Consider the following example: Java ApplicationContext ctx = \u00a0  new FileSystemXmlApplicationContext(\"classpath:conf/appContext.xml\"); 230", "chunk_char_count": 1690, "chunk_word_count": 222, "chunk_token_count": 422.5}, {"page_number": 231, "sentence_chunk": "Kotlin val ctx = FileSystemXmlApplicationContext(\"classpath:conf/appContext.xml\") Using FileSystemXmlApplicationContext loads the bean definitions from the classpath. However, it is still a FileSystemXmlApplicationContext. If it is subsequently used as a ResourceLoader, any unprefixed paths are still treated as filesystem paths. Constructing ClassPathXmlApplicationContext Instances\u2009\u2014\u2009Shortcuts The ClassPathXmlApplicationContext exposes a number of constructors to enable convenient instantiation. The basic idea is that you can supply merely a string array that contains only the filenames of the XML files themselves (without the leading path information) and also supply a Class. The ClassPathXmlApplicationContext then derives the path information from the supplied class. Consider the following directory layout: com/ \u00a0 example/ \u00a0  services.xml \u00a0  repositories.xml \u00a0  MessengerService.class The following example shows how a ClassPathXmlApplicationContext instance composed of the beans defined in files named services.xml and repositories.xml (which are on the classpath) can be instantiated: Java ApplicationContext ctx = new ClassPathXmlApplicationContext( \u00a0  new String[] {\"services.xml\", \"repositories.xml\"}, MessengerService.class); Kotlin val ctx = ClassPathXmlApplicationContext(arrayOf(\"services.xml\", \"repositories.xml\"), MessengerService::class.java) See the ClassPathXmlApplicationContext javadoc for details on the various constructors. Wildcards in Application Context Constructor Resource Paths The resource paths in application context constructor values may be simple paths (as shown earlier), each of which has a one-to-one mapping to a target Resource or, alternately, may contain the special classpath*: prefix or internal Ant-style patterns (matched by using Spring\u2019s PathMatcher utility). Both of the latter are effectively wildcards. One use for this mechanism is when you need to do component-style application assembly.", "chunk_char_count": 1952, "chunk_word_count": 240, "chunk_token_count": 488.0}, {"page_number": 232, "sentence_chunk": "components can publish context definition fragments to a well-known location path, and, when the final application context is created using the same path prefixed with classpath*:, all component fragments are automatically picked up. Note that this wildcarding is specific to the use of resource paths in application context constructors (or when you use the PathMatcher utility class hierarchy directly) and is resolved at construction time. It has nothing to do with the Resource type itself. You cannot use the classpath*: prefix to construct an actual Resource, as a resource points to just one resource at a time. Ant-style Patterns Path locations can contain Ant-style patterns, as the following example shows: /WEB-INF/*-context.xml com/mycompany/**/applicationContext.xml file:C:/some/path/*-context.xml classpath:com/mycompany/**/applicationContext.xml When the path location contains an Ant-style pattern, the resolver follows a more complex procedure to try to resolve the wildcard. It produces a Resource for the path up to the last non- wildcard segment and obtains a URL from it. If this URL is not a jar: URL or container-specific variant (such as zip: in WebLogic, wsjar in WebSphere, and so on), a java.io. File is obtained from it and used to resolve the wildcard by traversing the filesystem. In the case of a jar URL, the resolver either gets a java.net. JarURLConnection from it or manually parses the jar URL and then traverses the contents of the jar file to resolve the wildcards.", "chunk_char_count": 1504, "chunk_word_count": 229, "chunk_token_count": 376.0}, {"page_number": 232, "sentence_chunk": "Implications on Portability If the specified path is already a file URL (either implicitly because the base ResourceLoader is a filesystem one or explicitly), wildcarding is guaranteed to work in a completely portable fashion. If the specified path is a classpath location, the resolver must obtain the last non-wildcard path segment URL by making a Classloader.getResource() call. Since this is just a node of the path (not the file at the end), it is actually undefined (in the ClassLoader javadoc) exactly what sort of a URL is returned in this case. In practice, it is always a java.io. File representing the directory (where the classpath resource resolves to a filesystem location) or a jar URL of some sort (where the classpath resource resolves to a jar location). Still, there is a portability concern on this operation. If a jar URL is obtained for the last non-wildcard segment, the resolver must be able to get a java.net. JarURLConnection from it or manually parse the jar URL, to be able to walk the contents of the jar and resolve the wildcard. This does work in most environments but fails in others, and we strongly recommend that the wildcard resolution of resources coming from jars be thoroughly tested in your specific environment before you rely on it. The classpath*: Prefix When constructing an XML-based application context, a location string may use the special classpath*: prefix, as the following example shows: 232", "chunk_char_count": 1443, "chunk_word_count": 238, "chunk_token_count": 360.75}, {"page_number": 233, "sentence_chunk": "Java ApplicationContext ctx = \u00a0  new ClassPathXmlApplicationContext(\"classpath*:conf/appContext.xml\"); Kotlin val ctx = ClassPathXmlApplicationContext(\"classpath*:conf/appContext.xml\") This special prefix specifies that all classpath resources that match the given name must be obtained (internally, this essentially happens through a call to ClassLoader.getResources(\u2026)) and then merged to form the final application context definition.\uf05a The wildcard classpath relies on the getResources() method of the underlying ClassLoader. As most application servers nowadays supply their own ClassLoader implementation, the behavior might differ, especially when dealing with jar files. A simple test to check if classpath* works is to use the ClassLoader to load a file from within a jar on the classpath: getClass().getClassLoader().getResources(\"<someFileInsideTheJar>\"). Try this test with files that have the same name but reside in two different locations\u2009\u2014\u2009for example, files with the same name and same path but in different jars on the classpath. In case an inappropriate result is returned, check the application server documentation for settings that might affect the ClassLoader behavior. You can also combine the classpath*: prefix with a PathMatcher pattern in the rest of the location path (for example, classpath*:META-INF/*-beans.xml). In this case, the resolution strategy is fairly simple: A ClassLoader.getResources() call is used on the last non-wildcard path segment to get all the matching resources in the class loader hierarchy and then, off each resource, the same PathMatcher resolution strategy described earlier is used for the wildcard subpath. Other Notes Relating to Wildcards Note that classpath*:, when combined with Ant-style patterns, only works reliably with at least one root directory before the pattern starts, unless the actual target files reside in the file system. This means that a pattern such as classpath*:*.xml might not retrieve files from the root of jar files but rather only from the root of expanded directories.", "chunk_char_count": 2057, "chunk_word_count": 290, "chunk_token_count": 514.25}, {"page_number": 233, "sentence_chunk": "Spring\u2019s ability to retrieve classpath entries originates from the JDK\u2019s ClassLoader.getResources() method, which only returns file system locations for an empty string (indicating potential roots to search). Spring evaluates URLClassLoader runtime configuration and the java.class.path manifest in jar files as well, but this is not guaranteed to lead to portable behavior.233", "chunk_char_count": 377, "chunk_word_count": 51, "chunk_token_count": 94.25}, {"page_number": 234, "sentence_chunk": "\uf05a The scanning of classpath packages requires the presence of corresponding directory entries in the classpath. When you build JARs with Ant, do not activate the files-only switch of the JAR task. Also, classpath directories may not get exposed based on security policies in some environments\u2009\u2014\u2009for example, stand- alone applications on JDK 1.7.0_45 and higher (which requires 'Trusted-Library' to be set up in your manifests. See https://stackoverflow.com/questions/19394570/ java-jre-7u45-breaks-classloader-getresources). On JDK 9\u2019s module path (Jigsaw), Spring\u2019s classpath scanning generally works as expected. Putting resources into a dedicated directory is highly recommendable here as well, avoiding the aforementioned portability problems with searching the jar file root level. Ant-style patterns with classpath: resources are not guaranteed to find matching resources if the root package to search is available in multiple classpath locations. Consider the following example of a resource location: com/mycompany/package1/service-context.xml Now consider an Ant-style path that someone might use to try to find that file: classpath:com/mycompany/**/service-context.xml Such a resource may exist in only one location in the classpath, but when a path such as the preceding example is used to try to resolve it, the resolver works off the (first) URL returned by getResource(\"com/mycompany\");. If this base package node exists in multiple ClassLoader locations, the desired resource may not exist in the first location found. Therefore, in such cases you should prefer using classpath*: with the same Ant-style pattern, which searches all classpath locations that contain the com.mycompany base package: classpath*:com/mycompany/**/service-context.xml.", "chunk_char_count": 1760, "chunk_word_count": 239, "chunk_token_count": 440.0}, {"page_number": 234, "sentence_chunk": "FileSystemResource Caveats A FileSystemResource that is not attached to a FileSystemApplicationContext (that is, when a FileSystemApplicationContext is not the actual ResourceLoader) treats absolute and relative paths as you would expect. Relative paths are relative to the current working directory, while absolute paths are relative to the root of the filesystem. For backwards compatibility (historical) reasons however, this changes when the FileSystemApplicationContext is the ResourceLoader. The FileSystemApplicationContext forces all attached FileSystemResource instances to treat all location paths as relative, whether they start with a leading slash or not. In practice, this means the following examples are equivalent: Java ApplicationContext ctx = \u00a0  new FileSystemXmlApplicationContext(\"conf/context.xml\"); 234", "chunk_char_count": 825, "chunk_word_count": 105, "chunk_token_count": 206.25}, {"page_number": 235, "sentence_chunk": "Kotlin val ctx = FileSystemXmlApplicationContext(\"conf/context.xml\") Java ApplicationContext ctx = \u00a0  new FileSystemXmlApplicationContext(\"/conf/context.xml\"); Kotlin val ctx = FileSystemXmlApplicationContext(\"/conf/context.xml\") The following examples are also equivalent (even though it would make sense for them to be different, as one case is relative and the other absolute): Java FileSystemXmlApplicationContext ctx = ...; ctx.getResource(\"some/resource/path/myTemplate.txt\"); Kotlin val ctx: FileSystemXmlApplicationContext = ... ctx.getResource(\"some/resource/path/myTemplate.txt\") Java FileSystemXmlApplicationContext ctx = ...; ctx.getResource(\"/some/resource/path/myTemplate.txt\"); Kotlin val ctx: FileSystemXmlApplicationContext = ... ctx.getResource(\"/some/resource/path/myTemplate.txt\") In practice, if you need true absolute filesystem paths, you should avoid using absolute paths with FileSystemResource or FileSystemXmlApplicationContext and force the use of a UrlResource by using the file: URL prefix. The following examples show how to do so: Java // actual context type doesn't matter, the Resource will always be UrlResource ctx.getResource(\"file:///some/resource/path/myTemplate.txt\"); 235", "chunk_char_count": 1212, "chunk_word_count": 125, "chunk_token_count": 303.0}, {"page_number": 236, "sentence_chunk": "Kotlin // actual context type doesn't matter, the Resource will always be UrlResource ctx.getResource(\"file:///some/resource/path/myTemplate.txt\") Java // force this FileSystemXmlApplicationContext to load its definition via a UrlResource ApplicationContext ctx = \u00a0  new FileSystemXmlApplicationContext(\"file:///conf/context.xml\"); Kotlin // force this FileSystemXmlApplicationContext to load its definition via a UrlResource val ctx = FileSystemXmlApplicationContext(\"file:///conf/context.xml\") 2.3. Validation, Data Binding, and Type Conversion There are pros and cons for considering validation as business logic, and Spring offers a design for validation (and data binding) that does not exclude either one of them. Specifically, validation should not be tied to the web tier and should be easy to localize, and it should be possible to plug in any available validator. Considering these concerns, Spring provides a Validator contract that is both basic and eminently usable in every layer of an application. Data binding is useful for letting user input be dynamically bound to the domain model of an application (or whatever objects you use to process user input). Spring provides the aptly named DataBinder to do exactly that. The Validator and the DataBinder make up the validation package, which is primarily used in but not limited to the web layer. The BeanWrapper is a fundamental concept in the Spring Framework and is used in a lot of places. However, you probably do not need to use the BeanWrapper directly. Because this is reference documentation, however, we felt that some explanation might be in order.", "chunk_char_count": 1622, "chunk_word_count": 236, "chunk_token_count": 405.5}, {"page_number": 236, "sentence_chunk": "We explain the BeanWrapper in this chapter, since, if you are going to use it at all, you are most likely do so when trying to bind data to objects. Spring\u2019s DataBinder and the lower-level BeanWrapper both use PropertyEditorSupport implementations to parse and format property values. The PropertyEditor and PropertyEditorSupport types are part of the JavaBeans specification and are also explained in this chapter. Spring 3 introduced a core.convert package that provides a general type conversion facility, as well as a higher-level \u201cformat\u201d package for formatting UI field values. You can use these packages as simpler alternatives to PropertyEditorSupport implementations. They are also discussed in this chapter. Spring supports Java Bean Validation through setup infrastructure and an adaptor to Spring\u2019s own Validator contract. Applications can enable Bean Validation once globally, as described in Java Bean Validation, and use it exclusively for all validation needs. In the web layer, applications can further register controller-local Spring Validator instances per DataBinder, as described in Configuring a 236", "chunk_char_count": 1122, "chunk_word_count": 164, "chunk_token_count": 280.5}, {"page_number": 237, "sentence_chunk": "DataBinder, which can be useful for plugging in custom validation logic.2.3.1. Validation by Using Spring\u2019s Validator Interface Spring features a Validator interface that you can use to validate objects. The Validator interface works by using an Errors object so that, while validating, validators can report validation failures to the Errors object. Consider the following example of a small data object: Java public class Person { \u00a0  private String name; \u00a0  private int age; \u00a0  // the usual getters and setters... } Kotlin class Person(val name: String, val age: Int) The next example provides validation behavior for the Person class by implementing the following two methods of the org.springframework.validation. Validator interface: \u2022 supports(Class): Can this Validator validate instances of the supplied Class? \u2022validate(Object, org.springframework.validation. Errors): Validates the given object and, in case of validation errors, registers those with the given Errors object. Implementing a Validator is fairly straightforward, especially when you know of the ValidationUtils helper class that the Spring Framework also provides. The following example implements Validator for Person instances: 237", "chunk_char_count": 1208, "chunk_word_count": 174, "chunk_token_count": 302.0}, {"page_number": 238, "sentence_chunk": "Java public class PersonValidator implements Validator { \u00a0  /** \u00a0  * This Validator validates only Person instances \u00a0  */ \u00a0  public boolean supports(Class clazz) { \u00a0    return Person.class.equals(clazz); \u00a0  } \u00a0  public void validate(Object obj, Errors e) { \u00a0    ValidationUtils.rejectIfEmpty(e, \"name\", \"name.empty\"); \u00a0    Person p = (Person) obj; \u00a0    if (p.getAge() < 0) { \u00a0      e.rejectValue(\"age\", \"negativevalue\"); \u00a0    } else if (p.getAge() > 110) { \u00a0      e.rejectValue(\"age\", \"too.darn.old\"); \u00a0    } \u00a0  } } Kotlin class PersonValidator : Validator { \u00a0  /** \u00a0  * This Validator validates only Person instances \u00a0  */ \u00a0  override fun supports(clazz: Class<*>): Boolean { \u00a0    return Person::class.java == clazz \u00a0  } \u00a0  override fun validate(obj: Any, e: Errors) { \u00a0    ValidationUtils.rejectIfEmpty(e, \"name\", \"name.empty\") \u00a0    val p = obj as Person \u00a0    if (p.age < 0) { \u00a0      e.rejectValue(\"age\", \"negativevalue\") \u00a0    } else if (p.age > 110) { \u00a0      e.rejectValue(\"age\", \"too.darn.old\") \u00a0    } \u00a0  } } The static rejectIfEmpty(..) method on the ValidationUtils class is used to reject the name property if it is null or the empty string. Have a look at the ValidationUtils javadoc to see what functionality it provides besides the example shown previously. While it is certainly possible to implement a single Validator class to validate each of the nested objects in a rich object, it may be better to encapsulate the validation logic for each nested class of 238", "chunk_char_count": 1475, "chunk_word_count": 297, "chunk_token_count": 368.75}, {"page_number": 239, "sentence_chunk": "object in its own Validator implementation. A simple example of a \u201crich\u201d object would be a Customer that is composed of two String properties (a first and a second name) and a complex Address object. Address objects may be used independently of Customer objects, so a distinct AddressValidator has been implemented. If you want your CustomerValidator to reuse the logic contained within the AddressValidator class without resorting to copy-and-paste, you can dependency-inject or instantiate an AddressValidator within your CustomerValidator, as the following example shows: Java public class CustomerValidator implements Validator { \u00a0  private final Validator addressValidator; \u00a0  public CustomerValidator(Validator addressValidator) { \u00a0    if (addressValidator == null) { \u00a0      throw new IllegalArgumentException(\"The supplied [Validator] is \" + \u00a0        \"required and must not be null.\");\u00a0    } \u00a0    if (!addressValidator.supports(Address.class)) { \u00a0      throw new IllegalArgumentException(\"The supplied [Validator] must \" + \u00a0        \"support the validation of [Address] instances.\");\u00a0    } \u00a0    this.addressValidator = addressValidator; \u00a0  } \u00a0  /** \u00a0  * This Validator validates Customer instances, and any subclasses of Customer too \u00a0  */ \u00a0  public boolean supports(Class clazz) { \u00a0    return Customer.class.isAssignableFrom(clazz); \u00a0  } \u00a0  public void validate(Object target, Errors errors) { \u00a0    ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"firstName\", \"field.required\"); \u00a0    ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"surname\", \"field.required\"); \u00a0    Customer customer = (Customer) target; \u00a0    try { \u00a0      errors.pushNestedPath(\"address\"); \u00a0      ValidationUtils.invokeValidator(this.addressValidator, customer.getAddress(), errors); \u00a0    } finally { \u00a0      errors.popNestedPath(); \u00a0    } \u00a0  } } 239", "chunk_char_count": 1828, "chunk_word_count": 307, "chunk_token_count": 457.0}, {"page_number": 240, "sentence_chunk": "Kotlin class CustomerValidator(private val addressValidator: Validator) : Validator { \u00a0  init { \u00a0    if (addressValidator == null) { \u00a0      throw IllegalArgumentException(\"The supplied [Validator] is required and must not be null.\")\u00a0    } \u00a0    if (!addressValidator.supports(Address::class.java)) { \u00a0      throw IllegalArgumentException(\"The supplied [Validator] must support the validation of [Address] instances.\")\u00a0    } \u00a0  } \u00a0  /* \u00a0  * This Validator validates Customer instances, and any subclasses of Customer too \u00a0  */ \u00a0  override fun supports(clazz: Class<>): Boolean { \u00a0    return Customer::class.java.isAssignableFrom(clazz) \u00a0  } \u00a0  override fun validate(target: Any, errors: Errors) { \u00a0    ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"firstName\", \"field.required\") \u00a0    ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"surname\", \"field.required\") \u00a0    val customer = target as Customer \u00a0    try { \u00a0      errors.pushNestedPath(\"address\") \u00a0      ValidationUtils.invokeValidator(this.addressValidator, customer.address, errors) \u00a0    } finally { \u00a0      errors.popNestedPath() \u00a0    } \u00a0  } } Validation errors are reported to the Errors object passed to the validator. In the case of Spring Web MVC, you can use the <spring:bind/> tag to inspect the error messages, but you can also inspect the Errors object yourself. More information about the methods it offers can be found in the javadoc.2.3.2. Resolving Codes to Error Messages We covered databinding and validation. This section covers outputting messages that correspond to validation errors. In the example shown in the preceding section, we rejected the name and age fields.", "chunk_char_count": 1645, "chunk_word_count": 276, "chunk_token_count": 411.25}, {"page_number": 240, "sentence_chunk": "If we want to output the error messages by using a MessageSource, we can do so using the error code we provide when rejecting the field ('name' and 'age' in this case). When you call (either directly, or indirectly, by using, for example, the ValidationUtils class) rejectValue or one of the other reject methods from the Errors interface, the underlying implementation not only registers the code you passed in but also registers a number of additional error codes. The 240", "chunk_char_count": 474, "chunk_word_count": 80, "chunk_token_count": 118.5}, {"page_number": 241, "sentence_chunk": "MessageCodesResolver determines which error codes the Errors interface registers. By default, the DefaultMessageCodesResolver is used, which (for example) not only registers a message with the code you gave but also registers messages that include the field name you passed to the reject method. So, if you reject a field by using rejectValue(\"age\", \"too.darn.old\"), apart from the too.darn.old code, Spring also registers too.darn.old.age and too.darn.old.age.int (the first includes the field name and the second includes the type of the field). This is done as a convenience to aid developers when targeting error messages. More information on the MessageCodesResolver and the default strategy can be found in the javadoc of MessageCodesResolver and DefaultMessageCodesResolver, respectively.2.3.3. Bean Manipulation and the BeanWrapper The org.springframework.beans package adheres to the JavaBeans standard. A JavaBean is a class with a default no-argument constructor and that follows a naming convention where (for example) a property named bingoMadness would have a setter method setBingoMadness(..) and a getter method getBingoMadness(). For more information about JavaBeans and the specification, see javabeans. One quite important class in the beans package is the BeanWrapper interface and its corresponding implementation (BeanWrapperImpl).", "chunk_char_count": 1353, "chunk_word_count": 186, "chunk_token_count": 338.25}, {"page_number": 241, "sentence_chunk": "As quoted from the javadoc, the BeanWrapper offers functionality to set and get property values (individually or in bulk), get property descriptors, and query properties to determine if they are readable or writable. Also, the BeanWrapper offers support for nested properties, enabling the setting of properties on sub-properties to an unlimited depth. The BeanWrapper also supports the ability to add standard JavaBeans PropertyChangeListeners and VetoableChangeListeners, without the need for supporting code in the target class. Last but not least, the BeanWrapper provides support for setting indexed properties. The BeanWrapper usually is not used by application code directly but is used by the DataBinder and the BeanFactory. The way the BeanWrapper works is partly indicated by its name: it wraps a bean to perform actions on that bean, such as setting and retrieving properties. Setting and Getting Basic and Nested Properties Setting and getting properties is done through the setPropertyValue and getPropertyValue overloaded method variants of BeanWrapper. See their Javadoc for details. The below table shows some examples of these conventions: Table 11. Examples of properties Expression Explanation name Indicates the property name that corresponds to the getName() or isName() and setName(..) methods.", "chunk_char_count": 1316, "chunk_word_count": 192, "chunk_token_count": 329.0}, {"page_number": 241, "sentence_chunk": "account.name Indicates the nested property name of the property account that corresponds to (for example) the getAccount().setName() or getAccount().getName() methods.241", "chunk_char_count": 170, "chunk_word_count": 20, "chunk_token_count": 42.5}, {"page_number": 242, "sentence_chunk": "Expression Explanation account[2] Indicates the third element of the indexed property account. Indexed properties can be of type array, list, or other naturally ordered collection.account[COMPANYNAME] Indicates the value of the map entry indexed by the COMPANYNAME key of the account Map property. (This next section is not vitally important to you if you do not plan to work with the BeanWrapper directly. If you use only the DataBinder and the BeanFactory and their default implementations, you should skip ahead to the section on PropertyEditors.)The following two example classes use the BeanWrapper to get and set properties: Java public class Company { \u00a0  private String name; \u00a0  private Employee managingDirector; \u00a0  public String getName() { \u00a0    return this.name; \u00a0  } \u00a0  public void setName(String name) { \u00a0    this.name = name; \u00a0  } \u00a0  public Employee getManagingDirector() { \u00a0    return this.managingDirector; \u00a0  } \u00a0  public void setManagingDirector(Employee managingDirector) { \u00a0    this.managingDirector = managingDirector; \u00a0  } } Kotlin class Company { \u00a0  var name: String?= null \u00a0  var managingDirector: Employee?= null } 242", "chunk_char_count": 1141, "chunk_word_count": 194, "chunk_token_count": 285.25}, {"page_number": 243, "sentence_chunk": "Java public class Employee { \u00a0  private String name; \u00a0  private float salary; \u00a0  public String getName() { \u00a0    return this.name; \u00a0  } \u00a0  public void setName(String name) { \u00a0    this.name = name; \u00a0  } \u00a0  public float getSalary() { \u00a0    return salary; \u00a0  } \u00a0  public void setSalary(float salary) { \u00a0    this.salary = salary; \u00a0  } } Kotlin class Employee { \u00a0  var name: String?= null \u00a0  var salary: Float?= null } The following code snippets show some examples of how to retrieve and manipulate some of the properties of instantiated Companys and Employees: 243", "chunk_char_count": 559, "chunk_word_count": 120, "chunk_token_count": 139.75}, {"page_number": 244, "sentence_chunk": "Java BeanWrapper company = new BeanWrapperImpl(new Company()); // setting the company name.. company.setPropertyValue(\"name\", \"Some Company Inc.\"); // ... can also be done like this: PropertyValue value = new PropertyValue(\"name\", \"Some Company Inc.\"); company.setPropertyValue(value); // ok, let's create the director and tie it to the company: BeanWrapper jim = new BeanWrapperImpl(new Employee()); jim.setPropertyValue(\"name\", \"Jim Stravinsky\"); company.setPropertyValue(\"managingDirector\", jim.getWrappedInstance()); // retrieving the salary of the managingDirector through the company Float salary = (Float) company.getPropertyValue(\"managingDirector.salary\"); Kotlin val company = BeanWrapperImpl(Company()) // setting the company name.. company.setPropertyValue(\"name\", \"Some Company Inc.\") // ... can also be done like this: val value = PropertyValue(\"name\", \"Some Company Inc.\") company.setPropertyValue(value) // ok, let's create the director and tie it to the company: val jim = BeanWrapperImpl(Employee()) jim.setPropertyValue(\"name\", \"Jim Stravinsky\") company.setPropertyValue(\"managingDirector\", jim.wrappedInstance) // retrieving the salary of the managingDirector through the company val salary = company.getPropertyValue(\"managingDirector.salary\") as Float?Built-in PropertyEditor Implementations Spring uses the concept of a PropertyEditor to effect the conversion between an Object and a String. It can be handy to represent properties in a different way than the object itself. For example, a Date can be represented in a human readable way (as the String: '2007-14-09'), while we can still convert the human readable form back to the original date (or, even better, convert any date entered in a human readable form back to Date objects). This behavior can be achieved by registering custom editors of type java.beans. PropertyEditor. Registering custom editors on a BeanWrapper or, alternatively, in a specific IoC container (as mentioned in the previous chapter), gives it the knowledge of how to convert properties to the desired type. For more about PropertyEditor, see the javadoc of the java.beans package from Oracle. A couple of examples where property editing is used in Spring: \u2022 Setting properties on beans is done by using PropertyEditor implementations. When you use 244", "chunk_char_count": 2304, "chunk_word_count": 302, "chunk_token_count": 576.0}, {"page_number": 245, "sentence_chunk": "String as the value of a property of some bean that you declare in an XML file, Spring (if the setter of the corresponding property has a Class parameter) uses ClassEditor to try to resolve the parameter to a Class object. \u2022Parsing HTTP request parameters in Spring\u2019s MVC framework is done by using all kinds of PropertyEditor implementations that you can manually bind in all subclasses of the CommandController. Spring has a number of built-in PropertyEditor implementations to make life easy. They are all located in the org.springframework.beans.propertyeditors package. Most, (but not all, as indicated in the following table) are, by default, registered by BeanWrapperImpl. Where the property editor is configurable in some fashion, you can still register your own variant to override the default one. The following table describes the various PropertyEditor implementations that Spring provides: Table 12. Built-in PropertyEditor Implementations Class Explanation ByteArrayPropertyEditor Editor for byte arrays. Converts strings to their corresponding byte representations. Registered by default by BeanWrapperImpl.", "chunk_char_count": 1122, "chunk_word_count": 161, "chunk_token_count": 280.5}, {"page_number": 245, "sentence_chunk": "ClassEditor Parses Strings that represent classes to actual classes and vice-versa. When a class is not found, an IllegalArgumentException is thrown. By default, registered by BeanWrapperImpl. CustomBooleanEditor Customizable property editor for Boolean properties. By default, registered by BeanWrapperImpl but can be overridden by registering a custom instance of it as a custom editor. CustomCollectionEditor Property editor for collections, converting any source Collection to a given target Collection type. CustomDateEditor Customizable property editor for java.util. Date, supporting a custom DateFormat. NOT registered by default. Must be user- registered with the appropriate format as needed.", "chunk_char_count": 702, "chunk_word_count": 93, "chunk_token_count": 175.5}, {"page_number": 245, "sentence_chunk": "CustomNumberEditor Customizable property editor for any Number subclass, such as Integer, Long, Float, or Double. By default, registered by BeanWrapperImpl but can be overridden by registering a custom instance of it as a custom editor. FileEditor Resolves strings to java.io. File objects. By default, registered by BeanWrapperImpl. InputStreamEditor One-way property editor that can take a string and produce (through an intermediate ResourceEditor and Resource) an InputStream so that InputStream properties may be directly set as strings. Note that the default usage does not close the InputStream for you. By default, registered by BeanWrapperImpl. LocaleEditor Can resolve strings to Locale objects and vice-versa (the string format is [language]_[country]_[variant], same as the toString() method of Locale). Also accepts spaces as separators, as an alternative to underscores.", "chunk_char_count": 884, "chunk_word_count": 124, "chunk_token_count": 221.0}, {"page_number": 246, "sentence_chunk": "Class Explanation PatternEditor Can resolve strings to java.util.regex. Pattern objects and vice- versa. PropertiesEditor Can convert strings (formatted with the format defined in the javadoc of the java.util. Properties class) to Properties objects. By default, registered by BeanWrapperImpl. StringTrimmerEditor Property editor that trims strings. Optionally allows transforming an empty string into a null value. NOT registered by default\u2009\u2014\u2009must be user-registered. URLEditor Can resolve a string representation of a URL to an actual URL object. By default, registered by BeanWrapperImpl.", "chunk_char_count": 591, "chunk_word_count": 79, "chunk_token_count": 147.75}, {"page_number": 246, "sentence_chunk": "Spring uses the java.beans. PropertyEditorManager to set the search path for property editors that might be needed. The search path also includes sun.bean.editors, which includes PropertyEditor implementations for types such as Font, Color, and most of the primitive types. Note also that the standard JavaBeans infrastructure automatically discovers PropertyEditor classes (without you having to register them explicitly) if they are in the same package as the class they handle and have the same name as that class, with Editor appended. For example, one could have the following class and package structure, which would be sufficient for the SomethingEditor class to be recognized and used as the PropertyEditor for Something-typed properties.com \u00a0 chank \u00a0  pop \u00a0   Something \u00a0   SomethingEditor // the PropertyEditor for the Something class Note that you can also use the standard BeanInfo JavaBeans mechanism here as well (described to some extent here). The following example uses the BeanInfo mechanism to explicitly register one or more PropertyEditor instances with the properties of an associated class: com \u00a0 chank \u00a0  pop \u00a0   Something \u00a0   SomethingBeanInfo // the BeanInfo for the Something class The following Java source code for the referenced SomethingBeanInfo class associates a CustomNumberEditor with the age property of the Something class: 246", "chunk_char_count": 1364, "chunk_word_count": 214, "chunk_token_count": 341.0}, {"page_number": 247, "sentence_chunk": "Java public class SomethingBeanInfo extends SimpleBeanInfo { \u00a0  public PropertyDescriptor[] getPropertyDescriptors() { \u00a0    try { \u00a0      final PropertyEditor numberPE = new CustomNumberEditor(Integer.class, true); \u00a0      PropertyDescriptor ageDescriptor = new PropertyDescriptor(\"age\", Something.class) { \u00a0        @Override \u00a0        public PropertyEditor createPropertyEditor(Object bean) { \u00a0          return numberPE; \u00a0        } \u00a0      }; \u00a0      return new PropertyDescriptor[] { ageDescriptor }; \u00a0    } \u00a0    catch (IntrospectionException ex) { \u00a0      throw new Error(ex.toString()); \u00a0    } \u00a0  } } Kotlin class SomethingBeanInfo : SimpleBeanInfo() { \u00a0  override fun getPropertyDescriptors(): Array<PropertyDescriptor> { \u00a0    try { \u00a0      val numberPE = CustomNumberEditor(Int::class.java, true) \u00a0      val ageDescriptor = object : PropertyDescriptor(\"age\", Something::class.java) { \u00a0        override fun createPropertyEditor(bean: Any): PropertyEditor { \u00a0          return numberPE \u00a0        } \u00a0      } \u00a0      return arrayOf(ageDescriptor) \u00a0    } catch (ex: IntrospectionException) { \u00a0      throw Error(ex.toString()) \u00a0    } \u00a0  } } Registering Additional Custom PropertyEditor Implementations When setting bean properties as string values, a Spring IoC container ultimately uses standard JavaBeans PropertyEditor implementations to convert these strings to the complex type of the property. Spring pre-registers a number of custom PropertyEditor implementations (for example, to convert a class name expressed as a string into a Class object). Additionally, Java\u2019s standard 247", "chunk_char_count": 1576, "chunk_word_count": 318, "chunk_token_count": 394.0}, {"page_number": 248, "sentence_chunk": "JavaBeans PropertyEditor lookup mechanism lets a PropertyEditor for a class be named appropriately and placed in the same package as the class for which it provides support, so that it can be found automatically. If there is a need to register other custom PropertyEditors, several mechanisms are available. The most manual approach, which is not normally convenient or recommended, is to use the registerCustomEditor() method of the ConfigurableBeanFactory interface, assuming you have a BeanFactory reference. Another (slightly more convenient) mechanism is to use a special bean factory post-processor called CustomEditorConfigurer. Although you can use bean factory post- processors with BeanFactory implementations, the CustomEditorConfigurer has a nested property setup, so we strongly recommend that you use it with the ApplicationContext, where you can deploy it in similar fashion to any other bean and where it can be automatically detected and applied. Note that all bean factories and application contexts automatically use a number of built-in property editors, through their use of a BeanWrapper to handle property conversions. The standard property editors that the BeanWrapper registers are listed in the previous section. Additionally, ApplicationContexts also override or add additional editors to handle resource lookups in a manner appropriate to the specific application context type. Standard JavaBeans PropertyEditor instances are used to convert property values expressed as strings to the actual complex type of the property. You can use CustomEditorConfigurer, a bean factory post-processor, to conveniently add support for additional PropertyEditor instances to an ApplicationContext.", "chunk_char_count": 1711, "chunk_word_count": 242, "chunk_token_count": 427.75}, {"page_number": 248, "sentence_chunk": "Consider the following example, which defines a user class called ExoticType and another class called DependsOnExoticType, which needs ExoticType set as a property: Java package example; public class ExoticType { \u00a0  private String name; \u00a0  public ExoticType(String name) { \u00a0    this.name = name; \u00a0  } } public class DependsOnExoticType { \u00a0  private ExoticType type; \u00a0  public void setType(ExoticType type) { \u00a0    this.type = type; \u00a0  } } 248", "chunk_char_count": 441, "chunk_word_count": 80, "chunk_token_count": 110.25}, {"page_number": 249, "sentence_chunk": "Kotlin package example class ExoticType(val name: String) class DependsOnExoticType { \u00a0  var type: ExoticType?= null } When things are properly set up, we want to be able to assign the type property as a string, which a PropertyEditor converts into an actual ExoticType instance. The following bean definition shows how to set up this relationship: <bean id=\"sample\" class=\"example. DependsOnExoticType\"> \u00a0  <property name=\"type\" value=\"aNameForExoticType\"/> </bean> The PropertyEditor implementation could look similar to the following: Java // converts string representation to ExoticType object package example; public class ExoticTypeEditor extends PropertyEditorSupport { \u00a0  public void setAsText(String text) { \u00a0    setValue(new ExoticType(text.toUpperCase())); \u00a0  } } Kotlin // converts string representation to ExoticType object package example import java.beans. PropertyEditorSupport class ExoticTypeEditor : PropertyEditorSupport() { \u00a0  override fun setAsText(text: String) { \u00a0    value = ExoticType(text.toUpperCase()) \u00a0  } } Finally, the following example shows how to use CustomEditorConfigurer to register the new 249", "chunk_char_count": 1132, "chunk_word_count": 158, "chunk_token_count": 283.0}, {"page_number": 250, "sentence_chunk": "PropertyEditor with the ApplicationContext, which will then be able to use it as needed: <bean class=\"org.springframework.beans.factory.config. CustomEditorConfigurer\"> \u00a0  <property name=\"customEditors\"> \u00a0    <map> \u00a0      <entry key=\"example. ExoticType\" value=\"example. ExoticTypeEditor\"/> \u00a0    </map> \u00a0  </property> </bean> Using PropertyEditorRegistrar Another mechanism for registering property editors with the Spring container is to create and use a PropertyEditorRegistrar. This interface is particularly useful when you need to use the same set of property editors in several different situations. You can write a corresponding registrar and reuse it in each case. PropertyEditorRegistrar instances work in conjunction with an interface called PropertyEditorRegistry, an interface that is implemented by the Spring BeanWrapper (and DataBinder). PropertyEditorRegistrar instances are particularly convenient when used in conjunction with CustomEditorConfigurer (described here), which exposes a property called setPropertyEditorRegistrars(..). PropertyEditorRegistrar instances added to a CustomEditorConfigurer in this fashion can easily be shared with DataBinder and Spring MVC controllers. Furthermore, it avoids the need for synchronization on custom editors: A PropertyEditorRegistrar is expected to create fresh PropertyEditor instances for each bean creation attempt.", "chunk_char_count": 1381, "chunk_word_count": 180, "chunk_token_count": 345.25}, {"page_number": 250, "sentence_chunk": "The following example shows how to create your own PropertyEditorRegistrar implementation: Java package com.foo.editors.spring; public final class CustomPropertyEditorRegistrar implements PropertyEditorRegistrar { \u00a0  public void registerCustomEditors(PropertyEditorRegistry registry) { \u00a0    // it is expected that new PropertyEditor instances are created \u00a0    registry.registerCustomEditor(ExoticType.class, new ExoticTypeEditor()); \u00a0    // you could register as many custom property editors as are required here... \u00a0  } } 250", "chunk_char_count": 526, "chunk_word_count": 71, "chunk_token_count": 131.5}, {"page_number": 251, "sentence_chunk": "Kotlin package com.foo.editors.spring import org.springframework.beans. PropertyEditorRegistrar import org.springframework.beans. PropertyEditorRegistry class CustomPropertyEditorRegistrar : PropertyEditorRegistrar { \u00a0  override fun registerCustomEditors(registry: PropertyEditorRegistry) { \u00a0    // it is expected that new PropertyEditor instances are created \u00a0    registry.registerCustomEditor(ExoticType::class.java, ExoticTypeEditor()) \u00a0    // you could register as many custom property editors as are required here... \u00a0  } } See also the org.springframework.beans.support. ResourceEditorRegistrar for an example PropertyEditorRegistrar implementation. Notice how in its implementation of the registerCustomEditors(..) method, it creates new instances of each property editor. The next example shows how to configure a CustomEditorConfigurer and inject an instance of our CustomPropertyEditorRegistrar into it: <bean class=\"org.springframework.beans.factory.config. CustomEditorConfigurer\"> \u00a0  <property name=\"propertyEditorRegistrars\"> \u00a0    <list> \u00a0      <ref bean=\"customPropertyEditorRegistrar\"/> \u00a0    </list> \u00a0  </property> </bean> <bean id=\"customPropertyEditorRegistrar\" \u00a0  class=\"com.foo.editors.spring. CustomPropertyEditorRegistrar\"/> Finally (and in a bit of a departure from the focus of this chapter) for those of you using Spring\u2019s MVC web framework, using a PropertyEditorRegistrar in conjunction with data-binding web controllers can be very convenient. The following example uses a PropertyEditorRegistrar in the implementation of an @InitBinder method: 251", "chunk_char_count": 1576, "chunk_word_count": 192, "chunk_token_count": 394.0}, {"page_number": 252, "sentence_chunk": "Java @Controller public class RegisterUserController { \u00a0  private final PropertyEditorRegistrar customPropertyEditorRegistrar; \u00a0  RegisterUserController(PropertyEditorRegistrar propertyEditorRegistrar) { \u00a0    this.customPropertyEditorRegistrar = propertyEditorRegistrar; \u00a0  } \u00a0  @InitBinder \u00a0  void initBinder(WebDataBinder binder) { \u00a0    this.customPropertyEditorRegistrar.registerCustomEditors(binder); \u00a0  } \u00a0  // other methods related to registering a User } Kotlin @Controller class RegisterUserController( \u00a0  private val customPropertyEditorRegistrar: PropertyEditorRegistrar) { \u00a0  @InitBinder \u00a0  fun initBinder(binder: WebDataBinder) { \u00a0    this.customPropertyEditorRegistrar.registerCustomEditors(binder) \u00a0  } \u00a0  // other methods related to registering a User } This style of PropertyEditor registration can lead to concise code (the implementation of the @InitBinder method is only one line long) and lets common PropertyEditor registration code be encapsulated in a class and then shared amongst as many controllers as needed.2.3.4. Spring Type Conversion Spring 3 introduced a core.convert package that provides a general type conversion system. The system defines an SPI to implement type conversion logic and an API to perform type conversions at runtime. Within a Spring container, you can use this system as an alternative to PropertyEditor implementations to convert externalized bean property value strings to the required property types. You can also use the public API anywhere in your application where type conversion is needed. Converter SPI The SPI to implement type conversion logic is simple and strongly typed, as the following interface 252", "chunk_char_count": 1666, "chunk_word_count": 232, "chunk_token_count": 416.5}, {"page_number": 253, "sentence_chunk": "definition shows: package org.springframework.core.convert.converter; public interface Converter<S, T> { \u00a0  T convert(S source); } To create your own converter, implement the Converter interface and parameterize S as the type you are converting from and T as the type you are converting to. You can also transparently apply such a converter if a collection or array of S needs to be converted to an array or collection of T, provided that a delegating array or collection converter has been registered as well (which DefaultConversionService does by default). For each call to convert(S), the source argument is guaranteed to not be null. Your Converter may throw any unchecked exception if conversion fails. Specifically, it should throw an IllegalArgumentException to report an invalid source value. Take care to ensure that your Converter implementation is thread-safe. Several converter implementations are provided in the core.convert.support package as a convenience. These include converters from strings to numbers and other common types. The following listing shows the StringToInteger class, which is a typical Converter implementation: package org.springframework.core.convert.support; final class StringToInteger implements Converter<String, Integer> { \u00a0  public Integer convert(String source) { \u00a0    return Integer.valueOf(source); \u00a0  } } Using ConverterFactory When you need to centralize the conversion logic for an entire class hierarchy (for example, when converting from String to Enum objects), you can implement ConverterFactory, as the following example shows: package org.springframework.core.convert.converter; public interface ConverterFactory<S, R> { \u00a0  <T extends R> Converter<S, T> getConverter(Class<T> targetType); } Parameterize S to be the type you are converting from and R to be the base type defining the range 253", "chunk_char_count": 1848, "chunk_word_count": 266, "chunk_token_count": 462.0}, {"page_number": 254, "sentence_chunk": "of classes you can convert to. Then implement getConverter(Class<T>), where T is a subclass of R. Consider the StringToEnumConverterFactory as an example: package org.springframework.core.convert.support; final class StringToEnumConverterFactory implements ConverterFactory<String, Enum> { \u00a0  public <T extends Enum> Converter<String, T> getConverter(Class<T> targetType) { \u00a0    return new StringToEnumConverter(targetType); \u00a0  } \u00a0  private final class StringToEnumConverter<T extends Enum> implements Converter<String, T> { \u00a0    private Class<T> enumType; \u00a0    public StringToEnumConverter(Class<T> enumType) { \u00a0      this.enumType = enumType; \u00a0    } \u00a0    public T convert(String source) { \u00a0      return (T) Enum.valueOf(this.enumType, source.trim()); \u00a0    } \u00a0  } } Using GenericConverter When you require a sophisticated Converter implementation, consider using the GenericConverter interface. With a more flexible but less strongly typed signature than Converter, a GenericConverter supports converting between multiple source and target types. In addition, a GenericConverter makes available source and target field context that you can use when you implement your conversion logic. Such context lets a type conversion be driven by a field annotation or by generic information declared on a field signature. The following listing shows the interface definition of GenericConverter: package org.springframework.core.convert.converter; public interface GenericConverter { \u00a0  public Set<ConvertiblePair> getConvertibleTypes(); \u00a0  Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType); } To implement a GenericConverter, have getConvertibleTypes() return the supported source\u2192target 254", "chunk_char_count": 1716, "chunk_word_count": 239, "chunk_token_count": 429.0}, {"page_number": 255, "sentence_chunk": "type pairs. Then implement convert(Object, TypeDescriptor, TypeDescriptor) to contain your conversion logic. The source TypeDescriptor provides access to the source field that holds the value being converted. The target TypeDescriptor provides access to the target field where the converted value is to be set. A good example of a GenericConverter is a converter that converts between a Java array and a collection. Such an ArrayToCollectionConverter introspects the field that declares the target collection type to resolve the collection\u2019s element type. This lets each element in the source array be converted to the collection element type before the collection is set on the target field.\uf05a Because GenericConverter is a more complex SPI interface, you should use it only when you need it. Favor Converter or ConverterFactory for basic type conversion needs. Using ConditionalGenericConverter Sometimes, you want a Converter to run only if a specific condition holds true.", "chunk_char_count": 975, "chunk_word_count": 146, "chunk_token_count": 243.75}, {"page_number": 255, "sentence_chunk": "For example, you might want to run a Converter only if a specific annotation is present on the target field, or you might want to run a Converter only if a specific method (such as a static valueOf method) is defined on the target class. ConditionalGenericConverter is the union of the GenericConverter and ConditionalConverter interfaces that lets you define such custom matching criteria: public interface ConditionalConverter { \u00a0  boolean matches(TypeDescriptor sourceType, TypeDescriptor targetType); } public interface ConditionalGenericConverter extends GenericConverter, ConditionalConverter { } A good example of a ConditionalGenericConverter is an IdToEntityConverter that converts between a persistent entity identifier and an entity reference. Such an IdToEntityConverter might match only if the target entity type declares a static finder method (for example, findAccount(Long)). You might perform such a finder method check in the implementation of matches(TypeDescriptor, TypeDescriptor). The ConversionService API ConversionService defines a unified API for executing type conversion logic at runtime. Converters are often run behind the following facade interface: 255", "chunk_char_count": 1184, "chunk_word_count": 161, "chunk_token_count": 296.0}, {"page_number": 256, "sentence_chunk": "package org.springframework.core.convert; public interface ConversionService { \u00a0  boolean canConvert(Class<?> sourceType, Class<?> targetType); \u00a0  <T> T convert(Object source, Class<T> targetType); \u00a0  boolean canConvert(TypeDescriptor sourceType, TypeDescriptor targetType); \u00a0  Object convert(Object source, TypeDescriptor sourceType, TypeDescriptor targetType); } Most ConversionService implementations also implement ConverterRegistry, which provides an SPI for registering converters. Internally, a ConversionService implementation delegates to its registered converters to carry out type conversion logic. A robust ConversionService implementation is provided in the core.convert.support package. GenericConversionService is the general-purpose implementation suitable for use in most environments. ConversionServiceFactory provides a convenient factory for creating common ConversionService configurations. Configuring a ConversionService A ConversionService is a stateless object designed to be instantiated at application startup and then shared between multiple threads. In a Spring application, you typically configure a ConversionService instance for each Spring container (or ApplicationContext). Spring picks up that ConversionService and uses it whenever a type conversion needs to be performed by the framework.", "chunk_char_count": 1325, "chunk_word_count": 154, "chunk_token_count": 331.25}, {"page_number": 256, "sentence_chunk": "You can also inject this ConversionService into any of your beans and invoke it directly.\uf05a If no ConversionService is registered with Spring, the original PropertyEditor-based system is used. To register a default ConversionService with Spring, add the following bean definition with an id of conversionService: <bean id=\"conversionService\" \u00a0  class=\"org.springframework.context.support. ConversionServiceFactoryBean\"/> A default ConversionService can convert between strings, numbers, enums, collections, maps, and other common types. To supplement or override the default converters with your own custom converters, set the converters property. Property values can implement any of the Converter, ConverterFactory, or GenericConverter interfaces.256", "chunk_char_count": 751, "chunk_word_count": 94, "chunk_token_count": 187.75}, {"page_number": 257, "sentence_chunk": "<bean id=\"conversionService\" \u00a0    class=\"org.springframework.context.support. ConversionServiceFactoryBean\"> \u00a0  <property name=\"converters\"> \u00a0    <set> \u00a0      <bean class=\"example. MyCustomConverter\"/> \u00a0    </set> \u00a0  </property> </bean> It is also common to use a ConversionService within a Spring MVC application. See Conversion and Formatting in the Spring MVC chapter. In certain situations, you may wish to apply formatting during conversion. See The FormatterRegistry SPI for details on using FormattingConversionServiceFactoryBean. Using a ConversionService Programmatically To work with a ConversionService instance programmatically, you can inject a reference to it like you would for any other bean. The following example shows how to do so: Java @Service public class MyService { \u00a0  public MyService(ConversionService conversionService) { \u00a0    this.conversionService = conversionService; \u00a0  } \u00a0  public void doIt() { \u00a0    this.conversionService.convert(...) \u00a0  } } Kotlin @Service class MyService(private val conversionService: ConversionService) { \u00a0  fun doIt() { \u00a0    conversionService.convert(...) \u00a0  } } For most use cases, you can use the convert method that specifies the targetType, but it does not work with more complex types, such as a collection of a parameterized element. For example, if you want to convert a List of Integer to a List of String programmatically, you need to provide a formal definition of the source and target types.257", "chunk_char_count": 1461, "chunk_word_count": 230, "chunk_token_count": 365.25}, {"page_number": 258, "sentence_chunk": "Fortunately, TypeDescriptor provides various options to make doing so straightforward, as the following example shows: Java DefaultConversionService cs = new DefaultConversionService(); List<Integer> input = ... cs.convert(input, \u00a0  TypeDescriptor.forObject(input), // List<Integer> type descriptor \u00a0  TypeDescriptor.collection(List.class, TypeDescriptor.valueOf(String.class))); Kotlin val cs = DefaultConversionService() val input: List<Integer> = ... cs.convert(input, \u00a0    TypeDescriptor.forObject(input), // List<Integer> type descriptor \u00a0    TypeDescriptor.collection(List::class.java, TypeDescriptor.valueOf(String::class.java))) Note that DefaultConversionService automatically registers converters that are appropriate for most environments. This includes collection converters, scalar converters, and basic Object-to-String converters. You can register the same converters with any ConverterRegistry by using the static addDefaultConverters method on the DefaultConversionService class. Converters for value types are reused for arrays and collections, so there is no need to create a specific converter to convert from a Collection of S to a Collection of T, assuming that standard collection handling is appropriate.2.3.5. Spring Field Formatting As discussed in the previous section, core.convert is a general-purpose type conversion system. It provides a unified ConversionService API as well as a strongly typed Converter SPI for implementing conversion logic from one type to another. A Spring container uses this system to bind bean property values. In addition, both the Spring Expression Language (SpEL) and DataBinder use this system to bind field values. For example, when SpEL needs to coerce a Short to a Long to complete an expression.setValue(Object bean, Object value) attempt, the core.convert system performs the coercion.", "chunk_char_count": 1850, "chunk_word_count": 236, "chunk_token_count": 462.5}, {"page_number": 258, "sentence_chunk": "Now consider the type conversion requirements of a typical client environment, such as a web or desktop application. In such environments, you typically convert from String to support the client postback process, as well as back to String to support the view rendering process. In addition, you often need to localize String values. The more general core.convert Converter SPI does not address such formatting requirements directly. To directly address them, Spring 3 introduced a convenient Formatter SPI that provides a simple and robust alternative to PropertyEditor implementations for client environments.258", "chunk_char_count": 613, "chunk_word_count": 90, "chunk_token_count": 153.25}, {"page_number": 259, "sentence_chunk": "In general, you can use the Converter SPI when you need to implement general-purpose type conversion logic\u2009\u2014\u2009for example, for converting between a java.util. Date and a Long. You can use the Formatter SPI when you work in a client environment (such as a web application) and need to parse and print localized field values. The ConversionService provides a unified type conversion API for both SPIs. The Formatter SPI The Formatter SPI to implement field formatting logic is simple and strongly typed. The following listing shows the Formatter interface definition: package org.springframework.format; public interface Formatter<T> extends Printer<T>, Parser<T> { } Formatter extends from the Printer and Parser building-block interfaces. The following listing shows the definitions of those two interfaces: public interface Printer<T> { \u00a0  String print(T fieldValue, Locale locale); } import java.text. ParseException; public interface Parser<T> { \u00a0  T parse(String clientValue, Locale locale) throws ParseException; } To create your own Formatter, implement the Formatter interface shown earlier. Parameterize T to be the type of object you wish to format\u2009\u2014\u2009for example, java.util. Date.", "chunk_char_count": 1188, "chunk_word_count": 173, "chunk_token_count": 297.0}, {"page_number": 259, "sentence_chunk": "Implement the print() operation to print an instance of T for display in the client locale. Implement the parse() operation to parse an instance of T from the formatted representation returned from the client locale. Your Formatter should throw a ParseException or an IllegalArgumentException if a parse attempt fails. Take care to ensure that your Formatter implementation is thread-safe. The format subpackages provide several Formatter implementations as a convenience. The number package provides NumberStyleFormatter, CurrencyStyleFormatter, and PercentStyleFormatter to format Number objects that use a java.text. NumberFormat. The datetime package provides a DateFormatter to format java.util. Date objects with a java.text. DateFormat.", "chunk_char_count": 743, "chunk_word_count": 101, "chunk_token_count": 185.75}, {"page_number": 260, "sentence_chunk": "Java package org.springframework.format.datetime; public final class DateFormatter implements Formatter<Date> { \u00a0  private String pattern; \u00a0  public DateFormatter(String pattern) { \u00a0    this.pattern = pattern; \u00a0  } \u00a0  public String print(Date date, Locale locale) { \u00a0    if (date == null) { \u00a0      return \"\"; \u00a0    } \u00a0    return getDateFormat(locale).format(date); \u00a0  } \u00a0  public Date parse(String formatted, Locale locale) throws ParseException { \u00a0    if (formatted.length() == 0) { \u00a0      return null; \u00a0    } \u00a0    return getDateFormat(locale).parse(formatted); \u00a0  } \u00a0  protected DateFormat getDateFormat(Locale locale) { \u00a0    DateFormat dateFormat = new SimpleDateFormat(this.pattern, locale); \u00a0    dateFormat.setLenient(false); \u00a0    return dateFormat; \u00a0  } } Kotlin class DateFormatter(private val pattern: String) : Formatter<Date> { \u00a0  override fun print(date: Date, locale: Locale) \u00a0      = getDateFormat(locale).format(date) \u00a0  @Throws(ParseException::class) \u00a0  override fun parse(formatted: String, locale: Locale) \u00a0      = getDateFormat(locale).parse(formatted) \u00a0  protected fun getDateFormat(locale: Locale): DateFormat { \u00a0    val dateFormat = SimpleDateFormat(this.pattern, locale) \u00a0    dateFormat.isLenient = false \u00a0    return dateFormat \u00a0  } } 260", "chunk_char_count": 1259, "chunk_word_count": 224, "chunk_token_count": 314.75}, {"page_number": 261, "sentence_chunk": "The Spring team welcomes community-driven Formatter contributions. See GitHub Issues to contribute. Annotation-driven Formatting Field formatting can be configured by field type or annotation. To bind an annotation to a Formatter, implement AnnotationFormatterFactory. The following listing shows the definition of the AnnotationFormatterFactory interface: package org.springframework.format; public interface AnnotationFormatterFactory<A extends Annotation> { \u00a0  Set<Class<?>> getFieldTypes(); \u00a0  Printer<?> getPrinter(A annotation, Class<?> fieldType); \u00a0  Parser<?> getParser(A annotation, Class<?> fieldType); } To create an implementation: 1.", "chunk_char_count": 646, "chunk_word_count": 75, "chunk_token_count": 161.5}, {"page_number": 261, "sentence_chunk": "Parameterize A to be the field annotationType with which you wish to associate formatting logic\u2009\u2014\u2009for example org.springframework.format.annotation. DateTimeFormat.2. Have getFieldTypes() return the types of fields on which the annotation can be used.3. Have getPrinter() return a Printer to print the value of an annotated field.4. Have getParser() return a Parser to parse a clientValue for an annotated field. The following example AnnotationFormatterFactory implementation binds the @NumberFormat annotation to a formatter to let a number style or pattern be specified: 261", "chunk_char_count": 577, "chunk_word_count": 80, "chunk_token_count": 144.25}, {"page_number": 262, "sentence_chunk": "Java public final class NumberFormatAnnotationFormatterFactory \u00a0    implements AnnotationFormatterFactory<NumberFormat> { \u00a0  public Set<Class<?>> getFieldTypes() { \u00a0    return new HashSet<Class<?>>(asList(new Class<?>[] { \u00a0      Short.class, Integer.class, Long.class, Float.class, \u00a0      Double.class, BigDecimal.class, BigInteger.class })); \u00a0  } \u00a0  public Printer<Number> getPrinter(NumberFormat annotation, Class<?> fieldType) { \u00a0    return configureFormatterFrom(annotation, fieldType); \u00a0  } \u00a0  public Parser<Number> getParser(NumberFormat annotation, Class<?> fieldType) { \u00a0    return configureFormatterFrom(annotation, fieldType); \u00a0  } \u00a0  private Formatter<Number> configureFormatterFrom(NumberFormat annotation, Class<?> fieldType) { \u00a0    if (!annotation.pattern().isEmpty()) { \u00a0      return new NumberStyleFormatter(annotation.pattern()); \u00a0    } else { \u00a0      Style style = annotation.style(); \u00a0      if (style == Style. PERCENT) { \u00a0        return new PercentStyleFormatter(); \u00a0      } else if (style == Style. CURRENCY) { \u00a0        return new CurrencyStyleFormatter(); \u00a0      } else { \u00a0        return new NumberStyleFormatter(); \u00a0      } \u00a0    } \u00a0  } } 262", "chunk_char_count": 1163, "chunk_word_count": 215, "chunk_token_count": 290.75}, {"page_number": 263, "sentence_chunk": "Kotlin class NumberFormatAnnotationFormatterFactory : AnnotationFormatterFactory<NumberFormat> { \u00a0  override fun getFieldTypes(): Set<Class<*>> { \u00a0    return setOf(Short::class.java, Int::class.java, Long::class.java, Float::class.java, Double::class.java, BigDecimal::class.java, BigInteger::class.java) \u00a0  } \u00a0  override fun getPrinter(annotation: NumberFormat, fieldType: Class<*>): Printer<Number> { \u00a0    return configureFormatterFrom(annotation, fieldType) \u00a0  } \u00a0  override fun getParser(annotation: NumberFormat, fieldType: Class<*>): Parser<Number> { \u00a0    return configureFormatterFrom(annotation, fieldType) \u00a0  } \u00a0  private fun configureFormatterFrom(annotation: NumberFormat, fieldType: Class<*>): Formatter<Number> { \u00a0    return if (annotation.pattern.isNotEmpty()) { \u00a0      NumberStyleFormatter(annotation.pattern) \u00a0    } else { \u00a0      val style = annotation.style \u00a0      when { \u00a0        style === NumberFormat. Style. PERCENT -> PercentStyleFormatter() \u00a0        style === NumberFormat. Style. CURRENCY -> CurrencyStyleFormatter() \u00a0        else -> NumberStyleFormatter() \u00a0      } \u00a0    } \u00a0  } } To trigger formatting, you can annotate fields with @NumberFormat, as the following example shows: Java public class MyModel { \u00a0  @NumberFormat(style=Style. CURRENCY) \u00a0  private BigDecimal decimal; } 263", "chunk_char_count": 1307, "chunk_word_count": 205, "chunk_token_count": 326.75}, {"page_number": 264, "sentence_chunk": "Kotlin class MyModel( \u00a0  @field:NumberFormat(style = Style. CURRENCY) private val decimal: BigDecimal ) Format Annotation API A portable format annotation API exists in the org.springframework.format.annotation package. You can use @NumberFormat to format Number fields such as Double and Long, and @DateTimeFormat to format java.util. Date, java.util. Calendar, Long (for millisecond timestamps) as well as JSR-310 java.time. The following example uses @DateTimeFormat to format a java.util. Date as an ISO Date (yyyy-MM- dd): Java public class MyModel { \u00a0  @DateTimeFormat(iso=ISO. DATE) \u00a0  private Date date; } Kotlin class MyModel( \u00a0  @DateTimeFormat(iso=ISO. DATE) private val date: Date ) The FormatterRegistry SPI The FormatterRegistry is an SPI for registering formatters and converters. FormattingConversionService is an implementation of FormatterRegistry suitable for most environments. You can programmatically or declaratively configure this variant as a Spring bean, e.g. by using FormattingConversionServiceFactoryBean. Because this implementation also implements ConversionService, you can directly configure it for use with Spring\u2019s DataBinder and the Spring Expression Language (SpEL).", "chunk_char_count": 1203, "chunk_word_count": 161, "chunk_token_count": 300.75}, {"page_number": 265, "sentence_chunk": "package org.springframework.format; public interface FormatterRegistry extends ConverterRegistry { \u00a0  void addPrinter(Printer<?> printer); \u00a0  void addParser(Parser<?> parser); \u00a0  void addFormatter(Formatter<?> formatter); \u00a0  void addFormatterForFieldType(Class<?> fieldType, Formatter<?> formatter); \u00a0  void addFormatterForFieldType(Class<?> fieldType, Printer<?> printer, Parser<?> parser); \u00a0  void addFormatterForFieldAnnotation(AnnotationFormatterFactory<?extends Annotation> annotationFormatterFactory); } As shown in the preceding listing, you can register formatters by field type or by annotation.", "chunk_char_count": 604, "chunk_word_count": 62, "chunk_token_count": 151.0}, {"page_number": 265, "sentence_chunk": "The FormatterRegistry SPI lets you configure formatting rules centrally, instead of duplicating such configuration across your controllers. For example, you might want to enforce that all date fields are formatted a certain way or that fields with a specific annotation are formatted in a certain way. With a shared FormatterRegistry, you define these rules once, and they are applied whenever formatting is needed. The FormatterRegistrar SPI FormatterRegistrar is an SPI for registering formatters and converters through the FormatterRegistry. The following listing shows its interface definition: package org.springframework.format; public interface FormatterRegistrar { \u00a0  void registerFormatters(FormatterRegistry registry); } A FormatterRegistrar is useful when registering multiple related converters and formatters for a given formatting category, such as date formatting. It can also be useful where declarative registration is insufficient\u2009\u2014\u2009for example, when a formatter needs to be indexed under a specific field type different from its own <T> or when registering a Printer/Parser pair. The next section provides more information on converter and formatter registration. Configuring Formatting in Spring MVC See Conversion and Formatting in the Spring MVC chapter.265", "chunk_char_count": 1279, "chunk_word_count": 176, "chunk_token_count": 319.75}, {"page_number": 266, "sentence_chunk": "2.3.6. Configuring a Global Date and Time Format By default, date and time fields not annotated with @DateTimeFormat are converted from strings by using the DateFormat. SHORT style. If you prefer, you can change this by defining your own global format. To do that, ensure that Spring does not register default formatters. Instead, register formatters manually with the help of: \u2022 org.springframework.format.datetime.standard. DateTimeFormatterRegistrar \u2022 org.springframework.format.datetime. DateFormatterRegistrar For example, the following Java configuration registers a global yyyyMMdd format: Java @Configuration public class AppConfig { \u00a0  @Bean \u00a0  public FormattingConversionService conversionService() { \u00a0    // Use the DefaultFormattingConversionService but do not register defaults \u00a0    DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService(false); \u00a0    // Ensure @NumberFormat is still supported \u00a0    conversionService.addFormatterForFieldAnnotation(new NumberFormatAnnotationFormatterFactory()); \u00a0    // Register JSR-310 date conversion with a specific global format \u00a0    DateTimeFormatterRegistrar registrar = new DateTimeFormatterRegistrar(); \u00a0    registrar.setDateFormatter(DateTimeFormatter.ofPattern(\"yyyyMMdd\")); \u00a0    registrar.registerFormatters(conversionService); \u00a0    // Register date conversion with a specific global format \u00a0    DateFormatterRegistrar registrar = new DateFormatterRegistrar(); \u00a0    registrar.setFormatter(new DateFormatter(\"yyyyMMdd\")); \u00a0    registrar.registerFormatters(conversionService); \u00a0    return conversionService; \u00a0  } } 266", "chunk_char_count": 1612, "chunk_word_count": 207, "chunk_token_count": 403.0}, {"page_number": 267, "sentence_chunk": "Kotlin @Configuration class AppConfig { \u00a0  @Bean \u00a0  fun conversionService(): FormattingConversionService { \u00a0    // Use the DefaultFormattingConversionService but do not register defaults \u00a0    return DefaultFormattingConversionService(false).apply { \u00a0      // Ensure @NumberFormat is still supported \u00a0      addFormatterForFieldAnnotation(NumberFormatAnnotationFormatterFactory()) \u00a0      // Register JSR-310 date conversion with a specific global format \u00a0      val registrar = DateTimeFormatterRegistrar() \u00a0      registrar.setDateFormatter(DateTimeFormatter.ofPattern(\"yyyyMMdd\")) \u00a0      registrar.registerFormatters(this) \u00a0      // Register date conversion with a specific global format \u00a0      val registrar = DateFormatterRegistrar() \u00a0      registrar.setFormatter(DateFormatter(\"yyyyMMdd\")) \u00a0      registrar.registerFormatters(this) \u00a0    } \u00a0  } } If you prefer XML-based configuration, you can use a FormattingConversionServiceFactoryBean. The following example shows how to do so: 267", "chunk_char_count": 985, "chunk_word_count": 160, "chunk_token_count": 246.25}, {"page_number": 268, "sentence_chunk": "<?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd> \u00a0  <bean id=\"conversionService\" class=\"org.springframework.format.support. FormattingConversionServiceFactoryBean\"> \u00a0    <property name=\"registerDefaultFormatters\" value=\"false\" /> \u00a0    <property name=\"formatters\"> \u00a0      <set> \u00a0        <bean class=\"org.springframework.format.number. NumberFormatAnnotationFormatterFactory\" /> \u00a0      </set> \u00a0    </property> \u00a0    <property name=\"formatterRegistrars\"> \u00a0      <set> \u00a0        <bean class=\"org.springframework.format.datetime.standard. DateTimeFormatterRegistrar\"> \u00a0          <property name=\"dateFormatter\"> \u00a0            <bean class=\"org.springframework.format.datetime.standard. DateTimeFormatterFactoryBean\"> \u00a0              <property name=\"pattern\" value=\"yyyyMMdd\"/> \u00a0            </bean> \u00a0          </property> \u00a0        </bean> \u00a0      </set> \u00a0    </property> \u00a0  </bean> </beans> Note there are extra considerations when configuring date and time formats in web applications. Please see WebMVC Conversion and Formatting or WebFlux Conversion and Formatting.2.3.7. Java Bean Validation The Spring Framework provides support for the Java Bean Validation API.", "chunk_char_count": 1401, "chunk_word_count": 228, "chunk_token_count": 350.25}, {"page_number": 268, "sentence_chunk": "Overview of Bean Validation Bean Validation provides a common way of validation through constraint declaration and metadata for Java applications. To use it, you annotate domain model properties with declarative validation constraints which are then enforced by the runtime. There are built-in constraints, and you can also define your own custom constraints. Consider the following example, which shows a simple PersonForm model with two properties: 268", "chunk_char_count": 454, "chunk_word_count": 66, "chunk_token_count": 113.5}, {"page_number": 269, "sentence_chunk": "Java public class PersonForm { \u00a0  private String name; \u00a0  private int age; } Kotlin class PersonForm( \u00a0    private val name: String, \u00a0    private val age: Int ) Bean Validation lets you declare constraints as the following example shows: Java public class PersonForm { \u00a0  @NotNull \u00a0  @Size(max=64) \u00a0  private String name; \u00a0  @Min(0) \u00a0  private int age; } Kotlin class PersonForm( \u00a0  @get:NotNull @get:Size(max=64) \u00a0  private val name: String, \u00a0  @get:Min(0) \u00a0  private val age: Int ) A Bean Validation validator then validates instances of this class based on the declared constraints. See Bean Validation for general information about the API. See the Hibernate Validator documentation for specific constraints. To learn how to set up a bean validation provider as a Spring bean, keep reading. Configuring a Bean Validation Provider Spring provides full support for the Bean Validation API including the bootstrapping of a Bean Validation provider as a Spring bean. This lets you inject a jakarta.validation. ValidatorFactory or jakarta.validation. Validator wherever validation is needed in your application.269", "chunk_char_count": 1113, "chunk_word_count": 186, "chunk_token_count": 278.25}, {"page_number": 270, "sentence_chunk": "You can use the LocalValidatorFactoryBean to configure a default Validator as a Spring bean, as the following example shows: Java import org.springframework.validation.beanvalidation. LocalValidatorFactoryBean; @Configuration public class AppConfig { \u00a0  @Bean \u00a0  public LocalValidatorFactoryBean validator() { \u00a0    return new LocalValidatorFactoryBean(); \u00a0  } } XML <bean id=\"validator\" \u00a0  class=\"org.springframework.validation.beanvalidation. LocalValidatorFactoryBean\"/> The basic configuration in the preceding example triggers bean validation to initialize by using its default bootstrap mechanism. A Bean Validation provider, such as the Hibernate Validator, is expected to be present in the classpath and is automatically detected. Injecting a Validator LocalValidatorFactoryBean implements both jakarta.validation. ValidatorFactory and jakarta.validation. Validator, as well as Spring\u2019s org.springframework.validation. Validator. You can inject a reference to either of these interfaces into beans that need to invoke validation logic. You can inject a reference to jakarta.validation.", "chunk_char_count": 1092, "chunk_word_count": 136, "chunk_token_count": 273.0}, {"page_number": 270, "sentence_chunk": "Validator if you prefer to work with the Bean Validation API directly, as the following example shows: Java import jakarta.validation. Validator; @Service public class MyService { \u00a0  @Autowired \u00a0  private Validator validator; } 270", "chunk_char_count": 231, "chunk_word_count": 36, "chunk_token_count": 57.75}, {"page_number": 271, "sentence_chunk": "Kotlin import jakarta.validation. Validator; @Service class MyService(@Autowired private val validator: Validator) You can inject a reference to org.springframework.validation. Validator if your bean requires the Spring Validation API, as the following example shows: Java import org.springframework.validation. Validator; @Service public class MyService { \u00a0  @Autowired \u00a0  private Validator validator; } Kotlin import org.springframework.validation. Validator @Service class MyService(@Autowired private val validator: Validator) Configuring Custom Constraints Each bean validation constraint consists of two parts: \u2022 A @Constraint annotation that declares the constraint and its configurable properties. \u2022An implementation of the jakarta.validation. ConstraintValidator interface that implements the constraint\u2019s behavior. To associate a declaration with an implementation, each @Constraint annotation references a corresponding ConstraintValidator implementation class. At runtime, a ConstraintValidatorFactory instantiates the referenced implementation when the constraint annotation is encountered in your domain model. By default, the LocalValidatorFactoryBean configures a SpringConstraintValidatorFactory that uses Spring to create ConstraintValidator instances.", "chunk_char_count": 1270, "chunk_word_count": 144, "chunk_token_count": 317.5}, {"page_number": 271, "sentence_chunk": "This lets your custom ConstraintValidators benefit from dependency injection like any other Spring bean. The following example shows a custom @Constraint declaration followed by an associated ConstraintValidator implementation that uses Spring for dependency injection: 271", "chunk_char_count": 273, "chunk_word_count": 35, "chunk_token_count": 68.25}, {"page_number": 272, "sentence_chunk": "Java @Target({ElementType. METHOD, ElementType. FIELD}) @Retention(RetentionPolicy. RUNTIME) @Constraint(validatedBy=MyConstraintValidator.class) public @interface MyConstraint { } Kotlin @Target(AnnotationTarget. FUNCTION, AnnotationTarget. FIELD) @Retention(AnnotationRetention. RUNTIME) @Constraint(validatedBy = MyConstraintValidator::class) annotation class MyConstraint Java import jakarta.validation. ConstraintValidator; public class MyConstraintValidator implements ConstraintValidator { \u00a0  @Autowired; \u00a0  private Foo aDependency; \u00a0  // ... } Kotlin import jakarta.validation. ConstraintValidator class MyConstraintValidator(private val aDependency: Foo) : ConstraintValidator { \u00a0  // ... } As the preceding example shows, a ConstraintValidator implementation can have its dependencies @Autowired as any other Spring bean. Spring-driven Method Validation You can integrate the method validation feature supported by Bean Validation 1.1 (and, as a custom extension, also by Hibernate Validator 4.3) into a Spring context through a MethodValidationPostProcessor bean definition: 272", "chunk_char_count": 1089, "chunk_word_count": 119, "chunk_token_count": 272.25}, {"page_number": 273, "sentence_chunk": "Java import org.springframework.validation.beanvalidation. MethodValidationPostProcessor; @Configuration public class AppConfig { \u00a0  @Bean \u00a0  public MethodValidationPostProcessor validationPostProcessor() { \u00a0    return new MethodValidationPostProcessor(); \u00a0  } } XML <bean class=\"org.springframework.validation.beanvalidation. MethodValidationPostProcessor\"/> To be eligible for Spring-driven method validation, all target classes need to be annotated with Spring\u2019s @Validated annotation, which can optionally also declare the validation groups to use. See MethodValidationPostProcessor for setup details with the Hibernate Validator and Bean Validation 1.1 providers.\uf0eb Method validation relies on AOP Proxies around the target classes, either JDK dynamic proxies for methods on interfaces or CGLIB proxies. There are certain limitations with the use of proxies, some of which are described in Understanding AOP Proxies. In addition remember to always use methods and accessors on proxied classes; direct field access will not work. Additional Configuration Options The default LocalValidatorFactoryBean configuration suffices for most cases. There are a number of configuration options for various Bean Validation constructs, from message interpolation to traversal resolution. See the LocalValidatorFactoryBean javadoc for more information on these options.", "chunk_char_count": 1359, "chunk_word_count": 171, "chunk_token_count": 339.75}, {"page_number": 273, "sentence_chunk": "Configuring a DataBinder Since Spring 3, you can configure a DataBinder instance with a Validator. Once configured, you can invoke the Validator by calling binder.validate(). Any validation Errors are automatically added to the binder\u2019s BindingResult. The following example shows how to use a DataBinder programmatically to invoke validation logic after binding to a target object: 273", "chunk_char_count": 385, "chunk_word_count": 56, "chunk_token_count": 96.25}, {"page_number": 274, "sentence_chunk": "Java Foo target = new Foo(); DataBinder binder = new DataBinder(target); binder.setValidator(new FooValidator()); // bind to the target object binder.bind(propertyValues); // validate the target object binder.validate(); // get BindingResult that includes any validation errors BindingResult results = binder.getBindingResult(); Kotlin val target = Foo() val binder = DataBinder(target) binder.validator = FooValidator() // bind to the target object binder.bind(propertyValues) // validate the target object binder.validate() // get BindingResult that includes any validation errors val results = binder.bindingResult You can also configure a DataBinder with multiple Validator instances through dataBinder.addValidators and dataBinder.replaceValidators. This is useful when combining globally configured bean validation with a Spring Validator configured locally on a DataBinder instance. See Spring MVC Validation Configuration. Spring MVC 3 Validation See Validation in the Spring MVC chapter.2.4. Spring Expression Language (SpEL) The Spring Expression Language (\u201cSpEL\u201d for short) is a powerful expression language that supports querying and manipulating an object graph at runtime. The language syntax is similar to Unified EL but offers additional features, most notably method invocation and basic string templating functionality. While there are several other Java expression languages available\u2009\u2014\u2009OGNL, MVEL, and JBoss EL, to name a few\u2009\u2014\u2009the Spring Expression Language was created to provide the Spring community with a single well supported expression language that can be used across all the products in the Spring 274", "chunk_char_count": 1630, "chunk_word_count": 217, "chunk_token_count": 407.5}, {"page_number": 275, "sentence_chunk": "portfolio. Its language features are driven by the requirements of the projects in the Spring portfolio, including tooling requirements for code completion support within the Spring Tools for Eclipse. That said, SpEL is based on a technology-agnostic API that lets other expression language implementations be integrated, should the need arise. While SpEL serves as the foundation for expression evaluation within the Spring portfolio, it is not directly tied to Spring and can be used independently. To be self contained, many of the examples in this chapter use SpEL as if it were an independent expression language. This requires creating a few bootstrapping infrastructure classes, such as the parser. Most Spring users need not deal with this infrastructure and can, instead, author only expression strings for evaluation. An example of this typical use is the integration of SpEL into creating XML or annotation-based bean definitions, as shown in Expression support for defining bean definitions. This chapter covers the features of the expression language, its API, and its language syntax. In several places, Inventor and Society classes are used as the target objects for expression evaluation.", "chunk_char_count": 1204, "chunk_word_count": 184, "chunk_token_count": 301.0}, {"page_number": 275, "sentence_chunk": "These class declarations and the data used to populate them are listed at the end of the chapter. The expression language supports the following functionality: \u2022 Literal expressions \u2022 Boolean and relational operators \u2022 Regular expressions \u2022 Class expressions \u2022 Accessing properties, arrays, lists, and maps \u2022 Method invocation \u2022 Relational operators \u2022 Assignment \u2022 Calling constructors \u2022 Bean references \u2022 Array construction \u2022 Inline lists \u2022 Inline maps \u2022 Ternary operator \u2022 Variables \u2022 User-defined functions \u2022 Collection projection \u2022 Collection selection \u2022 Templated expressions 2.4.1. Evaluation This section introduces the simple use of SpEL interfaces and its expression language. The complete 275", "chunk_char_count": 702, "chunk_word_count": 104, "chunk_token_count": 175.5}, {"page_number": 276, "sentence_chunk": "language reference can be found in Language Reference. The following code introduces the SpEL API to evaluate the literal string expression, Hello World. Java ExpressionParser parser = new SpelExpressionParser(); Expression exp = parser.parseExpression(\"'Hello World'\"); \u2460 String message = (String) exp.getValue(); \u2460 The value of the message variable is 'Hello World'. Kotlin val parser = SpelExpressionParser() val exp = parser.parseExpression(\"'Hello World'\") \u2460 val message = exp.value as String \u2460 The value of the message variable is 'Hello World'. The SpEL classes and interfaces you are most likely to use are located in the org.springframework.expression package and its sub-packages, such as spel.support. The ExpressionParser interface is responsible for parsing an expression string. In the preceding example, the expression string is a string literal denoted by the surrounding single quotation marks. The Expression interface is responsible for evaluating the previously defined expression string. Two exceptions that can be thrown, ParseException and EvaluationException, when calling parser.parseExpression and exp.getValue, respectively. SpEL supports a wide range of features, such as calling methods, accessing properties, and calling constructors.", "chunk_char_count": 1264, "chunk_word_count": 171, "chunk_token_count": 316.0}, {"page_number": 276, "sentence_chunk": "In the following example of method invocation, we call the concat method on the string literal: Java ExpressionParser parser = new SpelExpressionParser(); Expression exp = parser.parseExpression(\"'Hello World'.concat('!')\");\u2460 String message = (String) exp.getValue(); \u2460 The value of message is now 'Hello World!'. Kotlin val parser = SpelExpressionParser() val exp = parser.parseExpression(\"'Hello World'.concat('!')\")\u2460 val message = exp.value as String \u2460 The value of message is now 'Hello World!'. The following example of calling a JavaBean property calls the String property Bytes: 276", "chunk_char_count": 589, "chunk_word_count": 80, "chunk_token_count": 147.25}, {"page_number": 277, "sentence_chunk": "Java ExpressionParser parser = new SpelExpressionParser(); // invokes 'getBytes()' Expression exp = parser.parseExpression(\"'Hello World'.bytes\"); \u2460 byte[] bytes = (byte[]) exp.getValue(); \u2460 This line converts the literal to a byte array. Kotlin val parser = SpelExpressionParser() // invokes 'getBytes()' val exp = parser.parseExpression(\"'Hello World'.bytes\") \u2460 val bytes = exp.value as ByteArray \u2460 This line converts the literal to a byte array. SpEL also supports nested properties by using the standard dot notation (such as prop1.prop2.prop3) and also the corresponding setting of property values. Public fields may also be accessed. The following example shows how to use dot notation to get the length of a literal: Java ExpressionParser parser = new SpelExpressionParser(); // invokes 'getBytes().length' Expression exp = parser.parseExpression(\"'Hello World'.bytes.length\"); \u2460 int length = (Integer) exp.getValue(); \u2460 'Hello World'.bytes.length gives the length of the literal. Kotlin val parser = SpelExpressionParser() // invokes 'getBytes().length' val exp = parser.parseExpression(\"'Hello World'.bytes.length\") \u2460 val length = exp.value as Int \u2460 'Hello World'.bytes.length gives the length of the literal. The String\u2019s constructor can be called instead of using a string literal, as the following example shows: 277", "chunk_char_count": 1328, "chunk_word_count": 180, "chunk_token_count": 332.0}, {"page_number": 278, "sentence_chunk": "Java ExpressionParser parser = new SpelExpressionParser(); Expression exp = parser.parseExpression(\"new String('hello world').toUpperCase()\"); \u2460 String message = exp.getValue(String.class); \u2460 Construct a new String from the literal and make it be upper case. Kotlin val parser = SpelExpressionParser() val exp = parser.parseExpression(\"new String('hello world').toUpperCase()\") \u2460 val message = exp.getValue(String::class.java) \u2460 Construct a new String from the literal and make it be upper case. Note the use of the generic method: public <T> T getValue(Class<T> desiredResultType). Using this method removes the need to cast the value of the expression to the desired result type. An EvaluationException is thrown if the value cannot be cast to the type T or converted by using the registered type converter. The more common usage of SpEL is to provide an expression string that is evaluated against a specific object instance (called the root object). The following example shows how to retrieve the name property from an instance of the Inventor class or create a boolean condition: Java // Create and set a calendar GregorianCalendar c = new GregorianCalendar(); c.set(1856, 7, 9); // The constructor arguments are name, birthday, and nationality. Inventor tesla = new Inventor(\"Nikola Tesla\", c.getTime(), \"Serbian\"); ExpressionParser parser = new SpelExpressionParser(); Expression exp = parser.parseExpression(\"name\"); // Parse name as an expression String name = (String) exp.getValue(tesla); // name == \"Nikola Tesla\" exp = parser.parseExpression(\"name == 'Nikola Tesla'\"); boolean result = exp.getValue(tesla, Boolean.class); // result == true 278", "chunk_char_count": 1657, "chunk_word_count": 232, "chunk_token_count": 414.25}, {"page_number": 279, "sentence_chunk": "Kotlin // Create and set a calendar val c = GregorianCalendar() c.set(1856, 7, 9) // The constructor arguments are name, birthday, and nationality.val tesla = Inventor(\"Nikola Tesla\", c.time, \"Serbian\") val parser = SpelExpressionParser() var exp = parser.parseExpression(\"name\") // Parse name as an expression val name = exp.getValue(tesla) as String // name == \"Nikola Tesla\" exp = parser.parseExpression(\"name == 'Nikola Tesla'\") val result = exp.getValue(tesla, Boolean::class.java) // result == true Understanding EvaluationContext The EvaluationContext interface is used when evaluating an expression to resolve properties, methods, or fields and to help perform type conversion. Spring provides two implementations. \u2022SimpleEvaluationContext: Exposes a subset of essential SpEL language features and configuration options, for categories of expressions that do not require the full extent of the SpEL language syntax and should be meaningfully restricted. Examples include but are not limited to data binding expressions and property-based filters. \u2022StandardEvaluationContext: Exposes the full set of SpEL language features and configuration options. You can use it to specify a default root object and to configure every available evaluation-related strategy. SimpleEvaluationContext is designed to support only a subset of the SpEL language syntax. It excludes Java type references, constructors, and bean references. It also requires you to explicitly choose the level of support for properties and methods in expressions.", "chunk_char_count": 1531, "chunk_word_count": 210, "chunk_token_count": 382.75}, {"page_number": 279, "sentence_chunk": "By default, the create() static factory method enables only read access to properties. You can also obtain a builder to configure the exact level of support needed, targeting one or some combination of the following: \u2022 Custom PropertyAccessor only (no reflection) \u2022 Data binding properties for read-only access \u2022 Data binding properties for read and write Type Conversion By default, SpEL uses the conversion service available in Spring core (org.springframework.core.convert. ConversionService). This conversion service comes with many built-in converters for common conversions but is also fully extensible so that you can add custom conversions between types. Additionally, it is generics-aware. This means that, when you work with 279", "chunk_char_count": 738, "chunk_word_count": 108, "chunk_token_count": 184.5}, {"page_number": 280, "sentence_chunk": "generic types in expressions, SpEL attempts conversions to maintain type correctness for any objects it encounters. What does this mean in practice?Suppose assignment, using setValue(), is being used to set a List property. The type of the property is actually List<Boolean>. SpEL recognizes that the elements of the list need to be converted to Boolean before being placed in it. The following example shows how to do so: Java class Simple { \u00a0  public List<Boolean> booleanList = new ArrayList<Boolean>(); } Simple simple = new Simple(); simple.booleanList.add(true); EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build(); // \"false\" is passed in here as a String. SpEL and the conversion service // will recognize that it needs to be a Boolean and convert it accordingly.parser.parseExpression(\"booleanList[0]\").setValue(context, simple, \"false\"); // b is false Boolean b = simple.booleanList.get(0); Kotlin class Simple { \u00a0  var booleanList: MutableList<Boolean> = ArrayList() } val simple = Simple() simple.booleanList.add(true) val context = SimpleEvaluationContext.forReadOnlyDataBinding().build() // \"false\" is passed in here as a String. SpEL and the conversion service // will recognize that it needs to be a Boolean and convert it accordingly.parser.parseExpression(\"booleanList[0]\").setValue(context, simple, \"false\") // b is false val b = simple.booleanList[0] Parser Configuration It is possible to configure the SpEL expression parser by using a parser configuration object (org.springframework.expression.spel.", "chunk_char_count": 1556, "chunk_word_count": 206, "chunk_token_count": 389.0}, {"page_number": 280, "sentence_chunk": "SpelParserConfiguration). The configuration object controls the behavior of some of the expression components. For example, if you index into an array or 280", "chunk_char_count": 157, "chunk_word_count": 23, "chunk_token_count": 39.25}, {"page_number": 281, "sentence_chunk": "collection and the element at the specified index is null, SpEL can automatically create the element. This is useful when using expressions made up of a chain of property references. If you index into an array or list and specify an index that is beyond the end of the current size of the array or list, SpEL can automatically grow the array or list to accommodate that index. In order to add an element at the specified index, SpEL will try to create the element using the element type\u2019s default constructor before setting the specified value. If the element type does not have a default constructor, null will be added to the array or list. If there is no built-in or custom converter that knows how to set the value, null will remain in the array or list at the specified index. The following example demonstrates how to automatically grow the list: Java class Demo { \u00a0  public List<String> list; } // Turn on: // - auto null reference initialization // - auto collection growing SpelParserConfiguration config = new SpelParserConfiguration(true, true); ExpressionParser parser = new SpelExpressionParser(config); Expression expression = parser.parseExpression(\"list[3]\"); Demo demo = new Demo(); Object o = expression.getValue(demo); // demo.list will now be a real collection of 4 entries // Each entry is a new empty String 281", "chunk_char_count": 1333, "chunk_word_count": 220, "chunk_token_count": 333.25}, {"page_number": 282, "sentence_chunk": "Kotlin class Demo { \u00a0  var list: List<String>?= null } // Turn on: // - auto null reference initialization // - auto collection growing val config = SpelParserConfiguration(true, true) val parser = SpelExpressionParser(config) val expression = parser.parseExpression(\"list[3]\") val demo = Demo() val o = expression.getValue(demo) // demo.list will now be a real collection of 4 entries // Each entry is a new empty String SpEL Compilation Spring Framework 4.1 includes a basic expression compiler. Expressions are usually interpreted, which provides a lot of dynamic flexibility during evaluation but does not provide optimum performance. For occasional expression usage, this is fine, but, when used by other components such as Spring Integration, performance can be very important, and there is no real need for the dynamism. The SpEL compiler is intended to address this need. During evaluation, the compiler generates a Java class that embodies the expression behavior at runtime and uses that class to achieve much faster expression evaluation. Due to the lack of typing around expressions, the compiler uses information gathered during the interpreted evaluations of an expression when performing compilation. For example, it does not know the type of a property reference purely from the expression, but during the first interpreted evaluation, it finds out what it is. Of course, basing compilation on such derived information can cause trouble later if the types of the various expression elements change over time. For this reason, compilation is best suited to expressions whose type information is not going to change on repeated evaluations.", "chunk_char_count": 1654, "chunk_word_count": 253, "chunk_token_count": 413.5}, {"page_number": 282, "sentence_chunk": "Consider the following basic expression: someArray[0].someProperty.someOtherProperty < 0.1 Because the preceding expression involves array access, some property de-referencing, and numeric operations, the performance gain can be very noticeable. In an example micro benchmark run of 50000 iterations, it took 75ms to evaluate by using the interpreter and only 3ms using the compiled version of the expression.282", "chunk_char_count": 412, "chunk_word_count": 56, "chunk_token_count": 103.0}, {"page_number": 283, "sentence_chunk": "Compiler Configuration The compiler is not turned on by default, but you can turn it on in either of two different ways. You can turn it on by using the parser configuration process (discussed earlier) or by using a Spring property when SpEL usage is embedded inside another component. This section discusses both of these options. The compiler can operate in one of three modes, which are captured in the org.springframework.expression.spel. SpelCompilerMode enum. The modes are as follows: \u2022 OFF (default): The compiler is switched off. \u2022IMMEDIATE: In immediate mode, the expressions are compiled as soon as possible. This is typically after the first interpreted evaluation. If the compiled expression fails (typically due to a type changing, as described earlier), the caller of the expression evaluation receives an exception. \u2022MIXED: In mixed mode, the expressions silently switch between interpreted and compiled mode over time.", "chunk_char_count": 935, "chunk_word_count": 144, "chunk_token_count": 233.75}, {"page_number": 283, "sentence_chunk": "After some number of interpreted runs, they switch to compiled form and, if something goes wrong with the compiled form (such as a type changing, as described earlier), the expression automatically switches back to interpreted form again. Sometime later, it may generate another compiled form and switch to it. Basically, the exception that the user gets in IMMEDIATE mode is instead handled internally. IMMEDIATE mode exists because MIXED mode could cause issues for expressions that have side effects. If a compiled expression blows up after partially succeeding, it may have already done something that has affected the state of the system. If this has happened, the caller may not want it to silently re-run in interpreted mode, since part of the expression may be running twice. After selecting a mode, use the SpelParserConfiguration to configure the parser. The following example shows how to do so: Java SpelParserConfiguration config = new SpelParserConfiguration(SpelCompilerMode. IMMEDIATE, \u00a0    this.getClass().getClassLoader()); SpelExpressionParser parser = new SpelExpressionParser(config); Expression expr = parser.parseExpression(\"payload\"); MyMessage message = new MyMessage(); Object payload = expr.getValue(message); 283", "chunk_char_count": 1240, "chunk_word_count": 176, "chunk_token_count": 310.0}, {"page_number": 284, "sentence_chunk": "Kotlin val config = SpelParserConfiguration(SpelCompilerMode. IMMEDIATE, \u00a0    this.javaClass.classLoader) val parser = SpelExpressionParser(config) val expr = parser.parseExpression(\"payload\") val message = MyMessage() val payload = expr.getValue(message) When you specify the compiler mode, you can also specify a classloader (passing null is allowed). Compiled expressions are defined in a child classloader created under any that is supplied. It is important to ensure that, if a classloader is specified, it can see all the types involved in the expression evaluation process. If you do not specify a classloader, a default classloader is used (typically the context classloader for the thread that is running during expression evaluation). The second way to configure the compiler is for use when SpEL is embedded inside some other component and it may not be possible to configure it through a configuration object. In these cases, it is possible to set the spring.expression.compiler.mode property via a JVM system property (or via the SpringProperties mechanism) to one of the SpelCompilerMode enum values (off, immediate, or mixed). Compiler Limitations Since Spring Framework 4.1, the basic compilation framework is in place. However, the framework does not yet support compiling every kind of expression. The initial focus has been on the common expressions that are likely to be used in performance-critical contexts.", "chunk_char_count": 1429, "chunk_word_count": 211, "chunk_token_count": 357.25}, {"page_number": 284, "sentence_chunk": "The following kinds of expression cannot be compiled at the moment: \u2022 Expressions involving assignment \u2022 Expressions relying on the conversion service \u2022 Expressions using custom resolvers or accessors \u2022 Expressions using selection or projection More types of expressions will be compilable in the future.2.4.2. Expressions in Bean Definitions You can use SpEL expressions with XML-based or annotation-based configuration metadata for defining BeanDefinition instances. In both cases, the syntax to define the expression is of the form #{ <expression string> }. XML Configuration A property or constructor argument value can be set by using expressions, as the following 284", "chunk_char_count": 673, "chunk_word_count": 99, "chunk_token_count": 168.25}, {"page_number": 285, "sentence_chunk": "example shows: <bean id=\"numberGuess\" class=\"org.spring.samples. NumberGuess\"> \u00a0  <property name=\"randomNumber\" value=\"#{ T(java.lang. Math).random() * 100.0 }\"/> \u00a0  <!--other properties --> </bean> All beans in the application context are available as predefined variables with their common bean name. This includes standard context beans such as environment (of type org.springframework.core.env. Environment) as well as systemProperties and systemEnvironment (of type Map<String, Object>) for access to the runtime environment. The following example shows access to the systemProperties bean as a SpEL variable: <bean id=\"taxCalculator\" class=\"org.spring.samples. TaxCalculator\"> \u00a0  <property name=\"defaultLocale\" value=\"#{ systemProperties['user.region'] }\"/> \u00a0  <!--other properties --> </bean> Note that you do not have to prefix the predefined variable with the # symbol here. You can also refer to other bean properties by name, as the following example shows: <bean id=\"numberGuess\" class=\"org.spring.samples.", "chunk_char_count": 1018, "chunk_word_count": 130, "chunk_token_count": 254.5}, {"page_number": 285, "sentence_chunk": "NumberGuess\"> \u00a0  <property name=\"randomNumber\" value=\"#{ T(java.lang. Math).random() * 100.0 }\"/> \u00a0  <!--other properties --> </bean> <bean id=\"shapeGuess\" class=\"org.spring.samples. ShapeGuess\"> \u00a0  <property name=\"initialShapeSeed\" value=\"#{ numberGuess.randomNumber }\"/> \u00a0  <!--other properties --> </bean> Annotation Configuration To specify a default value, you can place the @Value annotation on fields, methods, and method or constructor parameters. The following example sets the default value of a field: 285", "chunk_char_count": 516, "chunk_word_count": 66, "chunk_token_count": 129.0}, {"page_number": 286, "sentence_chunk": "Java public class FieldValueTestBean { \u00a0  @Value(\"#{ systemProperties['user.region'] }\") \u00a0  private String defaultLocale; \u00a0  public void setDefaultLocale(String defaultLocale) { \u00a0    this.defaultLocale = defaultLocale; \u00a0  } \u00a0  public String getDefaultLocale() { \u00a0    return this.defaultLocale; \u00a0  } } Kotlin class FieldValueTestBean { \u00a0  @Value(\"#{ systemProperties['user.region'] }\") \u00a0  var defaultLocale: String?= null } The following example shows the equivalent but on a property setter method: Java public class PropertyValueTestBean { \u00a0  private String defaultLocale; \u00a0  @Value(\"#{ systemProperties['user.region'] }\") \u00a0  public void setDefaultLocale(String defaultLocale) { \u00a0    this.defaultLocale = defaultLocale; \u00a0  } \u00a0  public String getDefaultLocale() { \u00a0    return this.defaultLocale; \u00a0  } } 286", "chunk_char_count": 806, "chunk_word_count": 125, "chunk_token_count": 201.5}, {"page_number": 287, "sentence_chunk": "Kotlin class PropertyValueTestBean { \u00a0  @Value(\"#{ systemProperties['user.region'] }\") \u00a0  var defaultLocale: String?= null } Autowired methods and constructors can also use the @Value annotation, as the following examples show: Java public class SimpleMovieLister { \u00a0  private MovieFinder movieFinder; \u00a0  private String defaultLocale; \u00a0  @Autowired \u00a0  public void configure(MovieFinder movieFinder, \u00a0      @Value(\"#{ systemProperties['user.region'] }\") String defaultLocale) { \u00a0    this.movieFinder = movieFinder; \u00a0    this.defaultLocale = defaultLocale; \u00a0  } \u00a0  // ... } Kotlin class SimpleMovieLister { \u00a0  private lateinit var movieFinder: MovieFinder \u00a0  private lateinit var defaultLocale: String \u00a0  @Autowired \u00a0  fun configure(movieFinder: MovieFinder, \u00a0        @Value(\"#{ systemProperties['user.region'] }\") defaultLocale: String) { \u00a0    this.movieFinder = movieFinder \u00a0    this.defaultLocale = defaultLocale \u00a0  } \u00a0  // ... } 287", "chunk_char_count": 934, "chunk_word_count": 152, "chunk_token_count": 233.5}, {"page_number": 288, "sentence_chunk": "Java public class MovieRecommender { \u00a0  private String defaultLocale; \u00a0  private CustomerPreferenceDao customerPreferenceDao; \u00a0  public MovieRecommender(CustomerPreferenceDao customerPreferenceDao, \u00a0      @Value(\"#{systemProperties['user.country']}\") String defaultLocale) { \u00a0    this.customerPreferenceDao = customerPreferenceDao; \u00a0    this.defaultLocale = defaultLocale; \u00a0  } \u00a0  // ... } Kotlin class MovieRecommender(private val customerPreferenceDao: CustomerPreferenceDao, \u00a0      @Value(\"#{systemProperties['user.country']}\") private val defaultLocale: String) { \u00a0  // ... } 2.4.3. Language Reference This section describes how the Spring Expression Language works. It covers the following topics: \u2022 Literal Expressions \u2022 Properties, Arrays, Lists, Maps, and Indexers \u2022 Inline Lists \u2022 Inline Maps \u2022 Array Construction \u2022 Methods \u2022 Operators \u2022 Types \u2022 Constructors \u2022 Variables \u2022 Functions \u2022 Bean References \u2022 Ternary Operator (If-Then-Else) \u2022 The Elvis Operator 288", "chunk_char_count": 968, "chunk_word_count": 135, "chunk_token_count": 242.0}, {"page_number": 289, "sentence_chunk": "\u2022 Safe Navigation Operator Literal Expressions The types of literal expressions supported are strings, numeric values (int, real, hex), boolean, and null. Strings are delimited by single quotation marks. To put a single quotation mark itself in a string, use two single quotation mark characters. The following listing shows simple usage of literals. Typically, they are not used in isolation like this but, rather, as part of a more complex expression\u2009\u2014\u2009for example, using a literal on one side of a logical comparison operator. Java ExpressionParser parser = new SpelExpressionParser(); // evals to \"Hello World\" String helloWorld = (String) parser.parseExpression(\"'Hello World'\").getValue(); double avogadrosNumber = (Double) parser.parseExpression(\"6.0221415E+23\").getValue(); // evals to 2147483647 int maxValue = (Integer) parser.parseExpression(\"0x7FFFFFFF\").getValue(); boolean trueValue = (Boolean) parser.parseExpression(\"true\").getValue(); Object nullValue = parser.parseExpression(\"null\").getValue(); Kotlin val parser = SpelExpressionParser() // evals to \"Hello World\" val helloWorld = parser.parseExpression(\"'Hello World'\").value as String val avogadrosNumber = parser.parseExpression(\"6.0221415E+23\").value as Double // evals to 2147483647 val maxValue = parser.parseExpression(\"0x7FFFFFFF\").value as Int val trueValue = parser.parseExpression(\"true\").value as Boolean val nullValue = parser.parseExpression(\"null\").value Numbers support the use of the negative sign, exponential notation, and decimal points. By default, real numbers are parsed by using Double.parseDouble(). Properties, Arrays, Lists, Maps, and Indexers Navigating with property references is easy. To do so, use a period to indicate a nested property 289", "chunk_char_count": 1741, "chunk_word_count": 212, "chunk_token_count": 435.25}, {"page_number": 290, "sentence_chunk": "value. The instances of the Inventor class, pupin and tesla, were populated with data listed in the Classes used in the examples section. To navigate \"down\" the object graph and get Tesla\u2019s year of birth and Pupin\u2019s city of birth, we use the following expressions: Java // evals to 1856 int year = (Integer) parser.parseExpression(\"birthdate.year + 1900\").getValue(context); String city = (String) parser.parseExpression(\"placeOfBirth.city\").getValue(context); Kotlin // evals to 1856 val year = parser.parseExpression(\"birthdate.year + 1900\").getValue(context) as Int val city = parser.parseExpression(\"placeOfBirth.city\").getValue(context) as String \uf05a Case insensitivity is allowed for the first letter of property names. Thus, the expressions in the above example may be written as Birthdate. Year + 1900 and PlaceOfBirth. City, respectively. In addition, properties may optionally be accessed via method invocations\u2009\u2014\u2009for example, getPlaceOfBirth().getCity() instead of placeOfBirth.city. The contents of arrays and lists are obtained by using square bracket notation, as the following example shows: 290", "chunk_char_count": 1108, "chunk_word_count": 146, "chunk_token_count": 277.0}, {"page_number": 291, "sentence_chunk": "Java ExpressionParser parser = new SpelExpressionParser(); EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build(); // Inventions Array // evaluates to \"Induction motor\" String invention = parser.parseExpression(\"inventions[3]\").getValue( \u00a0    context, tesla, String.class); // Members List // evaluates to \"Nikola Tesla\" String name = parser.parseExpression(\"members[0].name\").getValue( \u00a0    context, ieee, String.class); // List and Array navigation // evaluates to \"Wireless communication\" String invention = parser.parseExpression(\"members[0].inventions[6]\").getValue( \u00a0    context, ieee, String.class); Kotlin val parser = SpelExpressionParser() val context = SimpleEvaluationContext.forReadOnlyDataBinding().build() // Inventions Array // evaluates to \"Induction motor\" val invention = parser.parseExpression(\"inventions[3]\").getValue( \u00a0    context, tesla, String::class.java) // Members List // evaluates to \"Nikola Tesla\" val name = parser.parseExpression(\"members[0].name\").getValue( \u00a0    context, ieee, String::class.java) // List and Array navigation // evaluates to \"Wireless communication\" val invention = parser.parseExpression(\"members[0].inventions[6]\").getValue( \u00a0    context, ieee, String::class.java) The contents of maps are obtained by specifying the literal key value within the brackets. In the following example, because keys for the officers map are strings, we can specify string literals: 291", "chunk_char_count": 1448, "chunk_word_count": 170, "chunk_token_count": 362.0}, {"page_number": 292, "sentence_chunk": "Java // Officer's Dictionary Inventor pupin = parser.parseExpression(\"officers['president']\").getValue( \u00a0    societyContext, Inventor.class); // evaluates to \"Idvor\" String city = parser.parseExpression(\"officers['president'].placeOfBirth.city\").getValue( \u00a0    societyContext, String.class); // setting values parser.parseExpression(\"officers['advisors'][0].placeOfBirth.country\").setValue( \u00a0    societyContext, \"Croatia\"); Kotlin // Officer's Dictionary val pupin = parser.parseExpression(\"officers['president']\").getValue( \u00a0    societyContext, Inventor::class.java) // evaluates to \"Idvor\" val city = parser.parseExpression(\"officers['president'].placeOfBirth.city\").getValue( \u00a0    societyContext, String::class.java) // setting values parser.parseExpression(\"officers['advisors'][0].placeOfBirth.country\").setValue( \u00a0    societyContext, \"Croatia\") Inline Lists You can directly express lists in an expression by using {} notation. Java // evaluates to a Java list containing the four numbers List numbers = (List) parser.parseExpression(\"{1,2,3,4}\").getValue(context); List listOfLists = (List) parser.parseExpression(\"{{'a','b'},{'x','y'}}\").getValue(context); 292", "chunk_char_count": 1168, "chunk_word_count": 112, "chunk_token_count": 292.0}, {"page_number": 293, "sentence_chunk": "Kotlin // evaluates to a Java list containing the four numbers val numbers = parser.parseExpression(\"{1,2,3,4}\").getValue(context) as List<*> val listOfLists = parser.parseExpression(\"{{'a','b'},{'x','y'}}\").getValue(context) as List<*> {} by itself means an empty list. For performance reasons, if the list is itself entirely composed of fixed literals, a constant list is created to represent the expression (rather than building a new list on each evaluation). Inline Maps You can also directly express maps in an expression by using {key:value} notation. The following example shows how to do so: Java // evaluates to a Java map containing the two entries Map inventorInfo = (Map) parser.parseExpression(\"{name:'Nikola',dob:'10-July- 1856'}\").getValue(context); Map mapOfMaps = (Map) parser.parseExpression(\"{name:{first:'Nikola',last:'Tesla'},dob:{day:10,month:'July',y ear:1856}}\").getValue(context); Kotlin // evaluates to a Java map containing the two entries val inventorInfo = parser.parseExpression(\"{name:'Nikola',dob:'10-July- 1856'}\").getValue(context) as Map<*, *> val mapOfMaps = parser.parseExpression(\"{name:{first:'Nikola',last:'Tesla'},dob:{day:10,month:'July',y ear:1856}}\").getValue(context) as Map<*, *> {:} by itself means an empty map. For performance reasons, if the map is itself composed of fixed literals or other nested constant structures (lists or maps), a constant map is created to represent the expression (rather than building a new map on each evaluation). Quoting of the map keys is optional (unless the key contains a period (.)). The examples above do not use quoted keys. Array Construction You can build arrays by using the familiar Java syntax, optionally supplying an initializer to have the array populated at construction time. The following example shows how to do so: 293", "chunk_char_count": 1819, "chunk_word_count": 234, "chunk_token_count": 454.75}, {"page_number": 294, "sentence_chunk": "Java int[] numbers1 = (int[]) parser.parseExpression(\"new int[4]\").getValue(context); // Array with initializer int[] numbers2 = (int[]) parser.parseExpression(\"new int[]{1,2,3}\").getValue(context); // Multi dimensional array int[][] numbers3 = (int[][]) parser.parseExpression(\"new int[4][5]\").getValue(context); Kotlin val numbers1 = parser.parseExpression(\"new int[4]\").getValue(context) as IntArray // Array with initializer val numbers2 = parser.parseExpression(\"new int[]{1,2,3}\").getValue(context) as IntArray // Multi dimensional array val numbers3 = parser.parseExpression(\"new int[4][5]\").getValue(context) as Array<IntArray> You cannot currently supply an initializer when you construct a multi-dimensional array. Methods You can invoke methods by using typical Java programming syntax. You can also invoke methods on literals. Variable arguments are also supported. The following examples show how to invoke methods: Java // string literal, evaluates to \"bc\" String bc = parser.parseExpression(\"'abc'.substring(1, 3)\").getValue(String.class); // evaluates to true boolean isMember = parser.parseExpression(\"isMember('Mihajlo Pupin')\").getValue( \u00a0    societyContext, Boolean.class); Kotlin // string literal, evaluates to \"bc\" val bc = parser.parseExpression(\"'abc'.substring(1, 3)\").getValue(String::class.java) // evaluates to true val isMember = parser.parseExpression(\"isMember('Mihajlo Pupin')\").getValue( \u00a0    societyContext, Boolean::class.java) 294", "chunk_char_count": 1467, "chunk_word_count": 155, "chunk_token_count": 366.75}, {"page_number": 295, "sentence_chunk": "Operators The Spring Expression Language supports the following kinds of operators: \u2022 Relational Operators \u2022 Logical Operators \u2022 Mathematical Operators \u2022 The Assignment Operator Relational Operators The relational operators (equal, not equal, less than, less than or equal, greater than, and greater than or equal) are supported by using standard operator notation. These operators work on Number types as well as types implementing Comparable. The following listing shows a few examples of operators: Java // evaluates to true boolean trueValue = parser.parseExpression(\"2 == 2\").getValue(Boolean.class); // evaluates to false boolean falseValue = parser.parseExpression(\"2 < -5.0\").getValue(Boolean.class); // evaluates to true boolean trueValue = parser.parseExpression(\"'black' < 'block'\").getValue(Boolean.class); // uses CustomValue:::compareTo boolean trueValue = parser.parseExpression(\"new CustomValue(1) < new CustomValue(2)\").getValue(Boolean.class); Kotlin // evaluates to true val trueValue = parser.parseExpression(\"2 == 2\").getValue(Boolean::class.java) // evaluates to false val falseValue = parser.parseExpression(\"2 < -5.0\").getValue(Boolean::class.java) // evaluates to true val trueValue = parser.parseExpression(\"'black' < 'block'\").getValue(Boolean::class.java) // uses CustomValue:::compareTo val trueValue = parser.parseExpression(\"new CustomValue(1) < new CustomValue(2)\").getValue(Boolean::class.java); 295", "chunk_char_count": 1432, "chunk_word_count": 158, "chunk_token_count": 358.0}, {"page_number": 296, "sentence_chunk": "\uf05a Greater-than and less-than comparisons against null follow a simple rule: null is treated as nothing (that is NOT as zero). As a consequence, any other value is always greater than null (X > null is always true) and no other value is ever less than nothing (X < null is always false). If you prefer numeric comparisons instead, avoid number-based null comparisons in favor of comparisons against zero (for example, X > 0 or X < 0). In addition to the standard relational operators, SpEL supports the instanceof and regular expression-based matches operator. The following listing shows examples of both: Java // evaluates to false boolean falseValue = parser.parseExpression( \u00a0    \"'xyz' instanceof T(Integer)\").getValue(Boolean.class); // evaluates to true boolean trueValue = parser.parseExpression( \u00a0    \"'5.00' matches '^-?\\\\d+(\\\\.\\\\d{2})?$'\").getValue(Boolean.class); // evaluates to false boolean falseValue = parser.parseExpression( \u00a0    \"'5.0067' matches '^-?\\\\d+(\\\\.\\\\d{2})?$'\").getValue(Boolean.class); Kotlin // evaluates to false val falseValue = parser.parseExpression( \u00a0    \"'xyz' instanceof T(Integer)\").getValue(Boolean::class.java) // evaluates to true val trueValue = parser.parseExpression( \u00a0    \"'5.00' matches '^-?\\\\d+(\\\\.\\\\d{2})?$'\").getValue(Boolean::class.java) // evaluates to false val falseValue = parser.parseExpression( \u00a0    \"'5.0067' matches '^-?\\\\d+(\\\\.\\\\d{2})?$'\").getValue(Boolean::class.java) \uf06d Be careful with primitive types, as they are immediately boxed up to their wrapper types. For example, 1 instanceof T(int) evaluates to false, while 1 instanceof T(Integer) evaluates to true, as expected. Each symbolic operator can also be specified as a purely alphabetic equivalent. This avoids problems where the symbols used have special meaning for the document type in which the expression is embedded (such as in an XML document). The textual equivalents are: \u2022 lt (<) 296", "chunk_char_count": 1910, "chunk_word_count": 272, "chunk_token_count": 477.5}, {"page_number": 297, "sentence_chunk": "\u2022 gt (>) \u2022 le (<=) \u2022 ge (>=) \u2022 eq (==) \u2022 ne (!=) \u2022 div (/) \u2022 mod (%) \u2022 not (!). All of the textual operators are case-insensitive. Logical Operators SpEL supports the following logical operators: \u2022 and (&&) \u2022 or (||) \u2022 not (!)The following example shows how to use the logical operators: 297", "chunk_char_count": 291, "chunk_word_count": 58, "chunk_token_count": 72.75}, {"page_number": 298, "sentence_chunk": "Java // -- AND -- // evaluates to false boolean falseValue = parser.parseExpression(\"true and false\").getValue(Boolean.class); // evaluates to true String expression = \"isMember('Nikola Tesla') and isMember('Mihajlo Pupin')\"; boolean trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class); // -- OR -- // evaluates to true boolean trueValue = parser.parseExpression(\"true or false\").getValue(Boolean.class); // evaluates to true String expression = \"isMember('Nikola Tesla') or isMember('Albert Einstein')\"; boolean trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class); // -- NOT -- // evaluates to false boolean falseValue = parser.parseExpression(\"!true\").getValue(Boolean.class); // -- AND and NOT -- String expression = \"isMember('Nikola Tesla') and !isMember('Mihajlo Pupin')\"; boolean falseValue = parser.parseExpression(expression).getValue(societyContext, Boolean.class); 298", "chunk_char_count": 949, "chunk_word_count": 95, "chunk_token_count": 237.25}, {"page_number": 299, "sentence_chunk": "Kotlin // -- AND -- // evaluates to false val falseValue = parser.parseExpression(\"true and false\").getValue(Boolean::class.java) // evaluates to true val expression = \"isMember('Nikola Tesla') and isMember('Mihajlo Pupin')\" val trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean::class.java) // -- OR -- // evaluates to true val trueValue = parser.parseExpression(\"true or false\").getValue(Boolean::class.java) // evaluates to true val expression = \"isMember('Nikola Tesla') or isMember('Albert Einstein')\" val trueValue = parser.parseExpression(expression).getValue(societyContext, Boolean::class.java) // -- NOT -- // evaluates to false val falseValue = parser.parseExpression(\"!true\").getValue(Boolean::class.java) // -- AND and NOT -- val expression = \"isMember('Nikola Tesla') and !isMember('Mihajlo Pupin')\" val falseValue = parser.parseExpression(expression).getValue(societyContext, Boolean::class.java) Mathematical Operators You can use the addition operator (+) on both numbers and strings. You can use the subtraction (-), multiplication (*), and division (/) operators only on numbers. You can also use the modulus (%) and exponential power (^) operators on numbers. Standard operator precedence is enforced. The following example shows the mathematical operators in use: 299", "chunk_char_count": 1318, "chunk_word_count": 152, "chunk_token_count": 329.5}, {"page_number": 300, "sentence_chunk": "Java // Addition int two = parser.parseExpression(\"1 + 1\").getValue(Integer.class); // 2 String testString = parser.parseExpression( \u00a0    \"'test' + ' ' + 'string'\").getValue(String.class); // 'test string' // Subtraction int four = parser.parseExpression(\"1 - -3\").getValue(Integer.class); // 4 double d = parser.parseExpression(\"1000.00 - 1e4\").getValue(Double.class); // -9000 // Multiplication int six = parser.parseExpression(\"-2 * -3\").getValue(Integer.class); // 6 double twentyFour = parser.parseExpression(\"2.0 * 3e0 * 4\").getValue(Double.class); // 24.0 // Division int minusTwo = parser.parseExpression(\"6 / -3\").getValue(Integer.class); // -2 double one = parser.parseExpression(\"8.0 / 4e0 / 2\").getValue(Double.class); // 1.0 // Modulus int three = parser.parseExpression(\"7 % 4\").getValue(Integer.class); // 3 int one = parser.parseExpression(\"8 / 5 % 2\").getValue(Integer.class); // 1 // Operator precedence int minusTwentyOne = parser.parseExpression(\"1+2-3*8\").getValue(Integer.class); // -21 300", "chunk_char_count": 1012, "chunk_word_count": 116, "chunk_token_count": 253.0}, {"page_number": 301, "sentence_chunk": "Kotlin // Addition val two = parser.parseExpression(\"1 + 1\").getValue(Int::class.java) // 2 val testString = parser.parseExpression( \u00a0    \"'test' + ' ' + 'string'\").getValue(String::class.java) // 'test string' // Subtraction val four = parser.parseExpression(\"1 - -3\").getValue(Int::class.java) // 4 val d = parser.parseExpression(\"1000.00 - 1e4\").getValue(Double::class.java) // -9000 // Multiplication val six = parser.parseExpression(\"-2 * -3\").getValue(Int::class.java) // 6 val twentyFour = parser.parseExpression(\"2.0 * 3e0 * 4\").getValue(Double::class.java) // 24.0 // Division val minusTwo = parser.parseExpression(\"6 / -3\").getValue(Int::class.java) // -2 val one = parser.parseExpression(\"8.0 / 4e0 / 2\").getValue(Double::class.java) // 1.0 // Modulus val three = parser.parseExpression(\"7 % 4\").getValue(Int::class.java) // 3 val one = parser.parseExpression(\"8 / 5 % 2\").getValue(Int::class.java) // 1 // Operator precedence val minusTwentyOne = parser.parseExpression(\"1+2-3*8\").getValue(Int::class.java) // -21 The Assignment Operator To set a property, use the assignment operator (=). This is typically done within a call to setValue but can also be done inside a call to getValue. The following listing shows both ways to use the assignment operator: Java Inventor inventor = new Inventor(); EvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build(); parser.parseExpression(\"name\").setValue(context, inventor, \"Aleksandar Seovic\"); // alternatively String aleks = parser.parseExpression( \u00a0    \"name = 'Aleksandar Seovic'\").getValue(context, inventor, String.class); 301", "chunk_char_count": 1615, "chunk_word_count": 188, "chunk_token_count": 403.75}, {"page_number": 302, "sentence_chunk": "Kotlin val inventor = Inventor() val context = SimpleEvaluationContext.forReadWriteDataBinding().build() parser.parseExpression(\"name\").setValue(context, inventor, \"Aleksandar Seovic\") // alternatively val aleks = parser.parseExpression( \u00a0    \"name = 'Aleksandar Seovic'\").getValue(context, inventor, String::class.java) Types You can use the special T operator to specify an instance of java.lang. Class (the type). Static methods are invoked by using this operator as well. The StandardEvaluationContext uses a TypeLocator to find types, and the StandardTypeLocator (which can be replaced) is built with an understanding of the java.lang package. This means that T() references to types within the java.lang package do not need to be fully qualified, but all other type references must be. The following example shows how to use the T operator: Java Class dateClass = parser.parseExpression(\"T(java.util. Date)\").getValue(Class.class); Class stringClass = parser.parseExpression(\"T(String)\").getValue(Class.class); boolean trueValue = parser.parseExpression( \u00a0    \"T(java.math. RoundingMode). CEILING < T(java.math. RoundingMode). FLOOR\") \u00a0    .getValue(Boolean.class); Kotlin val dateClass = parser.parseExpression(\"T(java.util. Date)\").getValue(Class::class.java) val stringClass = parser.parseExpression(\"T(String)\").getValue(Class::class.java) val trueValue = parser.parseExpression( \u00a0    \"T(java.math.", "chunk_char_count": 1408, "chunk_word_count": 164, "chunk_token_count": 352.0}, {"page_number": 302, "sentence_chunk": "RoundingMode). CEILING < T(java.math. RoundingMode). FLOOR\") \u00a0    .getValue(Boolean::class.java) Constructors You can invoke constructors by using the new operator. You should use the fully qualified class name for all types except those located in the java.lang package (Integer, Float, String, and so on). The following example shows how to use the new operator to invoke constructors: 302", "chunk_char_count": 391, "chunk_word_count": 59, "chunk_token_count": 97.75}, {"page_number": 303, "sentence_chunk": "Java Inventor einstein = p.parseExpression( \u00a0    \"new org.spring.samples.spel.inventor. Inventor('Albert Einstein', 'German')\") \u00a0    .getValue(Inventor.class); // create new Inventor instance within the add() method of List p.parseExpression( \u00a0    \"Members.add(new org.spring.samples.spel.inventor. Inventor( \u00a0      'Albert Einstein', 'German'))\").getValue(societyContext); Kotlin val einstein = p.parseExpression( \u00a0    \"new org.spring.samples.spel.inventor. Inventor('Albert Einstein', 'German')\") \u00a0    .getValue(Inventor::class.java) // create new Inventor instance within the add() method of List p.parseExpression( \u00a0    \"Members.add(new org.spring.samples.spel.inventor. Inventor('Albert Einstein', 'German'))\") \u00a0    .getValue(societyContext) Variables You can reference variables in the expression by using the #variableName syntax. Variables are set by using the setVariable method on EvaluationContext implementations.\uf05a Valid variable names must be composed of one or more of the following supported characters. \u2022letters: A to Z and a to z \u2022 digits: 0 to 9 \u2022 underscore: _ \u2022 dollar sign: $ The following example shows how to use variables. Java Inventor tesla = new Inventor(\"Nikola Tesla\", \"Serbian\"); EvaluationContext context = SimpleEvaluationContext.forReadWriteDataBinding().build(); context.setVariable(\"newName\", \"Mike Tesla\"); parser.parseExpression(\"name = #newName\").getValue(context, tesla); System.out.println(tesla.getName()) // \"Mike Tesla\" 303", "chunk_char_count": 1466, "chunk_word_count": 183, "chunk_token_count": 366.5}, {"page_number": 304, "sentence_chunk": "Kotlin val tesla = Inventor(\"Nikola Tesla\", \"Serbian\") val context = SimpleEvaluationContext.forReadWriteDataBinding().build() context.setVariable(\"newName\", \"Mike Tesla\") parser.parseExpression(\"name = #newName\").getValue(context, tesla) println(tesla.name) // \"Mike Tesla\" The #this and #root Variables The #this variable is always defined and refers to the current evaluation object (against which unqualified references are resolved). The #root variable is always defined and refers to the root context object. Although #this may vary as components of an expression are evaluated, #root always refers to the root. The following examples show how to use the #this and #root variables: Java // create an array of integers List<Integer> primes = new ArrayList<Integer>(); primes.addAll(Arrays.asList(2,3,5,7,11,13,17)); // create parser and set variable 'primes' as the array of integers ExpressionParser parser = new SpelExpressionParser(); EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataAccess(); context.setVariable(\"primes\", primes); // all prime numbers > 10 from the list (using selection ?{...}) //evaluates to [11, 13, 17] List<Integer> primesGreaterThanTen = (List<Integer>) parser.parseExpression( \u00a0    \"#primes.?[#this>10]\").getValue(context); Kotlin // create an array of integers val primes = ArrayList<Int>() primes.addAll(listOf(2, 3, 5, 7, 11, 13, 17)) // create parser and set variable 'primes' as the array of integers val parser = SpelExpressionParser() val context = SimpleEvaluationContext.forReadOnlyDataAccess() context.setVariable(\"primes\", primes) // all prime numbers > 10 from the list (using selection ?{...}) //evaluates to [11, 13, 17] val primesGreaterThanTen = parser.parseExpression( \u00a0    \"#primes.?[#this>10]\").getValue(context) as List<Int> 304", "chunk_char_count": 1800, "chunk_word_count": 220, "chunk_token_count": 450.0}, {"page_number": 305, "sentence_chunk": "Functions You can extend SpEL by registering user-defined functions that can be called within the expression string. The function is registered through the EvaluationContext. The following example shows how to register a user-defined function: Java Method method = ...; EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build(); context.setVariable(\"myFunction\", method); Kotlin val method: Method = ... val context = SimpleEvaluationContext.forReadOnlyDataBinding().build() context.setVariable(\"myFunction\", method) For example, consider the following utility method that reverses a string: Java public abstract class StringUtils { \u00a0  public static String reverseString(String input) { \u00a0    StringBuilder backwards = new StringBuilder(input.length()); \u00a0    for (int i = 0; i < input.length(); i++) { \u00a0      backwards.append(input.charAt(input.length() - 1 - i)); \u00a0    } \u00a0    return backwards.toString(); \u00a0  } } Kotlin fun reverseString(input: String): String { \u00a0  val backwards = StringBuilder(input.length) \u00a0  for (i in 0 until input.length) { \u00a0    backwards.append(input[input.length - 1 - i]) \u00a0  } \u00a0  return backwards.toString() } You can then register and use the preceding method, as the following example shows: 305", "chunk_char_count": 1249, "chunk_word_count": 184, "chunk_token_count": 312.25}, {"page_number": 306, "sentence_chunk": "Java ExpressionParser parser = new SpelExpressionParser(); EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build(); context.setVariable(\"reverseString\", \u00a0    StringUtils.class.getDeclaredMethod(\"reverseString\", String.class)); String helloWorldReversed = parser.parseExpression( \u00a0    \"#reverseString('hello')\").getValue(context, String.class); Kotlin val parser = SpelExpressionParser() val context = SimpleEvaluationContext.forReadOnlyDataBinding().build() context.setVariable(\"reverseString\", ::reverseString::javaMethod) val helloWorldReversed = parser.parseExpression( \u00a0    \"#reverseString('hello')\").getValue(context, String::class.java) Bean References If the evaluation context has been configured with a bean resolver, you can look up beans from an expression by using the @ symbol. The following example shows how to do so: Java ExpressionParser parser = new SpelExpressionParser(); StandardEvaluationContext context = new StandardEvaluationContext(); context.setBeanResolver(new MyBeanResolver()); // This will end up calling resolve(context,\"something\") on MyBeanResolver during evaluation Object bean = parser.parseExpression(\"@something\").getValue(context); Kotlin val parser = SpelExpressionParser() val context = StandardEvaluationContext() context.setBeanResolver(MyBeanResolver()) // This will end up calling resolve(context,\"something\") on MyBeanResolver during evaluation val bean = parser.parseExpression(\"@something\").getValue(context) To access a factory bean itself, you should instead prefix the bean name with an & symbol. The following example shows how to do so: 306", "chunk_char_count": 1622, "chunk_word_count": 161, "chunk_token_count": 405.5}, {"page_number": 307, "sentence_chunk": "Java ExpressionParser parser = new SpelExpressionParser(); StandardEvaluationContext context = new StandardEvaluationContext(); context.setBeanResolver(new MyBeanResolver()); // This will end up calling resolve(context,\"&foo\") on MyBeanResolver during evaluation Object bean = parser.parseExpression(\"&foo\").getValue(context); Kotlin val parser = SpelExpressionParser() val context = StandardEvaluationContext() context.setBeanResolver(MyBeanResolver()) // This will end up calling resolve(context,\"&foo\") on MyBeanResolver during evaluation val bean = parser.parseExpression(\"&foo\").getValue(context) Ternary Operator (If-Then-Else) You can use the ternary operator for performing if-then-else conditional logic inside the expression. The following listing shows a minimal example: Java String falseString = parser.parseExpression( \u00a0    \"false ? 'trueExp' : 'falseExp'\").getValue(String.class); Kotlin val falseString = parser.parseExpression( \u00a0    \"false ? 'trueExp' : 'falseExp'\").getValue(String::class.java) In this case, the boolean false results in returning the string value 'falseExp'. A more realistic example follows: 307", "chunk_char_count": 1132, "chunk_word_count": 124, "chunk_token_count": 283.0}, {"page_number": 308, "sentence_chunk": "Java parser.parseExpression(\"name\").setValue(societyContext, \"IEEE\"); societyContext.setVariable(\"queryName\", \"Nikola Tesla\"); expression = \"isMember(#queryName)? #queryName + ' is a member of the ' \" + \u00a0    \"+ Name + ' Society' : #queryName + ' is not a member of the ' + Name + ' Society'\"; String queryResultString = parser.parseExpression(expression) \u00a0    .getValue(societyContext, String.class); // queryResultString = \"Nikola Tesla is a member of the IEEE Society\" Kotlin parser.parseExpression(\"name\").setValue(societyContext, \"IEEE\") societyContext.setVariable(\"queryName\", \"Nikola Tesla\") expression = \"isMember(#queryName)? #queryName + ' is a member of the ' \" + \"+ Name + ' Society' : #queryName + ' is not a member of the ' + Name + ' Society'\" val queryResultString = parser.parseExpression(expression) \u00a0    .getValue(societyContext, String::class.java) // queryResultString = \"Nikola Tesla is a member of the IEEE Society\" See the next section on the Elvis operator for an even shorter syntax for the ternary operator. The Elvis Operator The Elvis operator is a shortening of the ternary operator syntax and is used in the Groovy language. With the ternary operator syntax, you usually have to repeat a variable twice, as the following example shows: String name = \"Elvis Presley\"; String displayName = (name != null ?name : \"Unknown\"); Instead, you can use the Elvis operator (named for the resemblance to Elvis' hair style). The following example shows how to use the Elvis operator: Java ExpressionParser parser = new SpelExpressionParser(); String name = parser.parseExpression(\"name?:'Unknown'\").getValue(new Inventor(), String.class); System.out.println(name); // 'Unknown' 308", "chunk_char_count": 1698, "chunk_word_count": 241, "chunk_token_count": 424.5}, {"page_number": 309, "sentence_chunk": "Kotlin val parser = SpelExpressionParser() val name = parser.parseExpression(\"name?:'Unknown'\").getValue(Inventor(), String::class.java) println(name) // 'Unknown' The following listing shows a more complex example: Java ExpressionParser parser = new SpelExpressionParser(); EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build(); Inventor tesla = new Inventor(\"Nikola Tesla\", \"Serbian\"); String name = parser.parseExpression(\"name?:'Elvis Presley'\").getValue(context, tesla, String.class); System.out.println(name); // Nikola Tesla tesla.setName(null); name = parser.parseExpression(\"name?:'Elvis Presley'\").getValue(context, tesla, String.class); System.out.println(name); // Elvis Presley Kotlin val parser = SpelExpressionParser() val context = SimpleEvaluationContext.forReadOnlyDataBinding().build() val tesla = Inventor(\"Nikola Tesla\", \"Serbian\") var name = parser.parseExpression(\"name?:'Elvis Presley'\").getValue(context, tesla, String::class.java) println(name) // Nikola Tesla tesla.setName(null) name = parser.parseExpression(\"name?:'Elvis Presley'\").getValue(context, tesla, String::class.java) println(name) // Elvis Presley \uf05a You can use the Elvis operator to apply default values in expressions. The following example shows how to use the Elvis operator in a @Value expression: @Value(\"#{systemProperties['pop3.port'] ?:25}\") This will inject a system property pop3.port if it is defined or 25 if not.309", "chunk_char_count": 1450, "chunk_word_count": 141, "chunk_token_count": 362.5}, {"page_number": 310, "sentence_chunk": "Safe Navigation Operator The safe navigation operator is used to avoid a NullPointerException and comes from the Groovy language. Typically, when you have a reference to an object, you might need to verify that it is not null before accessing methods or properties of the object. To avoid this, the safe navigation operator returns null instead of throwing an exception. The following example shows how to use the safe navigation operator: Java ExpressionParser parser = new SpelExpressionParser(); EvaluationContext context = SimpleEvaluationContext.forReadOnlyDataBinding().build(); Inventor tesla = new Inventor(\"Nikola Tesla\", \"Serbian\"); tesla.setPlaceOfBirth(new PlaceOfBirth(\"Smiljan\")); String city = parser.parseExpression(\"placeOfBirth?.city\").getValue(context, tesla, String.class); System.out.println(city); // Smiljan tesla.setPlaceOfBirth(null); city = parser.parseExpression(\"placeOfBirth?.city\").getValue(context, tesla, String.class); System.out.println(city); // null - does not throw NullPointerException!!!Kotlin val parser = SpelExpressionParser() val context = SimpleEvaluationContext.forReadOnlyDataBinding().build() val tesla = Inventor(\"Nikola Tesla\", \"Serbian\") tesla.setPlaceOfBirth(PlaceOfBirth(\"Smiljan\")) var city = parser.parseExpression(\"placeOfBirth?.city\").getValue(context, tesla, String::class.java) println(city) // Smiljan tesla.setPlaceOfBirth(null) city = parser.parseExpression(\"placeOfBirth?.city\").getValue(context, tesla, String::class.java) println(city) // null - does not throw NullPointerException!!!Collection Selection Selection is a powerful expression language feature that lets you transform a source collection into another collection by selecting from its entries. Selection uses a syntax of .?[selectionExpression]. It filters the collection and returns a new collection that contains a subset of the original elements. For example, selection lets us easily get a list of Serbian inventors, as the following example shows: 310", "chunk_char_count": 1982, "chunk_word_count": 215, "chunk_token_count": 495.5}, {"page_number": 311, "sentence_chunk": "Java List<Inventor> list = (List<Inventor>) parser.parseExpression( \u00a0    \"members.?[nationality == 'Serbian']\").getValue(societyContext); Kotlin val list = parser.parseExpression( \u00a0    \"members.?[nationality == 'Serbian']\").getValue(societyContext) as List<Inventor> Selection is supported for arrays and anything that implements java.lang. Iterable or java.util. Map. For a list or array, the selection criteria is evaluated against each individual element. Against a map, the selection criteria is evaluated against each map entry (objects of the Java type Map. Entry). Each map entry has its key and value accessible as properties for use in the selection. The following expression returns a new map that consists of those elements of the original map where the entry\u2019s value is less than 27: Java Map newMap = parser.parseExpression(\"map.?[value<27]\").getValue(); Kotlin val newMap = parser.parseExpression(\"map.?[value<27]\").getValue() In addition to returning all the selected elements, you can retrieve only the first or the last element. To obtain the first element matching the selection, the syntax is .^[selectionExpression]. To obtain the last matching selection, the syntax is .$[selectionExpression].", "chunk_char_count": 1214, "chunk_word_count": 164, "chunk_token_count": 303.5}, {"page_number": 311, "sentence_chunk": "Collection Projection Projection lets a collection drive the evaluation of a sub-expression, and the result is a new collection. The syntax for projection is .![projectionExpression]. For example, suppose we have a list of inventors but want the list of cities where they were born. Effectively, we want to evaluate 'placeOfBirth.city' for every entry in the inventor list. The following example uses projection to do so: Java // returns ['Smiljan', 'Idvor' ] List placesOfBirth = (List)parser.parseExpression(\"members.![placeOfBirth.city]\"); 311", "chunk_char_count": 546, "chunk_word_count": 76, "chunk_token_count": 136.5}, {"page_number": 312, "sentence_chunk": "Kotlin // returns ['Smiljan', 'Idvor' ] val placesOfBirth = parser.parseExpression(\"members.![placeOfBirth.city]\") as List<*> Projection is supported for arrays and anything that implements java.lang. Iterable or java.util. Map. When using a map to drive projection, the projection expression is evaluated against each entry in the map (represented as a Java Map. Entry). The result of a projection across a map is a list that consists of the evaluation of the projection expression against each map entry. Expression templating Expression templates allow mixing literal text with one or more evaluation blocks. Each evaluation block is delimited with prefix and suffix characters that you can define. A common choice is to use #{ } as the delimiters, as the following example shows: Java String randomPhrase = parser.parseExpression( \u00a0    \"random number is #{T(java.lang. Math).random()}\", \u00a0    new TemplateParserContext()).getValue(String.class); // evaluates to \"random number is 0.7038186818312008\" Kotlin val randomPhrase = parser.parseExpression( \u00a0    \"random number is #{T(java.lang.", "chunk_char_count": 1090, "chunk_word_count": 158, "chunk_token_count": 272.5}, {"page_number": 312, "sentence_chunk": "Math).random()}\", \u00a0    TemplateParserContext()).getValue(String::class.java) // evaluates to \"random number is 0.7038186818312008\" The string is evaluated by concatenating the literal text 'random number is ' with the result of evaluating the expression inside the #{ } delimiter (in this case, the result of calling that random() method). The second argument to the parseExpression() method is of the type ParserContext. The ParserContext interface is used to influence how the expression is parsed in order to support the expression templating functionality. The definition of TemplateParserContext follows: 312", "chunk_char_count": 613, "chunk_word_count": 86, "chunk_token_count": 153.25}, {"page_number": 313, "sentence_chunk": "Java public class TemplateParserContext implements ParserContext { \u00a0  public String getExpressionPrefix() { \u00a0    return \"#{\"; \u00a0  } \u00a0  public String getExpressionSuffix() { \u00a0    return \"}\"; \u00a0  } \u00a0  public boolean isTemplate() { \u00a0    return true; \u00a0  } } Kotlin class TemplateParserContext : ParserContext { \u00a0  override fun getExpressionPrefix(): String { \u00a0    return \"#{\" \u00a0  } \u00a0  override fun getExpressionSuffix(): String { \u00a0    return \"}\" \u00a0  } \u00a0  override fun isTemplate(): Boolean { \u00a0    return true \u00a0  } } 2.4.4. Classes Used in the Examples This section lists the classes used in the examples throughout this chapter. Inventor. Java package org.spring.samples.spel.inventor; import java.util. Date; import java.util. GregorianCalendar; public class Inventor { \u00a0  private String name; \u00a0  private String nationality; \u00a0  private String[] inventions; 313", "chunk_char_count": 853, "chunk_word_count": 156, "chunk_token_count": 213.25}, {"page_number": 314, "sentence_chunk": "private Date birthdate; \u00a0  private PlaceOfBirth placeOfBirth; \u00a0  public Inventor(String name, String nationality) { \u00a0    GregorianCalendar c= new GregorianCalendar(); \u00a0    this.name = name; \u00a0    this.nationality = nationality; \u00a0    this.birthdate = c.getTime(); \u00a0  } \u00a0  public Inventor(String name, Date birthdate, String nationality) { \u00a0    this.name = name; \u00a0    this.nationality = nationality; \u00a0    this.birthdate = birthdate; \u00a0  } \u00a0  public Inventor() { \u00a0  } \u00a0  public String getName() { \u00a0    return name; \u00a0  } \u00a0  public void setName(String name) { \u00a0    this.name = name; \u00a0  } \u00a0  public String getNationality() { \u00a0    return nationality; \u00a0  } \u00a0  public void setNationality(String nationality) { \u00a0    this.nationality = nationality; \u00a0  } \u00a0  public Date getBirthdate() { \u00a0    return birthdate; \u00a0  } \u00a0  public void setBirthdate(Date birthdate) { \u00a0    this.birthdate = birthdate; \u00a0  } \u00a0  public PlaceOfBirth getPlaceOfBirth() { \u00a0    return placeOfBirth; \u00a0  } \u00a0  public void setPlaceOfBirth(PlaceOfBirth placeOfBirth) { \u00a0    this.placeOfBirth = placeOfBirth; \u00a0  } 314", "chunk_char_count": 1066, "chunk_word_count": 219, "chunk_token_count": 266.5}, {"page_number": 315, "sentence_chunk": "public void setInventions(String[] inventions) { \u00a0    this.inventions = inventions; \u00a0  } \u00a0  public String[] getInventions() { \u00a0    return inventions; \u00a0  } } Inventor.kt class Inventor( \u00a0  var name: String, \u00a0  var nationality: String, \u00a0  var inventions: Array<String>?= null, \u00a0  var birthdate: Date = GregorianCalendar().time, \u00a0  var placeOfBirth: PlaceOfBirth?= null) 315", "chunk_char_count": 371, "chunk_word_count": 64, "chunk_token_count": 92.75}, {"page_number": 316, "sentence_chunk": "PlaceOfBirth.java package org.spring.samples.spel.inventor; public class PlaceOfBirth { \u00a0  private String city; \u00a0  private String country; \u00a0  public PlaceOfBirth(String city) { \u00a0    this.city=city; \u00a0  } \u00a0  public PlaceOfBirth(String city, String country) { \u00a0    this(city); \u00a0    this.country = country; \u00a0  } \u00a0  public String getCity() { \u00a0    return city; \u00a0  } \u00a0  public void setCity(String s) { \u00a0    this.city = s; \u00a0  } \u00a0  public String getCountry() { \u00a0    return country; \u00a0  } \u00a0  public void setCountry(String country) { \u00a0    this.country = country; \u00a0  } } PlaceOfBirth.kt class PlaceOfBirth(var city: String, var country: String?= null) { 316", "chunk_char_count": 644, "chunk_word_count": 130, "chunk_token_count": 161.0}, {"page_number": 317, "sentence_chunk": "Society.java package org.spring.samples.spel.inventor; import java.util.*;public class Society { \u00a0  private String name; \u00a0  public static String Advisors = \"advisors\"; \u00a0  public static String President = \"president\"; \u00a0  private List<Inventor> members = new ArrayList<Inventor>(); \u00a0  private Map officers = new HashMap(); \u00a0  public List getMembers() { \u00a0    return members; \u00a0  } \u00a0  public Map getOfficers() { \u00a0    return officers; \u00a0  } \u00a0  public String getName() { \u00a0    return name; \u00a0  } \u00a0  public void setName(String name) { \u00a0    this.name = name; \u00a0  } \u00a0  public boolean isMember(String name) { \u00a0    for (Inventor inventor : members) { \u00a0      if (inventor.getName().equals(name)) { \u00a0        return true; \u00a0      } \u00a0    } \u00a0    return false; \u00a0  } } 317", "chunk_char_count": 748, "chunk_word_count": 166, "chunk_token_count": 187.0}, {"page_number": 318, "sentence_chunk": "Society.kt package org.spring.samples.spel.inventor import java.util.*class Society { \u00a0  val Advisors = \"advisors\" \u00a0  val President = \"president\" \u00a0  var name: String?= null \u00a0  val members = ArrayList<Inventor>() \u00a0  val officers = mapOf<Any, Any>() \u00a0  fun isMember(name: String): Boolean { \u00a0    for (inventor in members) { \u00a0      if (inventor.name == name) { \u00a0        return true \u00a0      } \u00a0    } \u00a0    return false \u00a0  } } 2.5. Aspect Oriented Programming with Spring Aspect-oriented Programming (AOP) complements Object-oriented Programming (OOP) by providing another way of thinking about program structure. The key unit of modularity in OOP is the class, whereas in AOP the unit of modularity is the aspect. Aspects enable the modularization of concerns (such as transaction management) that cut across multiple types and objects. (Such concerns are often termed \u201ccrosscutting\u201d concerns in AOP literature.)One of the key components of Spring is the AOP framework. While the Spring IoC container does not depend on AOP (meaning you do not need to use AOP if you don\u2019t want to), AOP complements Spring IoC to provide a very capable middleware solution. Spring AOP with AspectJ pointcuts Spring provides simple and powerful ways of writing custom aspects by using either a schema-based approach or the @AspectJ annotation style.", "chunk_char_count": 1325, "chunk_word_count": 236, "chunk_token_count": 331.25}, {"page_number": 318, "sentence_chunk": "Both of these styles offer fully typed advice and use of the AspectJ pointcut language while still using Spring AOP for weaving. This chapter discusses the schema- and @AspectJ-based AOP support. The lower-level AOP support is discussed in the following chapter.318", "chunk_char_count": 265, "chunk_word_count": 41, "chunk_token_count": 66.25}, {"page_number": 319, "sentence_chunk": "AOP is used in the Spring Framework to: \u2022 Provide declarative enterprise services. The most important such service is declarative transaction management. \u2022Let users implement custom aspects, complementing their use of OOP with AOP.\uf05a If you are interested only in generic declarative services or other pre-packaged declarative middleware services such as pooling, you do not need to work directly with Spring AOP, and can skip most of this chapter.2.5.1. AOP Concepts Let us begin by defining some central AOP concepts and terminology. These terms are not Spring- specific. Unfortunately, AOP terminology is not particularly intuitive. However, it would be even more confusing if Spring used its own terminology. \u2022Aspect: A modularization of a concern that cuts across multiple classes.", "chunk_char_count": 785, "chunk_word_count": 119, "chunk_token_count": 196.25}, {"page_number": 319, "sentence_chunk": "Transaction management is a good example of a crosscutting concern in enterprise Java applications. In Spring AOP, aspects are implemented by using regular classes (the schema-based approach) or regular classes annotated with the @Aspect annotation (the @AspectJ style). \u2022Join point: A point during the execution of a program, such as the execution of a method or the handling of an exception. In Spring AOP, a join point always represents a method execution. \u2022Advice: Action taken by an aspect at a particular join point. Different types of advice include \u201caround\u201d, \u201cbefore\u201d and \u201cafter\u201d advice. (Advice types are discussed later.)Many AOP frameworks, including Spring, model an advice as an interceptor and maintain a chain of interceptors around the join point. \u2022Pointcut: A predicate that matches join points. Advice is associated with a pointcut expression and runs at any join point matched by the pointcut (for example, the execution of a method with a certain name).", "chunk_char_count": 973, "chunk_word_count": 153, "chunk_token_count": 243.25}, {"page_number": 319, "sentence_chunk": "The concept of join points as matched by pointcut expressions is central to AOP, and Spring uses the AspectJ pointcut expression language by default. \u2022Introduction: Declaring additional methods or fields on behalf of a type. Spring AOP lets you introduce new interfaces (and a corresponding implementation) to any advised object. For example, you could use an introduction to make a bean implement an IsModified interface, to simplify caching. (An introduction is known as an inter-type declaration in the AspectJ community.) \u2022Target object: An object being advised by one or more aspects. Also referred to as the \u201cadvised object\u201d. Since Spring AOP is implemented by using runtime proxies, this object is always a proxied object. \u2022AOP proxy: An object created by the AOP framework in order to implement the aspect contracts (advise method executions and so on). In the Spring Framework, an AOP proxy is a JDK dynamic proxy or a CGLIB proxy. \u2022", "chunk_char_count": 942, "chunk_word_count": 153, "chunk_token_count": 235.5}, {"page_number": 319, "sentence_chunk": "Weaving: linking aspects with other application types or objects to create an advised object. This can be done at compile time (using the AspectJ compiler, for example), load time, or at runtime. Spring AOP, like other pure Java AOP frameworks, performs weaving at runtime.319", "chunk_char_count": 276, "chunk_word_count": 44, "chunk_token_count": 69.0}, {"page_number": 320, "sentence_chunk": "Spring AOP includes the following types of advice: \u2022 Before advice: Advice that runs before a join point but that does not have the ability to prevent execution flow proceeding to the join point (unless it throws an exception). \u2022After returning advice: Advice to be run after a join point completes normally (for example, if a method returns without throwing an exception). \u2022After throwing advice: Advice to be run if a method exits by throwing an exception. \u2022After (finally) advice: Advice to be run regardless of the means by which a join point exits (normal or exceptional return). \u2022Around advice: Advice that surrounds a join point such as a method invocation. This is the most powerful kind of advice. Around advice can perform custom behavior before and after the method invocation. It is also responsible for choosing whether to proceed to the join point or to shortcut the advised method execution by returning its own return value or throwing an exception. Around advice is the most general kind of advice. Since Spring AOP, like AspectJ, provides a full range of advice types, we recommend that you use the least powerful advice type that can implement the required behavior.", "chunk_char_count": 1185, "chunk_word_count": 198, "chunk_token_count": 296.25}, {"page_number": 320, "sentence_chunk": "For example, if you need only to update a cache with the return value of a method, you are better off implementing an after returning advice than an around advice, although an around advice can accomplish the same thing. Using the most specific advice type provides a simpler programming model with less potential for errors. For example, you do not need to invoke the proceed() method on the JoinPoint used for around advice, and, hence, you cannot fail to invoke it. All advice parameters are statically typed so that you work with advice parameters of the appropriate type (e.g. the type of the return value from a method execution) rather than Object arrays. The concept of join points matched by pointcuts is the key to AOP, which distinguishes it from older technologies offering only interception. Pointcuts enable advice to be targeted independently of the object-oriented hierarchy. For example, you can apply an around advice providing declarative transaction management to a set of methods that span multiple objects (such as all business operations in the service layer).2.5.2. Spring AOP Capabilities and Goals Spring AOP is implemented in pure Java. There is no need for a special compilation process.", "chunk_char_count": 1215, "chunk_word_count": 197, "chunk_token_count": 303.75}, {"page_number": 320, "sentence_chunk": "Spring AOP does not need to control the class loader hierarchy and is thus suitable for use in a servlet container or application server. Spring AOP currently supports only method execution join points (advising the execution of methods on Spring beans). Field interception is not implemented, although support for field interception could be added without breaking the core Spring AOP APIs. If you need to advise field access and update join points, consider a language such as AspectJ. Spring AOP\u2019s approach to AOP differs from that of most other AOP frameworks. The aim is not to provide the most complete AOP implementation (although Spring AOP is quite capable). Rather, the aim is to provide a close integration between AOP implementation and Spring IoC, to help solve 320", "chunk_char_count": 778, "chunk_word_count": 127, "chunk_token_count": 194.5}, {"page_number": 321, "sentence_chunk": "common problems in enterprise applications. Thus, for example, the Spring Framework\u2019s AOP functionality is normally used in conjunction with the Spring IoC container. Aspects are configured by using normal bean definition syntax (although this allows powerful \u201cauto-proxying\u201d capabilities). This is a crucial difference from other AOP implementations. You cannot do some things easily or efficiently with Spring AOP, such as advise very fine-grained objects (typically, domain objects). AspectJ is the best choice in such cases. However, our experience is that Spring AOP provides an excellent solution to most problems in enterprise Java applications that are amenable to AOP. Spring AOP never strives to compete with AspectJ to provide a comprehensive AOP solution. We believe that both proxy-based frameworks such as Spring AOP and full-blown frameworks such as AspectJ are valuable and that they are complementary, rather than in competition. Spring seamlessly integrates Spring AOP and IoC with AspectJ, to enable all uses of AOP within a consistent Spring-based application architecture.", "chunk_char_count": 1093, "chunk_word_count": 160, "chunk_token_count": 273.25}, {"page_number": 321, "sentence_chunk": "This integration does not affect the Spring AOP API or the AOP Alliance API. Spring AOP remains backward-compatible. See the following chapter for a discussion of the Spring AOP APIs.\uf05a One of the central tenets of the Spring Framework is that of non-invasiveness. This is the idea that you should not be forced to introduce framework-specific classes and interfaces into your business or domain model. However, in some places, the Spring Framework does give you the option to introduce Spring Framework- specific dependencies into your codebase. The rationale in giving you such options is because, in certain scenarios, it might be just plain easier to read or code some specific piece of functionality in such a way. However, the Spring Framework (almost) always offers you the choice: You have the freedom to make an informed decision as to which option best suits your particular use case or scenario. One such choice that is relevant to this chapter is that of which AOP framework (and which AOP style) to choose. You have the choice of AspectJ, Spring AOP, or both.", "chunk_char_count": 1071, "chunk_word_count": 179, "chunk_token_count": 267.75}, {"page_number": 321, "sentence_chunk": "You also have the choice of either the @AspectJ annotation-style approach or the Spring XML configuration-style approach. The fact that this chapter chooses to introduce the @AspectJ-style approach first should not be taken as an indication that the Spring team favors the @AspectJ annotation-style approach over the Spring XML configuration-style. See Choosing which AOP Declaration Style to Use for a more complete discussion of the \u201cwhys and wherefores\u201d of each style.2.5.3. AOP Proxies Spring AOP defaults to using standard JDK dynamic proxies for AOP proxies. This enables any interface (or set of interfaces) to be proxied. Spring AOP can also use CGLIB proxies. This is necessary to proxy classes rather than interfaces. By default, CGLIB is used if a business object does not implement an interface. As it is good practice to program to interfaces rather than classes, business classes normally implement one or more business interfaces.", "chunk_char_count": 945, "chunk_word_count": 147, "chunk_token_count": 236.25}, {"page_number": 321, "sentence_chunk": "It is possible to force the use of CGLIB, in those (hopefully rare) cases where you need to advise a method that is not declared on an interface or where you need to pass a 321", "chunk_char_count": 176, "chunk_word_count": 36, "chunk_token_count": 44.0}, {"page_number": 322, "sentence_chunk": "proxied object to a method as a concrete type. It is important to grasp the fact that Spring AOP is proxy-based. See Understanding AOP Proxies for a thorough examination of exactly what this implementation detail actually means.2.5.4.@AspectJ support @AspectJ refers to a style of declaring aspects as regular Java classes annotated with annotations. The @AspectJ style was introduced by the AspectJ project as part of the AspectJ 5 release. Spring interprets the same annotations as AspectJ 5, using a library supplied by AspectJ for pointcut parsing and matching. The AOP runtime is still pure Spring AOP, though, and there is no dependency on the AspectJ compiler or weaver.\uf05a Using the AspectJ compiler and weaver enables use of the full AspectJ language and is discussed in Using AspectJ with Spring Applications. Enabling @AspectJ Support To use @AspectJ aspects in a Spring configuration, you need to enable Spring support for configuring Spring AOP based on @AspectJ aspects and auto-proxying beans based on whether or not they are advised by those aspects.", "chunk_char_count": 1064, "chunk_word_count": 169, "chunk_token_count": 266.0}, {"page_number": 322, "sentence_chunk": "By auto-proxying, we mean that, if Spring determines that a bean is advised by one or more aspects, it automatically generates a proxy for that bean to intercept method invocations and ensures that advice is run as needed. The @AspectJ support can be enabled with XML- or Java-style configuration. In either case, you also need to ensure that AspectJ\u2019s aspectjweaver.jar library is on the classpath of your application (version 1.8 or later). This library is available in the lib directory of an AspectJ distribution or from the Maven Central repository. Enabling @AspectJ Support with Java Configuration To enable @AspectJ support with Java @Configuration, add the @EnableAspectJAutoProxy annotation, as the following example shows: Java @Configuration @EnableAspectJAutoProxy public class AppConfig { } Kotlin @Configuration @EnableAspectJAutoProxy class AppConfig 322", "chunk_char_count": 870, "chunk_word_count": 126, "chunk_token_count": 217.5}, {"page_number": 323, "sentence_chunk": "Enabling @AspectJ Support with XML Configuration To enable @AspectJ support with XML-based configuration, use the aop:aspectj-autoproxy element, as the following example shows: <aop:aspectj-autoproxy/> This assumes that you use schema support as described in XML Schema-based configuration. See the AOP schema for how to import the tags in the aop namespace. Declaring an Aspect With @AspectJ support enabled, any bean defined in your application context with a class that is an @AspectJ aspect (has the @Aspect annotation) is automatically detected by Spring and used to configure Spring AOP. The next two examples show the minimal definition required for a not-very- useful aspect. The first of the two example shows a regular bean definition in the application context that points to a bean class that has the @Aspect annotation: <bean id=\"myAspect\" class=\"org.xyz. NotVeryUsefulAspect\"> \u00a0  <!--configure properties of the aspect here --> </bean> The second of the two examples shows the NotVeryUsefulAspect class definition, which is annotated with the org.aspectj.lang.annotation. Aspect annotation; Java package org.xyz; import org.aspectj.lang.annotation. Aspect; @Aspect public class NotVeryUsefulAspect { } Kotlin package org.xyz import org.aspectj.lang.annotation. Aspect; @Aspect class NotVeryUsefulAspect Aspects (classes annotated with @Aspect) can have methods and fields, the same as any other class.", "chunk_char_count": 1415, "chunk_word_count": 197, "chunk_token_count": 353.75}, {"page_number": 324, "sentence_chunk": "They can also contain pointcut, advice, and introduction (inter-type) declarations.\uf05a Autodetecting aspects through component scanning You can register aspect classes as regular beans in your Spring XML configuration, via @Bean methods in @Configuration classes, or have Spring autodetect them through classpath scanning\u2009\u2014\u2009the same as any other Spring-managed bean. However, note that the @Aspect annotation is not sufficient for autodetection in the classpath. For that purpose, you need to add a separate @Component annotation (or, alternatively, a custom stereotype annotation that qualifies, as per the rules of Spring\u2019s component scanner).\uf05a Advising aspects with other aspects?In Spring AOP, aspects themselves cannot be the targets of advice from other aspects. The @Aspect annotation on a class marks it as an aspect and, hence, excludes it from auto-proxying. Declaring a Pointcut Pointcuts determine join points of interest and thus enable us to control when advice runs. Spring AOP only supports method execution join points for Spring beans, so you can think of a pointcut as matching the execution of methods on Spring beans. A pointcut declaration has two parts: a signature comprising a name and any parameters and a pointcut expression that determines exactly which method executions we are interested in.", "chunk_char_count": 1319, "chunk_word_count": 197, "chunk_token_count": 329.75}, {"page_number": 324, "sentence_chunk": "In the @AspectJ annotation-style of AOP, a pointcut signature is provided by a regular method definition, and the pointcut expression is indicated by using the @Pointcut annotation (the method serving as the pointcut signature must have a void return type). An example may help make this distinction between a pointcut signature and a pointcut expression clear. The following example defines a pointcut named anyOldTransfer that matches the execution of any method named transfer: Java @Pointcut(\"execution(* transfer(..))\") // the pointcut expression private void anyOldTransfer() {} // the pointcut signature Kotlin @Pointcut(\"execution(* transfer(..))\") // the pointcut expression private fun anyOldTransfer() {} // the pointcut signature The pointcut expression that forms the value of the @Pointcut annotation is a regular AspectJ pointcut expression. For a full discussion of AspectJ\u2019s pointcut language, see the AspectJ Programming Guide (and, for extensions, the AspectJ 5 Developer\u2019s Notebook) or one of the books on AspectJ (such as Eclipse AspectJ, by Colyer et al.,or AspectJ in Action, by Ramnivas Laddad).324", "chunk_char_count": 1122, "chunk_word_count": 162, "chunk_token_count": 280.5}, {"page_number": 325, "sentence_chunk": "Supported Pointcut Designators Spring AOP supports the following AspectJ pointcut designators (PCD) for use in pointcut expressions: \u2022 execution: For matching method execution join points. This is the primary pointcut designator to use when working with Spring AOP. \u2022within: Limits matching to join points within certain types (the execution of a method declared within a matching type when using Spring AOP). \u2022this: Limits matching to join points (the execution of methods when using Spring AOP) where the bean reference (Spring AOP proxy) is an instance of the given type. \u2022target: Limits matching to join points (the execution of methods when using Spring AOP) where the target object (application object being proxied) is an instance of the given type. \u2022args: Limits matching to join points (the execution of methods when using Spring AOP) where the arguments are instances of the given types. \u2022@target: Limits matching to join points (the execution of methods when using Spring AOP) where the class of the executing object has an annotation of the given type. \u2022@args: Limits matching to join points (the execution of methods when using Spring AOP) where the runtime type of the actual arguments passed have annotations of the given types. \u2022@within: Limits matching to join points within types that have the given annotation (the execution of methods declared in types with the given annotation when using Spring AOP). \u2022@annotation: Limits matching to join points where the subject of the join point (the method being run in Spring AOP) has the given annotation.", "chunk_char_count": 1566, "chunk_word_count": 250, "chunk_token_count": 391.5}, {"page_number": 325, "sentence_chunk": "Other pointcut types The full AspectJ pointcut language supports additional pointcut designators that are not supported in Spring: call, get, set, preinitialization, staticinitialization, initialization, handler, adviceexecution, withincode, cflow, cflowbelow, if, @this, and @withincode. Use of these pointcut designators in pointcut expressions interpreted by Spring AOP results in an IllegalArgumentException being thrown. The set of pointcut designators supported by Spring AOP may be extended in future releases to support more of the AspectJ pointcut designators. Because Spring AOP limits matching to only method execution join points, the preceding discussion of the pointcut designators gives a narrower definition than you can find in the AspectJ programming guide. In addition, AspectJ itself has type-based semantics and, at an execution join point, both this and target refer to the same object: the object executing the method. Spring AOP is a proxy-based system and differentiates between the proxy object itself (which is bound to this) and the target object behind the proxy (which is bound to target).325", "chunk_char_count": 1122, "chunk_word_count": 162, "chunk_token_count": 280.5}, {"page_number": 326, "sentence_chunk": "\uf05a Due to the proxy-based nature of Spring\u2019s AOP framework, calls within the target object are, by definition, not intercepted. For JDK proxies, only public interface method calls on the proxy can be intercepted. With CGLIB, public and protected method calls on the proxy are intercepted (and even package-visible methods, if necessary). However, common interactions through proxies should always be designed through public signatures. Note that pointcut definitions are generally matched against any intercepted method. If a pointcut is strictly meant to be public-only, even in a CGLIB proxy scenario with potential non-public interactions through proxies, it needs to be defined accordingly. If your interception needs include method calls or even constructors within the target class, consider the use of Spring-driven native AspectJ weaving instead of Spring\u2019s proxy-based AOP framework. This constitutes a different mode of AOP usage with different characteristics, so be sure to make yourself familiar with weaving before making a decision. Spring AOP also supports an additional PCD named bean. This PCD lets you limit the matching of join points to a particular named Spring bean or to a set of named Spring beans (when using wildcards).", "chunk_char_count": 1245, "chunk_word_count": 190, "chunk_token_count": 311.25}, {"page_number": 326, "sentence_chunk": "The bean PCD has the following form: Java bean(idOrNameOfBean) Kotlin bean(idOrNameOfBean) The idOrNameOfBean token can be the name of any Spring bean. Limited wildcard support that uses the * character is provided, so, if you establish some naming conventions for your Spring beans, you can write a bean PCD expression to select them. As is the case with other pointcut designators, the bean PCD can be used with the && (and), || (or), and ! (negation) operators, too.\uf05a The bean PCD is supported only in Spring AOP and not in native AspectJ weaving. It is a Spring-specific extension to the standard PCDs that AspectJ defines and is, therefore, not available for aspects declared in the @Aspect model. The bean PCD operates at the instance level (building on the Spring bean name concept) rather than at the type level only (to which weaving-based AOP is limited). Instance-based pointcut designators are a special capability of Spring\u2019s proxy-based AOP framework and its close integration with the Spring bean factory, where it is natural and straightforward to identify specific beans by name. Combining Pointcut Expressions You can combine pointcut expressions by using &&, || and !. You can also refer to pointcut 326", "chunk_char_count": 1222, "chunk_word_count": 199, "chunk_token_count": 305.5}, {"page_number": 327, "sentence_chunk": "expressions by name. The following example shows three pointcut expressions: Java @Pointcut(\"execution(public * *(..))\") private void anyPublicOperation() {} \u2460 @Pointcut(\"within(com.xyz.myapp.trading..*)\") private void inTrading() {} \u2461 @Pointcut(\"anyPublicOperation() && inTrading()\") private void tradingOperation() {} \u2462 \u2460 anyPublicOperation matches if a method execution join point represents the execution of any public method.\u2461 inTrading matches if a method execution is in the trading module.\u2462 tradingOperation matches if a method execution represents any public method in the trading module. Kotlin @Pointcut(\"execution(public * *(..))\") private fun anyPublicOperation() {} \u2460 @Pointcut(\"within(com.xyz.myapp.trading..*)\") private fun inTrading() {} \u2461 @Pointcut(\"anyPublicOperation() && inTrading()\") private fun tradingOperation() {} \u2462 \u2460 anyPublicOperation matches if a method execution join point represents the execution of any public method.\u2461 inTrading matches if a method execution is in the trading module.\u2462 tradingOperation matches if a method execution represents any public method in the trading module. It is a best practice to build more complex pointcut expressions out of smaller named components, as shown earlier. When referring to pointcuts by name, normal Java visibility rules apply (you can see private pointcuts in the same type, protected pointcuts in the hierarchy, public pointcuts anywhere, and so on). Visibility does not affect pointcut matching.", "chunk_char_count": 1477, "chunk_word_count": 194, "chunk_token_count": 369.25}, {"page_number": 327, "sentence_chunk": "Sharing Common Pointcut Definitions When working with enterprise applications, developers often want to refer to modules of the application and particular sets of operations from within several aspects. We recommend defining a CommonPointcuts aspect that captures common pointcut expressions for this purpose. Such an aspect typically resembles the following example: Java 327", "chunk_char_count": 376, "chunk_word_count": 52, "chunk_token_count": 94.0}, {"page_number": 328, "sentence_chunk": "package com.xyz.myapp; import org.aspectj.lang.annotation. Aspect; import org.aspectj.lang.annotation. Pointcut; @Aspect public class CommonPointcuts { \u00a0  /** \u00a0  * A join point is in the web layer if the method is defined \u00a0  * in a type in the com.xyz.myapp.web package or any sub-package \u00a0  * under that.\u00a0  */ \u00a0  @Pointcut(\"within(com.xyz.myapp.web..*)\") \u00a0  public void inWebLayer() {} \u00a0  /** \u00a0  * A join point is in the service layer if the method is defined \u00a0  * in a type in the com.xyz.myapp.service package or any sub-package \u00a0  * under that.\u00a0  */ \u00a0  @Pointcut(\"within(com.xyz.myapp.service..*)\") \u00a0  public void inServiceLayer() {} \u00a0  /** \u00a0  * A join point is in the data access layer if the method is defined \u00a0  * in a type in the com.xyz.myapp.dao package or any sub-package \u00a0  * under that.\u00a0  */ \u00a0  @Pointcut(\"within(com.xyz.myapp.dao..*)\") \u00a0  public void inDataAccessLayer() {} \u00a0  /** \u00a0  * A business service is the execution of any method defined on a service \u00a0  * interface. This definition assumes that interfaces are placed in the \u00a0  * \"service\" package, and that implementation types are in sub-packages.\u00a0  * \u00a0  * If you group service interfaces by functional area (for example, \u00a0  * in packages com.xyz.myapp.abc.service and com.xyz.myapp.def.service) then \u00a0  * the pointcut expression \"execution(* com.xyz.myapp..service.*.*(..))\"\u00a0  * could be used instead.\u00a0  * \u00a0  * Alternatively, you can write the expression using the 'bean' \u00a0  * PCD, like so \"bean(*Service)\". (", "chunk_char_count": 1482, "chunk_word_count": 262, "chunk_token_count": 370.5}, {"page_number": 328, "sentence_chunk": "This assumes that you have \u00a0  * named your Spring service beans in a consistent fashion.)\u00a0  */ \u00a0  @Pointcut(\"execution(* com.xyz.myapp..service.*.*(..))\")\u00a0  public void businessService() {} \u00a0  /** 328", "chunk_char_count": 200, "chunk_word_count": 32, "chunk_token_count": 50.0}, {"page_number": 329, "sentence_chunk": "* A data access operation is the execution of any method defined on a \u00a0  * dao interface. This definition assumes that interfaces are placed in the \u00a0  * \"dao\" package, and that implementation types are in sub-packages.\u00a0  */ \u00a0  @Pointcut(\"execution(* com.xyz.myapp.dao.*.*(..))\")\u00a0  public void dataAccessOperation() {} } Kotlin package com.xyz.myapp import org.aspectj.lang.annotation. Aspect import org.aspectj.lang.annotation. Pointcut @Aspect class CommonPointcuts { \u00a0  /** \u00a0  * A join point is in the web layer if the method is defined \u00a0  * in a type in the com.xyz.myapp.web package or any sub-package \u00a0  * under that.\u00a0  */ \u00a0  @Pointcut(\"within(com.xyz.myapp.web..*)\") \u00a0  fun inWebLayer() { \u00a0  } \u00a0  /** \u00a0  * A join point is in the service layer if the method is defined \u00a0  * in a type in the com.xyz.myapp.service package or any sub-package \u00a0  * under that.\u00a0  */ \u00a0  @Pointcut(\"within(com.xyz.myapp.service..*)\") \u00a0  fun inServiceLayer() { \u00a0  } \u00a0  /** \u00a0  * A join point is in the data access layer if the method is defined \u00a0  * in a type in the com.xyz.myapp.dao package or any sub-package \u00a0  * under that.\u00a0  */ \u00a0  @Pointcut(\"within(com.xyz.myapp.dao..*)\") \u00a0  fun inDataAccessLayer() { \u00a0  } \u00a0  /** \u00a0  * A business service is the execution of any method defined on a service \u00a0  * interface. This definition assumes that interfaces are placed in the \u00a0  * \"service\" package, and that implementation types are in sub-packages.", "chunk_char_count": 1424, "chunk_word_count": 260, "chunk_token_count": 356.0}, {"page_number": 330, "sentence_chunk": "* If you group service interfaces by functional area (for example, \u00a0  * in packages com.xyz.myapp.abc.service and com.xyz.myapp.def.service) then \u00a0  * the pointcut expression \"execution(* com.xyz.myapp..service.*.*(..))\"\u00a0  * could be used instead.\u00a0  * \u00a0  * Alternatively, you can write the expression using the 'bean' \u00a0  * PCD, like so \"bean(*Service)\". (This assumes that you have \u00a0  * named your Spring service beans in a consistent fashion.)\u00a0  */ \u00a0  @Pointcut(\"execution(* com.xyz.myapp..service.*.*(..))\")\u00a0  fun businessService() { \u00a0  } \u00a0  /** \u00a0  * A data access operation is the execution of any method defined on a \u00a0  * dao interface. This definition assumes that interfaces are placed in the \u00a0  * \"dao\" package, and that implementation types are in sub-packages.\u00a0  */ \u00a0  @Pointcut(\"execution(* com.xyz.myapp.dao.*.*(..))\")\u00a0  fun dataAccessOperation() { \u00a0  } } You can refer to the pointcuts defined in such an aspect anywhere you need a pointcut expression. For example, to make the service layer transactional, you could write the following: <aop:config> \u00a0  <aop:advisor \u00a0    pointcut=\"com.xyz.myapp.", "chunk_char_count": 1108, "chunk_word_count": 183, "chunk_token_count": 277.0}, {"page_number": 330, "sentence_chunk": "CommonPointcuts.businessService()\" \u00a0    advice-ref=\"tx-advice\"/> </aop:config> <tx:advice id=\"tx-advice\"> \u00a0  <tx:attributes> \u00a0    <tx:method name=\"*\" propagation=\"REQUIRED\"/> \u00a0  </tx:attributes> </tx:advice> The <aop:config> and <aop:advisor> elements are discussed in Schema-based AOP Support. The transaction elements are discussed in Transaction Management. Examples Spring AOP users are likely to use the execution pointcut designator the most often. The format of an execution expression follows: 330", "chunk_char_count": 505, "chunk_word_count": 65, "chunk_token_count": 126.25}, {"page_number": 331, "sentence_chunk": "execution(modifiers-pattern?ret-type-pattern declaring-type-pattern?name- pattern(param-pattern) \u00a0        throws-pattern?)All parts except the returning type pattern (ret-type-pattern in the preceding snippet), the name pattern, and the parameters pattern are optional. The returning type pattern determines what the return type of the method must be in order for a join point to be matched. *is most frequently used as the returning type pattern. It matches any return type. A fully-qualified type name matches only when the method returns the given type. The name pattern matches the method name. You can use the * wildcard as all or part of a name pattern. If you specify a declaring type pattern, include a trailing .", "chunk_char_count": 721, "chunk_word_count": 114, "chunk_token_count": 180.25}, {"page_number": 331, "sentence_chunk": "to join it to the name pattern component. The parameters pattern is slightly more complex: () matches a method that takes no parameters, whereas (..) matches any number (zero or more) of parameters. The (*) pattern matches a method that takes one parameter of any type. (*,String) matches a method that takes two parameters. The first can be of any type, while the second must be a String. Consult the Language Semantics section of the AspectJ Programming Guide for more information. The following examples show some common pointcut expressions: \u2022 The execution of any public method: \u00a0  execution(public * *(..)) \u2022 The execution of any method with a name that begins with set: \u00a0  execution(* set*(..)) \u2022 The execution of any method defined by the AccountService interface: \u00a0  execution(* com.xyz.service. AccountService.*(..)) \u2022The execution of any method defined in the service package: \u00a0  execution(* com.xyz.service.*.*(..)) \u2022The execution of any method defined in the service package or one of its sub-packages: \u00a0  execution(* com.xyz.service..*.*(..)) \u2022", "chunk_char_count": 1058, "chunk_word_count": 168, "chunk_token_count": 264.5}, {"page_number": 332, "sentence_chunk": "\u2022 Any join point (method execution only in Spring AOP) within the service package or one of its sub-packages: \u00a0  within(com.xyz.service..*) \u2022 Any join point (method execution only in Spring AOP) where the proxy implements the AccountService interface: \u00a0  this(com.xyz.service. AccountService) \uf05a this is more commonly used in a binding form. See the section on Declaring Advice for how to make the proxy object available in the advice body. \u2022Any join point (method execution only in Spring AOP) where the target object implements the AccountService interface: \u00a0  target(com.xyz.service. AccountService) \uf05a target is more commonly used in a binding form. See the Declaring Advice section for how to make the target object available in the advice body. \u2022Any join point (method execution only in Spring AOP) that takes a single parameter and where the argument passed at runtime is Serializable: \u00a0  args(java.io. Serializable) \uf05a args is more commonly used in a binding form. See the Declaring Advice section for how to make the method arguments available in the advice body. Note that the pointcut given in this example is different from execution(* *(java.io.", "chunk_char_count": 1155, "chunk_word_count": 186, "chunk_token_count": 288.75}, {"page_number": 332, "sentence_chunk": "Serializable)). The args version matches if the argument passed at runtime is Serializable, and the execution version matches if the method signature declares a single parameter of type Serializable. \u2022Any join point (method execution only in Spring AOP) where the target object has a @Transactional annotation: \u00a0  @target(org.springframework.transaction.annotation. Transactional) \uf05a You can also use @target in a binding form. See the Declaring Advice section for how to make the annotation object available in the advice body.332", "chunk_char_count": 530, "chunk_word_count": 77, "chunk_token_count": 132.5}, {"page_number": 333, "sentence_chunk": "\u2022 Any join point (method execution only in Spring AOP) where the declared type of the target object has an @Transactional annotation: \u00a0  @within(org.springframework.transaction.annotation. Transactional) \uf05a You can also use @within in a binding form. See the Declaring Advice section for how to make the annotation object available in the advice body. \u2022Any join point (method execution only in Spring AOP) where the executing method has an @Transactional annotation: \u00a0  @annotation(org.springframework.transaction.annotation. Transactional) \uf05a You can also use @annotation in a binding form. See the Declaring Advice section for how to make the annotation object available in the advice body. \u2022Any join point (method execution only in Spring AOP) which takes a single parameter, and where the runtime type of the argument passed has the @Classified annotation: \u00a0  @args(com.xyz.security. Classified) \uf05a You can also use @args in a binding form. See the Declaring Advice section how to make the annotation object(s) available in the advice body. \u2022Any join point (method execution only in Spring AOP) on a Spring bean named tradeService: \u00a0  bean(tradeService) \u2022 Any join point (method execution only in Spring AOP) on Spring beans having names that match the wildcard expression *Service: \u00a0  bean(*Service) Writing Good Pointcuts During compilation, AspectJ processes pointcuts in order to optimize matching performance.", "chunk_char_count": 1415, "chunk_word_count": 214, "chunk_token_count": 353.75}, {"page_number": 333, "sentence_chunk": "Examining code and determining if each join point matches (statically or dynamically) a given pointcut is a costly process. (A dynamic match means the match cannot be fully determined from static analysis and that a test is placed in the code to determine if there is an actual match when the code is running). On first encountering a pointcut declaration, AspectJ rewrites it into an optimal form for the matching process. What does this mean?Basically, pointcuts are rewritten in DNF (Disjunctive Normal Form) and the components of the pointcut are sorted such that those 333", "chunk_char_count": 577, "chunk_word_count": 95, "chunk_token_count": 144.25}, {"page_number": 334, "sentence_chunk": "components that are cheaper to evaluate are checked first. This means you do not have to worry about understanding the performance of various pointcut designators and may supply them in any order in a pointcut declaration. However, AspectJ can work only with what it is told. For optimal performance of matching, you should think about what they are trying to achieve and narrow the search space for matches as much as possible in the definition. The existing designators naturally fall into one of three groups: kinded, scoping, and contextual: \u2022 Kinded designators select a particular kind of join point: execution, get, set, call, and handler. \u2022Scoping designators select a group of join points of interest (probably of many kinds): within and withincode \u2022 Contextual designators match (and optionally bind) based on context: this, target, and @annotation A well written pointcut should include at least the first two types (kinded and scoping). You can include the contextual designators to match based on join point context or bind that context for use in the advice. Supplying only a kinded designator or only a contextual designator works but could affect weaving performance (time and memory used), due to extra processing and analysis. Scoping designators are very fast to match, and using them means AspectJ can very quickly dismiss groups of join points that should not be further processed. A good pointcut should always include one if possible.", "chunk_char_count": 1457, "chunk_word_count": 234, "chunk_token_count": 364.25}, {"page_number": 334, "sentence_chunk": "Declaring Advice Advice is associated with a pointcut expression and runs before, after, or around method executions matched by the pointcut. The pointcut expression may be either a simple reference to a named pointcut or a pointcut expression declared in place. Before Advice You can declare before advice in an aspect by using the @Before annotation: Java import org.aspectj.lang.annotation. Aspect; import org.aspectj.lang.annotation. Before; @Aspect public class BeforeExample { \u00a0  @Before(\"com.xyz.myapp. CommonPointcuts.dataAccessOperation()\") \u00a0  public void doAccessCheck() { \u00a0    // ... \u00a0  } } 334", "chunk_char_count": 605, "chunk_word_count": 89, "chunk_token_count": 151.25}, {"page_number": 335, "sentence_chunk": "Kotlin import org.aspectj.lang.annotation. Aspect import org.aspectj.lang.annotation. Before @Aspect class BeforeExample { \u00a0  @Before(\"com.xyz.myapp. CommonPointcuts.dataAccessOperation()\") \u00a0  fun doAccessCheck() { \u00a0    // ... \u00a0  } } If we use an in-place pointcut expression, we could rewrite the preceding example as the following example: Java import org.aspectj.lang.annotation. Aspect; import org.aspectj.lang.annotation. Before; @Aspect public class BeforeExample { \u00a0  @Before(\"execution(* com.xyz.myapp.dao.*.*(..))\")\u00a0  public void doAccessCheck() { \u00a0    // ... \u00a0  } } Kotlin import org.aspectj.lang.annotation. Aspect import org.aspectj.lang.annotation. Before @Aspect class BeforeExample { \u00a0  @Before(\"execution(* com.xyz.myapp.dao.*.*(..))\")\u00a0  fun doAccessCheck() { \u00a0    // ... \u00a0  } } After Returning Advice After returning advice runs when a matched method execution returns normally.", "chunk_char_count": 895, "chunk_word_count": 121, "chunk_token_count": 223.75}, {"page_number": 336, "sentence_chunk": "Java import org.aspectj.lang.annotation. Aspect; import org.aspectj.lang.annotation. AfterReturning; @Aspect public class AfterReturningExample { \u00a0  @AfterReturning(\"com.xyz.myapp. CommonPointcuts.dataAccessOperation()\") \u00a0  public void doAccessCheck() { \u00a0    // ... \u00a0  } } Kotlin import org.aspectj.lang.annotation. Aspect import org.aspectj.lang.annotation. AfterReturning @Aspect class AfterReturningExample { \u00a0  @AfterReturning(\"com.xyz.myapp. CommonPointcuts.dataAccessOperation()\") \u00a0  fun doAccessCheck() { \u00a0    // ... \u00a0  } } \uf05a You can have multiple advice declarations (and other members as well), all inside the same aspect. We show only a single advice declaration in these examples to focus the effect of each one. Sometimes, you need access in the advice body to the actual value that was returned. You can use the form of @AfterReturning that binds the return value to get that access, as the following example shows: 336", "chunk_char_count": 932, "chunk_word_count": 133, "chunk_token_count": 233.0}, {"page_number": 337, "sentence_chunk": "Java import org.aspectj.lang.annotation. Aspect; import org.aspectj.lang.annotation. AfterReturning; @Aspect public class AfterReturningExample { \u00a0  @AfterReturning( \u00a0    pointcut=\"com.xyz.myapp. CommonPointcuts.dataAccessOperation()\", \u00a0    returning=\"retVal\") \u00a0  public void doAccessCheck(Object retVal) { \u00a0    // ... \u00a0  } } Kotlin import org.aspectj.lang.annotation. Aspect import org.aspectj.lang.annotation. AfterReturning @Aspect class AfterReturningExample { \u00a0  @AfterReturning( \u00a0    pointcut = \"com.xyz.myapp. CommonPointcuts.dataAccessOperation()\", \u00a0    returning = \"retVal\") \u00a0  fun doAccessCheck(retVal: Any) { \u00a0    // ... \u00a0  } } The name used in the returning attribute must correspond to the name of a parameter in the advice method. When a method execution returns, the return value is passed to the advice method as the corresponding argument value. A returning clause also restricts matching to only those method executions that return a value of the specified type (in this case, Object, which matches any return value). Please note that it is not possible to return a totally different reference when using after returning advice.", "chunk_char_count": 1146, "chunk_word_count": 172, "chunk_token_count": 286.5}, {"page_number": 337, "sentence_chunk": "After Throwing Advice After throwing advice runs when a matched method execution exits by throwing an exception. You can declare it by using the @AfterThrowing annotation, as the following example shows: 337", "chunk_char_count": 207, "chunk_word_count": 32, "chunk_token_count": 51.75}, {"page_number": 338, "sentence_chunk": "Java import org.aspectj.lang.annotation. Aspect; import org.aspectj.lang.annotation. AfterThrowing; @Aspect public class AfterThrowingExample { \u00a0  @AfterThrowing(\"com.xyz.myapp. CommonPointcuts.dataAccessOperation()\") \u00a0  public void doRecoveryActions() { \u00a0    // ... \u00a0  } } Kotlin import org.aspectj.lang.annotation. Aspect import org.aspectj.lang.annotation. AfterThrowing @Aspect class AfterThrowingExample { \u00a0  @AfterThrowing(\"com.xyz.myapp. CommonPointcuts.dataAccessOperation()\") \u00a0  fun doRecoveryActions() { \u00a0    // ... \u00a0  } } Often, you want the advice to run only when exceptions of a given type are thrown, and you also often need access to the thrown exception in the advice body. You can use the throwing attribute to both restrict matching (if desired\u2009\u2014\u2009use Throwable as the exception type otherwise) and bind the thrown exception to an advice parameter. The following example shows how to do so: Java import org.aspectj.lang.annotation. Aspect; import org.aspectj.lang.annotation.", "chunk_char_count": 993, "chunk_word_count": 133, "chunk_token_count": 248.25}, {"page_number": 338, "sentence_chunk": "AfterThrowing; @Aspect public class AfterThrowingExample { \u00a0  @AfterThrowing( \u00a0    pointcut=\"com.xyz.myapp. CommonPointcuts.dataAccessOperation()\", \u00a0    throwing=\"ex\") \u00a0  public void doRecoveryActions(DataAccessException ex) { \u00a0    // ... \u00a0  } } 338", "chunk_char_count": 249, "chunk_word_count": 38, "chunk_token_count": 62.25}, {"page_number": 339, "sentence_chunk": "Kotlin import org.aspectj.lang.annotation. Aspect import org.aspectj.lang.annotation. AfterThrowing @Aspect class AfterThrowingExample { \u00a0  @AfterThrowing( \u00a0    pointcut = \"com.xyz.myapp. CommonPointcuts.dataAccessOperation()\", \u00a0    throwing = \"ex\") \u00a0  fun doRecoveryActions(ex: DataAccessException) { \u00a0    // ... \u00a0  } } The name used in the throwing attribute must correspond to the name of a parameter in the advice method. When a method execution exits by throwing an exception, the exception is passed to the advice method as the corresponding argument value. A throwing clause also restricts matching to only those method executions that throw an exception of the specified type (DataAccessException, in this case).\uf05a Note that @AfterThrowing does not indicate a general exception handling callback. Specifically, an @AfterThrowing advice method is only supposed to receive exceptions from the join point (user-declared target method) itself but not from an accompanying @After/@AfterReturning method. After (Finally) Advice After (finally) advice runs when a matched method execution exits. It is declared by using the @After annotation.", "chunk_char_count": 1142, "chunk_word_count": 167, "chunk_token_count": 285.5}, {"page_number": 339, "sentence_chunk": "After advice must be prepared to handle both normal and exception return conditions. It is typically used for releasing resources and similar purposes. The following example shows how to use after finally advice: Java import org.aspectj.lang.annotation. Aspect; import org.aspectj.lang.annotation. After; @Aspect public class AfterFinallyExample { \u00a0  @After(\"com.xyz.myapp. CommonPointcuts.dataAccessOperation()\") \u00a0  public void doReleaseLock() { \u00a0    // ... \u00a0  } } 339", "chunk_char_count": 469, "chunk_word_count": 66, "chunk_token_count": 117.25}, {"page_number": 340, "sentence_chunk": "Kotlin import org.aspectj.lang.annotation. Aspect import org.aspectj.lang.annotation. After @Aspect class AfterFinallyExample { \u00a0  @After(\"com.xyz.myapp. CommonPointcuts.dataAccessOperation()\") \u00a0  fun doReleaseLock() { \u00a0    // ... \u00a0  } } \uf05a Note that @After advice in AspectJ is defined as \"after finally advice\", analogous to a finally block in a try-catch statement. It will be invoked for any outcome, normal return or exception thrown from the join point (user-declared target method), in contrast to @AfterReturning which only applies to successful normal returns. Around Advice The last kind of advice is around advice. Around advice runs \"around\" a matched method\u2019s execution. It has the opportunity to do work both before and after the method runs and to determine when, how, and even if the method actually gets to run at all. Around advice is often used if you need to share state before and after a method execution in a thread-safe manner \u2013 for example, starting and stopping a timer.\uf0eb Always use the least powerful form of advice that meets your requirements.", "chunk_char_count": 1071, "chunk_word_count": 171, "chunk_token_count": 267.75}, {"page_number": 340, "sentence_chunk": "For example, do not use around advice if before advice is sufficient for your needs. Around advice is declared by annotating a method with the @Around annotation. The method should declare Object as its return type, and the first parameter of the method must be of type ProceedingJoinPoint. Within the body of the advice method, you must invoke proceed() on the ProceedingJoinPoint in order for the underlying method to run. Invoking proceed() without arguments will result in the caller\u2019s original arguments being supplied to the underlying method when it is invoked. For advanced use cases, there is an overloaded variant of the proceed() method which accepts an array of arguments (Object[]). The values in the array will be used as the arguments to the underlying method when it is invoked.340", "chunk_char_count": 797, "chunk_word_count": 130, "chunk_token_count": 199.25}, {"page_number": 341, "sentence_chunk": "\uf05a The behavior of proceed when called with an Object[] is a little different than the behavior of proceed for around advice compiled by the AspectJ compiler. For around advice written using the traditional AspectJ language, the number of arguments passed to proceed must match the number of arguments passed to the around advice (not the number of arguments taken by the underlying join point), and the value passed to proceed in a given argument position supplants the original value at the join point for the entity the value was bound to (do not worry if this does not make sense right now). The approach taken by Spring is simpler and a better match to its proxy-based, execution-only semantics. You only need to be aware of this difference if you compile @AspectJ aspects written for Spring and use proceed with arguments with the AspectJ compiler and weaver. There is a way to write such aspects that is 100% compatible across both Spring AOP and AspectJ, and this is discussed in the following section on advice parameters. The value returned by the around advice is the return value seen by the caller of the method. For example, a simple caching aspect could return a value from a cache if it has one or invoke proceed() (and return that value) if it does not. Note that proceed may be invoked once, many times, or not at all within the body of the around advice. All of these are legal.\uf071 If you declare the return type of your around advice method as void, null will always be returned to the caller, effectively ignoring the result of any invocation of proceed().", "chunk_char_count": 1574, "chunk_word_count": 277, "chunk_token_count": 393.5}, {"page_number": 341, "sentence_chunk": "It is therefore recommended that an around advice method declare a return type of Object. The advice method should typically return the value returned from an invocation of proceed(), even if the underlying method has a void return type. However, the advice may optionally return a cached value, a wrapped value, or some other value depending on the use case. The following example shows how to use around advice: Java import org.aspectj.lang.annotation. Aspect; import org.aspectj.lang.annotation. Around; import org.aspectj.lang. ProceedingJoinPoint; @Aspect public class AroundExample { \u00a0  @Around(\"com.xyz.myapp. CommonPointcuts.businessService()\") \u00a0  public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable { \u00a0    // start stopwatch \u00a0    Object retVal = pjp.proceed(); \u00a0    // stop stopwatch \u00a0    return retVal; \u00a0  } } 341", "chunk_char_count": 844, "chunk_word_count": 130, "chunk_token_count": 211.0}, {"page_number": 342, "sentence_chunk": "Kotlin import org.aspectj.lang.annotation. Aspect import org.aspectj.lang.annotation. Around import org.aspectj.lang. ProceedingJoinPoint @Aspect class AroundExample { \u00a0  @Around(\"com.xyz.myapp. CommonPointcuts.businessService()\") \u00a0  fun doBasicProfiling(pjp: ProceedingJoinPoint): Any { \u00a0    // start stopwatch \u00a0    val retVal = pjp.proceed() \u00a0    // stop stopwatch \u00a0    return retVal \u00a0  } } Advice Parameters Spring offers fully typed advice, meaning that you declare the parameters you need in the advice signature (as we saw earlier for the returning and throwing examples) rather than work with Object[] arrays all the time. We see how to make argument and other contextual values available to the advice body later in this section. First, we take a look at how to write generic advice that can find out about the method the advice is currently advising. Access to the Current JoinPoint Any advice method may declare, as its first parameter, a parameter of type org.aspectj.lang. JoinPoint. Note that around advice is required to declare a first parameter of type ProceedingJoinPoint, which is a subclass of JoinPoint.", "chunk_char_count": 1123, "chunk_word_count": 177, "chunk_token_count": 280.75}, {"page_number": 342, "sentence_chunk": "The JoinPoint interface provides a number of useful methods: \u2022 getArgs(): Returns the method arguments. \u2022getThis(): Returns the proxy object. \u2022getTarget(): Returns the target object. \u2022getSignature(): Returns a description of the method that is being advised. \u2022toString(): Prints a useful description of the method being advised. See the javadoc for more detail. Passing Parameters to Advice We have already seen how to bind the returned value or exception value (using after returning and after throwing advice). To make argument values available to the advice body, you can use the binding form of args. If you use a parameter name in place of a type name in an args expression, the value of the corresponding argument is passed as the parameter value when the advice is 342", "chunk_char_count": 775, "chunk_word_count": 126, "chunk_token_count": 193.75}, {"page_number": 343, "sentence_chunk": "invoked. An example should make this clearer. Suppose you want to advise the execution of DAO operations that take an Account object as the first parameter, and you need access to the account in the advice body. You could write the following: Java @Before(\"com.xyz.myapp. CommonPointcuts.dataAccessOperation() && args(account,..)\") public void validateAccount(Account account) { \u00a0  // ... } Kotlin @Before(\"com.xyz.myapp. CommonPointcuts.dataAccessOperation() && args(account,..)\") fun validateAccount(account: Account) { \u00a0  // ... } The args(account,..) part of the pointcut expression serves two purposes. First, it restricts matching to only those method executions where the method takes at least one parameter, and the argument passed to that parameter is an instance of Account. Second, it makes the actual Account object available to the advice through the account parameter. Another way of writing this is to declare a pointcut that \"provides\" the Account object value when it matches a join point, and then refer to the named pointcut from the advice. This would look as follows: Java @Pointcut(\"com.xyz.myapp.", "chunk_char_count": 1119, "chunk_word_count": 164, "chunk_token_count": 279.75}, {"page_number": 343, "sentence_chunk": "CommonPointcuts.dataAccessOperation() && args(account,..)\") private void accountDataAccessOperation(Account account) {} @Before(\"accountDataAccessOperation(account)\") public void validateAccount(Account account) { \u00a0  // ... } Kotlin @Pointcut(\"com.xyz.myapp. CommonPointcuts.dataAccessOperation() && args(account,..)\") private fun accountDataAccessOperation(account: Account) { } @Before(\"accountDataAccessOperation(account)\") fun validateAccount(account: Account) { \u00a0  // ... } 343", "chunk_char_count": 482, "chunk_word_count": 41, "chunk_token_count": 120.5}, {"page_number": 344, "sentence_chunk": "See the AspectJ programming guide for more details. The proxy object (this), target object (target), and annotations (@within, @target, @annotation, and @args) can all be bound in a similar fashion. The next two examples show how to match the execution of methods annotated with an @Auditable annotation and extract the audit code: The first of the two examples shows the definition of the @Auditable annotation: Java @Retention(RetentionPolicy. RUNTIME) @Target(ElementType. METHOD) public @interface Auditable { \u00a0  AuditCode value(); } Kotlin @Retention(AnnotationRetention. RUNTIME) @Target(AnnotationTarget. FUNCTION) annotation class Auditable(val value: AuditCode) The second of the two examples shows the advice that matches the execution of @Auditable methods: Java @Before(\"com.xyz.lib. Pointcuts.anyPublicMethod() && @annotation(auditable)\") public void audit(Auditable auditable) { \u00a0  AuditCode code = auditable.value(); \u00a0  // ... } Kotlin @Before(\"com.xyz.lib. Pointcuts.anyPublicMethod() && @annotation(auditable)\") fun audit(auditable: Auditable) { \u00a0  val code = auditable.value() \u00a0  // ... } Advice Parameters and Generics Spring AOP can handle generics used in class declarations and method parameters. Suppose you have a generic type like the following: 344", "chunk_char_count": 1274, "chunk_word_count": 172, "chunk_token_count": 318.5}, {"page_number": 345, "sentence_chunk": "Java public interface Sample<T> { \u00a0  void sampleGenericMethod(T param); \u00a0  void sampleGenericCollectionMethod(Collection<T> param); } Kotlin interface Sample<T> { \u00a0  fun sampleGenericMethod(param: T) \u00a0  fun sampleGenericCollectionMethod(param: Collection<T>) } You can restrict interception of method types to certain parameter types by tying the advice parameter to the parameter type for which you want to intercept the method: Java @Before(\"execution(* .. Sample+.sampleGenericMethod(*)) && args(param)\") public void beforeSampleMethod(MyType param) { \u00a0  // Advice implementation } Kotlin @Before(\"execution(* .. Sample+.sampleGenericMethod(*)) && args(param)\") fun beforeSampleMethod(param: MyType) { \u00a0  // Advice implementation } This approach does not work for generic collections. So you cannot define a pointcut as follows: Java @Before(\"execution(* .. Sample+.sampleGenericCollectionMethod(*)) && args(param)\") public void beforeSampleMethod(Collection<MyType> param) { \u00a0  // Advice implementation } Kotlin @Before(\"execution(* .. Sample+.sampleGenericCollectionMethod(*)) && args(param)\") fun beforeSampleMethod(param: Collection<MyType>) { \u00a0  // Advice implementation } 345", "chunk_char_count": 1184, "chunk_word_count": 142, "chunk_token_count": 296.0}, {"page_number": 346, "sentence_chunk": "To make this work, we would have to inspect every element of the collection, which is not reasonable, as we also cannot decide how to treat null values in general. To achieve something similar to this, you have to type the parameter to Collection<?> and manually check the type of the elements. Determining Argument Names The parameter binding in advice invocations relies on matching names used in pointcut expressions to declared parameter names in advice and pointcut method signatures. Parameter names are not available through Java reflection, so Spring AOP uses the following strategy to determine parameter names: \u2022 If the parameter names have been explicitly specified by the user, the specified parameter names are used. Both the advice and the pointcut annotations have an optional argNames attribute that you can use to specify the argument names of the annotated method. These argument names are available at runtime. The following example shows how to use the argNames attribute: Java @Before(value=\"com.xyz.lib. Pointcuts.anyPublicMethod() && target(bean) && @annotation(auditable)\", \u00a0    argNames=\"bean,auditable\") public void audit(Object bean, Auditable auditable) { \u00a0  AuditCode code = auditable.value(); \u00a0  // ... use code and bean } Kotlin @Before(value = \"com.xyz.lib. Pointcuts.anyPublicMethod() && target(bean) && @annotation(auditable)\", argNames = \"bean,auditable\") fun audit(bean: Any, auditable: Auditable) { \u00a0  val code = auditable.value() \u00a0  // ... use code and bean } If the first parameter is of the JoinPoint, ProceedingJoinPoint, or JoinPoint.", "chunk_char_count": 1576, "chunk_word_count": 236, "chunk_token_count": 394.0}, {"page_number": 346, "sentence_chunk": "StaticPart type, you can leave out the name of the parameter from the value of the argNames attribute. For example, if you modify the preceding advice to receive the join point object, the argNames attribute need not include it: 346", "chunk_char_count": 232, "chunk_word_count": 40, "chunk_token_count": 58.0}, {"page_number": 347, "sentence_chunk": "Java @Before(value=\"com.xyz.lib. Pointcuts.anyPublicMethod() && target(bean) && @annotation(auditable)\", \u00a0    argNames=\"bean,auditable\") public void audit(JoinPoint jp, Object bean, Auditable auditable) { \u00a0  AuditCode code = auditable.value(); \u00a0  // ... use code, bean, and jp } Kotlin @Before(value = \"com.xyz.lib. Pointcuts.anyPublicMethod() && target(bean) && @annotation(auditable)\", argNames = \"bean,auditable\") fun audit(jp: JoinPoint, bean: Any, auditable: Auditable) { \u00a0  val code = auditable.value() \u00a0  // ... use code, bean, and jp } The special treatment given to the first parameter of the JoinPoint, ProceedingJoinPoint, and JoinPoint. StaticPart types is particularly convenient for advice instances that do not collect any other join point context. In such situations, you may omit the argNames attribute. For example, the following advice need not declare the argNames attribute: Java @Before(\"com.xyz.lib. Pointcuts.anyPublicMethod()\") public void audit(JoinPoint jp) { \u00a0  // ... use jp } Kotlin @Before(\"com.xyz.lib. Pointcuts.anyPublicMethod()\") fun audit(jp: JoinPoint) { \u00a0  // ... use jp } \u2022 Using the argNames attribute is a little clumsy, so if the argNames attribute has not been specified, Spring AOP looks at the debug information for the class and tries to determine the parameter names from the local variable table. This information is present as long as the classes have been compiled with debug information (-g:vars at a minimum). The consequences of compiling with this flag on are: (1) your code is slightly easier to understand (reverse engineer), (2) the class file sizes are very slightly bigger (typically inconsequential), (3) the optimization to remove unused local variables is not applied by your compiler.", "chunk_char_count": 1747, "chunk_word_count": 256, "chunk_token_count": 436.75}, {"page_number": 348, "sentence_chunk": "\uf05a If an @AspectJ aspect has been compiled by the AspectJ compiler (ajc) even without the debug information, you need not add the argNames attribute, as the compiler retain the needed information. \u2022If the code has been compiled without the necessary debug information, Spring AOP tries to deduce the pairing of binding variables to parameters (for example, if only one variable is bound in the pointcut expression, and the advice method takes only one parameter, the pairing is obvious). If the binding of variables is ambiguous given the available information, an AmbiguousBindingException is thrown. \u2022If all of the above strategies fail, an IllegalArgumentException is thrown. Proceeding with Arguments We remarked earlier that we would describe how to write a proceed call with arguments that works consistently across Spring AOP and AspectJ. The solution is to ensure that the advice signature binds each of the method parameters in order. The following example shows how to do so: Java @Around(\"execution(List<Account> find*(..)) && \" + \u00a0    \"com.xyz.myapp. CommonPointcuts.inDataAccessLayer() && \" + \u00a0    \"args(accountHolderNamePattern)\") public Object preProcessQueryPattern(ProceedingJoinPoint pjp, \u00a0    String accountHolderNamePattern) throws Throwable { \u00a0  String newPattern = preProcess(accountHolderNamePattern); \u00a0  return pjp.proceed(new Object[] {newPattern}); } Kotlin @Around(\"execution(List<Account> find*(..)) && \" + \u00a0    \"com.xyz.myapp. CommonPointcuts.inDataAccessLayer() && \" + \u00a0    \"args(accountHolderNamePattern)\") fun preProcessQueryPattern(pjp: ProceedingJoinPoint, \u00a0            accountHolderNamePattern: String): Any { \u00a0  val newPattern = preProcess(accountHolderNamePattern) \u00a0  return pjp.proceed(arrayOf<Any>(newPattern)) } In many cases, you do this binding anyway (as in the preceding example). Advice Ordering What happens when multiple pieces of advice all want to run at the same join point?Spring AOP follows the same precedence rules as AspectJ to determine the order of advice execution.", "chunk_char_count": 2022, "chunk_word_count": 298, "chunk_token_count": 505.5}, {"page_number": 348, "sentence_chunk": "The highest precedence advice runs first \"on the way in\" (so, given two pieces of before advice, the one with highest precedence runs first). \"On the way out\" from a join point, the highest precedence advice runs last (so, given two pieces of after advice, the one with the highest precedence will run 348", "chunk_char_count": 305, "chunk_word_count": 54, "chunk_token_count": 76.25}, {"page_number": 349, "sentence_chunk": "second). When two pieces of advice defined in different aspects both need to run at the same join point, unless you specify otherwise, the order of execution is undefined. You can control the order of execution by specifying precedence. This is done in the normal Spring way by either implementing the org.springframework.core. Ordered interface in the aspect class or annotating it with the @Order annotation. Given two aspects, the aspect returning the lower value from Ordered.getOrder() (or the annotation value) has the higher precedence.\uf05a Each of the distinct advice types of a particular aspect is conceptually meant to apply to the join point directly. As a consequence, an @AfterThrowing advice method is not supposed to receive an exception from an accompanying @After /@AfterReturning method. As of Spring Framework 5.2.7, advice methods defined in the same @Aspect class that need to run at the same join point are assigned precedence based on their advice type in the following order, from highest to lowest precedence: @Around, @Before, @After, @AfterReturning, @AfterThrowing. Note, however, that an @After advice method will effectively be invoked after any @AfterReturning or @AfterThrowing advice methods in the same aspect, following AspectJ\u2019s \"after finally advice\" semantics for @After.", "chunk_char_count": 1307, "chunk_word_count": 198, "chunk_token_count": 326.75}, {"page_number": 349, "sentence_chunk": "When two pieces of the same type of advice (for example, two @After advice methods) defined in the same @Aspect class both need to run at the same join point, the ordering is undefined (since there is no way to retrieve the source code declaration order through reflection for javac-compiled classes). Consider collapsing such advice methods into one advice method per join point in each @Aspect class or refactor the pieces of advice into separate @Aspect classes that you can order at the aspect level via Ordered or @Order. Introductions Introductions (known as inter-type declarations in AspectJ) enable an aspect to declare that advised objects implement a given interface, and to provide an implementation of that interface on behalf of those objects. You can make an introduction by using the @DeclareParents annotation. This annotation is used to declare that matching types have a new parent (hence the name). For example, given an interface named UsageTracked and an implementation of that interface named DefaultUsageTracked, the following aspect declares that all implementors of service interfaces also implement the UsageTracked interface (e.g. for statistics via JMX): 349", "chunk_char_count": 1187, "chunk_word_count": 184, "chunk_token_count": 296.75}, {"page_number": 350, "sentence_chunk": "Java @Aspect public class UsageTracking { \u00a0  @DeclareParents(value=\"com.xzy.myapp.service.*+\", defaultImpl=DefaultUsageTracked.class) \u00a0  public static UsageTracked mixin; \u00a0  @Before(\"com.xyz.myapp. CommonPointcuts.businessService() && this(usageTracked)\") \u00a0  public void recordUsage(UsageTracked usageTracked) { \u00a0    usageTracked.incrementUseCount(); \u00a0  } } Kotlin @Aspect class UsageTracking { \u00a0  companion object { \u00a0    @DeclareParents(value = \"com.xzy.myapp.service.*+\", defaultImpl = DefaultUsageTracked::class) \u00a0    lateinit var mixin: UsageTracked \u00a0  } \u00a0  @Before(\"com.xyz.myapp. CommonPointcuts.businessService() && this(usageTracked)\") \u00a0  fun recordUsage(usageTracked: UsageTracked) { \u00a0    usageTracked.incrementUseCount() \u00a0  } } The interface to be implemented is determined by the type of the annotated field. The value attribute of the @DeclareParents annotation is an AspectJ type pattern. Any bean of a matching type implements the UsageTracked interface. Note that, in the before advice of the preceding example, service beans can be directly used as implementations of the UsageTracked interface. If accessing a bean programmatically, you would write the following: Java UsageTracked usageTracked = (UsageTracked) context.getBean(\"myService\"); Kotlin val usageTracked = context.getBean(\"myService\") as UsageTracked 350", "chunk_char_count": 1333, "chunk_word_count": 172, "chunk_token_count": 333.25}, {"page_number": 351, "sentence_chunk": "Aspect Instantiation Models \uf05a This is an advanced topic. If you are just starting out with AOP, you can safely skip it until later. By default, there is a single instance of each aspect within the application context. AspectJ calls this the singleton instantiation model. It is possible to define aspects with alternate lifecycles. Spring supports AspectJ\u2019s perthis and pertarget instantiation models; percflow, percflowbelow, and pertypewithin are not currently supported. You can declare a perthis aspect by specifying a perthis clause in the @Aspect annotation. Consider the following example: Java @Aspect(\"perthis(com.xyz.myapp. CommonPointcuts.businessService())\") public class MyAspect { \u00a0  private int someState; \u00a0  @Before(\"com.xyz.myapp. CommonPointcuts.businessService()\") \u00a0  public void recordServiceUsage() { \u00a0    // ... \u00a0  } } Kotlin @Aspect(\"perthis(com.xyz.myapp.", "chunk_char_count": 879, "chunk_word_count": 123, "chunk_token_count": 219.75}, {"page_number": 351, "sentence_chunk": "CommonPointcuts.businessService())\") class MyAspect { \u00a0  private val someState: Int = 0 \u00a0  @Before(\"com.xyz.myapp. CommonPointcuts.businessService()\") \u00a0  fun recordServiceUsage() { \u00a0    // ... \u00a0  } } In the preceding example, the effect of the perthis clause is that one aspect instance is created for each unique service object that performs a business service (each unique object bound to this at join points matched by the pointcut expression). The aspect instance is created the first time that a method is invoked on the service object. The aspect goes out of scope when the service object goes out of scope. Before the aspect instance is created, none of the advice within it runs. As soon as the aspect instance has been created, the advice declared within it runs at matched join points, but only when the service object is the one with which this aspect is associated. See the AspectJ Programming Guide for more information on per clauses. The pertarget instantiation model works in exactly the same way as perthis, but it creates one 351", "chunk_char_count": 1047, "chunk_word_count": 178, "chunk_token_count": 261.75}, {"page_number": 352, "sentence_chunk": "aspect instance for each unique target object at matched join points. An AOP Example Now that you have seen how all the constituent parts work, we can put them together to do something useful. The execution of business services can sometimes fail due to concurrency issues (for example, a deadlock loser). If the operation is retried, it is likely to succeed on the next try. For business services where it is appropriate to retry in such conditions (idempotent operations that do not need to go back to the user for conflict resolution), we want to transparently retry the operation to avoid the client seeing a PessimisticLockingFailureException. This is a requirement that clearly cuts across multiple services in the service layer and, hence, is ideal for implementing through an aspect. Because we want to retry the operation, we need to use around advice so that we can call proceed multiple times. The following listing shows the basic aspect implementation: 352", "chunk_char_count": 969, "chunk_word_count": 159, "chunk_token_count": 242.25}, {"page_number": 353, "sentence_chunk": "Java @Aspect public class ConcurrentOperationExecutor implements Ordered { \u00a0  private static final int DEFAULT_MAX_RETRIES = 2; \u00a0  private int maxRetries = DEFAULT_MAX_RETRIES; \u00a0  private int order = 1; \u00a0  public void setMaxRetries(int maxRetries) { \u00a0    this.maxRetries = maxRetries; \u00a0  } \u00a0  public int getOrder() { \u00a0    return this.order; \u00a0  } \u00a0  public void setOrder(int order) { \u00a0    this.order = order; \u00a0  } \u00a0  @Around(\"com.xyz.myapp. CommonPointcuts.businessService()\") \u00a0  public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable { \u00a0    int numAttempts = 0; \u00a0    PessimisticLockingFailureException lockFailureException; \u00a0    do { \u00a0      numAttempts++; \u00a0      try { \u00a0        return pjp.proceed(); \u00a0      } \u00a0      catch(PessimisticLockingFailureException ex) { \u00a0        lockFailureException = ex; \u00a0      } \u00a0    } while(numAttempts <= this.maxRetries); \u00a0    throw lockFailureException; \u00a0  } } 353", "chunk_char_count": 920, "chunk_word_count": 191, "chunk_token_count": 230.0}, {"page_number": 354, "sentence_chunk": "Kotlin @Aspect class ConcurrentOperationExecutor : Ordered { \u00a0  private val DEFAULT_MAX_RETRIES = 2 \u00a0  private var maxRetries = DEFAULT_MAX_RETRIES \u00a0  private var order = 1 \u00a0  fun setMaxRetries(maxRetries: Int) { \u00a0    this.maxRetries = maxRetries \u00a0  } \u00a0  override fun getOrder(): Int { \u00a0    return this.order \u00a0  } \u00a0  fun setOrder(order: Int) { \u00a0    this.order = order \u00a0  } \u00a0  @Around(\"com.xyz.myapp. CommonPointcuts.businessService()\") \u00a0  fun doConcurrentOperation(pjp: ProceedingJoinPoint): Any { \u00a0    var numAttempts = 0 \u00a0    var lockFailureException: PessimisticLockingFailureException \u00a0    do { \u00a0      numAttempts++ \u00a0      try { \u00a0        return pjp.proceed() \u00a0      } catch (ex: PessimisticLockingFailureException) { \u00a0        lockFailureException = ex \u00a0      } \u00a0    } while (numAttempts <= this.maxRetries) \u00a0    throw lockFailureException \u00a0  } } Note that the aspect implements the Ordered interface so that we can set the precedence of the aspect higher than the transaction advice (we want a fresh transaction each time we retry). The maxRetries and order properties are both configured by Spring. The main action happens in the doConcurrentOperation around advice. Notice that, for the moment, we apply the retry logic to each businessService(). We try to proceed, and if we fail with a PessimisticLockingFailureException, we try again, unless we have exhausted all of our retry attempts. The corresponding Spring configuration follows: 354", "chunk_char_count": 1447, "chunk_word_count": 274, "chunk_token_count": 361.75}, {"page_number": 355, "sentence_chunk": "<aop:aspectj-autoproxy/> <bean id=\"concurrentOperationExecutor\" class=\"com.xyz.myapp.service.impl. ConcurrentOperationExecutor\"> \u00a0  <property name=\"maxRetries\" value=\"3\"/> \u00a0  <property name=\"order\" value=\"100\"/> </bean> To refine the aspect so that it retries only idempotent operations, we might define the following Idempotent annotation: Java @Retention(RetentionPolicy. RUNTIME) public @interface Idempotent { \u00a0  // marker annotation } Kotlin @Retention(AnnotationRetention. RUNTIME) annotation class Idempotent// marker annotation We can then use the annotation to annotate the implementation of service operations. The change to the aspect to retry only idempotent operations involves refining the pointcut expression so that only @Idempotent operations match, as follows: Java @Around(\"com.xyz.myapp. CommonPointcuts.businessService() && \" + \u00a0    \"@annotation(com.xyz.myapp.service. Idempotent)\") public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable { \u00a0  // ... } Kotlin @Around(\"com.xyz.myapp. CommonPointcuts.businessService() && \" + \u00a0    \"@annotation(com.xyz.myapp.service. Idempotent)\") fun doConcurrentOperation(pjp: ProceedingJoinPoint): Any { \u00a0  // ... } 2.5.5. Schema-based AOP Support If you prefer an XML-based format, Spring also offers support for defining aspects using the aop namespace tags.", "chunk_char_count": 1338, "chunk_word_count": 159, "chunk_token_count": 334.5}, {"page_number": 356, "sentence_chunk": "style are supported. Hence, in this section we focus on that syntax and refer the reader to the discussion in the previous section (@AspectJ support) for an understanding of writing pointcut expressions and the binding of advice parameters. To use the aop namespace tags described in this section, you need to import the spring-aop schema, as described in XML Schema-based configuration. See the AOP schema for how to import the tags in the aop namespace. Within your Spring configurations, all aspect and advisor elements must be placed within an <aop:config> element (you can have more than one <aop:config> element in an application context configuration). An <aop:config> element can contain pointcut, advisor, and aspect elements (note that these must be declared in that order).\uf071 The <aop:config> style of configuration makes heavy use of Spring\u2019s auto-proxying mechanism. This can cause issues (such as advice not being woven) if you already use explicit auto-proxying through the use of BeanNameAutoProxyCreator or something similar. The recommended usage pattern is to use either only the <aop:config> style or only the AutoProxyCreator style and never mix them. Declaring an Aspect When you use the schema support, an aspect is a regular Java object defined as a bean in your Spring application context.", "chunk_char_count": 1313, "chunk_word_count": 205, "chunk_token_count": 328.25}, {"page_number": 356, "sentence_chunk": "The state and behavior are captured in the fields and methods of the object, and the pointcut and advice information are captured in the XML. You can declare an aspect by using the <aop:aspect> element, and reference the backing bean by using the ref attribute, as the following example shows: <aop:config> \u00a0  <aop:aspect id=\"myAspect\" ref=\"aBean\"> \u00a0    ... \u00a0  </aop:aspect> </aop:config> <bean id=\"aBean\" class=\"...\"> \u00a0  ... </bean> The bean that backs the aspect (aBean in this case) can of course be configured and dependency injected just like any other Spring bean. Declaring a Pointcut You can declare a named pointcut inside an <aop:config> element, letting the pointcut definition be shared across several aspects and advisors. A pointcut that represents the execution of any business service in the service layer can be defined as follows: 356", "chunk_char_count": 852, "chunk_word_count": 140, "chunk_token_count": 213.0}, {"page_number": 357, "sentence_chunk": "<aop:config> \u00a0  <aop:pointcut id=\"businessService\" \u00a0    expression=\"execution(* com.xyz.myapp.service.*.*(..))\"/> </aop:config> Note that the pointcut expression itself is using the same AspectJ pointcut expression language as described in @AspectJ support. If you use the schema based declaration style, you can refer to named pointcuts defined in types (@Aspects) within the pointcut expression. Another way of defining the above pointcut would be as follows: <aop:config> \u00a0  <aop:pointcut id=\"businessService\" \u00a0    expression=\"com.xyz.myapp. CommonPointcuts.businessService()\"/> </aop:config> Assume that you have a CommonPointcuts aspect as described in Sharing Common Pointcut Definitions. Then declaring a pointcut inside an aspect is very similar to declaring a top-level pointcut, as the following example shows: <aop:config> \u00a0  <aop:aspect id=\"myAspect\" ref=\"aBean\"> \u00a0    <aop:pointcut id=\"businessService\" \u00a0      expression=\"execution(* com.xyz.myapp.service.*.*(..))\"/> \u00a0    ... \u00a0  </aop:aspect> </aop:config> In much the same way as an @AspectJ aspect, pointcuts declared by using the schema based definition style can collect join point context. For example, the following pointcut collects the this object as the join point context and passes it to the advice: 357", "chunk_char_count": 1278, "chunk_word_count": 183, "chunk_token_count": 319.5}, {"page_number": 358, "sentence_chunk": "<aop:config> \u00a0  <aop:aspect id=\"myAspect\" ref=\"aBean\"> \u00a0    <aop:pointcut id=\"businessService\" \u00a0      expression=\"execution(* com.xyz.myapp.service.*.*(..)) &amp;&amp; this(service)\"/> \u00a0    <aop:before pointcut-ref=\"businessService\" method=\"monitor\"/> \u00a0    ... \u00a0  </aop:aspect> </aop:config> The advice must be declared to receive the collected join point context by including parameters of the matching names, as follows: Java public void monitor(Object service) { \u00a0  // ... } Kotlin fun monitor(service: Any) { \u00a0  // ... } When combining pointcut sub-expressions, &amp;&amp; is awkward within an XML document, so you can use the and, or, and not keywords in place of &amp;&amp;, ||, and !,respectively. For example, the previous pointcut can be better written as follows: <aop:config> \u00a0  <aop:aspect id=\"myAspect\" ref=\"aBean\"> \u00a0    <aop:pointcut id=\"businessService\" \u00a0      expression=\"execution(* com.xyz.myapp.service.*.*(..))and this(service)\"/> \u00a0    <aop:before pointcut-ref=\"businessService\" method=\"monitor\"/> \u00a0    ... \u00a0  </aop:aspect> </aop:config> 358", "chunk_char_count": 1061, "chunk_word_count": 157, "chunk_token_count": 265.25}, {"page_number": 359, "sentence_chunk": "Note that pointcuts defined in this way are referred to by their XML id and cannot be used as named pointcuts to form composite pointcuts. The named pointcut support in the schema-based definition style is thus more limited than that offered by the @AspectJ style. Declaring Advice The schema-based AOP support uses the same five kinds of advice as the @AspectJ style, and they have exactly the same semantics. Before Advice Before advice runs before a matched method execution. It is declared inside an <aop:aspect> by using the <aop:before> element, as the following example shows: <aop:aspect id=\"beforeExample\" ref=\"aBean\"> \u00a0  <aop:before \u00a0    pointcut-ref=\"dataAccessOperation\" \u00a0    method=\"doAccessCheck\"/> \u00a0  ... </aop:aspect> Here, dataAccessOperation is the id of a pointcut defined at the top (<aop:config>) level. To define the pointcut inline instead, replace the pointcut-ref attribute with a pointcut attribute, as follows: <aop:aspect id=\"beforeExample\" ref=\"aBean\"> \u00a0  <aop:before \u00a0    pointcut=\"execution(* com.xyz.myapp.dao.*.*(..))\"\u00a0    method=\"doAccessCheck\"/> \u00a0  ... </aop:aspect> As we noted in the discussion of the @AspectJ style, using named pointcuts can significantly improve the readability of your code. The method attribute identifies a method (doAccessCheck) that provides the body of the advice. This method must be defined for the bean referenced by the aspect element that contains the advice. Before a data access operation is performed (a method execution join point matched by the pointcut expression), the doAccessCheck method on the aspect bean is invoked.", "chunk_char_count": 1595, "chunk_word_count": 243, "chunk_token_count": 398.75}, {"page_number": 359, "sentence_chunk": "After Returning Advice After returning advice runs when a matched method execution completes normally. It is declared inside an <aop:aspect> in the same way as before advice. The following example shows how to 359", "chunk_char_count": 213, "chunk_word_count": 34, "chunk_token_count": 53.25}, {"page_number": 360, "sentence_chunk": "declare it: <aop:aspect id=\"afterReturningExample\" ref=\"aBean\"> \u00a0  <aop:after-returning \u00a0    pointcut-ref=\"dataAccessOperation\" \u00a0    method=\"doAccessCheck\"/> \u00a0  ... </aop:aspect> As in the @AspectJ style, you can get the return value within the advice body. To do so, use the returning attribute to specify the name of the parameter to which the return value should be passed, as the following example shows: <aop:aspect id=\"afterReturningExample\" ref=\"aBean\"> \u00a0  <aop:after-returning \u00a0    pointcut-ref=\"dataAccessOperation\" \u00a0    returning=\"retVal\" \u00a0    method=\"doAccessCheck\"/> \u00a0  ... </aop:aspect> The doAccessCheck method must declare a parameter named retVal. The type of this parameter constrains matching in the same way as described for @AfterReturning. For example, you can declare the method signature as follows: Java public void doAccessCheck(Object retVal) {... Kotlin fun doAccessCheck(retVal: Any) {... After Throwing Advice After throwing advice runs when a matched method execution exits by throwing an exception. It is declared inside an <aop:aspect> by using the after-throwing element, as the following example shows: 360", "chunk_char_count": 1140, "chunk_word_count": 168, "chunk_token_count": 285.0}, {"page_number": 361, "sentence_chunk": "<aop:aspect id=\"afterThrowingExample\" ref=\"aBean\"> \u00a0  <aop:after-throwing \u00a0    pointcut-ref=\"dataAccessOperation\" \u00a0    method=\"doRecoveryActions\"/> \u00a0  ... </aop:aspect> As in the @AspectJ style, you can get the thrown exception within the advice body. To do so, use the throwing attribute to specify the name of the parameter to which the exception should be passed as the following example shows: <aop:aspect id=\"afterThrowingExample\" ref=\"aBean\"> \u00a0  <aop:after-throwing \u00a0    pointcut-ref=\"dataAccessOperation\" \u00a0    throwing=\"dataAccessEx\" \u00a0    method=\"doRecoveryActions\"/> \u00a0  ... </aop:aspect> The doRecoveryActions method must declare a parameter named dataAccessEx. The type of this parameter constrains matching in the same way as described for @AfterThrowing. For example, the method signature may be declared as follows: Java public void doRecoveryActions(DataAccessException dataAccessEx) {... Kotlin fun doRecoveryActions(dataAccessEx: DataAccessException) {... After (Finally) Advice After (finally) advice runs no matter how a matched method execution exits. You can declare it by using the after element, as the following example shows: 361", "chunk_char_count": 1152, "chunk_word_count": 161, "chunk_token_count": 288.0}, {"page_number": 362, "sentence_chunk": "<aop:aspect id=\"afterFinallyExample\" ref=\"aBean\"> \u00a0  <aop:after \u00a0    pointcut-ref=\"dataAccessOperation\" \u00a0    method=\"doReleaseLock\"/> \u00a0  ... </aop:aspect> Around Advice The last kind of advice is around advice. Around advice runs \"around\" a matched method\u2019s execution. It has the opportunity to do work both before and after the method runs and to determine when, how, and even if the method actually gets to run at all. Around advice is often used if you need to share state before and after a method execution in a thread-safe manner \u2013 for example, starting and stopping a timer.\uf0eb Always use the least powerful form of advice that meets your requirements. For example, do not use around advice if before advice is sufficient for your needs. You can declare around advice by using the aop:around element. The advice method should declare Object as its return type, and the first parameter of the method must be of type ProceedingJoinPoint. Within the body of the advice method, you must invoke proceed() on the ProceedingJoinPoint in order for the underlying method to run. Invoking proceed() without arguments will result in the caller\u2019s original arguments being supplied to the underlying method when it is invoked.", "chunk_char_count": 1218, "chunk_word_count": 199, "chunk_token_count": 304.5}, {"page_number": 362, "sentence_chunk": "For advanced use cases, there is an overloaded variant of the proceed() method which accepts an array of arguments (Object[]). The values in the array will be used as the arguments to the underlying method when it is invoked. See Around Advice for notes on calling proceed with an Object[]. The following example shows how to declare around advice in XML: <aop:aspect id=\"aroundExample\" ref=\"aBean\"> \u00a0  <aop:around \u00a0    pointcut-ref=\"businessService\" \u00a0    method=\"doBasicProfiling\"/> \u00a0  ... </aop:aspect> The implementation of the doBasicProfiling advice can be exactly the same as in the @AspectJ example (minus the annotation, of course), as the following example shows: 362", "chunk_char_count": 676, "chunk_word_count": 108, "chunk_token_count": 169.0}, {"page_number": 363, "sentence_chunk": "Java public Object doBasicProfiling(ProceedingJoinPoint pjp) throws Throwable { \u00a0  // start stopwatch \u00a0  Object retVal = pjp.proceed(); \u00a0  // stop stopwatch \u00a0  return retVal; } Kotlin fun doBasicProfiling(pjp: ProceedingJoinPoint): Any { \u00a0  // start stopwatch \u00a0  val retVal = pjp.proceed() \u00a0  // stop stopwatch \u00a0  return pjp.proceed() } Advice Parameters The schema-based declaration style supports fully typed advice in the same way as described for the @AspectJ support\u2009\u2014\u2009by matching pointcut parameters by name against advice method parameters. See Advice Parameters for details. If you wish to explicitly specify argument names for the advice methods (not relying on the detection strategies previously described), you can do so by using the arg-names attribute of the advice element, which is treated in the same manner as the argNames attribute in an advice annotation (as described in Determining Argument Names). The following example shows how to specify an argument name in XML: <aop:before \u00a0  pointcut=\"com.xyz.lib. Pointcuts.anyPublicMethod() and @annotation(auditable)\" \u00a0  method=\"audit\" \u00a0  arg-names=\"auditable\"/> The arg-names attribute accepts a comma-delimited list of parameter names. The following slightly more involved example of the XSD-based approach shows some around advice used in conjunction with a number of strongly typed parameters: 363", "chunk_char_count": 1366, "chunk_word_count": 204, "chunk_token_count": 341.5}, {"page_number": 364, "sentence_chunk": "Java package x.y.service; public interface PersonService { \u00a0  Person getPerson(String personName, int age); } public class DefaultPersonService implements PersonService { \u00a0  public Person getPerson(String name, int age) { \u00a0    return new Person(name, age); \u00a0  } } Kotlin package x.y.service interface PersonService { \u00a0  fun getPerson(personName: String, age: Int): Person } class DefaultPersonService : PersonService { \u00a0  fun getPerson(name: String, age: Int): Person { \u00a0    return Person(name, age) \u00a0  } } Next up is the aspect. Notice the fact that the profile(..) method accepts a number of strongly- typed parameters, the first of which happens to be the join point used to proceed with the method call. The presence of this parameter is an indication that the profile(..) is to be used as around advice, as the following example shows: 364", "chunk_char_count": 844, "chunk_word_count": 142, "chunk_token_count": 211.0}, {"page_number": 365, "sentence_chunk": "Java package x.y; import org.aspectj.lang. ProceedingJoinPoint; import org.springframework.util. StopWatch; public class SimpleProfiler { \u00a0  public Object profile(ProceedingJoinPoint call, String name, int age) throws Throwable { \u00a0    StopWatch clock = new StopWatch(\"Profiling for '\" + name + \"' and '\" + age + \"'\"); \u00a0    try { \u00a0      clock.start(call.toShortString()); \u00a0      return call.proceed(); \u00a0    } finally { \u00a0      clock.stop(); \u00a0      System.out.println(clock.prettyPrint()); \u00a0    } \u00a0  } } Kotlin import org.aspectj.lang. ProceedingJoinPoint import org.springframework.util. StopWatch class SimpleProfiler { \u00a0  fun profile(call: ProceedingJoinPoint, name: String, age: Int): Any { \u00a0    val clock = StopWatch(\"Profiling for '$name' and '$age'\") \u00a0    try { \u00a0      clock.start(call.toShortString()) \u00a0      return call.proceed() \u00a0    } finally { \u00a0      clock.stop() \u00a0      println(clock.prettyPrint()) \u00a0    } \u00a0  } } Finally, the following example XML configuration effects the execution of the preceding advice for a particular join point: 365", "chunk_char_count": 1050, "chunk_word_count": 201, "chunk_token_count": 262.5}, {"page_number": 366, "sentence_chunk": "<beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:aop=\"http://www.springframework.org/schema/aop\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"> \u00a0  <!--this is the object that will be proxied by Spring's AOP infrastructure --> \u00a0  <bean id=\"personService\" class=\"x.y.service. DefaultPersonService\"/> \u00a0  <!--this is the actual advice itself --> \u00a0  <bean id=\"profiler\" class=\"x.y. SimpleProfiler\"/> \u00a0  <aop:config> \u00a0    <aop:aspect ref=\"profiler\"> \u00a0      <aop:pointcut id=\"theExecutionOfSomePersonServiceMethod\" \u00a0        expression=\"execution(* x.y.service. PersonService.getPerson(String,int)) \u00a0        and args(name, age)\"/> \u00a0      <aop:around pointcut-ref=\"theExecutionOfSomePersonServiceMethod\" \u00a0        method=\"profile\"/> \u00a0    </aop:aspect> \u00a0  </aop:config> </beans> Consider the following driver script: Java import org.springframework.beans.factory. BeanFactory; import org.springframework.context.support. ClassPathXmlApplicationContext; import x.y.service. PersonService; public final class Boot { \u00a0  public static void main(final String[] args) throws Exception { \u00a0    BeanFactory ctx = new ClassPathXmlApplicationContext(\"x/y/plain.xml\"); \u00a0    PersonService person = (PersonService) ctx.getBean(\"personService\"); \u00a0    person.getPerson(\"Pengo\", 12); \u00a0  } } 366", "chunk_char_count": 1537, "chunk_word_count": 184, "chunk_token_count": 384.25}, {"page_number": 367, "sentence_chunk": "Kotlin fun main() { \u00a0  val ctx = ClassPathXmlApplicationContext(\"x/y/plain.xml\") \u00a0  val person = ctx.getBean(\"personService\") as PersonService \u00a0  person.getPerson(\"Pengo\", 12) } With such a Boot class, we would get output similar to the following on standard output: StopWatch 'Profiling for 'Pengo' and '12': running time (millis) = 0 ----------------------------------------- ms   %   Task name ----------------------------------------- 00000 ? execution(getFoo) Advice Ordering When multiple pieces of advice need to run at the same join point (executing method) the ordering rules are as described in Advice Ordering. The precedence between aspects is determined via the order attribute in the <aop:aspect> element or by either adding the @Order annotation to the bean that backs the aspect or by having the bean implement the Ordered interface.\uf05a In contrast to the precedence rules for advice methods defined in the same @Aspect class, when two pieces of advice defined in the same <aop:aspect> element both need to run at the same join point, the precedence is determined by the order in which the advice elements are declared within the enclosing <aop:aspect> element, from highest to lowest precedence. For example, given an around advice and a before advice defined in the same <aop:aspect> element that apply to the same join point, to ensure that the around advice has higher precedence than the before advice, the <aop:around> element must be declared before the <aop:before> element. As a general rule of thumb, if you find that you have multiple pieces of advice defined in the same <aop:aspect> element that apply to the same join point, consider collapsing such advice methods into one advice method per join point in each <aop:aspect> element or refactor the pieces of advice into separate <aop:aspect> elements that you can order at the aspect level. Introductions Introductions (known as inter-type declarations in AspectJ) let an aspect declare that advised objects implement a given interface and provide an implementation of that interface on behalf of those objects. You can make an introduction by using the aop:declare-parents element inside an aop:aspect. You can use the aop:declare-parents element to declare that matching types have a new parent (hence 367", "chunk_char_count": 2285, "chunk_word_count": 355, "chunk_token_count": 571.25}, {"page_number": 368, "sentence_chunk": "the name). For example, given an interface named UsageTracked and an implementation of that interface named DefaultUsageTracked, the following aspect declares that all implementors of service interfaces also implement the UsageTracked interface. (In order to expose statistics through JMX for example.)<aop:aspect id=\"usageTrackerAspect\" ref=\"usageTracking\"> \u00a0  <aop:declare-parents \u00a0    types-matching=\"com.xzy.myapp.service.*+\" \u00a0    implement-interface=\"com.xyz.myapp.service.tracking. UsageTracked\" \u00a0    default-impl=\"com.xyz.myapp.service.tracking. DefaultUsageTracked\"/> \u00a0  <aop:before \u00a0    pointcut=\"com.xyz.myapp. CommonPointcuts.businessService() \u00a0      and this(usageTracked)\" \u00a0      method=\"recordUsage\"/> </aop:aspect> The class that backs the usageTracking bean would then contain the following method: Java public void recordUsage(UsageTracked usageTracked) { \u00a0  usageTracked.incrementUseCount(); } Kotlin fun recordUsage(usageTracked: UsageTracked) { \u00a0  usageTracked.incrementUseCount() } The interface to be implemented is determined by the implement-interface attribute. The value of the types-matching attribute is an AspectJ type pattern. Any bean of a matching type implements the UsageTracked interface. Note that, in the before advice of the preceding example, service beans can be directly used as implementations of the UsageTracked interface.", "chunk_char_count": 1366, "chunk_word_count": 174, "chunk_token_count": 341.5}, {"page_number": 368, "sentence_chunk": "To access a bean programmatically, you could write the following: Java UsageTracked usageTracked = (UsageTracked) context.getBean(\"myService\"); Kotlin val usageTracked = context.getBean(\"myService\") as UsageTracked 368", "chunk_char_count": 218, "chunk_word_count": 24, "chunk_token_count": 54.5}, {"page_number": 369, "sentence_chunk": "Aspect Instantiation Models The only supported instantiation model for schema-defined aspects is the singleton model. Other instantiation models may be supported in future releases. Advisors The concept of \u201cadvisors\u201d comes from the AOP support defined in Spring and does not have a direct equivalent in AspectJ. An advisor is like a small self-contained aspect that has a single piece of advice. The advice itself is represented by a bean and must implement one of the advice interfaces described in Advice Types in Spring. Advisors can take advantage of AspectJ pointcut expressions. Spring supports the advisor concept with the <aop:advisor> element. You most commonly see it used in conjunction with transactional advice, which also has its own namespace support in Spring. The following example shows an advisor: <aop:config> \u00a0  <aop:pointcut id=\"businessService\" \u00a0    expression=\"execution(* com.xyz.myapp.service.*.*(..))\"/> \u00a0  <aop:advisor \u00a0    pointcut-ref=\"businessService\" \u00a0    advice-ref=\"tx-advice\"/> </aop:config> <tx:advice id=\"tx-advice\"> \u00a0  <tx:attributes> \u00a0    <tx:method name=\"*\" propagation=\"REQUIRED\"/> \u00a0  </tx:attributes> </tx:advice> As well as the pointcut-ref attribute used in the preceding example, you can also use the pointcut attribute to define a pointcut expression inline. To define the precedence of an advisor so that the advice can participate in ordering, use the order attribute to define the Ordered value of the advisor. An AOP Schema Example This section shows how the concurrent locking failure retry example from An AOP Example looks when rewritten with the schema support.", "chunk_char_count": 1615, "chunk_word_count": 243, "chunk_token_count": 403.75}, {"page_number": 369, "sentence_chunk": "The execution of business services can sometimes fail due to concurrency issues (for example, a deadlock loser). If the operation is retried, it is likely to succeed on the next try. For business services where it is appropriate to retry in such conditions (idempotent operations that do not need to go back to the user for conflict resolution), we want to transparently retry the operation to avoid the client seeing a PessimisticLockingFailureException. This is a requirement that clearly cuts across multiple services in the service layer and, hence, is ideal for implementing through an 369", "chunk_char_count": 594, "chunk_word_count": 95, "chunk_token_count": 148.5}, {"page_number": 370, "sentence_chunk": "aspect. Because we want to retry the operation, we need to use around advice so that we can call proceed multiple times. The following listing shows the basic aspect implementation (which is a regular Java class that uses the schema support): Java public class ConcurrentOperationExecutor implements Ordered { \u00a0  private static final int DEFAULT_MAX_RETRIES = 2; \u00a0  private int maxRetries = DEFAULT_MAX_RETRIES; \u00a0  private int order = 1; \u00a0  public void setMaxRetries(int maxRetries) { \u00a0    this.maxRetries = maxRetries; \u00a0  } \u00a0  public int getOrder() { \u00a0    return this.order; \u00a0  } \u00a0  public void setOrder(int order) { \u00a0    this.order = order; \u00a0  } \u00a0  public Object doConcurrentOperation(ProceedingJoinPoint pjp) throws Throwable { \u00a0    int numAttempts = 0; \u00a0    PessimisticLockingFailureException lockFailureException; \u00a0    do { \u00a0      numAttempts++; \u00a0      try { \u00a0        return pjp.proceed(); \u00a0      } \u00a0      catch(PessimisticLockingFailureException ex) { \u00a0        lockFailureException = ex; \u00a0      } \u00a0    } while(numAttempts <= this.maxRetries); \u00a0    throw lockFailureException; \u00a0  } } 370", "chunk_char_count": 1092, "chunk_word_count": 227, "chunk_token_count": 273.0}, {"page_number": 371, "sentence_chunk": "Kotlin class ConcurrentOperationExecutor : Ordered { \u00a0  private val DEFAULT_MAX_RETRIES = 2 \u00a0  private var maxRetries = DEFAULT_MAX_RETRIES \u00a0  private var order = 1 \u00a0  fun setMaxRetries(maxRetries: Int) { \u00a0    this.maxRetries = maxRetries \u00a0  } \u00a0  override fun getOrder(): Int { \u00a0    return this.order \u00a0  } \u00a0  fun setOrder(order: Int) { \u00a0    this.order = order \u00a0  } \u00a0  fun doConcurrentOperation(pjp: ProceedingJoinPoint): Any { \u00a0    var numAttempts = 0 \u00a0    var lockFailureException: PessimisticLockingFailureException \u00a0    do { \u00a0      numAttempts++ \u00a0      try { \u00a0        return pjp.proceed() \u00a0      } catch (ex: PessimisticLockingFailureException) { \u00a0        lockFailureException = ex \u00a0      } \u00a0    } while (numAttempts <= this.maxRetries) \u00a0    throw lockFailureException \u00a0  } } Note that the aspect implements the Ordered interface so that we can set the precedence of the aspect higher than the transaction advice (we want a fresh transaction each time we retry). The maxRetries and order properties are both configured by Spring. The main action happens in the doConcurrentOperation around advice method. We try to proceed. If we fail with a PessimisticLockingFailureException, we try again, unless we have exhausted all of our retry attempts.\uf05a This class is identical to the one used in the @AspectJ example, but with the annotations removed. The corresponding Spring configuration is as follows: 371", "chunk_char_count": 1404, "chunk_word_count": 275, "chunk_token_count": 351.0}, {"page_number": 372, "sentence_chunk": "<aop:config> \u00a0  <aop:aspect id=\"concurrentOperationRetry\" ref=\"concurrentOperationExecutor\"> \u00a0    <aop:pointcut id=\"idempotentOperation\" \u00a0      expression=\"execution(* com.xyz.myapp.service.*.*(..))\"/> \u00a0    <aop:around \u00a0      pointcut-ref=\"idempotentOperation\" \u00a0      method=\"doConcurrentOperation\"/> \u00a0  </aop:aspect> </aop:config> <bean id=\"concurrentOperationExecutor\" \u00a0  class=\"com.xyz.myapp.service.impl. ConcurrentOperationExecutor\"> \u00a0    <property name=\"maxRetries\" value=\"3\"/> \u00a0    <property name=\"order\" value=\"100\"/> </bean> Notice that, for the time being, we assume that all business services are idempotent. If this is not the case, we can refine the aspect so that it retries only genuinely idempotent operations, by introducing an Idempotent annotation and using the annotation to annotate the implementation of service operations, as the following example shows: Java @Retention(RetentionPolicy. RUNTIME) public @interface Idempotent { \u00a0  // marker annotation } Kotlin @Retention(AnnotationRetention. RUNTIME) annotation class Idempotent { \u00a0  // marker annotation } The change to the aspect to retry only idempotent operations involves refining the pointcut expression so that only @Idempotent operations match, as follows: <aop:pointcut id=\"idempotentOperation\" \u00a0    expression=\"execution(* com.xyz.myapp.service.*.*(..))and \u00a0    @annotation(com.xyz.myapp.service. Idempotent)\"/> 372", "chunk_char_count": 1399, "chunk_word_count": 182, "chunk_token_count": 349.75}, {"page_number": 373, "sentence_chunk": "2.5.6. Choosing which AOP Declaration Style to Use Once you have decided that an aspect is the best approach for implementing a given requirement, how do you decide between using Spring AOP or AspectJ and between the Aspect language (code) style, the @AspectJ annotation style, or the Spring XML style?These decisions are influenced by a number of factors including application requirements, development tools, and team familiarity with AOP. Spring AOP or Full AspectJ?Use the simplest thing that can work. Spring AOP is simpler than using full AspectJ, as there is no requirement to introduce the AspectJ compiler / weaver into your development and build processes. If you only need to advise the execution of operations on Spring beans, Spring AOP is the right choice. If you need to advise objects not managed by the Spring container (such as domain objects, typically), you need to use AspectJ. You also need to use AspectJ if you wish to advise join points other than simple method executions (for example, field get or set join points and so on). When you use AspectJ, you have the choice of the AspectJ language syntax (also known as the \u201ccode style\u201d) or the @AspectJ annotation style. Clearly, if you do not use Java 5+, the choice has been made for you: Use the code style.", "chunk_char_count": 1282, "chunk_word_count": 218, "chunk_token_count": 320.5}, {"page_number": 373, "sentence_chunk": "If aspects play a large role in your design, and you are able to use the AspectJ Development Tools (AJDT) plugin for Eclipse, the AspectJ language syntax is the preferred option. It is cleaner and simpler because the language was purposefully designed for writing aspects. If you do not use Eclipse or have only a few aspects that do not play a major role in your application, you may want to consider using the @AspectJ style, sticking with regular Java compilation in your IDE, and adding an aspect weaving phase to your build script.@AspectJ or XML for Spring AOP?If you have chosen to use Spring AOP, you have a choice of @AspectJ or XML style. There are various tradeoffs to consider. The XML style may be most familiar to existing Spring users, and it is backed by genuine POJOs. When using AOP as a tool to configure enterprise services, XML can be a good choice (a good test is whether you consider the pointcut expression to be a part of your configuration that you might want to change independently). With the XML style, it is arguably clearer from your configuration which aspects are present in the system. The XML style has two disadvantages.", "chunk_char_count": 1156, "chunk_word_count": 203, "chunk_token_count": 289.0}, {"page_number": 373, "sentence_chunk": "First, it does not fully encapsulate the implementation of the requirement it addresses in a single place. The DRY principle says that there should be a single, unambiguous, authoritative representation of any piece of knowledge within a system. When using the XML style, the knowledge of how a requirement is implemented is split across the declaration of the backing bean class and the XML in the configuration file. When you use the @AspectJ style, this information is encapsulated in a single module: the aspect. Secondly, the XML style is slightly more limited in what it can express than the @AspectJ style: Only the \u201csingleton\u201d aspect instantiation model is supported, and it is not possible to combine named pointcuts declared in XML. For example, in the @AspectJ style you can write something like the following: 373", "chunk_char_count": 825, "chunk_word_count": 135, "chunk_token_count": 206.25}, {"page_number": 374, "sentence_chunk": "Java @Pointcut(\"execution(* get*())\") public void propertyAccess() {} @Pointcut(\"execution(org.xyz. Account+ *(..))\") public void operationReturningAnAccount() {} @Pointcut(\"propertyAccess() && operationReturningAnAccount()\") public void accountPropertyAccess() {} Kotlin @Pointcut(\"execution(* get*())\") fun propertyAccess() {} @Pointcut(\"execution(org.xyz. Account+ *(..))\") fun operationReturningAnAccount() {} @Pointcut(\"propertyAccess() && operationReturningAnAccount()\") fun accountPropertyAccess() {} In the XML style you can declare the first two pointcuts: <aop:pointcut id=\"propertyAccess\" \u00a0    expression=\"execution(* get*())\"/> <aop:pointcut id=\"operationReturningAnAccount\" \u00a0    expression=\"execution(org.xyz. Account+ *(..))\"/> The downside of the XML approach is that you cannot define the accountPropertyAccess pointcut by combining these definitions. The @AspectJ style supports additional instantiation models and richer pointcut composition. It has the advantage of keeping the aspect as a modular unit. It also has the advantage that the @AspectJ aspects can be understood (and thus consumed) both by Spring AOP and by AspectJ. So, if you later decide you need the capabilities of AspectJ to implement additional requirements, you can easily migrate to a classic AspectJ setup. On balance, the Spring team prefers the @AspectJ style for custom aspects beyond simple configuration of enterprise services.2.5.7. Mixing Aspect Types It is perfectly possible to mix @AspectJ style aspects by using the auto-proxying support, schema- defined <aop:aspect> aspects, <aop:advisor> declared advisors, and even proxies and interceptors in other styles in the same configuration.", "chunk_char_count": 1688, "chunk_word_count": 208, "chunk_token_count": 422.0}, {"page_number": 375, "sentence_chunk": "2.5.8. Proxying Mechanisms Spring AOP uses either JDK dynamic proxies or CGLIB to create the proxy for a given target object. JDK dynamic proxies are built into the JDK, whereas CGLIB is a common open-source class definition library (repackaged into spring-core). If the target object to be proxied implements at least one interface, a JDK dynamic proxy is used. All of the interfaces implemented by the target type are proxied. If the target object does not implement any interfaces, a CGLIB proxy is created. If you want to force the use of CGLIB proxying (for example, to proxy every method defined for the target object, not only those implemented by its interfaces), you can do so. However, you should consider the following issues: \u2022 With CGLIB, final methods cannot be advised, as they cannot be overridden in runtime- generated subclasses. \u2022As of Spring 4.0, the constructor of your proxied object is NOT called twice anymore, since the CGLIB proxy instance is created through Objenesis. Only if your JVM does not allow for constructor bypassing, you might see double invocations and corresponding debug log entries from Spring\u2019s AOP support.", "chunk_char_count": 1150, "chunk_word_count": 188, "chunk_token_count": 287.5}, {"page_number": 375, "sentence_chunk": "To force the use of CGLIB proxies, set the value of the proxy-target-class attribute of the <aop:config> element to true, as follows: <aop:config proxy-target-class=\"true\"> \u00a0  <!--other beans defined here... --> </aop:config> To force CGLIB proxying when you use the @AspectJ auto-proxy support, set the proxy-target-class attribute of the <aop:aspectj-autoproxy> element to true, as follows: <aop:aspectj-autoproxy proxy-target-class=\"true\"/> \uf05a Multiple <aop:config/> sections are collapsed into a single unified auto-proxy creator at runtime, which applies the strongest proxy settings that any of the <aop:config/> sections (typically from different XML bean definition files) specified. This also applies to the <tx:annotation-driven/> and <aop:aspectj- autoproxy/> elements. To be clear, using proxy-target-class=\"true\" on <tx:annotation-driven/>, <aop:aspectj-autoproxy/>, or <aop:config/> elements forces the use of CGLIB proxies for all three of them. Understanding AOP Proxies Spring AOP is proxy-based. It is vitally important that you grasp the semantics of what that last statement actually means before you write your own aspects or use any of the Spring AOP-based 375", "chunk_char_count": 1181, "chunk_word_count": 160, "chunk_token_count": 295.25}, {"page_number": 376, "sentence_chunk": "aspects supplied with the Spring Framework. Consider first the scenario where you have a plain-vanilla, un-proxied, nothing-special-about-it, straight object reference, as the following code snippet shows: Java public class SimplePojo implements Pojo { \u00a0  public void foo() { \u00a0    // this next method invocation is a direct call on the 'this' reference \u00a0    this.bar(); \u00a0  } \u00a0  public void bar() { \u00a0    // some logic... \u00a0  } } Kotlin class SimplePojo : Pojo { \u00a0  fun foo() { \u00a0    // this next method invocation is a direct call on the 'this' reference \u00a0    this.bar() \u00a0  } \u00a0  fun bar() { \u00a0    // some logic... \u00a0  } } If you invoke a method on an object reference, the method is invoked directly on that object reference, as the following image and listing show: 376", "chunk_char_count": 765, "chunk_word_count": 159, "chunk_token_count": 191.25}, {"page_number": 377, "sentence_chunk": "Java public class Main { \u00a0  public static void main(String[] args) { \u00a0    Pojo pojo = new SimplePojo(); \u00a0    // this is a direct method call on the 'pojo' reference \u00a0    pojo.foo(); \u00a0  } } Kotlin fun main() { \u00a0  val pojo = SimplePojo() \u00a0  // this is a direct method call on the 'pojo' reference \u00a0  pojo.foo() } Things change slightly when the reference that client code has is a proxy. Consider the following diagram and code snippet: Java public class Main { \u00a0  public static void main(String[] args) { \u00a0    ProxyFactory factory = new ProxyFactory(new SimplePojo()); \u00a0    factory.addInterface(Pojo.class); \u00a0    factory.addAdvice(new RetryAdvice()); \u00a0    Pojo pojo = (Pojo) factory.getProxy(); \u00a0    // this is a method call on the proxy!\u00a0    pojo.foo(); \u00a0  } } 377", "chunk_char_count": 764, "chunk_word_count": 158, "chunk_token_count": 191.0}, {"page_number": 378, "sentence_chunk": "Kotlin fun main() { \u00a0  val factory = ProxyFactory(SimplePojo()) \u00a0  factory.addInterface(Pojo::class.java) \u00a0  factory.addAdvice(RetryAdvice()) \u00a0  val pojo = factory.proxy as Pojo \u00a0  // this is a method call on the proxy!\u00a0  pojo.foo() } The key thing to understand here is that the client code inside the main(..) method of the Main class has a reference to the proxy. This means that method calls on that object reference are calls on the proxy. As a result, the proxy can delegate to all of the interceptors (advice) that are relevant to that particular method call. However, once the call has finally reached the target object (the SimplePojo reference in this case), any method calls that it may make on itself, such as this.bar() or this.foo(), are going to be invoked against the this reference, and not the proxy. This has important implications. It means that self-invocation is not going to result in the advice associated with a method invocation getting a chance to run. Okay, so what is to be done about this?The best approach (the term \"best\" is used loosely here) is to refactor your code such that the self-invocation does not happen. This does entail some work on your part, but it is the best, least-invasive approach.", "chunk_char_count": 1233, "chunk_word_count": 212, "chunk_token_count": 308.25}, {"page_number": 378, "sentence_chunk": "The next approach is absolutely horrendous, and we hesitate to point it out, precisely because it is so horrendous. You can (painful as it is to us) totally tie the logic within your class to Spring AOP, as the following example shows: Java public class SimplePojo implements Pojo { \u00a0  public void foo() { \u00a0    // this works, but... gah!\u00a0    ((Pojo) AopContext.currentProxy()).bar(); \u00a0  } \u00a0  public void bar() { \u00a0    // some logic... \u00a0  } } 378", "chunk_char_count": 444, "chunk_word_count": 90, "chunk_token_count": 111.0}, {"page_number": 379, "sentence_chunk": "Kotlin class SimplePojo : Pojo { \u00a0  fun foo() { \u00a0    // this works, but... gah!\u00a0    (AopContext.currentProxy() as Pojo).bar() \u00a0  } \u00a0  fun bar() { \u00a0    // some logic... \u00a0  } } This totally couples your code to Spring AOP, and it makes the class itself aware of the fact that it is being used in an AOP context, which flies in the face of AOP. It also requires some additional configuration when the proxy is being created, as the following example shows: Java public class Main { \u00a0  public static void main(String[] args) { \u00a0    ProxyFactory factory = new ProxyFactory(new SimplePojo()); \u00a0    factory.addInterface(Pojo.class); \u00a0    factory.addAdvice(new RetryAdvice()); \u00a0    factory.setExposeProxy(true); \u00a0    Pojo pojo = (Pojo) factory.getProxy(); \u00a0    // this is a method call on the proxy!\u00a0    pojo.foo(); \u00a0  } } Kotlin fun main() { \u00a0  val factory = ProxyFactory(SimplePojo()) \u00a0  factory.addInterface(Pojo::class.java) \u00a0  factory.addAdvice(RetryAdvice()) \u00a0  factory.isExposeProxy = true \u00a0  val pojo = factory.proxy as Pojo \u00a0  // this is a method call on the proxy!\u00a0  pojo.foo() } Finally, it must be noted that AspectJ does not have this self-invocation issue because it is not a proxy-based AOP framework.379", "chunk_char_count": 1211, "chunk_word_count": 229, "chunk_token_count": 302.75}, {"page_number": 380, "sentence_chunk": "2.5.9. Programmatic Creation of @AspectJ Proxies In addition to declaring aspects in your configuration by using either <aop:config> or <aop:aspectj- autoproxy>, it is also possible to programmatically create proxies that advise target objects. For the full details of Spring\u2019s AOP API, see the next chapter. Here, we want to focus on the ability to automatically create proxies by using @AspectJ aspects. You can use the org.springframework.aop.aspectj.annotation. AspectJProxyFactory class to create a proxy for a target object that is advised by one or more @AspectJ aspects. The basic usage for this class is very simple, as the following example shows: Java // create a factory that can generate a proxy for the given target object AspectJProxyFactory factory = new AspectJProxyFactory(targetObject); // add an aspect, the class must be an @AspectJ aspect // you can call this as many times as you need with different aspects factory.addAspect(SecurityManager.class); // you can also add existing aspect instances, the type of the object supplied must be an @AspectJ aspect factory.addAspect(usageTracker); // now get the proxy object... MyInterfaceType proxy = factory.getProxy(); Kotlin // create a factory that can generate a proxy for the given target object val factory = AspectJProxyFactory(targetObject) // add an aspect, the class must be an @AspectJ aspect // you can call this as many times as you need with different aspects factory.addAspect(SecurityManager::class.java) // you can also add existing aspect instances, the type of the object supplied must be an @AspectJ aspect factory.addAspect(usageTracker) // now get the proxy object... val proxy = factory.getProxy<Any>() See the javadoc for more information.2.5.10. Using AspectJ with Spring Applications Everything we have covered so far in this chapter is pure Spring AOP. In this section, we look at how you can use the AspectJ compiler or weaver instead of or in addition to Spring AOP if your 380", "chunk_char_count": 1973, "chunk_word_count": 300, "chunk_token_count": 493.25}, {"page_number": 381, "sentence_chunk": "needs go beyond the facilities offered by Spring AOP alone. Spring ships with a small AspectJ aspect library, which is available stand-alone in your distribution as spring-aspects.jar. You need to add this to your classpath in order to use the aspects in it. Using AspectJ to Dependency Inject Domain Objects with Spring and Other Spring aspects for AspectJ discuss the content of this library and how you can use it. Configuring AspectJ Aspects by Using Spring IoC discusses how to dependency inject AspectJ aspects that are woven using the AspectJ compiler. Finally, Load-time Weaving with AspectJ in the Spring Framework provides an introduction to load-time weaving for Spring applications that use AspectJ. Using AspectJ to Dependency Inject Domain Objects with Spring The Spring container instantiates and configures beans defined in your application context. It is also possible to ask a bean factory to configure a pre-existing object, given the name of a bean definition that contains the configuration to be applied.spring-aspects.jar contains an annotation- driven aspect that exploits this capability to allow dependency injection of any object. The support is intended to be used for objects created outside of the control of any container. Domain objects often fall into this category because they are often created programmatically with the new operator or by an ORM tool as a result of a database query.", "chunk_char_count": 1419, "chunk_word_count": 223, "chunk_token_count": 354.75}, {"page_number": 381, "sentence_chunk": "The @Configurable annotation marks a class as being eligible for Spring-driven configuration. In the simplest case, you can use purely it as a marker annotation, as the following example shows: Java package com.xyz.myapp.domain; import org.springframework.beans.factory.annotation. Configurable; @Configurable public class Account { \u00a0  // ... } Kotlin package com.xyz.myapp.domain import org.springframework.beans.factory.annotation. Configurable @Configurable class Account { \u00a0  // ... } When used as a marker interface in this way, Spring configures new instances of the annotated type (Account, in this case) by using a bean definition (typically prototype-scoped) with the same name as the fully-qualified type name (com.xyz.myapp.domain. Account). Since the default name for a bean is the fully-qualified name of its type, a convenient way to declare the prototype definition is 381", "chunk_char_count": 887, "chunk_word_count": 124, "chunk_token_count": 221.75}, {"page_number": 382, "sentence_chunk": "to omit the id attribute, as the following example shows: <bean class=\"com.xyz.myapp.domain. Account\" scope=\"prototype\"> \u00a0  <property name=\"fundsTransferService\" ref=\"fundsTransferService\"/> </bean> If you want to explicitly specify the name of the prototype bean definition to use, you can do so directly in the annotation, as the following example shows: Java package com.xyz.myapp.domain; import org.springframework.beans.factory.annotation. Configurable; @Configurable(\"account\") public class Account { \u00a0  // ... } Kotlin package com.xyz.myapp.domain import org.springframework.beans.factory.annotation. Configurable @Configurable(\"account\") class Account { \u00a0  // ... } Spring now looks for a bean definition named account and uses that as the definition to configure new Account instances. You can also use autowiring to avoid having to specify a dedicated bean definition at all. To have Spring apply autowiring, use the autowire property of the @Configurable annotation. You can specify either @Configurable(autowire=Autowire. BY_TYPE) or @Configurable(autowire=Autowire. BY_NAME) for autowiring by type or by name, respectively. As an alternative, it is preferable to specify explicit, annotation-driven dependency injection for your @Configurable beans through @Autowired or @Inject at the field or method level (see Annotation-based Container Configuration for further details).", "chunk_char_count": 1388, "chunk_word_count": 178, "chunk_token_count": 347.0}, {"page_number": 382, "sentence_chunk": "Finally, you can enable Spring dependency checking for the object references in the newly created and configured object by using the dependencyCheck attribute (for example, @Configurable(autowire=Autowire. BY_NAME,dependencyCheck=true)). If this attribute is set to true, Spring validates after configuration that all properties (which are not primitives or collections) have been set.382", "chunk_char_count": 388, "chunk_word_count": 50, "chunk_token_count": 97.0}, {"page_number": 383, "sentence_chunk": "Note that using the annotation on its own does nothing. It is the AnnotationBeanConfigurerAspect in spring-aspects.jar that acts on the presence of the annotation. In essence, the aspect says, \u201cafter returning from the initialization of a new object of a type annotated with @Configurable, configure the newly created object using Spring in accordance with the properties of the annotation\u201d. In this context, \u201cinitialization\u201d refers to newly instantiated objects (for example, objects instantiated with the new operator) as well as to Serializable objects that are undergoing deserialization (for example, through readResolve()).\uf05a One of the key phrases in the above paragraph is \u201cin essence\u201d. For most cases, the exact semantics of \u201cafter returning from the initialization of a new object\u201d are fine. In this context, \u201cafter initialization\u201d means that the dependencies are injected after the object has been constructed. This means that the dependencies are not available for use in the constructor bodies of the class. If you want the dependencies to be injected before the constructor bodies run and thus be available for use in the body of the constructors, you need to define this on the @Configurable declaration, as follows: Java @Configurable(preConstruction = true) Kotlin @Configurable(preConstruction = true) You can find more information about the language semantics of the various pointcut types in AspectJ in this appendix of the AspectJ Programming Guide. For this to work, the annotated types must be woven with the AspectJ weaver.", "chunk_char_count": 1546, "chunk_word_count": 236, "chunk_token_count": 386.5}, {"page_number": 383, "sentence_chunk": "You can either use a build-time Ant or Maven task to do this (see, for example, the AspectJ Development Environment Guide) or load-time weaving (see Load-time Weaving with AspectJ in the Spring Framework). The AnnotationBeanConfigurerAspect itself needs to be configured by Spring (in order to obtain a reference to the bean factory that is to be used to configure new objects). If you use Java-based configuration, you can add @EnableSpringConfigured to any @Configuration class, as follows: Java @Configuration @EnableSpringConfigured public class AppConfig { } 383", "chunk_char_count": 567, "chunk_word_count": 85, "chunk_token_count": 141.75}, {"page_number": 384, "sentence_chunk": "Kotlin @Configuration @EnableSpringConfigured class AppConfig { } If you prefer XML based configuration, the Spring context namespace defines a convenient context:spring-configured element, which you can use as follows: <context:spring-configured/> Instances of @Configurable objects created before the aspect has been configured result in a message being issued to the debug log and no configuration of the object taking place. An example might be a bean in the Spring configuration that creates domain objects when it is initialized by Spring. In this case, you can use the depends-on bean attribute to manually specify that the bean depends on the configuration aspect. The following example shows how to use the depends-on attribute: <bean id=\"myService\" \u00a0    class=\"com.xzy.myapp.service. MyService\" \u00a0    depends- on=\"org.springframework.beans.factory.aspectj. AnnotationBeanConfigurerAspect\"> \u00a0  <!-- ... --> </bean> \uf05a Do not activate @Configurable processing through the bean configurer aspect unless you really mean to rely on its semantics at runtime. In particular, make sure that you do not use @Configurable on bean classes that are registered as regular Spring beans with the container. Doing so results in double initialization, once through the container and once through the aspect. Unit Testing @Configurable Objects One of the goals of the @Configurable support is to enable independent unit testing of domain objects without the difficulties associated with hard-coded lookups.", "chunk_char_count": 1496, "chunk_word_count": 218, "chunk_token_count": 374.0}, {"page_number": 384, "sentence_chunk": "If @Configurable types have not been woven by AspectJ, the annotation has no affect during unit testing. You can set mock or stub property references in the object under test and proceed as normal. If @Configurable types have been woven by AspectJ, you can still unit test outside of the container as normal, but you see a warning message each time that you construct a @Configurable object indicating that it has not been configured by Spring.384", "chunk_char_count": 447, "chunk_word_count": 76, "chunk_token_count": 111.75}, {"page_number": 385, "sentence_chunk": "Working with Multiple Application Contexts The AnnotationBeanConfigurerAspect that is used to implement the @Configurable support is an AspectJ singleton aspect. The scope of a singleton aspect is the same as the scope of static members: There is one aspect instance per classloader that defines the type. This means that, if you define multiple application contexts within the same classloader hierarchy, you need to consider where to define the @EnableSpringConfigured bean and where to place spring-aspects.jar on the classpath. Consider a typical Spring web application configuration that has a shared parent application context that defines common business services, everything needed to support those services, and one child application context for each servlet (which contains definitions particular to that servlet). All of these contexts co-exist within the same classloader hierarchy, and so the AnnotationBeanConfigurerAspect can hold a reference to only one of them. In this case, we recommend defining the @EnableSpringConfigured bean in the shared (parent) application context. This defines the services that you are likely to want to inject into domain objects. A consequence is that you cannot configure domain objects with references to beans defined in the child (servlet- specific) contexts by using the @Configurable mechanism (which is probably not something you want to do anyway). When deploying multiple web applications within the same container, ensure that each web application loads the types in spring-aspects.jar by using its own classloader (for example, by placing spring-aspects.jar in WEB-INF/lib). If spring-aspects.jar is added only to the container- wide classpath (and hence loaded by the shared parent classloader), all web applications share the same aspect instance (which is probably not what you want).", "chunk_char_count": 1845, "chunk_word_count": 270, "chunk_token_count": 461.25}, {"page_number": 385, "sentence_chunk": "Other Spring aspects for AspectJ In addition to the @Configurable aspect, spring-aspects.jar contains an AspectJ aspect that you can use to drive Spring\u2019s transaction management for types and methods annotated with the @Transactional annotation. This is primarily intended for users who want to use the Spring Framework\u2019s transaction support outside of the Spring container. The aspect that interprets @Transactional annotations is the AnnotationTransactionAspect. When you use this aspect, you must annotate the implementation class (or methods within that class or both), not the interface (if any) that the class implements. AspectJ follows Java\u2019s rule that annotations on interfaces are not inherited. A @Transactional annotation on a class specifies the default transaction semantics for the execution of any public operation in the class. A @Transactional annotation on a method within the class overrides the default transaction semantics given by the class annotation (if present). Methods of any visibility may be annotated, including private methods. Annotating non-public methods directly is the only way to get transaction demarcation for the execution of such methods.\uf0eb Since Spring Framework 4.2, spring-aspects provides a similar aspect that offers the exact same features for the standard jakarta.transaction.", "chunk_char_count": 1325, "chunk_word_count": 190, "chunk_token_count": 331.25}, {"page_number": 386, "sentence_chunk": "For AspectJ programmers who want to use the Spring configuration and transaction management support but do not want to (or cannot) use annotations, spring-aspects.jar also contains abstract aspects you can extend to provide your own pointcut definitions. See the sources for the AbstractBeanConfigurerAspect and AbstractTransactionAspect aspects for more information. As an example, the following excerpt shows how you could write an aspect to configure all instances of objects defined in the domain model by using prototype bean definitions that match the fully qualified class names: public aspect DomainObjectConfiguration extends AbstractBeanConfigurerAspect { \u00a0  public DomainObjectConfiguration() { \u00a0    setBeanWiringInfoResolver(new ClassNameBeanWiringInfoResolver()); \u00a0  } \u00a0  // the creation of a new bean (any object in the domain model) \u00a0  protected pointcut beanCreation(Object beanInstance) : \u00a0    initialization(new(..)) && \u00a0    CommonPointcuts.inDomainModel() && \u00a0    this(beanInstance); } Configuring AspectJ Aspects by Using Spring IoC When you use AspectJ aspects with Spring applications, it is natural to both want and expect to be able to configure such aspects with Spring. The AspectJ runtime itself is responsible for aspect creation, and the means of configuring the AspectJ-created aspects through Spring depends on the AspectJ instantiation model (the per-xxx clause) used by the aspect. The majority of AspectJ aspects are singleton aspects. Configuration of these aspects is easy. You can create a bean definition that references the aspect type as normal and include the factory- method=\"aspectOf\" bean attribute. This ensures that Spring obtains the aspect instance by asking AspectJ for it rather than trying to create an instance itself. The following example shows how to use the factory-method=\"aspectOf\" attribute: <bean id=\"profiler\" class=\"com.xyz.profiler. Profiler\" \u00a0    factory-method=\"aspectOf\"> \u2460 \u00a0  <property name=\"profilingStrategy\" ref=\"jamonProfilingStrategy\"/> </bean> \u2460 Note the factory-method=\"aspectOf\" attribute Non-singleton aspects are harder to configure.", "chunk_char_count": 2110, "chunk_word_count": 301, "chunk_token_count": 527.5}, {"page_number": 386, "sentence_chunk": "However, it is possible to do so by creating prototype bean definitions and using the @Configurable support from spring-aspects.jar to configure the aspect instances once they have bean created by the AspectJ runtime. If you have some @AspectJ aspects that you want to weave with AspectJ (for example, using load- time weaving for domain model types) and other @AspectJ aspects that you want to use with Spring 386", "chunk_char_count": 414, "chunk_word_count": 68, "chunk_token_count": 103.5}, {"page_number": 387, "sentence_chunk": "AOP, and these aspects are all configured in Spring, you need to tell the Spring AOP @AspectJ auto- proxying support which exact subset of the @AspectJ aspects defined in the configuration should be used for auto-proxying. You can do this by using one or more <include/> elements inside the <aop:aspectj-autoproxy/> declaration. Each <include/> element specifies a name pattern, and only beans with names matched by at least one of the patterns are used for Spring AOP auto-proxy configuration. The following example shows how to use <include/> elements: <aop:aspectj-autoproxy> \u00a0  <aop:include name=\"thisBean\"/> \u00a0  <aop:include name=\"thatBean\"/> </aop:aspectj-autoproxy> \uf05a Do not be misled by the name of the <aop:aspectj-autoproxy/> element. Using it results in the creation of Spring AOP proxies. The @AspectJ style of aspect declaration is being used here, but the AspectJ runtime is not involved. Load-time Weaving with AspectJ in the Spring Framework Load-time weaving (LTW) refers to the process of weaving AspectJ aspects into an application\u2019s class files as they are being loaded into the Java virtual machine (JVM). The focus of this section is on configuring and using LTW in the specific context of the Spring Framework. This section is not a general introduction to LTW. For full details on the specifics of LTW and configuring LTW with only AspectJ (with Spring not being involved at all), see the LTW section of the AspectJ Development Environment Guide.", "chunk_char_count": 1469, "chunk_word_count": 230, "chunk_token_count": 367.25}, {"page_number": 387, "sentence_chunk": "The value that the Spring Framework brings to AspectJ LTW is in enabling much finer-grained control over the weaving process. 'Vanilla' AspectJ LTW is effected by using a Java (5+) agent, which is switched on by specifying a VM argument when starting up a JVM. It is, thus, a JVM-wide setting, which may be fine in some situations but is often a little too coarse. Spring-enabled LTW lets you switch on LTW on a per-ClassLoader basis, which is more fine-grained and which can make more sense in a 'single-JVM-multiple-application' environment (such as is found in a typical application server environment). Further, in certain environments, this support enables load-time weaving without making any modifications to the application server\u2019s launch script that is needed to add -javaagent:path/to/aspectjweaver.jar or (as we describe later in this section) -javaagent:path/to/spring-instrument.jar. Developers configure the application context to enable load-time weaving instead of relying on administrators who typically are in charge of the deployment configuration, such as the launch script. Now that the sales pitch is over, let us first walk through a quick example of AspectJ LTW that uses Spring, followed by detailed specifics about elements introduced in the example. For a complete example, see the Petclinic sample application. A First Example Assume that you are an application developer who has been tasked with diagnosing the cause of some performance problems in a system. Rather than break out a profiling tool, we are going to 387", "chunk_char_count": 1548, "chunk_word_count": 239, "chunk_token_count": 387.0}, {"page_number": 388, "sentence_chunk": "switch on a simple profiling aspect that lets us quickly get some performance metrics. We can then apply a finer-grained profiling tool to that specific area immediately afterwards.\uf05a The example presented here uses XML configuration. You can also configure and use @AspectJ with Java configuration. Specifically, you can use the @EnableLoadTimeWeaving annotation as an alternative to <context:load-time- weaver/> (see below for details). The following example shows the profiling aspect, which is not fancy. It is a time-based profiler that uses the @AspectJ-style of aspect declaration: Java package foo; import org.aspectj.lang. ProceedingJoinPoint; import org.aspectj.lang.annotation. Aspect; import org.aspectj.lang.annotation. Around; import org.aspectj.lang.annotation.", "chunk_char_count": 775, "chunk_word_count": 99, "chunk_token_count": 193.75}, {"page_number": 388, "sentence_chunk": "Pointcut; import org.springframework.util. StopWatch; import org.springframework.core.annotation. Order; @Aspect public class ProfilingAspect { \u00a0  @Around(\"methodsToBeProfiled()\") \u00a0  public Object profile(ProceedingJoinPoint pjp) throws Throwable { \u00a0    StopWatch sw = new StopWatch(getClass().getSimpleName()); \u00a0    try { \u00a0      sw.start(pjp.getSignature().getName()); \u00a0      return pjp.proceed(); \u00a0    } finally { \u00a0      sw.stop(); \u00a0      System.out.println(sw.prettyPrint()); \u00a0    } \u00a0  } \u00a0  @Pointcut(\"execution(public * foo..*.*(..))\")\u00a0  public void methodsToBeProfiled(){} } 388", "chunk_char_count": 583, "chunk_word_count": 94, "chunk_token_count": 145.75}, {"page_number": 389, "sentence_chunk": "Kotlin package foo import org.aspectj.lang. ProceedingJoinPoint import org.aspectj.lang.annotation. Aspect import org.aspectj.lang.annotation. Around import org.aspectj.lang.annotation. Pointcut import org.springframework.util. StopWatch import org.springframework.core.annotation. Order @Aspect class ProfilingAspect { \u00a0  @Around(\"methodsToBeProfiled()\") \u00a0  fun profile(pjp: ProceedingJoinPoint): Any { \u00a0    val sw = StopWatch(javaClass.simpleName) \u00a0    try { \u00a0      sw.start(pjp.getSignature().getName()) \u00a0      return pjp.proceed() \u00a0    } finally { \u00a0      sw.stop() \u00a0      println(sw.prettyPrint()) \u00a0    } \u00a0  } \u00a0  @Pointcut(\"execution(public * foo..*.*(..))\")\u00a0  fun methodsToBeProfiled() { \u00a0  } } We also need to create an META-INF/aop.xml file, to inform the AspectJ weaver that we want to weave our ProfilingAspect into our classes. This file convention, namely the presence of a file (or files) on the Java classpath called META-INF/aop.xml is standard AspectJ. The following example shows the aop.xml file: 389", "chunk_char_count": 1017, "chunk_word_count": 157, "chunk_token_count": 254.25}, {"page_number": 390, "sentence_chunk": "<!DOCTYPE aspectj PUBLIC \"-//AspectJ//DTD//EN\" \"https://www.eclipse.org/aspectj/dtd/aspectj.dtd\"> <aspectj> \u00a0  <weaver> \u00a0    <!--only weave classes in our application-specific packages --> \u00a0    <include within=\"foo.*\"/> \u00a0  </weaver> \u00a0  <aspects> \u00a0    <!--weave in just this aspect --> \u00a0    <aspect name=\"foo. ProfilingAspect\"/> \u00a0  </aspects> </aspectj> Now we can move on to the Spring-specific portion of the configuration. We need to configure a LoadTimeWeaver (explained later). This load-time weaver is the essential component responsible for weaving the aspect configuration in one or more META-INF/aop.xml files into the classes in your application. The good thing is that it does not require a lot of configuration (there are some more options that you can specify, but these are detailed later), as can be seen in the following example: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:context=\"http://www.springframework.org/schema/context\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/context \u00a0    https://www.springframework.org/schema/context/spring-context.xsd\"> \u00a0  <!--", "chunk_char_count": 1336, "chunk_word_count": 171, "chunk_token_count": 334.0}, {"page_number": 390, "sentence_chunk": "a service object; we will be profiling its methods --> \u00a0  <bean id=\"entitlementCalculationService\" \u00a0      class=\"foo. StubEntitlementCalculationService\"/> \u00a0  <!--this switches on the load-time weaving --> \u00a0  <context:load-time-weaver/> </beans> Now that all the required artifacts (the aspect, the META-INF/aop.xml file, and the Spring configuration) are in place, we can create the following driver class with a main(..) method to demonstrate the LTW in action: 390", "chunk_char_count": 466, "chunk_word_count": 71, "chunk_token_count": 116.5}, {"page_number": 391, "sentence_chunk": "Java package foo; import org.springframework.context.support. ClassPathXmlApplicationContext; public final class Main { \u00a0  public static void main(String[] args) { \u00a0    ApplicationContext ctx = new ClassPathXmlApplicationContext(\"beans.xml\", Main.class); \u00a0    EntitlementCalculationService entitlementCalculationService = \u00a0        (EntitlementCalculationService) ctx.getBean(\"entitlementCalculationService\"); \u00a0    // the profiling aspect is 'woven' around this method execution \u00a0    entitlementCalculationService.calculateEntitlement(); \u00a0  } } Kotlin package foo import org.springframework.context.support. ClassPathXmlApplicationContext fun main() { \u00a0  val ctx = ClassPathXmlApplicationContext(\"beans.xml\") \u00a0  val entitlementCalculationService = ctx.getBean(\"entitlementCalculationService\") as EntitlementCalculationService \u00a0  // the profiling aspect is 'woven' around this method execution \u00a0  entitlementCalculationService.calculateEntitlement() } We have one last thing to do. The introduction to this section did say that one could switch on LTW selectively on a per-ClassLoader basis with Spring, and this is true. However, for this example, we use a Java agent (supplied with Spring) to switch on LTW. We use the following command to run the Main class shown earlier: java -javaagent:C:/projects/foo/lib/global/spring-instrument.jar foo. Main The -javaagent is a flag for specifying and enabling agents to instrument programs that run on the JVM. The Spring Framework ships with such an agent, the InstrumentationSavingAgent, which is packaged in the spring-instrument.jar that was supplied as the value of the -javaagent argument in the preceding example.391", "chunk_char_count": 1665, "chunk_word_count": 219, "chunk_token_count": 416.25}, {"page_number": 392, "sentence_chunk": "The output from the execution of the Main program looks something like the next example. (I have introduced a Thread.sleep(..) statement into the calculateEntitlement() implementation so that the profiler actually captures something other than 0 milliseconds (the 01234 milliseconds is not an overhead introduced by the AOP). The following listing shows the output we got when we ran our profiler: Calculating entitlement StopWatch 'ProfilingAspect': running time (millis) = 1234 ------ ----- ---------------------------- ms   %   Task name ------ ----- ---------------------------- 01234 100% calculateEntitlement Since this LTW is effected by using full-blown AspectJ, we are not limited only to advising Spring beans. The following slight variation on the Main program yields the same result: Java package foo; import org.springframework.context.support. ClassPathXmlApplicationContext; public final class Main { \u00a0  public static void main(String[] args) { \u00a0    new ClassPathXmlApplicationContext(\"beans.xml\", Main.class); \u00a0    EntitlementCalculationService entitlementCalculationService = \u00a0        new StubEntitlementCalculationService(); \u00a0    // the profiling aspect will be 'woven' around this method execution \u00a0    entitlementCalculationService.calculateEntitlement(); \u00a0  } } 392", "chunk_char_count": 1286, "chunk_word_count": 184, "chunk_token_count": 321.5}, {"page_number": 393, "sentence_chunk": "Kotlin package foo import org.springframework.context.support. ClassPathXmlApplicationContext fun main(args: Array<String>) { \u00a0  ClassPathXmlApplicationContext(\"beans.xml\") \u00a0  val entitlementCalculationService = StubEntitlementCalculationService() \u00a0  // the profiling aspect will be 'woven' around this method execution \u00a0  entitlementCalculationService.calculateEntitlement() } Notice how, in the preceding program, we bootstrap the Spring container and then create a new instance of the StubEntitlementCalculationService totally outside the context of Spring. The profiling advice still gets woven in. Admittedly, the example is simplistic. However, the basics of the LTW support in Spring have all been introduced in the earlier example, and the rest of this section explains the \u201cwhy\u201d behind each bit of configuration and usage in detail.\uf05a The ProfilingAspect used in this example may be basic, but it is quite useful. It is a nice example of a development-time aspect that developers can use during development and then easily exclude from builds of the application being deployed into UAT or production. Aspects The aspects that you use in LTW have to be AspectJ aspects. You can write them in either the AspectJ language itself, or you can write your aspects in the @AspectJ-style. Your aspects are then both valid AspectJ and Spring AOP aspects.", "chunk_char_count": 1352, "chunk_word_count": 196, "chunk_token_count": 338.0}, {"page_number": 393, "sentence_chunk": "Furthermore, the compiled aspect classes need to be available on the classpath. 'META-INF/aop.xml' The AspectJ LTW infrastructure is configured by using one or more META-INF/aop.xml files that are on the Java classpath (either directly or, more typically, in jar files). The structure and contents of this file is detailed in the LTW part of the AspectJ reference documentation. Because the aop.xml file is 100% AspectJ, we do not describe it further here. Required libraries (JARS) At minimum, you need the following libraries to use the Spring Framework\u2019s support for AspectJ LTW: \u2022 spring-aop.jar 393", "chunk_char_count": 603, "chunk_word_count": 94, "chunk_token_count": 150.75}, {"page_number": 394, "sentence_chunk": "\u2022 aspectjweaver.jar If you use the Spring-provided agent to enable instrumentation, you also need: \u2022 spring-instrument.jar Spring Configuration The key component in Spring\u2019s LTW support is the LoadTimeWeaver interface (in the org.springframework.instrument.classloading package), and the numerous implementations of it that ship with the Spring distribution. A LoadTimeWeaver is responsible for adding one or more java.lang.instrument. ClassFileTransformers to a ClassLoader at runtime, which opens the door to all manner of interesting applications, one of which happens to be the LTW of aspects.\uf0eb If you are unfamiliar with the idea of runtime class file transformation, see the javadoc API documentation for the java.lang.instrument package before continuing. While that documentation is not comprehensive, at least you can see the key interfaces and classes (for reference as you read through this section). Configuring a LoadTimeWeaver for a particular ApplicationContext can be as easy as adding one line. (Note that you almost certainly need to use an ApplicationContext as your Spring container\u2009\u2014\u2009typically, a BeanFactory is not enough because the LTW support uses BeanFactoryPostProcessors.)To enable the Spring Framework\u2019s LTW support, you need to configure a LoadTimeWeaver, which typically is done by using the @EnableLoadTimeWeaving annotation, as follows: Java @Configuration @EnableLoadTimeWeaving public class AppConfig { } Kotlin @Configuration @EnableLoadTimeWeaving class AppConfig { } Alternatively, if you prefer XML-based configuration, use the <context:load-time-weaver/> element. Note that the element is defined in the context namespace. The following example shows how to use <context:load-time-weaver/>: 394", "chunk_char_count": 1734, "chunk_word_count": 235, "chunk_token_count": 433.5}, {"page_number": 395, "sentence_chunk": "<?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:context=\"http://www.springframework.org/schema/context\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/context \u00a0    https://www.springframework.org/schema/context/spring-context.xsd\"> \u00a0  <context:load-time-weaver/> </beans> The preceding configuration automatically defines and registers a number of LTW-specific infrastructure beans, such as a LoadTimeWeaver and an AspectJWeavingEnabler, for you. The default LoadTimeWeaver is the DefaultContextLoadTimeWeaver class, which attempts to decorate an automatically detected LoadTimeWeaver. The exact type of LoadTimeWeaver that is \u201cautomatically detected\u201d is dependent upon your runtime environment. The following table summarizes various LoadTimeWeaver implementations: Table 13. DefaultContextLoadTimeWeaver LoadTimeWeavers Runtime Environment LoadTimeWeaver implementation Running in Apache Tomcat TomcatLoadTimeWeaver Running in GlassFish (limited to EAR deployments) GlassFishLoadTimeWeaver Running in Red Hat\u2019s JBoss AS or WildFly JBossLoadTimeWeaver Running in IBM\u2019s WebSphere WebSphereLoadTimeWeaver Running in Oracle\u2019s WebLogic WebLogicLoadTimeWeaver JVM started with Spring InstrumentationSavingAgent (java -javaagent:path/to/spring-instrument.jar) InstrumentationLoadTimeWeaver Fallback, expecting the underlying ClassLoader to follow common conventions (namely addTransformer and optionally a getThrowawayClassLoader method) ReflectiveLoadTimeWeaver Note that the table lists only the LoadTimeWeavers that are autodetected when you use the DefaultContextLoadTimeWeaver. You can specify exactly which LoadTimeWeaver implementation to use. To specify a specific LoadTimeWeaver with Java configuration, implement the LoadTimeWeavingConfigurer interface and override the getLoadTimeWeaver() method. The following example specifies a ReflectiveLoadTimeWeaver: 395", "chunk_char_count": 2118, "chunk_word_count": 211, "chunk_token_count": 529.5}, {"page_number": 396, "sentence_chunk": "Java @Configuration @EnableLoadTimeWeaving public class AppConfig implements LoadTimeWeavingConfigurer { \u00a0  @Override \u00a0  public LoadTimeWeaver getLoadTimeWeaver() { \u00a0    return new ReflectiveLoadTimeWeaver(); \u00a0  } } Kotlin @Configuration @EnableLoadTimeWeaving class AppConfig : LoadTimeWeavingConfigurer { \u00a0  override fun getLoadTimeWeaver(): LoadTimeWeaver { \u00a0    return ReflectiveLoadTimeWeaver() \u00a0  } } If you use XML-based configuration, you can specify the fully qualified classname as the value of the weaver-class attribute on the <context:load-time-weaver/> element. Again, the following example specifies a ReflectiveLoadTimeWeaver: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:context=\"http://www.springframework.org/schema/context\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/context \u00a0    https://www.springframework.org/schema/context/spring-context.xsd\"> \u00a0  <context:load-time-weaver \u00a0      weaver- class=\"org.springframework.instrument.classloading. ReflectiveLoadTimeWeaver\"/> </beans> The LoadTimeWeaver that is defined and registered by the configuration can be later retrieved from the Spring container by using the well known name, loadTimeWeaver. Remember that the LoadTimeWeaver exists only as a mechanism for Spring\u2019s LTW infrastructure to add one or more ClassFileTransformers. The actual ClassFileTransformer that does the LTW is the ClassPreProcessorAgentAdapter (from the org.aspectj.weaver.loadtime package) class. See the class- 396", "chunk_char_count": 1719, "chunk_word_count": 194, "chunk_token_count": 429.75}, {"page_number": 397, "sentence_chunk": "level javadoc of the ClassPreProcessorAgentAdapter class for further details, because the specifics of how the weaving is actually effected is beyond the scope of this document. There is one final attribute of the configuration left to discuss: the aspectjWeaving attribute (or aspectj-weaving if you use XML). This attribute controls whether LTW is enabled or not. It accepts one of three possible values, with the default value being autodetect if the attribute is not present. The following table summarizes the three possible values: Table 14. AspectJ weaving attribute values Annotation Value XML Value Explanation ENABLED on AspectJ weaving is on, and aspects are woven at load-time as appropriate. DISABLED off LTW is off. No aspect is woven at load-time. AUTODETECT autodetect If the Spring LTW infrastructure can find at least one META-INF/aop.xml file, then AspectJ weaving is on. Otherwise, it is off.", "chunk_char_count": 912, "chunk_word_count": 141, "chunk_token_count": 228.0}, {"page_number": 397, "sentence_chunk": "This is the default value. Environment-specific Configuration This last section contains any additional settings and configuration that you need when you use Spring\u2019s LTW support in environments such as application servers and web containers. Tomcat, JBoss, WebSphere, WebLogic Tomcat, JBoss/WildFly, IBM WebSphere Application Server and Oracle WebLogic Server all provide a general app ClassLoader that is capable of local instrumentation. Spring\u2019s native LTW may leverage those ClassLoader implementations to provide AspectJ weaving. You can simply enable load-time weaving, as described earlier. Specifically, you do not need to modify the JVM launch script to add -javaagent:path/to/spring-instrument.jar. Note that on JBoss, you may need to disable the app server scanning to prevent it from loading the classes before the application actually starts. A quick workaround is to add to your artifact a file named WEB-INF/jboss-scanning.xml with the following content: <scanning xmlns=\"urn:jboss:scanning:1.0\"/> Generic Java Applications When class instrumentation is required in environments that are not supported by specific LoadTimeWeaver implementations, a JVM agent is the general solution. For such cases, Spring provides InstrumentationLoadTimeWeaver which requires a Spring-specific (but very general) JVM agent, spring-instrument.jar, autodetected by common @EnableLoadTimeWeaving and <context:load- 397", "chunk_char_count": 1415, "chunk_word_count": 187, "chunk_token_count": 353.75}, {"page_number": 398, "sentence_chunk": "time-weaver/> setups. To use it, you must start the virtual machine with the Spring agent by supplying the following JVM options: -javaagent:/path/to/spring-instrument.jar Note that this requires modification of the JVM launch script, which may prevent you from using this in application server environments (depending on your server and your operation policies). That said, for one-app-per-JVM deployments such as standalone Spring Boot applications, you typically control the entire JVM setup in any case.2.5.11. Further Resources More information on AspectJ can be found on the AspectJ website. Eclipse AspectJ by Adrian Colyer et.al. (Addison-Wesley, 2005) provides a comprehensive introduction and reference for the AspectJ language. AspectJ in Action, Second Edition by Ramnivas Laddad (Manning, 2009) comes highly recommended. The focus of the book is on AspectJ, but a lot of general AOP themes are explored (in some depth).", "chunk_char_count": 932, "chunk_word_count": 136, "chunk_token_count": 233.0}, {"page_number": 398, "sentence_chunk": "2.6. Spring AOP APIs The previous chapter described the Spring\u2019s support for AOP with @AspectJ and schema-based aspect definitions. In this chapter, we discuss the lower-level Spring AOP APIs. For common applications, we recommend the use of Spring AOP with AspectJ pointcuts as described in the previous chapter.2.6.1. Pointcut API in Spring This section describes how Spring handles the crucial pointcut concept. Concepts Spring\u2019s pointcut model enables pointcut reuse independent of advice types. You can target different advice with the same pointcut. The org.springframework.aop. Pointcut interface is the central interface, used to target advices to particular classes and methods.", "chunk_char_count": 687, "chunk_word_count": 99, "chunk_token_count": 171.75}, {"page_number": 399, "sentence_chunk": "public interface Pointcut { \u00a0  ClassFilter getClassFilter(); \u00a0  MethodMatcher getMethodMatcher(); } Splitting the Pointcut interface into two parts allows reuse of class and method matching parts and fine-grained composition operations (such as performing a \u201cunion\u201d with another method matcher). The ClassFilter interface is used to restrict the pointcut to a given set of target classes. If the matches() method always returns true, all target classes are matched. The following listing shows the ClassFilter interface definition: public interface ClassFilter { \u00a0  boolean matches(Class clazz); } The MethodMatcher interface is normally more important. The complete interface follows: public interface MethodMatcher { \u00a0  boolean matches(Method m, Class<?> targetClass); \u00a0  boolean isRuntime(); \u00a0  boolean matches(Method m, Class<?> targetClass, Object... args); } The matches(Method, Class) method is used to test whether this pointcut ever matches a given method on a target class. This evaluation can be performed when an AOP proxy is created to avoid the need for a test on every method invocation. If the two-argument matches method returns true for a given method, and the isRuntime() method for the MethodMatcher returns true, the three- argument matches method is invoked on every method invocation. This lets a pointcut look at the arguments passed to the method invocation immediately before the target advice starts.", "chunk_char_count": 1427, "chunk_word_count": 215, "chunk_token_count": 356.75}, {"page_number": 399, "sentence_chunk": "Most MethodMatcher implementations are static, meaning that their isRuntime() method returns false. In this case, the three-argument matches method is never invoked.\uf0eb If possible, try to make pointcuts static, allowing the AOP framework to cache the results of pointcut evaluation when an AOP proxy is created. Operations on Pointcuts Spring supports operations (notably, union and intersection) on pointcuts.399", "chunk_char_count": 412, "chunk_word_count": 58, "chunk_token_count": 103.0}, {"page_number": 400, "sentence_chunk": "Union means the methods that either pointcut matches. Intersection means the methods that both pointcuts match. Union is usually more useful. You can compose pointcuts by using the static methods in the org.springframework.aop.support. Pointcuts class or by using the ComposablePointcut class in the same package. However, using AspectJ pointcut expressions is usually a simpler approach. AspectJ Expression Pointcuts Since 2.0, the most important type of pointcut used by Spring is org.springframework.aop.aspectj. AspectJExpressionPointcut. This is a pointcut that uses an AspectJ- supplied library to parse an AspectJ pointcut expression string. See the previous chapter for a discussion of supported AspectJ pointcut primitives.", "chunk_char_count": 732, "chunk_word_count": 101, "chunk_token_count": 183.0}, {"page_number": 400, "sentence_chunk": "Convenience Pointcut Implementations Spring provides several convenient pointcut implementations. You can use some of them directly; others are intended to be subclassed in application-specific pointcuts. Static Pointcuts Static pointcuts are based on the method and the target class and cannot take into account the method\u2019s arguments. Static pointcuts suffice\u2009\u2014\u2009and are best\u2009\u2014\u2009for most usages. Spring can evaluate a static pointcut only once, when a method is first invoked. After that, there is no need to evaluate the pointcut again with each method invocation. The rest of this section describes some of the static pointcut implementations that are included with Spring. Regular Expression Pointcuts One obvious way to specify static pointcuts is regular expressions. Several AOP frameworks besides Spring make this possible.org.springframework.aop.support.", "chunk_char_count": 862, "chunk_word_count": 120, "chunk_token_count": 215.5}, {"page_number": 400, "sentence_chunk": "JdkRegexpMethodPointcut is a generic regular expression pointcut that uses the regular expression support in the JDK. With the JdkRegexpMethodPointcut class, you can provide a list of pattern strings. If any of these is a match, the pointcut evaluates to true. (As a consequence, the resulting pointcut is effectively the union of the specified patterns.)The following example shows how to use JdkRegexpMethodPointcut: 400", "chunk_char_count": 422, "chunk_word_count": 62, "chunk_token_count": 105.5}, {"page_number": 401, "sentence_chunk": "<bean id=\"settersAndAbsquatulatePointcut\" \u00a0    class=\"org.springframework.aop.support. JdkRegexpMethodPointcut\"> \u00a0  <property name=\"patterns\"> \u00a0    <list> \u00a0      <value>.*set.*</value> \u00a0      <value>.*absquatulate</value> \u00a0    </list> \u00a0  </property> </bean> Spring provides a convenience class named RegexpMethodPointcutAdvisor, which lets us also reference an Advice (remember that an Advice can be an interceptor, before advice, throws advice, and others). Behind the scenes, Spring uses a JdkRegexpMethodPointcut. Using RegexpMethodPointcutAdvisor simplifies wiring, as the one bean encapsulates both pointcut and advice, as the following example shows: <bean id=\"settersAndAbsquatulateAdvisor\" \u00a0    class=\"org.springframework.aop.support. RegexpMethodPointcutAdvisor\"> \u00a0  <property name=\"advice\"> \u00a0    <ref bean=\"beanNameOfAopAllianceInterceptor\"/> \u00a0  </property> \u00a0  <property name=\"patterns\"> \u00a0    <list> \u00a0      <value>.*set.*</value> \u00a0      <value>.*absquatulate</value> \u00a0    </list> \u00a0  </property> </bean> You can use RegexpMethodPointcutAdvisor with any Advice type. Attribute-driven Pointcuts An important type of static pointcut is a metadata-driven pointcut. This uses the values of metadata attributes (typically, source-level metadata). Dynamic pointcuts Dynamic pointcuts are costlier to evaluate than static pointcuts. They take into account method arguments as well as static information. This means that they must be evaluated with every method invocation and that the result cannot be cached, as arguments will vary.", "chunk_char_count": 1534, "chunk_word_count": 220, "chunk_token_count": 383.5}, {"page_number": 401, "sentence_chunk": "The main example is the control flow pointcut. Control Flow Pointcuts Spring control flow pointcuts are conceptually similar to AspectJ cflow pointcuts, although less powerful. (There is currently no way to specify that a pointcut runs below a join point matched by 401", "chunk_char_count": 269, "chunk_word_count": 43, "chunk_token_count": 67.25}, {"page_number": 402, "sentence_chunk": "another pointcut.)A control flow pointcut matches the current call stack. For example, it might fire if the join point was invoked by a method in the com.mycompany.web package or by the SomeCaller class. Control flow pointcuts are specified by using the org.springframework.aop.support. ControlFlowPointcut class.\uf05a Control flow pointcuts are significantly more expensive to evaluate at runtime than even other dynamic pointcuts. In Java 1.4, the cost is about five times that of other dynamic pointcuts. Pointcut Superclasses Spring provides useful pointcut superclasses to help you to implement your own pointcuts. Because static pointcuts are most useful, you should probably subclass StaticMethodMatcherPointcut. This requires implementing only one abstract method (although you can override other methods to customize behavior).", "chunk_char_count": 832, "chunk_word_count": 116, "chunk_token_count": 208.0}, {"page_number": 402, "sentence_chunk": "The following example shows how to subclass StaticMethodMatcherPointcut: Java class TestStaticPointcut extends StaticMethodMatcherPointcut { \u00a0  public boolean matches(Method m, Class targetClass) { \u00a0    // return true if custom criteria match \u00a0  } } Kotlin class TestStaticPointcut : StaticMethodMatcherPointcut() { \u00a0  override fun matches(method: Method, targetClass: Class<*>): Boolean { \u00a0    // return true if custom criteria match \u00a0  } } There are also superclasses for dynamic pointcuts. You can use custom pointcuts with any advice type. Custom Pointcuts Because pointcuts in Spring AOP are Java classes rather than language features (as in AspectJ), you can declare custom pointcuts, whether static or dynamic. Custom pointcuts in Spring can be arbitrarily complex. However, we recommend using the AspectJ pointcut expression language, if you can.402", "chunk_char_count": 857, "chunk_word_count": 131, "chunk_token_count": 214.25}, {"page_number": 403, "sentence_chunk": "\uf05a Later versions of Spring may offer support for \u201csemantic pointcuts\u201d as offered by JAC\u2009\u2014\u2009for example, \u201call methods that change instance variables in the target object.\u201d2.6.2. Advice API in Spring Now we can examine how Spring AOP handles advice. Advice Lifecycles Each advice is a Spring bean. An advice instance can be shared across all advised objects or be unique to each advised object. This corresponds to per-class or per-instance advice. Per-class advice is used most often. It is appropriate for generic advice, such as transaction advisors. These do not depend on the state of the proxied object or add new state. They merely act on the method and arguments.", "chunk_char_count": 668, "chunk_word_count": 110, "chunk_token_count": 167.0}, {"page_number": 403, "sentence_chunk": "Per-instance advice is appropriate for introductions, to support mixins. In this case, the advice adds state to the proxied object. You can use a mix of shared and per-instance advice in the same AOP proxy. Advice Types in Spring Spring provides several advice types and is extensible to support arbitrary advice types. This section describes the basic concepts and standard advice types. Interception Around Advice The most fundamental advice type in Spring is interception around advice. Spring is compliant with the AOP Alliance interface for around advice that uses method interception. Classes that implement MethodInterceptor and that implement around advice should also implement the following interface: public interface MethodInterceptor extends Interceptor { \u00a0  Object invoke(MethodInvocation invocation) throws Throwable; } The MethodInvocation argument to the invoke() method exposes the method being invoked, the target join point, the AOP proxy, and the arguments to the method. The invoke() method should return the invocation\u2019s result: the return value of the join point. The following example shows a simple MethodInterceptor implementation: 403", "chunk_char_count": 1162, "chunk_word_count": 169, "chunk_token_count": 290.5}, {"page_number": 404, "sentence_chunk": "Java public class DebugInterceptor implements MethodInterceptor { \u00a0  public Object invoke(MethodInvocation invocation) throws Throwable { \u00a0    System.out.println(\"Before: invocation=[\" + invocation + \"]\"); \u00a0    Object rval = invocation.proceed(); \u00a0    System.out.println(\"Invocation returned\"); \u00a0    return rval; \u00a0  } } Kotlin class DebugInterceptor : MethodInterceptor { \u00a0  override fun invoke(invocation: MethodInvocation): Any { \u00a0    println(\"Before: invocation=[$invocation]\") \u00a0    val rval = invocation.proceed() \u00a0    println(\"Invocation returned\") \u00a0    return rval \u00a0  } } Note the call to the proceed() method of MethodInvocation. This proceeds down the interceptor chain towards the join point. Most interceptors invoke this method and return its return value. However, a MethodInterceptor, like any around advice, can return a different value or throw an exception rather than invoke the proceed method. However, you do not want to do this without good reason.\uf05a MethodInterceptor implementations offer interoperability with other AOP Alliance- compliant AOP implementations. The other advice types discussed in the remainder of this section implement common AOP concepts but in a Spring- specific way. While there is an advantage in using the most specific advice type, stick with MethodInterceptor around advice if you are likely to want to run the aspect in another AOP framework. Note that pointcuts are not currently interoperable between frameworks, and the AOP Alliance does not currently define pointcut interfaces. Before Advice A simpler advice type is a before advice.", "chunk_char_count": 1586, "chunk_word_count": 248, "chunk_token_count": 396.5}, {"page_number": 404, "sentence_chunk": "This does not need a MethodInvocation object, since it is called only before entering the method. The main advantage of a before advice is that there is no need to invoke the proceed() method and, therefore, no possibility of inadvertently failing to proceed down the interceptor chain. The following listing shows the MethodBeforeAdvice interface: 404", "chunk_char_count": 352, "chunk_word_count": 55, "chunk_token_count": 88.0}, {"page_number": 405, "sentence_chunk": "public interface MethodBeforeAdvice extends BeforeAdvice { \u00a0  void before(Method m, Object[] args, Object target) throws Throwable; } (Spring\u2019s API design would allow for field before advice, although the usual objects apply to field interception and it is unlikely for Spring to ever implement it.)Note that the return type is void. Before advice can insert custom behavior before the join point runs but cannot change the return value. If a before advice throws an exception, it stops further execution of the interceptor chain. The exception propagates back up the interceptor chain. If it is unchecked or on the signature of the invoked method, it is passed directly to the client. Otherwise, it is wrapped in an unchecked exception by the AOP proxy. The following example shows a before advice in Spring, which counts all method invocations: Java public class CountingBeforeAdvice implements MethodBeforeAdvice { \u00a0  private int count; \u00a0  public void before(Method m, Object[] args, Object target) throws Throwable { \u00a0    ++count; \u00a0  } \u00a0  public int getCount() { \u00a0    return count; \u00a0  } } Kotlin class CountingBeforeAdvice : MethodBeforeAdvice { \u00a0  var count: Int = 0 \u00a0  override fun before(m: Method, args: Array<Any>, target: Any?) {\u00a0    ++count \u00a0  } } \uf0eb Before advice can be used with any pointcut. Throws Advice Throws advice is invoked after the return of the join point if the join point threw an exception.", "chunk_char_count": 1417, "chunk_word_count": 246, "chunk_token_count": 354.25}, {"page_number": 406, "sentence_chunk": "org.springframework.aop. ThrowsAdvice interface does not contain any methods. It is a tag interface identifying that the given object implements one or more typed throws advice methods. These should be in the following form: afterThrowing([Method, args, target], subclassOfThrowable) Only the last argument is required. The method signatures may have either one or four arguments, depending on whether the advice method is interested in the method and arguments. The next two listing show classes that are examples of throws advice. The following advice is invoked if a RemoteException is thrown (including from subclasses): Java public class RemoteThrowsAdvice implements ThrowsAdvice { \u00a0  public void afterThrowing(RemoteException ex) throws Throwable { \u00a0    // Do something with remote exception \u00a0  } } Kotlin class RemoteThrowsAdvice : ThrowsAdvice { \u00a0  fun afterThrowing(ex: RemoteException) { \u00a0    // Do something with remote exception \u00a0  } } Unlike the preceding advice, the next example declares four arguments, so that it has access to the invoked method, method arguments, and target object. The following advice is invoked if a ServletException is thrown: Java public class ServletThrowsAdviceWithArguments implements ThrowsAdvice { \u00a0  public void afterThrowing(Method m, Object[] args, Object target, ServletException ex) { \u00a0    // Do something with all arguments \u00a0  } } 406", "chunk_char_count": 1386, "chunk_word_count": 216, "chunk_token_count": 346.5}, {"page_number": 407, "sentence_chunk": "Kotlin class ServletThrowsAdviceWithArguments : ThrowsAdvice { \u00a0  fun afterThrowing(m: Method, args: Array<Any>, target: Any, ex: ServletException) { \u00a0    // Do something with all arguments \u00a0  } } The final example illustrates how these two methods could be used in a single class that handles both RemoteException and ServletException. Any number of throws advice methods can be combined in a single class. The following listing shows the final example: Java public static class CombinedThrowsAdvice implements ThrowsAdvice { \u00a0  public void afterThrowing(RemoteException ex) throws Throwable { \u00a0    // Do something with remote exception \u00a0  } \u00a0  public void afterThrowing(Method m, Object[] args, Object target, ServletException ex) { \u00a0    // Do something with all arguments \u00a0  } } Kotlin class CombinedThrowsAdvice : ThrowsAdvice { \u00a0  fun afterThrowing(ex: RemoteException) { \u00a0    // Do something with remote exception \u00a0  } \u00a0  fun afterThrowing(m: Method, args: Array<Any>, target: Any, ex: ServletException) { \u00a0    // Do something with all arguments \u00a0  } } 407", "chunk_char_count": 1062, "chunk_word_count": 182, "chunk_token_count": 265.5}, {"page_number": 408, "sentence_chunk": "\uf05a If a throws-advice method throws an exception itself, it overrides the original exception (that is, it changes the exception thrown to the user). The overriding exception is typically a RuntimeException, which is compatible with any method signature. However, if a throws-advice method throws a checked exception, it must match the declared exceptions of the target method and is, hence, to some degree coupled to specific target method signatures. Do not throw an undeclared checked exception that is incompatible with the target method\u2019s signature!\uf0eb Throws advice can be used with any pointcut. After Returning Advice An after returning advice in Spring must implement the org.springframework.aop. AfterReturningAdvice interface, which the following listing shows: public interface AfterReturningAdvice extends Advice { \u00a0  void afterReturning(Object returnValue, Method m, Object[] args, Object target) \u00a0      throws Throwable; } An after returning advice has access to the return value (which it cannot modify), the invoked method, the method\u2019s arguments, and the target. The following after returning advice counts all successful method invocations that have not thrown exceptions: Java public class CountingAfterReturningAdvice implements AfterReturningAdvice { \u00a0  private int count; \u00a0  public void afterReturning(Object returnValue, Method m, Object[] args, Object target) \u00a0      throws Throwable { \u00a0    ++count; \u00a0  } \u00a0  public int getCount() { \u00a0    return count; \u00a0  } } 408", "chunk_char_count": 1482, "chunk_word_count": 234, "chunk_token_count": 370.5}, {"page_number": 409, "sentence_chunk": "Kotlin class CountingAfterReturningAdvice : AfterReturningAdvice { \u00a0  var count: Int = 0 \u00a0    private set \u00a0  override fun afterReturning(returnValue: Any?,m: Method, args: Array<Any>, target: Any?) {\u00a0    ++count \u00a0  } } This advice does not change the execution path. If it throws an exception, it is thrown up the interceptor chain instead of the return value.\uf0eb After returning advice can be used with any pointcut. Introduction Advice Spring treats introduction advice as a special kind of interception advice. Introduction requires an IntroductionAdvisor and an IntroductionInterceptor that implement the following interface: public interface IntroductionInterceptor extends MethodInterceptor { \u00a0  boolean implementsInterface(Class intf); } The invoke() method inherited from the AOP Alliance MethodInterceptor interface must implement the introduction. That is, if the invoked method is on an introduced interface, the introduction interceptor is responsible for handling the method call\u2009\u2014\u2009it cannot invoke proceed(). Introduction advice cannot be used with any pointcut, as it applies only at the class, rather than the method, level. You can only use introduction advice with the IntroductionAdvisor, which has the following methods: 409", "chunk_char_count": 1242, "chunk_word_count": 183, "chunk_token_count": 310.5}, {"page_number": 410, "sentence_chunk": "public interface IntroductionAdvisor extends Advisor, IntroductionInfo { \u00a0  ClassFilter getClassFilter(); \u00a0  void validateInterfaces() throws IllegalArgumentException; } public interface IntroductionInfo { \u00a0  Class<?>[] getInterfaces(); } There is no MethodMatcher and, hence, no Pointcut associated with introduction advice. Only class filtering is logical. The getInterfaces() method returns the interfaces introduced by this advisor. The validateInterfaces() method is used internally to see whether or not the introduced interfaces can be implemented by the configured IntroductionInterceptor. Consider an example from the Spring test suite and suppose we want to introduce the following interface to one or more objects: Java public interface Lockable { \u00a0  void lock(); \u00a0  void unlock(); \u00a0  boolean locked(); } Kotlin interface Lockable { \u00a0  fun lock() \u00a0  fun unlock() \u00a0  fun locked(): Boolean } This illustrates a mixin. We want to be able to cast advised objects to Lockable, whatever their type and call lock and unlock methods. If we call the lock() method, we want all setter methods to throw a LockedException. Thus, we can add an aspect that provides the ability to make objects immutable without them having any knowledge of it: a good example of AOP. First, we need an IntroductionInterceptor that does the heavy lifting.", "chunk_char_count": 1335, "chunk_word_count": 208, "chunk_token_count": 333.75}, {"page_number": 410, "sentence_chunk": "In this case, we extend the org.springframework.aop.support. DelegatingIntroductionInterceptor convenience class. We could implement IntroductionInterceptor directly, but using DelegatingIntroductionInterceptor is best for most cases.410", "chunk_char_count": 237, "chunk_word_count": 23, "chunk_token_count": 59.25}, {"page_number": 411, "sentence_chunk": "The DelegatingIntroductionInterceptor is designed to delegate an introduction to an actual implementation of the introduced interfaces, concealing the use of interception to do so. You can set the delegate to any object using a constructor argument. The default delegate (when the no- argument constructor is used) is this. Thus, in the next example, the delegate is the LockMixin subclass of DelegatingIntroductionInterceptor. Given a delegate (by default, itself), a DelegatingIntroductionInterceptor instance looks for all interfaces implemented by the delegate (other than IntroductionInterceptor) and supports introductions against any of them. Subclasses such as LockMixin can call the suppressInterface(Class intf) method to suppress interfaces that should not be exposed. However, no matter how many interfaces an IntroductionInterceptor is prepared to support, the IntroductionAdvisor used controls which interfaces are actually exposed. An introduced interface conceals any implementation of the same interface by the target. Thus, LockMixin extends DelegatingIntroductionInterceptor and implements Lockable itself. The superclass automatically picks up that Lockable can be supported for introduction, so we do not need to specify that.", "chunk_char_count": 1247, "chunk_word_count": 168, "chunk_token_count": 311.75}, {"page_number": 411, "sentence_chunk": "We could introduce any number of interfaces in this way. Note the use of the locked instance variable. This effectively adds additional state to that held in the target object. The following example shows the example LockMixin class: Java public class LockMixin extends DelegatingIntroductionInterceptor implements Lockable { \u00a0  private boolean locked; \u00a0  public void lock() { \u00a0    this.locked = true; \u00a0  } \u00a0  public void unlock() { \u00a0    this.locked = false; \u00a0  } \u00a0  public boolean locked() { \u00a0    return this.locked; \u00a0  } \u00a0  public Object invoke(MethodInvocation invocation) throws Throwable { \u00a0    if (locked() && invocation.getMethod().getName().indexOf(\"set\") == 0) { \u00a0      throw new LockedException(); \u00a0    } \u00a0    return super.invoke(invocation); \u00a0  } } 411", "chunk_char_count": 763, "chunk_word_count": 144, "chunk_token_count": 190.75}, {"page_number": 412, "sentence_chunk": "Kotlin class LockMixin : DelegatingIntroductionInterceptor(), Lockable { \u00a0  private var locked: Boolean = false \u00a0  fun lock() { \u00a0    this.locked = true \u00a0  } \u00a0  fun unlock() { \u00a0    this.locked = false \u00a0  } \u00a0  fun locked(): Boolean { \u00a0    return this.locked \u00a0  } \u00a0  override fun invoke(invocation: MethodInvocation): Any? {\u00a0    if (locked() && invocation.method.name.indexOf(\"set\") == 0) { \u00a0      throw LockedException() \u00a0    } \u00a0    return super.invoke(invocation) \u00a0  } } Often, you need not override the invoke() method. The DelegatingIntroductionInterceptor implementation (which calls the delegate method if the method is introduced, otherwise proceeds towards the join point) usually suffices. In the present case, we need to add a check: no setter method can be invoked if in locked mode. The required introduction only needs to hold a distinct LockMixin instance and specify the introduced interfaces (in this case, only Lockable). A more complex example might take a reference to the introduction interceptor (which would be defined as a prototype). In this case, there is no configuration relevant for a LockMixin, so we create it by using new. The following example shows our LockMixinAdvisor class: Java public class LockMixinAdvisor extends DefaultIntroductionAdvisor { \u00a0  public LockMixinAdvisor() { \u00a0    super(new LockMixin(), Lockable.class); \u00a0  } } 412", "chunk_char_count": 1365, "chunk_word_count": 239, "chunk_token_count": 341.25}, {"page_number": 413, "sentence_chunk": "Kotlin class LockMixinAdvisor : DefaultIntroductionAdvisor(LockMixin(), Lockable::class.java) We can apply this advisor very simply, because it requires no configuration. (However, it is impossible to use an IntroductionInterceptor without an IntroductionAdvisor.)As usual with introductions, the advisor must be per-instance, as it is stateful. We need a different instance of LockMixinAdvisor, and hence LockMixin, for each advised object. The advisor comprises part of the advised object\u2019s state. We can apply this advisor programmatically by using the Advised.addAdvisor() method or (the recommended way) in XML configuration, as any other advisor. All proxy creation choices discussed below, including \u201cauto proxy creators,\u201d correctly handle introductions and stateful mixins.2.6.3. The Advisor API in Spring In Spring, an Advisor is an aspect that contains only a single advice object associated with a pointcut expression. Apart from the special case of introductions, any advisor can be used with any advice.", "chunk_char_count": 1016, "chunk_word_count": 141, "chunk_token_count": 254.0}, {"page_number": 413, "sentence_chunk": "org.springframework.aop.support. DefaultPointcutAdvisor is the most commonly used advisor class. It can be used with a MethodInterceptor, BeforeAdvice, or ThrowsAdvice. It is possible to mix advisor and advice types in Spring in the same AOP proxy. For example, you could use an interception around advice, throws advice, and before advice in one proxy configuration. Spring automatically creates the necessary interceptor chain.2.6.4. Using the ProxyFactoryBean to Create AOP Proxies If you use the Spring IoC container (an ApplicationContext or BeanFactory) for your business objects (and you should be!),you want to use one of Spring\u2019s AOP FactoryBean implementations. (Remember that a factory bean introduces a layer of indirection, letting it create objects of a different type.)", "chunk_char_count": 784, "chunk_word_count": 113, "chunk_token_count": 196.0}, {"page_number": 413, "sentence_chunk": "\uf05a The Spring AOP support also uses factory beans under the covers. The basic way to create an AOP proxy in Spring is to use the org.springframework.aop.framework. ProxyFactoryBean. This gives complete control over the pointcuts, any advice that applies, and their ordering. However, there are simpler options that are preferable if you do not need such control. Basics The ProxyFactoryBean, like other Spring FactoryBean implementations, introduces a level of indirection. If you define a ProxyFactoryBean named foo, objects that reference foo do not see the ProxyFactoryBean instance itself but an object created by the implementation of the getObject() method in the ProxyFactoryBean . This method creates an AOP proxy that wraps a target object.413", "chunk_char_count": 751, "chunk_word_count": 114, "chunk_token_count": 187.75}, {"page_number": 414, "sentence_chunk": "One of the most important benefits of using a ProxyFactoryBean or another IoC-aware class to create AOP proxies is that advices and pointcuts can also be managed by IoC. This is a powerful feature, enabling certain approaches that are hard to achieve with other AOP frameworks. For example, an advice may itself reference application objects (besides the target, which should be available in any AOP framework), benefiting from all the pluggability provided by Dependency Injection. JavaBean Properties In common with most FactoryBean implementations provided with Spring, the ProxyFactoryBean class is itself a JavaBean. Its properties are used to: \u2022 Specify the target you want to proxy. \u2022Specify whether to use CGLIB (described later and see also JDK- and CGLIB-based proxies). Some key properties are inherited from org.springframework.aop.framework. ProxyConfig (the superclass for all AOP proxy factories in Spring). These key properties include the following: \u2022 proxyTargetClass: true if the target class is to be proxied, rather than the target class\u2019s interfaces. If this property value is set to true, then CGLIB proxies are created (but see also JDK- and CGLIB- based proxies). \u2022optimize: Controls whether or not aggressive optimizations are applied to proxies created through CGLIB.", "chunk_char_count": 1294, "chunk_word_count": 195, "chunk_token_count": 323.5}, {"page_number": 414, "sentence_chunk": "You should not blithely use this setting unless you fully understand how the relevant AOP proxy handles optimization. This is currently used only for CGLIB proxies. It has no effect with JDK dynamic proxies. \u2022frozen: If a proxy configuration is frozen, changes to the configuration are no longer allowed. This is useful both as a slight optimization and for those cases when you do not want callers to be able to manipulate the proxy (through the Advised interface) after the proxy has been created. The default value of this property is false, so changes (such as adding additional advice) are allowed. \u2022exposeProxy: Determines whether or not the current proxy should be exposed in a ThreadLocal so that it can be accessed by the target. If a target needs to obtain the proxy and the exposeProxy property is set to true, the target can use the AopContext.currentProxy() method. Other properties specific to ProxyFactoryBean include the following: \u2022 proxyInterfaces: An array of String interface names. If this is not supplied, a CGLIB proxy for the target class is used (but see also JDK- and CGLIB-based proxies). \u2022", "chunk_char_count": 1117, "chunk_word_count": 185, "chunk_token_count": 279.25}, {"page_number": 414, "sentence_chunk": "interceptorNames: A String array of Advisor, interceptor, or other advice names to apply. Ordering is significant, on a first come-first served basis. That is to say that the first interceptor in the list is the first to be able to intercept the invocation. The names are bean names in the current factory, including bean names from ancestor factories. You cannot mention bean references here, since doing so results in the ProxyFactoryBean ignoring the singleton setting of the advice. You can append an interceptor name with an asterisk (*). Doing so results in the application of all advisor beans with names that start with the part before the asterisk to be applied. You can find an example of using this feature in Using \u201cGlobal\u201d Advisors.414", "chunk_char_count": 748, "chunk_word_count": 124, "chunk_token_count": 187.0}, {"page_number": 415, "sentence_chunk": "\u2022 singleton: Whether or not the factory should return a single object, no matter how often the getObject() method is called. Several FactoryBean implementations offer such a method. The default value is true. If you want to use stateful advice - for example, for stateful mixins - use prototype advices along with a singleton value of false. JDK- and CGLIB-based proxies This section serves as the definitive documentation on how the ProxyFactoryBean chooses to create either a JDK-based proxy or a CGLIB-based proxy for a particular target object (which is to be proxied).\uf05a The behavior of the ProxyFactoryBean with regard to creating JDK- or CGLIB-based proxies changed between versions 1.2.x and 2.0 of Spring. The ProxyFactoryBean now exhibits similar semantics with regard to auto-detecting interfaces as those of the TransactionProxyFactoryBean class. If the class of a target object that is to be proxied (hereafter simply referred to as the target class) does not implement any interfaces, a CGLIB-based proxy is created. This is the easiest scenario, because JDK proxies are interface-based, and no interfaces means JDK proxying is not even possible. You can plug in the target bean and specify the list of interceptors by setting the interceptorNames property.", "chunk_char_count": 1270, "chunk_word_count": 199, "chunk_token_count": 317.5}, {"page_number": 415, "sentence_chunk": "Note that a CGLIB-based proxy is created even if the proxyTargetClass property of the ProxyFactoryBean has been set to false. (Doing so makes no sense and is best removed from the bean definition, because it is, at best, redundant, and, at worst confusing.)If the target class implements one (or more) interfaces, the type of proxy that is created depends on the configuration of the ProxyFactoryBean. If the proxyTargetClass property of the ProxyFactoryBean has been set to true, a CGLIB-based proxy is created. This makes sense and is in keeping with the principle of least surprise. Even if the proxyInterfaces property of the ProxyFactoryBean has been set to one or more fully qualified interface names, the fact that the proxyTargetClass property is set to true causes CGLIB-based proxying to be in effect. If the proxyInterfaces property of the ProxyFactoryBean has been set to one or more fully qualified interface names, a JDK-based proxy is created. The created proxy implements all of the interfaces that were specified in the proxyInterfaces property. If the target class happens to implement a whole lot more interfaces than those specified in the proxyInterfaces property, that is all well and good, but those additional interfaces are not implemented by the returned proxy. If the proxyInterfaces property of the ProxyFactoryBean has not been set, but the target class does implement one (or more) interfaces, the ProxyFactoryBean auto-detects the fact that the target class does actually implement at least one interface, and a JDK-based proxy is created.", "chunk_char_count": 1570, "chunk_word_count": 248, "chunk_token_count": 392.5}, {"page_number": 415, "sentence_chunk": "The interfaces that are actually proxied are all of the interfaces that the target class implements. In effect, this is the same as supplying a list of each and every interface that the target class implements to the proxyInterfaces property. However, it is significantly less work and less prone to typographical errors.415", "chunk_char_count": 324, "chunk_word_count": 52, "chunk_token_count": 81.0}, {"page_number": 416, "sentence_chunk": "Proxying Interfaces Consider a simple example of ProxyFactoryBean in action. This example involves: \u2022 A target bean that is proxied. This is the personTarget bean definition in the example. \u2022An Advisor and an Interceptor used to provide advice. \u2022An AOP proxy bean definition to specify the target object (the personTarget bean), the interfaces to proxy, and the advices to apply. The following listing shows the example: <bean id=\"personTarget\" class=\"com.mycompany. PersonImpl\"> \u00a0  <property name=\"name\" value=\"Tony\"/> \u00a0  <property name=\"age\" value=\"51\"/> </bean> <bean id=\"myAdvisor\" class=\"com.mycompany. MyAdvisor\"> \u00a0  <property name=\"someProperty\" value=\"Custom string property value\"/> </bean> <bean id=\"debugInterceptor\" class=\"org.springframework.aop.interceptor. DebugInterceptor\"> </bean> <bean id=\"person\" \u00a0  class=\"org.springframework.aop.framework. ProxyFactoryBean\"> \u00a0  <property name=\"proxyInterfaces\" value=\"com.mycompany.", "chunk_char_count": 938, "chunk_word_count": 110, "chunk_token_count": 234.5}, {"page_number": 416, "sentence_chunk": "Person\"/> \u00a0  <property name=\"target\" ref=\"personTarget\"/> \u00a0  <property name=\"interceptorNames\"> \u00a0    <list> \u00a0      <value>myAdvisor</value> \u00a0      <value>debugInterceptor</value> \u00a0    </list> \u00a0  </property> </bean> Note that the interceptorNames property takes a list of String, which holds the bean names of the interceptors or advisors in the current factory. You can use advisors, interceptors, before, after returning, and throws advice objects. The ordering of advisors is significant.\uf05a You might be wondering why the list does not hold bean references. The reason for this is that, if the singleton property of the ProxyFactoryBean is set to false, it must be able to return independent proxy instances. If any of the advisors is itself a prototype, an independent instance would need to be returned, so it is necessary to be able to obtain an instance of the prototype from the factory. Holding a reference is not sufficient.416", "chunk_char_count": 935, "chunk_word_count": 158, "chunk_token_count": 233.75}, {"page_number": 417, "sentence_chunk": "The person bean definition shown earlier can be used in place of a Person implementation, as follows: Java Person person = (Person) factory.getBean(\"person\"); Kotlin val person = factory.getBean(\"person\") as Person; Other beans in the same IoC context can express a strongly typed dependency on it, as with an ordinary Java object. The following example shows how to do so: <bean id=\"personUser\" class=\"com.mycompany. PersonUser\"> \u00a0  <property name=\"person\"><ref bean=\"person\"/></property> </bean> The PersonUser class in this example exposes a property of type Person. As far as it is concerned, the AOP proxy can be used transparently in place of a \u201creal\u201d person implementation. However, its class would be a dynamic proxy class. It would be possible to cast it to the Advised interface (discussed later). You can conceal the distinction between target and proxy by using an anonymous inner bean. Only the ProxyFactoryBean definition is different. The advice is included only for completeness. The following example shows how to use an anonymous inner bean: 417", "chunk_char_count": 1063, "chunk_word_count": 163, "chunk_token_count": 265.75}, {"page_number": 418, "sentence_chunk": "<bean id=\"myAdvisor\" class=\"com.mycompany. MyAdvisor\"> \u00a0  <property name=\"someProperty\" value=\"Custom string property value\"/> </bean> <bean id=\"debugInterceptor\" class=\"org.springframework.aop.interceptor. DebugInterceptor\"/> <bean id=\"person\" class=\"org.springframework.aop.framework. ProxyFactoryBean\"> \u00a0  <property name=\"proxyInterfaces\" value=\"com.mycompany. Person\"/> \u00a0  <!--Use inner bean, not local reference to target --> \u00a0  <property name=\"target\"> \u00a0    <bean class=\"com.mycompany. PersonImpl\"> \u00a0      <property name=\"name\" value=\"Tony\"/> \u00a0      <property name=\"age\" value=\"51\"/> \u00a0    </bean> \u00a0  </property> \u00a0  <property name=\"interceptorNames\"> \u00a0    <list> \u00a0      <value>myAdvisor</value> \u00a0      <value>debugInterceptor</value> \u00a0    </list> \u00a0  </property> </bean> Using an anonymous inner bean has the advantage that there is only one object of type Person. This is useful if we want to prevent users of the application context from obtaining a reference to the un-advised object or need to avoid any ambiguity with Spring IoC autowiring. There is also, arguably, an advantage in that the ProxyFactoryBean definition is self-contained. However, there are times when being able to obtain the un-advised target from the factory might actually be an advantage (for example, in certain test scenarios).", "chunk_char_count": 1309, "chunk_word_count": 194, "chunk_token_count": 327.25}, {"page_number": 418, "sentence_chunk": "Proxying Classes What if you need to proxy a class, rather than one or more interfaces?Imagine that in our earlier example, there was no Person interface. We needed to advise a class called Person that did not implement any business interface. In this case, you can configure Spring to use CGLIB proxying rather than dynamic proxies. To do so, set the proxyTargetClass property on the ProxyFactoryBean shown earlier to true. While it is best to program to interfaces rather than classes, the ability to advise classes that do not implement interfaces can be useful when working with legacy code. (In general, Spring is not prescriptive. While it makes it easy to apply good practices, it avoids forcing a particular approach.)If you want to, you can force the use of CGLIB in any case, even if you do have interfaces. CGLIB proxying works by generating a subclass of the target class at runtime.", "chunk_char_count": 895, "chunk_word_count": 152, "chunk_token_count": 223.75}, {"page_number": 418, "sentence_chunk": "Spring configures this generated subclass to delegate method calls to the original target. The subclass is used to implement the Decorator pattern, weaving in the advice.418", "chunk_char_count": 173, "chunk_word_count": 26, "chunk_token_count": 43.25}, {"page_number": 419, "sentence_chunk": "CGLIB proxying should generally be transparent to users. However, there are some issues to consider: \u2022 Final methods cannot be advised, as they cannot be overridden. \u2022There is no need to add CGLIB to your classpath. As of Spring 3.2, CGLIB is repackaged and included in the spring-core JAR. In other words, CGLIB-based AOP works \u201cout of the box\u201d, as do JDK dynamic proxies. There is little performance difference between CGLIB proxying and dynamic proxies. Performance should not be a decisive consideration in this case. Using \u201cGlobal\u201d Advisors By appending an asterisk to an interceptor name, all advisors with bean names that match the part before the asterisk are added to the advisor chain. This can come in handy if you need to add a standard set of \u201cglobal\u201d advisors. The following example defines two global advisors: <bean id=\"proxy\" class=\"org.springframework.aop.framework.", "chunk_char_count": 884, "chunk_word_count": 140, "chunk_token_count": 221.0}, {"page_number": 419, "sentence_chunk": "ProxyFactoryBean\"> \u00a0  <property name=\"target\" ref=\"service\"/> \u00a0  <property name=\"interceptorNames\"> \u00a0    <list> \u00a0      <value>global*</value> \u00a0    </list> \u00a0  </property> </bean> <bean id=\"global_debug\" class=\"org.springframework.aop.interceptor. DebugInterceptor\"/> <bean id=\"global_performance\" class=\"org.springframework.aop.interceptor. PerformanceMonitorInterceptor\"/> 2.6.5. Concise Proxy Definitions Especially when defining transactional proxies, you may end up with many similar proxy definitions. The use of parent and child bean definitions, along with inner bean definitions, can result in much cleaner and more concise proxy definitions. First, we create a parent, template, bean definition for the proxy, as follows: <bean id=\"txProxyTemplate\" abstract=\"true\" \u00a0 class=\"org.springframework.transaction.interceptor. TransactionProxyFactoryBean\"> \u00a0  <property name=\"transactionManager\" ref=\"transactionManager\"/> \u00a0  <property name=\"transactionAttributes\"> \u00a0    <props> \u00a0      <prop key=\"*\">PROPAGATION_REQUIRED</prop> \u00a0    </props> \u00a0  </property> </bean> 419", "chunk_char_count": 1068, "chunk_word_count": 131, "chunk_token_count": 267.0}, {"page_number": 420, "sentence_chunk": "This is never instantiated itself, so it can actually be incomplete. Then, each proxy that needs to be created is a child bean definition, which wraps the target of the proxy as an inner bean definition, since the target is never used on its own anyway. The following example shows such a child bean: <bean id=\"myService\" parent=\"txProxyTemplate\"> \u00a0  <property name=\"target\"> \u00a0    <bean class=\"org.springframework.samples. MyServiceImpl\"> \u00a0    </bean> \u00a0  </property> </bean> You can override properties from the parent template. In the following example, we override the transaction propagation settings: <bean id=\"mySpecialService\" parent=\"txProxyTemplate\"> \u00a0  <property name=\"target\"> \u00a0    <bean class=\"org.springframework.samples. MySpecialServiceImpl\"> \u00a0    </bean> \u00a0  </property> \u00a0  <property name=\"transactionAttributes\"> \u00a0    <props> \u00a0      <prop key=\"get*\">PROPAGATION_REQUIRED,readOnly</prop> \u00a0      <prop key=\"find*\">PROPAGATION_REQUIRED,readOnly</prop> \u00a0      <prop key=\"load*\">PROPAGATION_REQUIRED,readOnly</prop> \u00a0      <prop key=\"store*\">PROPAGATION_REQUIRED</prop> \u00a0    </props> \u00a0  </property> </bean> Note that in the parent bean example, we explicitly marked the parent bean definition as being abstract by setting the abstract attribute to true, as described previously, so that it may not actually ever be instantiated. Application contexts (but not simple bean factories), by default, pre-instantiate all singletons. Therefore, it is important (at least for singleton beans) that, if you have a (parent) bean definition that you intend to use only as a template, and this definition specifies a class, you must make sure to set the abstract attribute to true. Otherwise, the application context actually tries to pre-instantiate it.2.6.6.", "chunk_char_count": 1758, "chunk_word_count": 267, "chunk_token_count": 439.5}, {"page_number": 420, "sentence_chunk": "Creating AOP Proxies Programmatically with the ProxyFactory It is easy to create AOP proxies programmatically with Spring. This lets you use Spring AOP without dependency on Spring IoC. The interfaces implemented by the target object are automatically proxied. The following listing shows creation of a proxy for a target object, with one interceptor and one advisor: 420", "chunk_char_count": 371, "chunk_word_count": 57, "chunk_token_count": 92.75}, {"page_number": 421, "sentence_chunk": "Java ProxyFactory factory = new ProxyFactory(myBusinessInterfaceImpl); factory.addAdvice(myMethodInterceptor); factory.addAdvisor(myAdvisor); MyBusinessInterface tb = (MyBusinessInterface) factory.getProxy(); Kotlin val factory = ProxyFactory(myBusinessInterfaceImpl) factory.addAdvice(myMethodInterceptor) factory.addAdvisor(myAdvisor) val tb = factory.proxy as MyBusinessInterface The first step is to construct an object of type org.springframework.aop.framework. ProxyFactory. You can create this with a target object, as in the preceding example, or specify the interfaces to be proxied in an alternate constructor. You can add advices (with interceptors as a specialized kind of advice), advisors, or both and manipulate them for the life of the ProxyFactory. If you add an IntroductionInterceptionAroundAdvisor, you can cause the proxy to implement additional interfaces. There are also convenience methods on ProxyFactory (inherited from AdvisedSupport) that let you add other advice types, such as before and throws advice. AdvisedSupport is the superclass of both ProxyFactory and ProxyFactoryBean.\uf0eb Integrating AOP proxy creation with the IoC framework is best practice in most applications. We recommend that you externalize configuration from Java code with AOP, as you should in general.2.6.7.", "chunk_char_count": 1307, "chunk_word_count": 162, "chunk_token_count": 326.75}, {"page_number": 421, "sentence_chunk": "Manipulating Advised Objects However you create AOP proxies, you can manipulate them BY using the org.springframework.aop.framework. Advised interface. Any AOP proxy can be cast to this interface, no matter which other interfaces it implements. This interface includes the following methods: 421", "chunk_char_count": 295, "chunk_word_count": 41, "chunk_token_count": 73.75}, {"page_number": 422, "sentence_chunk": "Java Advisor[] getAdvisors(); void addAdvice(Advice advice) throws AopConfigException; void addAdvice(int pos, Advice advice) throws AopConfigException; void addAdvisor(Advisor advisor) throws AopConfigException; void addAdvisor(int pos, Advisor advisor) throws AopConfigException; int indexOf(Advisor advisor); boolean removeAdvisor(Advisor advisor) throws AopConfigException; void removeAdvisor(int index) throws AopConfigException; boolean replaceAdvisor(Advisor a, Advisor b) throws AopConfigException; boolean isFrozen(); Kotlin fun getAdvisors(): Array<Advisor> @Throws(AopConfigException::class) fun addAdvice(advice: Advice) @Throws(AopConfigException::class) fun addAdvice(pos: Int, advice: Advice) @Throws(AopConfigException::class) fun addAdvisor(advisor: Advisor) @Throws(AopConfigException::class) fun addAdvisor(pos: Int, advisor: Advisor) fun indexOf(advisor: Advisor): Int @Throws(AopConfigException::class) fun removeAdvisor(advisor: Advisor): Boolean @Throws(AopConfigException::class) fun removeAdvisor(index: Int) @Throws(AopConfigException::class) fun replaceAdvisor(a: Advisor, b: Advisor): Boolean fun isFrozen(): Boolean 422", "chunk_char_count": 1148, "chunk_word_count": 97, "chunk_token_count": 287.0}, {"page_number": 423, "sentence_chunk": "The getAdvisors() method returns an Advisor for every advisor, interceptor, or other advice type that has been added to the factory. If you added an Advisor, the returned advisor at this index is the object that you added. If you added an interceptor or other advice type, Spring wrapped this in an advisor with a pointcut that always returns true. Thus, if you added a MethodInterceptor, the advisor returned for this index is a DefaultPointcutAdvisor that returns your MethodInterceptor and a pointcut that matches all classes and methods. The addAdvisor() methods can be used to add any Advisor. Usually, the advisor holding pointcut and advice is the generic DefaultPointcutAdvisor, which you can use with any advice or pointcut (but not for introductions). By default, it is possible to add or remove advisors or interceptors even once a proxy has been created. The only restriction is that it is impossible to add or remove an introduction advisor, as existing proxies from the factory do not show the interface change. (You can obtain a new proxy from the factory to avoid this problem.)The following example shows casting an AOP proxy to the Advised interface and examining and manipulating its advice: Java Advised advised = (Advised) myObject; Advisor[] advisors = advised.getAdvisors(); int oldAdvisorCount = advisors.length; System.out.println(oldAdvisorCount + \" advisors\"); // Add an advice like an interceptor without a pointcut // Will match all proxied methods // Can use for interceptors, before, after returning or throws advice advised.addAdvice(new DebugInterceptor()); // Add selective advice using a pointcut advised.addAdvisor(new DefaultPointcutAdvisor(mySpecialPointcut, myAdvice)); assertEquals(\"Added two advisors\", oldAdvisorCount + 2, advised.getAdvisors().length); 423", "chunk_char_count": 1799, "chunk_word_count": 263, "chunk_token_count": 449.75}, {"page_number": 424, "sentence_chunk": "Kotlin val advised = myObject as Advised val advisors = advised.advisors val oldAdvisorCount = advisors.size println(\"$oldAdvisorCount advisors\") // Add an advice like an interceptor without a pointcut // Will match all proxied methods // Can use for interceptors, before, after returning or throws advice advised.addAdvice(DebugInterceptor()) // Add selective advice using a pointcut advised.addAdvisor(DefaultPointcutAdvisor(mySpecialPointcut, myAdvice)) assertEquals(\"Added two advisors\", oldAdvisorCount + 2, advised.advisors.size) \uf05a It is questionable whether it is advisable (no pun intended) to modify advice on a business object in production, although there are, no doubt, legitimate usage cases. However, it can be very useful in development (for example, in tests). We have sometimes found it very useful to be able to add test code in the form of an interceptor or other advice, getting inside a method invocation that we want to test. (For example, the advice can get inside a transaction created for that method, perhaps to run SQL to check that a database was correctly updated, before marking the transaction for roll back.)Depending on how you created the proxy, you can usually set a frozen flag. In that case, the Advised isFrozen() method returns true, and any attempts to modify advice through addition or removal results in an AopConfigException. The ability to freeze the state of an advised object is useful in some cases (for example, to prevent calling code removing a security interceptor).2.6.8. Using the \"auto-proxy\" facility So far, we have considered explicit creation of AOP proxies by using a ProxyFactoryBean or similar factory bean. Spring also lets us use \u201cauto-proxy\u201d bean definitions, which can automatically proxy selected bean definitions.", "chunk_char_count": 1780, "chunk_word_count": 264, "chunk_token_count": 445.0}, {"page_number": 424, "sentence_chunk": "This is built on Spring\u2019s \u201cbean post processor\u201d infrastructure, which enables modification of any bean definition as the container loads. In this model, you set up some special bean definitions in your XML bean definition file to configure the auto-proxy infrastructure. This lets you declare the targets eligible for auto-proxying. You need not use ProxyFactoryBean. There are two ways to do this: \u2022 By using an auto-proxy creator that refers to specific beans in the current context. \u2022A special case of auto-proxy creation that deserves to be considered separately: auto-proxy creation driven by source-level metadata attributes.424", "chunk_char_count": 634, "chunk_word_count": 96, "chunk_token_count": 158.5}, {"page_number": 425, "sentence_chunk": "Auto-proxy Bean Definitions This section covers the auto-proxy creators provided by the org.springframework.aop.framework.autoproxy package. BeanNameAutoProxyCreator The BeanNameAutoProxyCreator class is a BeanPostProcessor that automatically creates AOP proxies for beans with names that match literal values or wildcards. The following example shows how to create a BeanNameAutoProxyCreator bean: <bean class=\"org.springframework.aop.framework.autoproxy. BeanNameAutoProxyCreator\"> \u00a0  <property name=\"beanNames\" value=\"jdk*,onlyJdk\"/> \u00a0  <property name=\"interceptorNames\"> \u00a0    <list> \u00a0      <value>myInterceptor</value> \u00a0    </list> \u00a0  </property> </bean> As with ProxyFactoryBean, there is an interceptorNames property rather than a list of interceptors, to allow correct behavior for prototype advisors. Named \u201cinterceptors\u201d can be advisors or any advice type. As with auto-proxying in general, the main point of using BeanNameAutoProxyCreator is to apply the same configuration consistently to multiple objects, with minimal volume of configuration. It is a popular choice for applying declarative transactions to multiple objects. Bean definitions whose names match, such as jdkMyBean and onlyJdk in the preceding example, are plain old bean definitions with the target class. An AOP proxy is automatically created by the BeanNameAutoProxyCreator. The same advice is applied to all matching beans.", "chunk_char_count": 1404, "chunk_word_count": 188, "chunk_token_count": 351.0}, {"page_number": 425, "sentence_chunk": "Note that, if advisors are used (rather than the interceptor in the preceding example), the pointcuts may apply differently to different beans. DefaultAdvisorAutoProxyCreator A more general and extremely powerful auto-proxy creator is DefaultAdvisorAutoProxyCreator. This automagically applies eligible advisors in the current context, without the need to include specific bean names in the auto-proxy advisor\u2019s bean definition. It offers the same merit of consistent configuration and avoidance of duplication as BeanNameAutoProxyCreator. Using this mechanism involves: \u2022 Specifying a DefaultAdvisorAutoProxyCreator bean definition. \u2022Specifying any number of advisors in the same or related contexts. Note that these must be advisors, not interceptors or other advices. This is necessary, because there must be a pointcut to evaluate, to check the eligibility of each advice to candidate bean definitions. The DefaultAdvisorAutoProxyCreator automatically evaluates the pointcut contained in each advisor, to see what (if any) advice it should apply to each business object (such as businessObject1 and 425", "chunk_char_count": 1106, "chunk_word_count": 152, "chunk_token_count": 276.5}, {"page_number": 426, "sentence_chunk": "businessObject2 in the example). This means that any number of advisors can be applied automatically to each business object. If no pointcut in any of the advisors matches any method in a business object, the object is not proxied. As bean definitions are added for new business objects, they are automatically proxied if necessary. Auto-proxying in general has the advantage of making it impossible for callers or dependencies to obtain an un-advised object. Calling getBean(\"businessObject1\") on this ApplicationContext returns an AOP proxy, not the target business object. (The \u201cinner bean\u201d idiom shown earlier also offers this benefit.)The following example creates a DefaultAdvisorAutoProxyCreator bean and the other elements discussed in this section: <bean class=\"org.springframework.aop.framework.autoproxy. DefaultAdvisorAutoProxyCreator\"/> <bean class=\"org.springframework.transaction.interceptor. TransactionAttributeSourceAdvisor\"> \u00a0  <property name=\"transactionInterceptor\" ref=\"transactionInterceptor\"/> </bean> <bean id=\"customAdvisor\" class=\"com.mycompany.", "chunk_char_count": 1072, "chunk_word_count": 126, "chunk_token_count": 268.0}, {"page_number": 426, "sentence_chunk": "MyAdvisor\"/> <bean id=\"businessObject1\" class=\"com.mycompany. BusinessObject1\"> \u00a0  <!--Properties omitted --> </bean> <bean id=\"businessObject2\" class=\"com.mycompany. BusinessObject2\"/> The DefaultAdvisorAutoProxyCreator is very useful if you want to apply the same advice consistently to many business objects. Once the infrastructure definitions are in place, you can add new business objects without including specific proxy configuration. You can also easily drop in additional aspects (for example, tracing or performance monitoring aspects) with minimal change to configuration. The DefaultAdvisorAutoProxyCreator offers support for filtering (by using a naming convention so that only certain advisors are evaluated, which allows the use of multiple, differently configured, AdvisorAutoProxyCreators in the same factory) and ordering. Advisors can implement the org.springframework.core. Ordered interface to ensure correct ordering if this is an issue. The TransactionAttributeSourceAdvisor used in the preceding example has a configurable order value.", "chunk_char_count": 1060, "chunk_word_count": 132, "chunk_token_count": 265.0}, {"page_number": 426, "sentence_chunk": "The default setting is unordered.2.6.9. Using TargetSource Implementations Spring offers the concept of a TargetSource, expressed in the org.springframework.aop. TargetSource interface. This interface is responsible for returning the \u201ctarget object\u201d that implements the join point. The TargetSource implementation is asked for a target instance each time the AOP proxy handles a method invocation.426", "chunk_char_count": 400, "chunk_word_count": 53, "chunk_token_count": 100.0}, {"page_number": 427, "sentence_chunk": "Developers who use Spring AOP do not normally need to work directly with TargetSource implementations, but this provides a powerful means of supporting pooling, hot swappable, and other sophisticated targets. For example, a pooling TargetSource can return a different target instance for each invocation, by using a pool to manage instances. If you do not specify a TargetSource, a default implementation is used to wrap a local object. The same target is returned for each invocation (as you would expect). The rest of this section describes the standard target sources provided with Spring and how you can use them.\uf0eb When using a custom target source, your target will usually need to be a prototype rather than a singleton bean definition. This allows Spring to create a new target instance when required. Hot-swappable Target Sources The org.springframework.aop.target. HotSwappableTargetSource exists to let the target of an AOP proxy be switched while letting callers keep their references to it. Changing the target source\u2019s target takes effect immediately.", "chunk_char_count": 1064, "chunk_word_count": 164, "chunk_token_count": 266.0}, {"page_number": 427, "sentence_chunk": "The HotSwappableTargetSource is thread-safe. You can change the target by using the swap() method on HotSwappableTargetSource, as the follow example shows: Java HotSwappableTargetSource swapper = (HotSwappableTargetSource) beanFactory.getBean(\"swapper\"); Object oldTarget = swapper.swap(newTarget); Kotlin val swapper = beanFactory.getBean(\"swapper\") as HotSwappableTargetSource val oldTarget = swapper.swap(newTarget) The following example shows the required XML definitions: <bean id=\"initialTarget\" class=\"mycompany. OldTarget\"/> <bean id=\"swapper\" class=\"org.springframework.aop.target. HotSwappableTargetSource\"> \u00a0  <constructor-arg ref=\"initialTarget\"/> </bean> <bean id=\"swappable\" class=\"org.springframework.aop.framework. ProxyFactoryBean\"> \u00a0  <property name=\"targetSource\" ref=\"swapper\"/> </bean> 427", "chunk_char_count": 810, "chunk_word_count": 74, "chunk_token_count": 202.5}, {"page_number": 428, "sentence_chunk": "The preceding swap() call changes the target of the swappable bean. Clients that hold a reference to that bean are unaware of the change but immediately start hitting the new target. Although this example does not add any advice (it is not necessary to add advice to use a TargetSource), any TargetSource can be used in conjunction with arbitrary advice. Pooling Target Sources Using a pooling target source provides a similar programming model to stateless session EJBs, in which a pool of identical instances is maintained, with method invocations going to free objects in the pool. A crucial difference between Spring pooling and SLSB pooling is that Spring pooling can be applied to any POJO. As with Spring in general, this service can be applied in a non-invasive way. Spring provides support for Commons Pool 2.2, which provides a fairly efficient pooling implementation. You need the commons-pool Jar on your application\u2019s classpath to use this feature. You can also subclass org.springframework.aop.target. AbstractPoolingTargetSource to support any other pooling API.", "chunk_char_count": 1077, "chunk_word_count": 168, "chunk_token_count": 269.25}, {"page_number": 428, "sentence_chunk": "\uf05a Commons Pool 1.5+ is also supported but is deprecated as of Spring Framework 4.2. The following listing shows an example configuration: <bean id=\"businessObjectTarget\" class=\"com.mycompany. MyBusinessObject\" \u00a0    scope=\"prototype\"> \u00a0  ... properties omitted </bean> <bean id=\"poolTargetSource\" class=\"org.springframework.aop.target. CommonsPool2TargetSource\"> \u00a0  <property name=\"targetBeanName\" value=\"businessObjectTarget\"/> \u00a0  <property name=\"maxSize\" value=\"25\"/> </bean> <bean id=\"businessObject\" class=\"org.springframework.aop.framework. ProxyFactoryBean\"> \u00a0  <property name=\"targetSource\" ref=\"poolTargetSource\"/> \u00a0  <property name=\"interceptorNames\" value=\"myInterceptor\"/> </bean> Note that the target object (businessObjectTarget in the preceding example) must be a prototype. This lets the PoolingTargetSource implementation create new instances of the target to grow the pool as necessary. See the javadoc of AbstractPoolingTargetSource and the concrete subclass you wish to use for information about its properties.maxSize is the most basic and is always guaranteed to be present. In this case, myInterceptor is the name of an interceptor that would need to be defined in the same IoC context. However, you need not specify interceptors to use pooling.", "chunk_char_count": 1266, "chunk_word_count": 157, "chunk_token_count": 316.5}, {"page_number": 429, "sentence_chunk": "and no other advice, do not set the interceptorNames property at all. You can configure Spring to be able to cast any pooled object to the org.springframework.aop.target. PoolingConfig interface, which exposes information about the configuration and current size of the pool through an introduction. You need to define an advisor similar to the following: <bean id=\"poolConfigAdvisor\" class=\"org.springframework.beans.factory.config. MethodInvokingFactoryBean\"> \u00a0  <property name=\"targetObject\" ref=\"poolTargetSource\"/> \u00a0  <property name=\"targetMethod\" value=\"getPoolingConfigMixin\"/> </bean> This advisor is obtained by calling a convenience method on the AbstractPoolingTargetSource class, hence the use of MethodInvokingFactoryBean. This advisor\u2019s name (poolConfigAdvisor, here) must be in the list of interceptors names in the ProxyFactoryBean that exposes the pooled object. The cast is defined as follows: Java PoolingConfig conf = (PoolingConfig) beanFactory.getBean(\"businessObject\"); System.out.println(\"Max pool size is \" + conf.getMaxSize()); Kotlin val conf = beanFactory.getBean(\"businessObject\") as PoolingConfig println(\"Max pool size is \" + conf.maxSize) \uf05a Pooling stateless service objects is not usually necessary. We do not believe it should be the default choice, as most stateless objects are naturally thread safe, and instance pooling is problematic if resources are cached. Simpler pooling is available by using auto-proxying. You can set the TargetSource implementations used by any auto-proxy creator.", "chunk_char_count": 1527, "chunk_word_count": 195, "chunk_token_count": 381.75}, {"page_number": 429, "sentence_chunk": "Prototype Target Sources Setting up a \u201cprototype\u201d target source is similar to setting up a pooling TargetSource. In this case, a new instance of the target is created on every method invocation. Although the cost of creating a new object is not high in a modern JVM, the cost of wiring up the new object (satisfying its IoC dependencies) may be more expensive. Thus, you should not use this approach without very good reason. To do this, you could modify the poolTargetSource definition shown earlier as follows (we also changed the name, for clarity): 429", "chunk_char_count": 556, "chunk_word_count": 95, "chunk_token_count": 139.0}, {"page_number": 430, "sentence_chunk": "<bean id=\"prototypeTargetSource\" class=\"org.springframework.aop.target. PrototypeTargetSource\"> \u00a0  <property name=\"targetBeanName\" ref=\"businessObjectTarget\"/> </bean> The only property is the name of the target bean. Inheritance is used in the TargetSource implementations to ensure consistent naming. As with the pooling target source, the target bean must be a prototype bean definition. ThreadLocal Target Sources ThreadLocal target sources are useful if you need an object to be created for each incoming request (per thread that is). The concept of a ThreadLocal provides a JDK-wide facility to transparently store a resource alongside a thread. Setting up a ThreadLocalTargetSource is pretty much the same as was explained for the other types of target source, as the following example shows: <bean id=\"threadlocalTargetSource\" class=\"org.springframework.aop.target. ThreadLocalTargetSource\"> \u00a0  <property name=\"targetBeanName\" value=\"businessObjectTarget\"/> </bean> \uf05a ThreadLocal instances come with serious issues (potentially resulting in memory leaks) when incorrectly using them in multi-threaded and multi-classloader environments. You should always consider wrapping a threadlocal in some other class and never directly use the ThreadLocal itself (except in the wrapper class). Also, you should always remember to correctly set and unset (where the latter simply involves a call to ThreadLocal.set(null)) the resource local to the thread.", "chunk_char_count": 1452, "chunk_word_count": 190, "chunk_token_count": 363.0}, {"page_number": 430, "sentence_chunk": "Unsetting should be done in any case, since not unsetting it might result in problematic behavior. Spring\u2019s ThreadLocal support does this for you and should always be considered in favor of using ThreadLocal instances without other proper handling code.2.6.10. Defining New Advice Types Spring AOP is designed to be extensible. While the interception implementation strategy is presently used internally, it is possible to support arbitrary advice types in addition to the interception around advice, before, throws advice, and after returning advice. The org.springframework.aop.framework.adapter package is an SPI package that lets support for new custom advice types be added without changing the core framework. The only constraint on a custom Advice type is that it must implement the org.aopalliance.aop. Advice marker interface. See the org.springframework.aop.framework.adapter javadoc for further information.430", "chunk_char_count": 921, "chunk_word_count": 128, "chunk_token_count": 230.25}, {"page_number": 431, "sentence_chunk": "2.7. Null-safety Although Java does not let you express null-safety with its type system, the Spring Framework now provides the following annotations in the org.springframework.lang package to let you declare nullability of APIs and fields: \u2022 @Nullable: Annotation to indicate that a specific parameter, return value, or field can be null. \u2022@NonNull: Annotation to indicate that a specific parameter, return value, or field cannot be null (not needed on parameters / return values and fields where @NonNullApi and @NonNullFields apply, respectively). \u2022@NonNullApi: Annotation at the package level that declares non-null as the default semantics for parameters and return values. \u2022@NonNullFields: Annotation at the package level that declares non-null as the default semantics for fields. The Spring Framework itself leverages these annotations, but they can also be used in any Spring- based Java project to declare null-safe APIs and optionally null-safe fields. Generic type arguments, varargs and array elements nullability are not supported yet but should be in an upcoming release, see SPR-15942 for up-to-date information. Nullability declarations are expected to be fine-tuned between Spring Framework releases, including minor ones. Nullability of types used inside method bodies is outside of the scope of this feature.\uf05a Other common libraries such as Reactor and Spring Data provide null-safe APIs that use a similar nullability arrangement, delivering a consistent overall experience for Spring application developers.", "chunk_char_count": 1529, "chunk_word_count": 221, "chunk_token_count": 382.25}, {"page_number": 431, "sentence_chunk": "2.7.1. Use cases In addition to providing an explicit declaration for Spring Framework API nullability, these annotations can be used by an IDE (such as IDEA or Eclipse) to provide useful warnings related to null-safety in order to avoid NullPointerException at runtime. They are also used to make Spring API null-safe in Kotlin projects, since Kotlin natively supports null-safety. More details are available in the Kotlin support documentation.2.7.2. JSR-305 meta-annotations Spring annotations are meta-annotated with JSR 305 annotations (a dormant but wide-spread JSR). JSR-305 meta-annotations let tooling vendors like IDEA or Kotlin provide null-safety support in a generic way, without having to hard-code support for Spring annotations. It is not necessary nor recommended to add a JSR-305 dependency to the project classpath to take advantage of Spring null-safe API. Only projects such as Spring-based libraries that use null-safety annotations in their codebase should add com.google.code.findbugs:jsr305:3.0.2 with compileOnly Gradle configuration or Maven provided scope to avoid compile warnings.431", "chunk_char_count": 1113, "chunk_word_count": 157, "chunk_token_count": 278.25}, {"page_number": 432, "sentence_chunk": "2.8. Data Buffers and Codecs Java NIO provides ByteBuffer but many libraries build their own byte buffer API on top, especially for network operations where reusing buffers and/or using direct buffers is beneficial for performance. For example Netty has the ByteBuf hierarchy, Undertow uses XNIO, Jetty uses pooled byte buffers with a callback to be released, and so on. The spring-core module provides a set of abstractions to work with various byte buffer APIs as follows: \u2022 DataBufferFactory abstracts the creation of a data buffer. \u2022DataBuffer represents a byte buffer, which may be pooled. \u2022DataBufferUtils offers utility methods for data buffers. \u2022Codecs decode or encode data buffer streams into higher level objects.2.8.1. DataBufferFactory DataBufferFactory is used to create data buffers in one of two ways: 1. Allocate a new data buffer, optionally specifying capacity upfront, if known, which is more efficient even though implementations of DataBuffer can grow and shrink on demand.", "chunk_char_count": 995, "chunk_word_count": 152, "chunk_token_count": 248.75}, {"page_number": 432, "sentence_chunk": "2. Wrap an existing byte[] or java.nio. ByteBuffer, which decorates the given data with a DataBuffer implementation and that does not involve allocation. Note that WebFlux applications do not create a DataBufferFactory directly but instead access it through the ServerHttpResponse or the ClientHttpRequest on the client side. The type of factory depends on the underlying client or server, e.g. NettyDataBufferFactory for Reactor Netty, DefaultDataBufferFactory for others.2.8.2. DataBuffer The DataBuffer interface offers similar operations as java.nio. ByteBuffer but also brings a few additional benefits some of which are inspired by the Netty ByteBuf. Below is a partial list of benefits: \u2022 Read and write with independent positions, i.e. not requiring a call to flip() to alternate between read and write. \u2022Capacity expanded on demand as with java.lang.", "chunk_char_count": 859, "chunk_word_count": 126, "chunk_token_count": 214.75}, {"page_number": 432, "sentence_chunk": "StringBuilder. \u2022Pooled buffers and reference counting via PooledDataBuffer. \u2022View a buffer as java.nio. ByteBuffer, InputStream, or OutputStream. \u2022Determine the index, or the last index, for a given byte.2.8.3. PooledDataBuffer As explained in the Javadoc for ByteBuffer, byte buffers can be direct or non-direct. Direct buffers may reside outside the Java heap which eliminates the need for copying for native I/O operations. That makes direct buffers particularly useful for receiving and sending data over a socket, but they\u2019re also more expensive to create and release, which leads to the idea of pooling buffers.432", "chunk_char_count": 620, "chunk_word_count": 92, "chunk_token_count": 155.0}, {"page_number": 433, "sentence_chunk": "PooledDataBuffer is an extension of DataBuffer that helps with reference counting which is essential for byte buffer pooling. How does it work?When a PooledDataBuffer is allocated the reference count is at 1. Calls to retain() increment the count, while calls to release() decrement it. As long as the count is above 0, the buffer is guaranteed not to be released. When the count is decreased to 0, the pooled buffer can be released, which in practice could mean the reserved memory for the buffer is returned to the memory pool. Note that instead of operating on PooledDataBuffer directly, in most cases it\u2019s better to use the convenience methods in DataBufferUtils that apply release or retain to a DataBuffer only if it is an instance of PooledDataBuffer.2.8.4. DataBufferUtils DataBufferUtils offers a number of utility methods to operate on data buffers: \u2022 Join a stream of data buffers into a single buffer possibly with zero copy, e.g. via composite buffers, if that\u2019s supported by the underlying byte buffer API. \u2022Turn InputStream or NIO Channel into Flux<DataBuffer>, and vice versa a Publisher<DataBuffer> into OutputStream or NIO Channel. \u2022", "chunk_char_count": 1151, "chunk_word_count": 185, "chunk_token_count": 287.75}, {"page_number": 433, "sentence_chunk": "Methods to release or retain a DataBuffer if the buffer is an instance of PooledDataBuffer. \u2022Skip or take from a stream of bytes until a specific byte count.2.8.5. Codecs The org.springframework.core.codec package provides the following strategy interfaces: \u2022 Encoder to encode Publisher<T> into a stream of data buffers. \u2022Decoder to decode Publisher<DataBuffer> into a stream of higher level objects. The spring-core module provides byte[], ByteBuffer, DataBuffer, Resource, and String encoder and decoder implementations. The spring-web module adds Jackson JSON, Jackson Smile, JAXB2, Protocol Buffers and other encoders and decoders. See Codecs in the WebFlux section.2.8.6. Using DataBuffer When working with data buffers, special care must be taken to ensure buffers are released since they may be pooled.", "chunk_char_count": 810, "chunk_word_count": 117, "chunk_token_count": 202.5}, {"page_number": 433, "sentence_chunk": "We\u2019ll use codecs to illustrate how that works but the concepts apply more generally. Let\u2019s see what codecs must do internally to manage data buffers. A Decoder is the last to read input data buffers, before creating higher level objects, and therefore it must release them as follows: 1. If a Decoder simply reads each input buffer and is ready to release it immediately, it can do so via DataBufferUtils.release(dataBuffer).2. If a Decoder is using Flux or Mono operators such as flatMap, reduce, and others that prefetch and cache data items internally, or is using operators such as filter, skip, and others that leave out items, then doOnDiscard(DataBuffer.class, DataBufferUtils::release) must be added to the 433", "chunk_char_count": 718, "chunk_word_count": 115, "chunk_token_count": 179.5}, {"page_number": 434, "sentence_chunk": "composition chain to ensure such buffers are released prior to being discarded, possibly also as a result of an error or cancellation signal.3. If a Decoder holds on to one or more data buffers in any other way, it must ensure they are released when fully read, or in case of an error or cancellation signals that take place before the cached data buffers have been read and released. Note that DataBufferUtils#join offers a safe and efficient way to aggregate a data buffer stream into a single data buffer. Likewise skipUntilByteCount and takeUntilByteCount are additional safe methods for decoders to use. An Encoder allocates data buffers that others must read (and release). So an Encoder doesn\u2019t have much to do. However an Encoder must take care to release a data buffer if a serialization error occurs while populating the buffer with data. For example: Java DataBuffer buffer = factory.allocateBuffer(); boolean release = true; try { \u00a0  // serialize and populate buffer.. \u00a0  release = false; } finally { \u00a0  if (release) { \u00a0    DataBufferUtils.release(buffer); \u00a0  } } return buffer; Kotlin val buffer = factory.allocateBuffer() var release = true try { \u00a0  // serialize and populate buffer.. \u00a0  release = false } finally { \u00a0  if (release) { \u00a0    DataBufferUtils.release(buffer) \u00a0  } } return buffer The consumer of an Encoder is responsible for releasing the data buffers it receives. In a WebFlux application, the output of the Encoder is used to write to the HTTP server response, or to the client HTTP request, in which case releasing the data buffers is the responsibility of the code writing to the server response, or to the client request.", "chunk_char_count": 1653, "chunk_word_count": 289, "chunk_token_count": 413.25}, {"page_number": 435, "sentence_chunk": "2.9. Logging Since Spring Framework 5.0, Spring comes with its own Commons Logging bridge implemented in the spring-jcl module. The implementation checks for the presence of the Log4j 2.x API and the SLF4J 1.7 API in the classpath and uses the first one of those found as the logging implementation, falling back to the Java platform\u2019s core logging facilities (also known as JUL or java.util.logging) if neither Log4j 2.x nor SLF4J is available. Put Log4j 2.x or Logback (or another SLF4J provider) in your classpath, without any extra bridges, and let the framework auto-adapt to your choice. For further information see the Spring Boot Logging Reference Documentation.\uf05a Spring\u2019s Commons Logging variant is only meant to be used for infrastructure logging purposes in the core framework and in extensions. For logging needs within application code, prefer direct use of Log4j 2.x, SLF4J, or JUL. A Log implementation may be retrieved via org.apache.commons.logging. LogFactory as in the following example. Java public class MyBean { \u00a0  private final Log log = LogFactory.getLog(getClass()); \u00a0  // ... } Kotlin class MyBean { \u00a0 private val log = LogFactory.getLog(javaClass) \u00a0 // ... } 2.10.", "chunk_char_count": 1191, "chunk_word_count": 190, "chunk_token_count": 297.75}, {"page_number": 435, "sentence_chunk": "Ahead of Time Optimizations This chapter covers Spring\u2019s Ahead of Time (AOT) optimizations. For AOT support specific to integration tests, see Ahead of Time Support for Tests.2.10.1. Introduction to Ahead of Time Optimizations Spring\u2019s support for AOT optimizations is meant to inspect an ApplicationContext at build time and apply decisions and discovery logic that usually happens at runtime. Doing so allows building an application startup arrangement that is more straightforward and focused on a fixed set of features based mainly on the classpath and the Environment.435", "chunk_char_count": 576, "chunk_word_count": 86, "chunk_token_count": 144.0}, {"page_number": 436, "sentence_chunk": "Applying such optimizations early implies the following restrictions: \u2022 The classpath is fixed and fully defined at build time. \u2022The beans defined in your application cannot change at runtime, meaning: \u25e6 @Profile, in particular profile-specific configuration needs to be chosen at build time.\u25e6 Environment properties that impact the presence of a bean (@Conditional) are only considered at build time. When these restrictions are in place, it becomes possible to perform ahead-of-time processing at build time and generate additional assets. A Spring AOT processed application typically generates: \u2022 Java source code \u2022 Bytecode (usually for dynamic proxies) \u2022 RuntimeHints for the use of reflection, resource loading, serialization, and JDK proxies.\uf05a At the moment, AOT is focused on allowing Spring applications to be deployed as native images using GraalVM. We intend to offer more JVM-based use cases in future generations.2.10.2. AOT engine overview The entry point of the AOT engine for processing an ApplicationContext arrangement is ApplicationContextAotGenerator. It takes care of the following steps, based on a GenericApplicationContext that represents the application to optimize and a GenerationContext: \u2022 Refresh an ApplicationContext for AOT processing.", "chunk_char_count": 1267, "chunk_word_count": 182, "chunk_token_count": 316.75}, {"page_number": 436, "sentence_chunk": "Contrary to a traditional refresh, this version only creates bean definitions, not bean instances. \u2022Invoke the available BeanFactoryInitializationAotProcessor implementations and apply their contributions against the GenerationContext. For instance, a core implementation iterates over all candidate bean definitions and generates the necessary code to restore the state of the BeanFactory. Once this process completes, the GenerationContext has been updated with the generated code, resources, and classes that are necessary for the application to run. The RuntimeHints instance can also be used to generate the relevant GraalVM native image configuration files. ApplicationContextAotGenerator#processAheadOfTime returns the class name of the ApplicationContextInitializer entry point that allows the context to be started with AOT optimizations. Those steps are covered in more details in the sections below.2.10.3. Refresh for AOT Processing Refresh for AOT processing is supported on all GenericApplicationContext implementations. An application context is created with any number of entry points, usually in the form of @Configuration-annotated classes.", "chunk_char_count": 1158, "chunk_word_count": 152, "chunk_token_count": 289.5}, {"page_number": 437, "sentence_chunk": "Let\u2019s look at a basic example: Java @Configuration(proxyBeanMethods=false) @ComponentScan @Import({DataSourceConfiguration.class, ContainerConfiguration.class}) public class MyApplication { } Starting this application with the regular runtime involves a number of steps including classpath scanning, configuration class parsing, bean instantiation, and lifecycle callback handling. Refresh for AOT processing only applies a subset of what happens with a regular refresh. AOT processing can be triggered as follows: Java GenericApplicationContext applicationContext = new AnnotatedConfigApplicationContext(); context.register(MyApplication.class); context.refreshForAotProcessing(); In this mode, BeanFactoryPostProcessor implementations are invoked as usual. This includes configuration class parsing, import selectors, classpath scanning, etc. Such steps make sure that the BeanRegistry contains the relevant bean definitions for the application. If bean definitions are guarded by conditions (such as @Profile), these are discarded at this stage. Because this mode does not actually create bean instances, BeanPostProcessor implementations are not invoked, except for specific variants that are relevant for AOT processing. These are: \u2022 MergedBeanDefinitionPostProcessor implementations post-process bean definitions to extract additional settings, such as init and destroy methods. \u2022SmartInstantiationAwareBeanPostProcessor implementations determine a more precise bean type if necessary. This makes sure to create any proxy that is required at runtime.", "chunk_char_count": 1556, "chunk_word_count": 184, "chunk_token_count": 389.0}, {"page_number": 437, "sentence_chunk": "One this part completes, the BeanFactory contains the bean definitions that are necessary for the application to run. It does not trigger bean instantiation but allows the AOT engine to inspect the beans that would be created at runtime.2.10.4. Bean Factory Initialization AOT Contributions Components that want to participate in this step can implement the BeanFactoryInitializationAotProcessor interface. Each implementation can return an AOT contribution, based on the state of the bean factory. An AOT contribution is a component that contributes generated code that reproduces a particular behavior. It can also contribute RuntimeHints to indicate the need for reflection, resource loading, serialization, or JDK proxies.437", "chunk_char_count": 729, "chunk_word_count": 104, "chunk_token_count": 182.25}, {"page_number": 438, "sentence_chunk": "A BeanFactoryInitializationAotProcessor implementation can be registered in META- INF/spring/aot.factories with a key equal to the fully qualified name of the interface. A BeanFactoryInitializationAotProcessor can also be implemented directly by a bean. In this mode, the bean provides an AOT contribution equivalent to the feature it provides with a regular runtime. Consequently, such a bean is automatically excluded from the AOT-optimized context.\uf05a If a bean implements the BeanFactoryInitializationAotProcessor interface, the bean and all of its dependencies will be initialized during AOT processing. We generally recommend that this interface is only implemented by infrastructure beans such as BeanFactoryPostProcessor which have limited dependencies and are already initialized early in the bean factory lifecycle. If such a bean is registered using an @Bean factory method, ensure the method is static so that its enclosing @Configuration class does not have to be initialized. Bean Registration AOT Contributions A core BeanFactoryInitializationAotProcessor implementation is responsible for collecting the necessary contributions for each candidate BeanDefinition. It does so using a dedicated BeanRegistrationAotProcessor. This interface is used as follows: \u2022 Implemented by a BeanPostProcessor bean, to replace its runtime behavior.", "chunk_char_count": 1346, "chunk_word_count": 181, "chunk_token_count": 336.5}, {"page_number": 438, "sentence_chunk": "For instance AutowiredAnnotationBeanPostProcessor implements this interface to generate code that injects members annotated with @Autowired. \u2022Implemented by a type registered in META-INF/spring/aot.factories with a key equal to the fully qualified name of the interface. Typically used when the bean definition needs to be tuned for specific features of the core framework.\uf05a If a bean implements the BeanRegistrationAotProcessor interface, the bean and all of its dependencies will be initialized during AOT processing. We generally recommend that this interface is only implemented by infrastructure beans such as BeanFactoryPostProcessor which have limited dependencies and are already initialized early in the bean factory lifecycle. If such a bean is registered using an @Bean factory method, ensure the method is static so that its enclosing @Configuration class does not have to be initialized. If no BeanRegistrationAotProcessor handles a particular registered bean, a default implementation processes it. This is the default behavior, since tuning the generated code for a bean definition should be restricted to corner cases. Taking our previous example, let\u2019s assume that DataSourceConfiguration is as follows: 438", "chunk_char_count": 1224, "chunk_word_count": 173, "chunk_token_count": 306.0}, {"page_number": 439, "sentence_chunk": "Java @Configuration(proxyBeanMethods = false) public class DataSourceConfiguration { \u00a0  @Bean \u00a0  public SimpleDataSource dataSource() { \u00a0    return new SimpleDataSource(); \u00a0  } } Since there isn\u2019t any particular condition on this class, dataSourceConfiguration and dataSource are identified as candidates. The AOT engine will convert the configuration class above to code similar to the following: 439", "chunk_char_count": 401, "chunk_word_count": 60, "chunk_token_count": 100.25}, {"page_number": 440, "sentence_chunk": "Java /** \u00a0* Bean definitions for {@link DataSourceConfiguration} \u00a0*/ public class DataSourceConfiguration__BeanDefinitions { \u00a0  /** \u00a0  * Get the bean definition for 'dataSourceConfiguration' \u00a0  */ \u00a0  public static BeanDefinition getDataSourceConfigurationBeanDefinition() { \u00a0    Class<?> beanType = DataSourceConfiguration.class; \u00a0    RootBeanDefinition beanDefinition = new RootBeanDefinition(beanType); \u00a0    beanDefinition.setInstanceSupplier(DataSourceConfiguration::new); \u00a0    return beanDefinition; \u00a0  } \u00a0  /** \u00a0  * Get the bean instance supplier for 'dataSource'.\u00a0  */ \u00a0  private static BeanInstanceSupplier<SimpleDataSource> getDataSourceInstanceSupplier() { \u00a0    return BeanInstanceSupplier.<SimpleDataSource>forFactoryMethod(DataSourceConfiguration.class, \"dataSource\") \u00a0        .withGenerator((registeredBean) -> registeredBean.getBeanFactory().getBean(DataSourceConfiguration.class).dataSource()); \u00a0  } \u00a0  /** \u00a0  * Get the bean definition for 'dataSource' \u00a0  */ \u00a0  public static BeanDefinition getDataSourceBeanDefinition() { \u00a0    Class<?> beanType = SimpleDataSource.class; \u00a0    RootBeanDefinition beanDefinition = new RootBeanDefinition(beanType); \u00a0    beanDefinition.setInstanceSupplier(getDataSourceInstanceSupplier()); \u00a0    return beanDefinition; \u00a0  } } \uf05a The exact code generated may differ depending on the exact nature of your bean definitions. The generated code above creates bean definitions equivalent to the @Configuration class, but in a direct way and without the use of reflection if at all possible. There is a bean definition for dataSourceConfiguration and one for dataSourceBean. When a datasource instance is required, a BeanInstanceSupplier is called. This supplier invokes the dataSource() method on the dataSourceConfiguration bean.440", "chunk_char_count": 1770, "chunk_word_count": 237, "chunk_token_count": 442.5}, {"page_number": 441, "sentence_chunk": "2.10.5. Runtime Hints Running an application as a native image requires additional information compared to a regular JVM runtime. For instance, GraalVM needs to know ahead of time if a component uses reflection. Similarly, classpath resources are not shipped in a native image unless specified explicitly. Consequently, if the application needs to load a resource, it must be referenced from the corresponding GraalVM native image configuration file. The RuntimeHints API collects the need for reflection, resource loading, serialization, and JDK proxies at runtime. The following example makes sure that config/app.properties can be loaded from the classpath at runtime within a native image: Java runtimeHints.resources().registerPattern(\"config/app.properties\"); A number of contracts are handled automatically during AOT processing. For instance, the return type of a @Controller method is inspected, and relevant reflection hints are added if Spring detects that the type should be serialized (typically to JSON). For cases that the core container cannot infer, you can register such hints programmatically. A number of convenient annotations are also provided for common use cases.", "chunk_char_count": 1187, "chunk_word_count": 169, "chunk_token_count": 296.75}, {"page_number": 441, "sentence_chunk": "@ImportRuntimeHints RuntimeHintsRegistrar implementations allow you to get a callback to the RuntimeHints instance managed by the AOT engine. Implementations of this interface can be registered using @ImportRuntimeHints on any Spring bean or @Bean factory method. RuntimeHintsRegistrar implementations are detected and invoked at build time. Java @Component @ImportRuntimeHints(MyComponentRuntimeHints.class) public class MyComponent { \u00a0  // ... \u00a0  private static class MyComponentRuntimeHints implements RuntimeHintsRegistrar { \u00a0    @Override \u00a0    public void registerHints(RuntimeHints hints, ClassLoader classLoader) { \u00a0      // ... \u00a0    } \u00a0  } } If at all possible, @ImportRuntimeHints should be used as close as possible to the component that requires the hints. This way, if the component is not contributed to the BeanFactory, the hints won\u2019t be contributed either.441", "chunk_char_count": 875, "chunk_word_count": 133, "chunk_token_count": 218.75}, {"page_number": 442, "sentence_chunk": "It is also possible to register an implementation statically by adding an entry in META- INF/spring/aot.factories with a key equal to the fully qualified name of the RuntimeHintsRegistrar interface.@Reflective @Reflective provides an idiomatic way to flag the need for reflection on an annotated element. For instance, @EventListener is meta-annotated with @Reflective since the underlying implementation invokes the annotated method using reflection. By default, only Spring beans are considered and an invocation hint is registered for the annotated element. This can be tuned by specifying a custom ReflectiveProcessor implementation via the @Reflective annotation. Library authors can reuse this annotation for their own purposes. If components other than Spring beans need to be processed, a BeanFactoryInitializationAotProcessor can detect the relevant types and use ReflectiveRuntimeHintsRegistrar to process them.@RegisterReflectionForBinding @RegisterReflectionForBinding is a specialization of @Reflective that registers the need for serializing arbitrary types. A typical use case is the use of DTOs that the container cannot infer, such as using a web client within a method body.@RegisterReflectionForBinding can be applied to any Spring bean at the class level, but it can also be applied directly to a method, field, or constructor to better indicate where the hints are actually required.", "chunk_char_count": 1404, "chunk_word_count": 196, "chunk_token_count": 351.0}, {"page_number": 442, "sentence_chunk": "The following example registers Account for serialization. Java @Component public class OrderService { \u00a0  @RegisterReflectionForBinding(Account.class) \u00a0  public void process(Order order) { \u00a0    // ... \u00a0  } } 2.11. Appendix 2.11.1. XML Schemas This part of the appendix lists XML schemas related to the core container. The util Schema As the name implies, the util tags deal with common, utility configuration issues, such as configuring collections, referencing constants, and so forth. To use the tags in the util schema, you 442", "chunk_char_count": 530, "chunk_word_count": 86, "chunk_token_count": 132.5}, {"page_number": 443, "sentence_chunk": "need to have the following preamble at the top of your Spring XML configuration file (the text in the snippet references the correct schema so that the tags in the util namespace are available to you): <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:util=\"http://www.springframework.org/schema/util\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/util https://www.springframework.org/schema/util/spring-util.xsd\"> \u00a0    <!--bean definitions here --> </beans> Using <util:constant/> Consider the following bean definition: <bean id=\"...\" class=\"...\"> \u00a0  <property name=\"isolation\"> \u00a0    <bean id=\"java.sql. Connection. TRANSACTION_SERIALIZABLE\" \u00a0 class=\"org.springframework.beans.factory.config. FieldRetrievingFactoryBean\" /> \u00a0  </property> </bean> The preceding configuration uses a Spring FactoryBean implementation (the FieldRetrievingFactoryBean) to set the value of the isolation property on a bean to the value of the java.sql. Connection. TRANSACTION_SERIALIZABLE constant. This is all well and good, but it is verbose and (unnecessarily) exposes Spring\u2019s internal plumbing to the end user.", "chunk_char_count": 1343, "chunk_word_count": 151, "chunk_token_count": 335.75}, {"page_number": 443, "sentence_chunk": "The following XML Schema-based version is more concise, clearly expresses the developer\u2019s intent (\u201cinject this constant value\u201d), and it reads better: <bean id=\"...\" class=\"...\"> \u00a0  <property name=\"isolation\"> \u00a0    <util:constant static-field=\"java.sql. Connection. TRANSACTION_SERIALIZABLE\"/> \u00a0  </property> </bean> Setting a Bean Property or Constructor Argument from a Field Value FieldRetrievingFactoryBean is a FactoryBean that retrieves a static or non-static field value. It is 443", "chunk_char_count": 487, "chunk_word_count": 66, "chunk_token_count": 121.75}, {"page_number": 444, "sentence_chunk": "typically used for retrieving public static final constants, which may then be used to set a property value or constructor argument for another bean. The following example shows how a static field is exposed, by using the staticField property: <bean id=\"myField\" \u00a0    class=\"org.springframework.beans.factory.config. FieldRetrievingFactoryBean\"> \u00a0  <property name=\"staticField\" value=\"java.sql. Connection. TRANSACTION_SERIALIZABLE\"/> </bean> There is also a convenience usage form where the static field is specified as the bean name, as the following example shows: <bean id=\"java.sql. Connection. TRANSACTION_SERIALIZABLE\" \u00a0    class=\"org.springframework.beans.factory.config. FieldRetrievingFactoryBean\"/> This does mean that there is no longer any choice in what the bean id is (so any other bean that refers to it also has to use this longer name), but this form is very concise to define and very convenient to use as an inner bean since the id does not have to be specified for the bean reference, as the following example shows: <bean id=\"...\" class=\"...\"> \u00a0  <property name=\"isolation\"> \u00a0    <bean id=\"java.sql. Connection. TRANSACTION_SERIALIZABLE\" \u00a0 class=\"org.springframework.beans.factory.config.", "chunk_char_count": 1210, "chunk_word_count": 170, "chunk_token_count": 302.5}, {"page_number": 444, "sentence_chunk": "FieldRetrievingFactoryBean\" /> \u00a0  </property> </bean> You can also access a non-static (instance) field of another bean, as described in the API documentation for the FieldRetrievingFactoryBean class. Injecting enumeration values into beans as either property or constructor arguments is easy to do in Spring. You do not actually have to do anything or know anything about the Spring internals (or even about classes such as the FieldRetrievingFactoryBean). The following example enumeration shows how easy injecting an enum value is: 444", "chunk_char_count": 538, "chunk_word_count": 80, "chunk_token_count": 134.5}, {"page_number": 445, "sentence_chunk": "Java package jakarta.persistence; public enum PersistenceContextType { \u00a0  TRANSACTION, \u00a0  EXTENDED } Kotlin package jakarta.persistence enum class PersistenceContextType { \u00a0  TRANSACTION, \u00a0  EXTENDED } Now consider the following setter of type PersistenceContextType and the corresponding bean definition: Java package example; public class Client { \u00a0  private PersistenceContextType persistenceContextType; \u00a0  public void setPersistenceContextType(PersistenceContextType type) { \u00a0    this.persistenceContextType = type; \u00a0  } } Kotlin package example class Client { \u00a0  lateinit var persistenceContextType: PersistenceContextType } 445", "chunk_char_count": 634, "chunk_word_count": 85, "chunk_token_count": 158.5}, {"page_number": 446, "sentence_chunk": "<bean class=\"example. Client\"> \u00a0  <property name=\"persistenceContextType\" value=\"TRANSACTION\"/> </bean> Using <util:property-path/> Consider the following example: <!--target bean to be referenced by name --> <bean id=\"testBean\" class=\"org.springframework.beans. TestBean\" scope=\"prototype\"> \u00a0  <property name=\"age\" value=\"10\"/> \u00a0  <property name=\"spouse\"> \u00a0    <bean class=\"org.springframework.beans. TestBean\"> \u00a0      <property name=\"age\" value=\"11\"/> \u00a0    </bean> \u00a0  </property> </bean> <!--results in 10, which is the value of property 'age' of bean 'testBean' --> <bean id=\"testBean.age\" class=\"org.springframework.beans.factory.config. PropertyPathFactoryBean\"/> The preceding configuration uses a Spring FactoryBean implementation (the PropertyPathFactoryBean) to create a bean (of type int) called testBean.age that has a value equal to the age property of the testBean bean. Now consider the following example, which adds a <util:property-path/> element: <!--target bean to be referenced by name --> <bean id=\"testBean\" class=\"org.springframework.beans. TestBean\" scope=\"prototype\"> \u00a0  <property name=\"age\" value=\"10\"/> \u00a0  <property name=\"spouse\"> \u00a0    <bean class=\"org.springframework.beans.", "chunk_char_count": 1201, "chunk_word_count": 150, "chunk_token_count": 300.25}, {"page_number": 446, "sentence_chunk": "TestBean\"> \u00a0      <property name=\"age\" value=\"11\"/> \u00a0    </bean> \u00a0  </property> </bean> <!--results in 10, which is the value of property 'age' of bean 'testBean' --> <util:property-path id=\"name\" path=\"testBean.age\"/> The value of the path attribute of the <property-path/> element follows the form of beanName.beanProperty. In this case, it picks up the age property of the bean named testBean. The value of that age property is 10.446", "chunk_char_count": 437, "chunk_word_count": 73, "chunk_token_count": 109.25}, {"page_number": 447, "sentence_chunk": "Using <util:property-path/> to Set a Bean Property or Constructor Argument PropertyPathFactoryBean is a FactoryBean that evaluates a property path on a given target object. The target object can be specified directly or by a bean name. You can then use this value in another bean definition as a property value or constructor argument. The following example shows a path being used against another bean, by name: <!--target bean to be referenced by name --> <bean id=\"person\" class=\"org.springframework.beans. TestBean\" scope=\"prototype\"> \u00a0  <property name=\"age\" value=\"10\"/> \u00a0  <property name=\"spouse\"> \u00a0    <bean class=\"org.springframework.beans. TestBean\"> \u00a0      <property name=\"age\" value=\"11\"/> \u00a0    </bean> \u00a0  </property> </bean> <!--results in 11, which is the value of property 'spouse.age' of bean 'person' --> <bean id=\"theAge\" \u00a0    class=\"org.springframework.beans.factory.config. PropertyPathFactoryBean\"> \u00a0  <property name=\"targetBeanName\" value=\"person\"/> \u00a0  <property name=\"propertyPath\" value=\"spouse.age\"/> </bean> In the following example, a path is evaluated against an inner bean: <!--results in 12, which is the value of property 'age' of the inner bean --> <bean id=\"theAge\" \u00a0    class=\"org.springframework.beans.factory.config.", "chunk_char_count": 1251, "chunk_word_count": 180, "chunk_token_count": 312.75}, {"page_number": 447, "sentence_chunk": "PropertyPathFactoryBean\"> \u00a0  <property name=\"targetObject\"> \u00a0    <bean class=\"org.springframework.beans. TestBean\"> \u00a0      <property name=\"age\" value=\"12\"/> \u00a0    </bean> \u00a0  </property> \u00a0  <property name=\"propertyPath\" value=\"age\"/> </bean> There is also a shortcut form, where the bean name is the property path. The following example shows the shortcut form: <!--results in 10, which is the value of property 'age' of bean 'person' --> <bean id=\"person.age\" \u00a0    class=\"org.springframework.beans.factory.config. PropertyPathFactoryBean\"/> This form does mean that there is no choice in the name of the bean. Any reference to it also has to use the same id, which is the path. If used as an inner bean, there is no need to refer to it at all, as 447", "chunk_char_count": 749, "chunk_word_count": 126, "chunk_token_count": 187.25}, {"page_number": 448, "sentence_chunk": "the following example shows: <bean id=\"...\" class=\"...\"> \u00a0  <property name=\"age\"> \u00a0    <bean id=\"person.age\" \u00a0 class=\"org.springframework.beans.factory.config. PropertyPathFactoryBean\"/> \u00a0  </property> </bean> You can specifically set the result type in the actual definition. This is not necessary for most use cases, but it can sometimes be useful. See the javadoc for more info on this feature. Using <util:properties/> Consider the following example: <!--creates a java.util. Properties instance with values loaded from the supplied location --> <bean id=\"jdbcConfiguration\" class=\"org.springframework.beans.factory.config. PropertiesFactoryBean\"> \u00a0  <property name=\"location\" value=\"classpath:com/foo/jdbc-production.properties\"/> </bean> The preceding configuration uses a Spring FactoryBean implementation (the PropertiesFactoryBean) to instantiate a java.util. Properties instance with values loaded from the supplied Resource location). The following example uses a util:properties element to make a more concise representation: <!--", "chunk_char_count": 1042, "chunk_word_count": 125, "chunk_token_count": 260.5}, {"page_number": 448, "sentence_chunk": "creates a java.util. Properties instance with values loaded from the supplied location --> <util:properties id=\"jdbcConfiguration\" location=\"classpath:com/foo/jdbc- production.properties\"/> Using <util:list/> Consider the following example: 448", "chunk_char_count": 244, "chunk_word_count": 24, "chunk_token_count": 61.0}, {"page_number": 449, "sentence_chunk": "<!--creates a java.util. List instance with values loaded from the supplied 'sourceList' --> <bean id=\"emails\" class=\"org.springframework.beans.factory.config. ListFactoryBean\"> \u00a0  <property name=\"sourceList\"> \u00a0    <list> \u00a0      <value>pechorin@hero.org</value> \u00a0      <value>raskolnikov@slums.org</value> \u00a0      <value>stavrogin@gov.org</value> \u00a0      <value>porfiry@gov.org</value> \u00a0    </list> \u00a0  </property> </bean> The preceding configuration uses a Spring FactoryBean implementation (the ListFactoryBean) to create a java.util. List instance and initialize it with values taken from the supplied sourceList. The following example uses a <util:list/> element to make a more concise representation: <!--creates a java.util. List instance with the supplied values --> <util:list id=\"emails\"> \u00a0  <value>pechorin@hero.org</value> \u00a0  <value>raskolnikov@slums.org</value> \u00a0  <value>stavrogin@gov.org</value> \u00a0  <value>porfiry@gov.org</value> </util:list> You can also explicitly control the exact type of List that is instantiated and populated by using the list-class attribute on the <util:list/> element. For example, if we really need a java.util. LinkedList to be instantiated, we could use the following configuration: <util:list id=\"emails\" list-class=\"java.util.", "chunk_char_count": 1269, "chunk_word_count": 172, "chunk_token_count": 317.25}, {"page_number": 449, "sentence_chunk": "LinkedList\"> \u00a0  <value>jackshaftoe@vagabond.org</value> \u00a0  <value>eliza@thinkingmanscrumpet.org</value> \u00a0  <value>vanhoek@pirate.org</value> \u00a0  <value>d'Arcachon@nemesis.org</value> </util:list> If no list-class attribute is supplied, the container chooses a List implementation. Using <util:map/> Consider the following example: 449", "chunk_char_count": 333, "chunk_word_count": 33, "chunk_token_count": 83.25}, {"page_number": 450, "sentence_chunk": "<!--creates a java.util. Map instance with values loaded from the supplied 'sourceMap' --> <bean id=\"emails\" class=\"org.springframework.beans.factory.config. MapFactoryBean\"> \u00a0  <property name=\"sourceMap\"> \u00a0    <map> \u00a0      <entry key=\"pechorin\" value=\"pechorin@hero.org\"/> \u00a0      <entry key=\"raskolnikov\" value=\"raskolnikov@slums.org\"/> \u00a0      <entry key=\"stavrogin\" value=\"stavrogin@gov.org\"/> \u00a0      <entry key=\"porfiry\" value=\"porfiry@gov.org\"/> \u00a0    </map> \u00a0  </property> </bean> The preceding configuration uses a Spring FactoryBean implementation (the MapFactoryBean) to create a java.util. Map instance initialized with key-value pairs taken from the supplied 'sourceMap'. The following example uses a <util:map/> element to make a more concise representation: <!--creates a java.util. Map instance with the supplied key-value pairs --> <util:map id=\"emails\"> \u00a0  <entry key=\"pechorin\" value=\"pechorin@hero.org\"/> \u00a0  <entry key=\"raskolnikov\" value=\"raskolnikov@slums.org\"/> \u00a0  <entry key=\"stavrogin\" value=\"stavrogin@gov.org\"/> \u00a0  <entry key=\"porfiry\" value=\"porfiry@gov.org\"/> </util:map> You can also explicitly control the exact type of Map that is instantiated and populated by using the 'map-class' attribute on the <util:map/> element. For example, if we really need a java.util. TreeMap to be instantiated, we could use the following configuration: <util:map id=\"emails\" map-class=\"java.util.", "chunk_char_count": 1406, "chunk_word_count": 188, "chunk_token_count": 351.5}, {"page_number": 450, "sentence_chunk": "TreeMap\"> \u00a0  <entry key=\"pechorin\" value=\"pechorin@hero.org\"/> \u00a0  <entry key=\"raskolnikov\" value=\"raskolnikov@slums.org\"/> \u00a0  <entry key=\"stavrogin\" value=\"stavrogin@gov.org\"/> \u00a0  <entry key=\"porfiry\" value=\"porfiry@gov.org\"/> </util:map> If no 'map-class' attribute is supplied, the container chooses a Map implementation. Using <util:set/> Consider the following example: 450", "chunk_char_count": 377, "chunk_word_count": 41, "chunk_token_count": 94.25}, {"page_number": 451, "sentence_chunk": "<!--creates a java.util. Set instance with values loaded from the supplied 'sourceSet' --> <bean id=\"emails\" class=\"org.springframework.beans.factory.config. SetFactoryBean\"> \u00a0  <property name=\"sourceSet\"> \u00a0    <set> \u00a0      <value>pechorin@hero.org</value> \u00a0      <value>raskolnikov@slums.org</value> \u00a0      <value>stavrogin@gov.org</value> \u00a0      <value>porfiry@gov.org</value> \u00a0    </set> \u00a0  </property> </bean> The preceding configuration uses a Spring FactoryBean implementation (the SetFactoryBean) to create a java.util. Set instance initialized with values taken from the supplied sourceSet. The following example uses a <util:set/> element to make a more concise representation: <!--creates a java.util. Set instance with the supplied values --> <util:set id=\"emails\"> \u00a0  <value>pechorin@hero.org</value> \u00a0  <value>raskolnikov@slums.org</value> \u00a0  <value>stavrogin@gov.org</value> \u00a0  <value>porfiry@gov.org</value> </util:set> You can also explicitly control the exact type of Set that is instantiated and populated by using the set-class attribute on the <util:set/> element. For example, if we really need a java.util. TreeSet to be instantiated, we could use the following configuration: <util:set id=\"emails\" set-class=\"java.util.", "chunk_char_count": 1242, "chunk_word_count": 170, "chunk_token_count": 310.5}, {"page_number": 451, "sentence_chunk": "TreeSet\"> \u00a0  <value>pechorin@hero.org</value> \u00a0  <value>raskolnikov@slums.org</value> \u00a0  <value>stavrogin@gov.org</value> \u00a0  <value>porfiry@gov.org</value> </util:set> If no set-class attribute is supplied, the container chooses a Set implementation. The aop Schema The aop tags deal with configuring all things AOP in Spring, including Spring\u2019s own proxy-based AOP framework and Spring\u2019s integration with the AspectJ AOP framework. These tags are comprehensively covered in the chapter entitled Aspect Oriented Programming with Spring. In the interest of completeness, to use the tags in the aop schema, you need to have the following preamble at the top of your Spring XML configuration file (the text in the snippet references the 451", "chunk_char_count": 737, "chunk_word_count": 105, "chunk_token_count": 184.25}, {"page_number": 452, "sentence_chunk": "correct schema so that the tags in the aop namespace are available to you): <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:aop=\"http://www.springframework.org/schema/aop\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"> \u00a0  <!--bean definitions here --> </beans> The context Schema The context tags deal with ApplicationContext configuration that relates to plumbing\u2009\u2014\u2009that is, not usually beans that are important to an end-user but rather beans that do a lot of the \u201cgrunt\u201d work in Spring, such as BeanfactoryPostProcessors. The following snippet references the correct schema so that the elements in the context namespace are available to you: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:context=\"http://www.springframework.org/schema/context\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"> \u00a0  <!--bean definitions here --> </beans> Using <property-placeholder/> This element activates the replacement of ${\u2026} placeholders, which are resolved against a specified properties file (as a Spring resource location). This element is a convenience mechanism that sets up a PropertySourcesPlaceholderConfigurer for you. If you need more control over the specific PropertySourcesPlaceholderConfigurer setup, you can explicitly define it as a bean yourself.", "chunk_char_count": 1887, "chunk_word_count": 194, "chunk_token_count": 471.75}, {"page_number": 452, "sentence_chunk": "Using <annotation-config/> This element activates the Spring infrastructure to detect annotations in bean classes: \u2022 Spring\u2019s @Configuration model 452", "chunk_char_count": 150, "chunk_word_count": 19, "chunk_token_count": 37.5}, {"page_number": 453, "sentence_chunk": "\u2022 @Autowired/@Inject, @Value, and @Lookup \u2022 JSR-250\u2019s @Resource, @PostConstruct, and @PreDestroy (if available) \u2022 JAX-WS\u2019s @WebServiceRef and EJB 3\u2019s @EJB (if available) \u2022 JPA\u2019s @PersistenceContext and @PersistenceUnit (if available) \u2022 Spring\u2019s @EventListener Alternatively, you can choose to explicitly activate the individual BeanPostProcessors for those annotations.\uf05a This element does not activate processing of Spring\u2019s @Transactional annotation; you can use the <tx:annotation-driven/> element for that purpose. Similarly, Spring\u2019s caching annotations need to be explicitly enabled as well. Using <component-scan/> This element is detailed in the section on annotation-based container configuration. Using <load-time-weaver/> This element is detailed in the section on load-time weaving with AspectJ in the Spring Framework. Using <spring-configured/> This element is detailed in the section on using AspectJ to dependency inject domain objects with Spring. Using <mbean-export/> This element is detailed in the section on configuring annotation-based MBean export. The Beans Schema Last but not least, we have the elements in the beans schema. These elements have been in Spring since the very dawn of the framework. Examples of the various elements in the beans schema are not shown here because they are quite comprehensively covered in dependencies and configuration in detail (and, indeed, in that entire chapter).", "chunk_char_count": 1425, "chunk_word_count": 198, "chunk_token_count": 356.25}, {"page_number": 453, "sentence_chunk": "Note that you can add zero or more key-value pairs to <bean/> XML definitions. What, if anything, is done with this extra metadata is totally up to your own custom logic (and so is typically only of use if you write your own custom elements as described in the appendix entitled XML Schema Authoring). The following example shows the <meta/> element in the context of a surrounding <bean/> (note that, without any logic to interpret it, the metadata is effectively useless as it stands).453", "chunk_char_count": 490, "chunk_word_count": 84, "chunk_token_count": 122.5}, {"page_number": 454, "sentence_chunk": "<?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"> \u00a0  <bean id=\"foo\" class=\"x.y. Foo\"> \u00a0    <meta key=\"cacheName\" value=\"foo\"/> \u2460 \u00a0    <property name=\"name\" value=\"Rick\"/> \u00a0  </bean> </beans> \u2460 This is the example meta element In the case of the preceding example, you could assume that there is some logic that consumes the bean definition and sets up some caching infrastructure that uses the supplied metadata.2.11.2. XML Schema Authoring Since version 2.0, Spring has featured a mechanism for adding schema-based extensions to the basic Spring XML format for defining and configuring beans. This section covers how to write your own custom XML bean definition parsers and integrate such parsers into the Spring IoC container. To facilitate authoring configuration files that use a schema-aware XML editor, Spring\u2019s extensible XML configuration mechanism is based on XML Schema. If you are not familiar with Spring\u2019s current XML configuration extensions that come with the standard Spring distribution, you should first read the previous section on XML Schemas. To create new XML configuration extensions: 1.", "chunk_char_count": 1352, "chunk_word_count": 184, "chunk_token_count": 338.0}, {"page_number": 454, "sentence_chunk": "Author an XML schema to describe your custom element(s).2. Code a custom NamespaceHandler implementation.3. Code one or more BeanDefinitionParser implementations (this is where the real work is done).4. Register your new artifacts with Spring. For a unified example, we create an XML extension (a custom XML element) that lets us configure objects of the type SimpleDateFormat (from the java.text package). When we are done, we will be able to define bean definitions of type SimpleDateFormat as follows: <myns:dateformat id=\"dateFormat\" \u00a0  pattern=\"yyyy-MM-dd HH:mm\" \u00a0  lenient=\"true\"/> (We include much more detailed examples follow later in this appendix. The intent of this first simple example is to walk you through the basic steps of making a custom extension.)", "chunk_char_count": 768, "chunk_word_count": 117, "chunk_token_count": 192.0}, {"page_number": 455, "sentence_chunk": "Authoring the Schema Creating an XML configuration extension for use with Spring\u2019s IoC container starts with authoring an XML Schema to describe the extension. For our example, we use the following schema to configure SimpleDateFormat objects: <!--myns.xsd (inside package org/springframework/samples/xml) --> <?xml version=\"1.0\" encoding=\"UTF-8\"?> <xsd:schema xmlns=\"http://www.mycompany.example/schema/myns\" \u00a0    xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" \u00a0    xmlns:beans=\"http://www.springframework.org/schema/beans\" \u00a0    targetNamespace=\"http://www.mycompany.example/schema/myns\" \u00a0    elementFormDefault=\"qualified\" \u00a0    attributeFormDefault=\"unqualified\"> \u00a0  <xsd:import namespace=\"http://www.springframework.org/schema/beans\"/> \u00a0  <xsd:element name=\"dateformat\"> \u00a0    <xsd:complexType> \u00a0      <xsd:complexContent> \u00a0        <xsd:extension base=\"beans:identifiedType\"> \u2460 \u00a0          <xsd:attribute name=\"lenient\" type=\"xsd:boolean\"/> \u00a0          <xsd:attribute name=\"pattern\" type=\"xsd:string\" use=\"required\"/> \u00a0        </xsd:extension> \u00a0      </xsd:complexContent> \u00a0    </xsd:complexType> \u00a0  </xsd:element> </xsd:schema> \u2460 The indicated line contains an extension base for all identifiable tags (meaning they have an id attribute that we can use as the bean identifier in the container). We can use this attribute because we imported the Spring-provided beans namespace. The preceding schema lets us configure SimpleDateFormat objects directly in an XML application context file by using the <myns:dateformat/> element, as the following example shows: <myns:dateformat id=\"dateFormat\" \u00a0  pattern=\"yyyy-MM-dd HH:mm\" \u00a0  lenient=\"true\"/> Note that, after we have created the infrastructure classes, the preceding snippet of XML is essentially the same as the following XML snippet: <bean id=\"dateFormat\" class=\"java.text. SimpleDateFormat\"> \u00a0  <constructor-arg value=\"yyyy-MM-dd HH:mm\"/> \u00a0  <property name=\"lenient\" value=\"true\"/> </bean> 455", "chunk_char_count": 1945, "chunk_word_count": 268, "chunk_token_count": 486.25}, {"page_number": 456, "sentence_chunk": "The second of the two preceding snippets creates a bean in the container (identified by the name dateFormat of type SimpleDateFormat) with a couple of properties set.\uf05a The schema-based approach to creating configuration format allows for tight integration with an IDE that has a schema-aware XML editor. By using a properly authored schema, you can use autocompletion to let a user choose between several configuration options defined in the enumeration. Coding a NamespaceHandler In addition to the schema, we need a NamespaceHandler to parse all elements of this specific namespace that Spring encounters while parsing configuration files. For this example, the NamespaceHandler should take care of the parsing of the myns:dateformat element. The NamespaceHandler interface features three methods: \u2022 init(): Allows for initialization of the NamespaceHandler and is called by Spring before the handler is used. \u2022BeanDefinition parse(Element, ParserContext): Called when Spring encounters a top-level element (not nested inside a bean definition or a different namespace). This method can itself register bean definitions, return a bean definition, or both. \u2022BeanDefinitionHolder decorate(Node, BeanDefinitionHolder, ParserContext): Called when Spring encounters an attribute or nested element of a different namespace. The decoration of one or more bean definitions is used (for example) with the scopes that Spring supports.", "chunk_char_count": 1426, "chunk_word_count": 204, "chunk_token_count": 356.5}, {"page_number": 456, "sentence_chunk": "We start by highlighting a simple example, without using decoration, after which we show decoration in a somewhat more advanced example. Although you can code your own NamespaceHandler for the entire namespace (and hence provide code that parses each and every element in the namespace), it is often the case that each top-level XML element in a Spring XML configuration file results in a single bean definition (as in our case, where a single <myns:dateformat/> element results in a single SimpleDateFormat bean definition). Spring features a number of convenience classes that support this scenario. In the following example, we use the NamespaceHandlerSupport class: Java package org.springframework.samples.xml; import org.springframework.beans.factory.xml. NamespaceHandlerSupport; public class MyNamespaceHandler extends NamespaceHandlerSupport { \u00a0  public void init() { \u00a0    registerBeanDefinitionParser(\"dateformat\", new SimpleDateFormatBeanDefinitionParser()); \u00a0  } } 456", "chunk_char_count": 980, "chunk_word_count": 133, "chunk_token_count": 245.0}, {"page_number": 457, "sentence_chunk": "Kotlin package org.springframework.samples.xml import org.springframework.beans.factory.xml. NamespaceHandlerSupport class MyNamespaceHandler : NamespaceHandlerSupport { \u00a0  override fun init() { \u00a0    registerBeanDefinitionParser(\"dateformat\", SimpleDateFormatBeanDefinitionParser()) \u00a0  } } You may notice that there is not actually a whole lot of parsing logic in this class. Indeed, the NamespaceHandlerSupport class has a built-in notion of delegation. It supports the registration of any number of BeanDefinitionParser instances, to which it delegates to when it needs to parse an element in its namespace. This clean separation of concerns lets a NamespaceHandler handle the orchestration of the parsing of all of the custom elements in its namespace while delegating to BeanDefinitionParsers to do the grunt work of the XML parsing. This means that each BeanDefinitionParser contains only the logic for parsing a single custom element, as we can see in the next step. Using BeanDefinitionParser A BeanDefinitionParser is used if the NamespaceHandler encounters an XML element of the type that has been mapped to the specific bean definition parser (dateformat in this case). In other words, the BeanDefinitionParser is responsible for parsing one distinct top-level XML element defined in the schema. In the parser, we' have access to the XML element (and thus to its subelements, too) so that we can parse our custom XML content, as you can see in the following example: 457", "chunk_char_count": 1480, "chunk_word_count": 220, "chunk_token_count": 370.0}, {"page_number": 458, "sentence_chunk": "Java package org.springframework.samples.xml; import org.springframework.beans.factory.support. BeanDefinitionBuilder; import org.springframework.beans.factory.xml. AbstractSingleBeanDefinitionParser; import org.springframework.util. StringUtils; import org.w3c.dom. Element; import java.text. SimpleDateFormat; public class SimpleDateFormatBeanDefinitionParser extends AbstractSingleBeanDefinitionParser { \u2460 \u00a0  protected Class getBeanClass(Element element) { \u00a0    return SimpleDateFormat.class; \u2461 \u00a0  } \u00a0  protected void doParse(Element element, BeanDefinitionBuilder bean) { \u00a0    // this will never be null since the schema explicitly requires that a value be supplied \u00a0    String pattern = element.getAttribute(\"pattern\"); \u00a0    bean.addConstructorArgValue(pattern); \u00a0    // this however is an optional property \u00a0    String lenient = element.getAttribute(\"lenient\"); \u00a0    if (StringUtils.hasText(lenient)) { \u00a0      bean.addPropertyValue(\"lenient\", Boolean.valueOf(lenient)); \u00a0    } \u00a0  } } \u2460 We use the Spring-provided AbstractSingleBeanDefinitionParser to handle a lot of the basic grunt work of creating a single BeanDefinition.\u2461 We supply the AbstractSingleBeanDefinitionParser superclass with the type that our single BeanDefinition represents.458", "chunk_char_count": 1251, "chunk_word_count": 160, "chunk_token_count": 312.75}, {"page_number": 459, "sentence_chunk": "Kotlin package org.springframework.samples.xml import org.springframework.beans.factory.support. BeanDefinitionBuilder import org.springframework.beans.factory.xml. AbstractSingleBeanDefinitionParser import org.springframework.util. StringUtils import org.w3c.dom. Element import java.text. SimpleDateFormat class SimpleDateFormatBeanDefinitionParser : AbstractSingleBeanDefinitionParser() { \u2460 \u00a0  override fun getBeanClass(element: Element): Class<*>? {\u2461 \u00a0    return SimpleDateFormat::class.java \u00a0  } \u00a0  override fun doParse(element: Element, bean: BeanDefinitionBuilder) { \u00a0    // this will never be null since the schema explicitly requires that a value be supplied \u00a0    val pattern = element.getAttribute(\"pattern\") \u00a0    bean.addConstructorArgValue(pattern) \u00a0    // this however is an optional property \u00a0    val lenient = element.getAttribute(\"lenient\") \u00a0    if (StringUtils.hasText(lenient)) { \u00a0      bean.addPropertyValue(\"lenient\", java.lang. Boolean.valueOf(lenient)) \u00a0    } \u00a0  } } \u2460 We use the Spring-provided AbstractSingleBeanDefinitionParser to handle a lot of the basic grunt work of creating a single BeanDefinition.\u2461 We supply the AbstractSingleBeanDefinitionParser superclass with the type that our single BeanDefinition represents. In this simple case, this is all that we need to do.", "chunk_char_count": 1300, "chunk_word_count": 172, "chunk_token_count": 325.0}, {"page_number": 459, "sentence_chunk": "The creation of our single BeanDefinition is handled by the AbstractSingleBeanDefinitionParser superclass, as is the extraction and setting of the bean definition\u2019s unique identifier. Registering the Handler and the Schema The coding is finished. All that remains to be done is to make the Spring XML parsing infrastructure aware of our custom element. We do so by registering our custom namespaceHandler and custom XSD file in two special-purpose properties files. These properties files are both placed in a META-INF directory in your application and can, for example, be distributed alongside your binary classes in a JAR file. The Spring XML parsing infrastructure automatically picks up your new extension by consuming these special properties files, the formats of which are detailed in the next two sections.459", "chunk_char_count": 818, "chunk_word_count": 125, "chunk_token_count": 204.5}, {"page_number": 460, "sentence_chunk": "Writing META-INF/spring.handlers The properties file called spring.handlers contains a mapping of XML Schema URIs to namespace handler classes. For our example, we need to write the following: http\\://www.mycompany.example/schema/myns=org.springframework.samples.xml. MyNamespaceH andler (The : character is a valid delimiter in the Java properties format, so : character in the URI needs to be escaped with a backslash.)The first part (the key) of the key-value pair is the URI associated with your custom namespace extension and needs to exactly match exactly the value of the targetNamespace attribute, as specified in your custom XSD schema. Writing 'META-INF/spring.schemas' The properties file called spring.schemas contains a mapping of XML Schema locations (referred to, along with the schema declaration, in XML files that use the schema as part of the xsi:schemaLocation attribute) to classpath resources. This file is needed to prevent Spring from absolutely having to use a default EntityResolver that requires Internet access to retrieve the schema file. If you specify the mapping in this properties file, Spring searches for the schema (in this case, myns.xsd in the org.springframework.samples.xml package) on the classpath. The following snippet shows the line we need to add for our custom schema: http\\://www.mycompany.example/schema/myns/myns.xsd=org/springframework/samples/xml/myn s.xsd (Remember that the : character must be escaped.)You are encouraged to deploy your XSD file (or files) right alongside the NamespaceHandler and BeanDefinitionParser classes on the classpath. Using a Custom Extension in Your Spring XML Configuration Using a custom extension that you yourself have implemented is no different from using one of the \u201ccustom\u201d extensions that Spring provides.", "chunk_char_count": 1796, "chunk_word_count": 251, "chunk_token_count": 449.0}, {"page_number": 460, "sentence_chunk": "The following example uses the custom <dateformat/> element developed in the previous steps in a Spring XML configuration file: 460", "chunk_char_count": 131, "chunk_word_count": 20, "chunk_token_count": 32.75}, {"page_number": 461, "sentence_chunk": "<?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:myns=\"http://www.mycompany.example/schema/myns\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.mycompany.example/schema/myns http://www.mycompany.com/schema/myns/myns.xsd\"> \u00a0  <!--as a top-level bean --> \u00a0  <myns:dateformat id=\"defaultDateFormat\" pattern=\"yyyy-MM-dd HH:mm\" lenient=\"true\"/> \u2460 \u00a0  <bean id=\"jobDetailTemplate\" abstract=\"true\"> \u00a0    <property name=\"dateFormat\"> \u00a0      <!--as an inner bean --> \u00a0      <myns:dateformat pattern=\"HH:mm MM-dd-yyyy\"/> \u00a0    </property> \u00a0  </bean> </beans> \u2460 Our custom bean. More Detailed Examples This section presents some more detailed examples of custom XML extensions. Nesting Custom Elements within Custom Elements The example presented in this section shows how you to write the various artifacts required to satisfy a target of the following configuration: 461", "chunk_char_count": 1078, "chunk_word_count": 129, "chunk_token_count": 269.5}, {"page_number": 462, "sentence_chunk": "<?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:foo=\"http://www.foo.example/schema/component\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.foo.example/schema/component http://www.foo.example/schema/component/component.xsd\"> \u00a0  <foo:component id=\"bionic-family\" name=\"Bionic-1\"> \u00a0    <foo:component name=\"Mother-1\"> \u00a0      <foo:component name=\"Karate-1\"/> \u00a0      <foo:component name=\"Sport-1\"/> \u00a0    </foo:component> \u00a0    <foo:component name=\"Rock-1\"/> \u00a0  </foo:component> </beans> The preceding configuration nests custom extensions within each other. The class that is actually configured by the <foo:component/> element is the Component class (shown in the next example). Notice how the Component class does not expose a setter method for the components property. This makes it hard (or rather impossible) to configure a bean definition for the Component class by using setter injection. The following listing shows the Component class: 462", "chunk_char_count": 1164, "chunk_word_count": 139, "chunk_token_count": 291.0}, {"page_number": 463, "sentence_chunk": "Java package com.foo; import java.util. ArrayList; import java.util. List; public class Component { \u00a0  private String name; \u00a0  private List<Component> components = new ArrayList<Component> (); \u00a0  // mmm, there is no setter method for the 'components' \u00a0  public void addComponent(Component component) { \u00a0    this.components.add(component); \u00a0  } \u00a0  public List<Component> getComponents() { \u00a0    return components; \u00a0  } \u00a0  public String getName() { \u00a0    return name; \u00a0  } \u00a0  public void setName(String name) { \u00a0    this.name = name; \u00a0  } } Kotlin package com.foo import java.util. ArrayList class Component { \u00a0  var name: String?= null \u00a0  private val components = ArrayList<Component>() \u00a0  // mmm, there is no setter method for the 'components' \u00a0  fun addComponent(component: Component) { \u00a0    this.components.add(component) \u00a0  } \u00a0  fun getComponents(): List<Component> { \u00a0    return components \u00a0  } } 463", "chunk_char_count": 902, "chunk_word_count": 167, "chunk_token_count": 225.5}, {"page_number": 464, "sentence_chunk": "The typical solution to this issue is to create a custom FactoryBean that exposes a setter property for the components property. The following listing shows such a custom FactoryBean: Java package com.foo; import org.springframework.beans.factory. FactoryBean; import java.util. List; public class ComponentFactoryBean implements FactoryBean<Component> { \u00a0  private Component parent; \u00a0  private List<Component> children; \u00a0  public void setParent(Component parent) { \u00a0    this.parent = parent; \u00a0  } \u00a0  public void setChildren(List<Component> children) { \u00a0    this.children = children; \u00a0  } \u00a0  public Component getObject() throws Exception { \u00a0    if (this.children != null && this.children.size() > 0) { \u00a0      for (Component child : children) { \u00a0        this.parent.addComponent(child); \u00a0      } \u00a0    } \u00a0    return this.parent; \u00a0  } \u00a0  public Class<Component> getObjectType() { \u00a0    return Component.class; \u00a0  } \u00a0  public boolean isSingleton() { \u00a0    return true; \u00a0  } } 464", "chunk_char_count": 973, "chunk_word_count": 183, "chunk_token_count": 243.25}, {"page_number": 465, "sentence_chunk": "Kotlin package com.foo import org.springframework.beans.factory. FactoryBean import org.springframework.stereotype. Component class ComponentFactoryBean : FactoryBean<Component> { \u00a0  private var parent: Component?= null \u00a0  private var children: List<Component>?= null \u00a0  fun setParent(parent: Component) { \u00a0    this.parent = parent \u00a0  } \u00a0  fun setChildren(children: List<Component>) { \u00a0    this.children = children \u00a0  } \u00a0  override fun getObject(): Component? {\u00a0    if (this.children != null && this.children!!.isNotEmpty()) { \u00a0      for (child in children!!) {\u00a0        this.parent!!.addComponent(child) \u00a0      } \u00a0    } \u00a0    return this.parent \u00a0  } \u00a0  override fun getObjectType(): Class<Component>? {\u00a0    return Component::class.java \u00a0  } \u00a0  override fun isSingleton(): Boolean { \u00a0    return true \u00a0  } } This works nicely, but it exposes a lot of Spring plumbing to the end user. What we are going to do is write a custom extension that hides away all of this Spring plumbing.", "chunk_char_count": 977, "chunk_word_count": 183, "chunk_token_count": 244.25}, {"page_number": 465, "sentence_chunk": "If we stick to the steps described previously, we start off by creating the XSD schema to define the structure of our custom tag, as the following listing shows: 465", "chunk_char_count": 165, "chunk_word_count": 30, "chunk_token_count": 41.25}, {"page_number": 466, "sentence_chunk": "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?> <xsd:schema xmlns=\"http://www.foo.example/schema/component\" \u00a0    xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" \u00a0    targetNamespace=\"http://www.foo.example/schema/component\" \u00a0    elementFormDefault=\"qualified\" \u00a0    attributeFormDefault=\"unqualified\"> \u00a0  <xsd:element name=\"component\"> \u00a0    <xsd:complexType> \u00a0      <xsd:choice minOccurs=\"0\" maxOccurs=\"unbounded\"> \u00a0        <xsd:element ref=\"component\"/> \u00a0      </xsd:choice> \u00a0      <xsd:attribute name=\"id\" type=\"xsd:ID\"/> \u00a0      <xsd:attribute name=\"name\" use=\"required\" type=\"xsd:string\"/> \u00a0    </xsd:complexType> \u00a0  </xsd:element> </xsd:schema> Again following the process described earlier, we then create a custom NamespaceHandler: Java package com.foo; import org.springframework.beans.factory.xml. NamespaceHandlerSupport; public class ComponentNamespaceHandler extends NamespaceHandlerSupport { \u00a0  public void init() { \u00a0    registerBeanDefinitionParser(\"component\", new ComponentBeanDefinitionParser()); \u00a0  } } Kotlin package com.foo import org.springframework.beans.factory.xml. NamespaceHandlerSupport class ComponentNamespaceHandler : NamespaceHandlerSupport() { \u00a0  override fun init() { \u00a0    registerBeanDefinitionParser(\"component\", ComponentBeanDefinitionParser()) \u00a0  } } 466", "chunk_char_count": 1293, "chunk_word_count": 158, "chunk_token_count": 323.25}, {"page_number": 467, "sentence_chunk": "Next up is the custom BeanDefinitionParser. Remember that we are creating a BeanDefinition that describes a ComponentFactoryBean. The following listing shows our custom BeanDefinitionParser implementation: Java package com.foo; import org.springframework.beans.factory.config. BeanDefinition; import org.springframework.beans.factory.support. AbstractBeanDefinition; import org.springframework.beans.factory.support. BeanDefinitionBuilder; import org.springframework.beans.factory.support. ManagedList; import org.springframework.beans.factory.xml. AbstractBeanDefinitionParser; import org.springframework.beans.factory.xml. ParserContext; import org.springframework.util.xml. DomUtils; import org.w3c.dom.", "chunk_char_count": 706, "chunk_word_count": 51, "chunk_token_count": 176.5}, {"page_number": 467, "sentence_chunk": "Element; import java.util. List; public class ComponentBeanDefinitionParser extends AbstractBeanDefinitionParser { \u00a0  protected AbstractBeanDefinition parseInternal(Element element, ParserContext parserContext) { \u00a0    return parseComponentElement(element); \u00a0  } \u00a0  private static AbstractBeanDefinition parseComponentElement(Element element) { \u00a0    BeanDefinitionBuilder factory = BeanDefinitionBuilder.rootBeanDefinition(ComponentFactoryBean.class); \u00a0    factory.addPropertyValue(\"parent\", parseComponent(element)); \u00a0    List<Element> childElements = DomUtils.getChildElementsByTagName(element, \"component\"); \u00a0    if (childElements != null && childElements.size() > 0) { \u00a0      parseChildComponents(childElements, factory); \u00a0    } \u00a0    return factory.getBeanDefinition(); \u00a0  } \u00a0  private static BeanDefinition parseComponent(Element element) { \u00a0    BeanDefinitionBuilder component = BeanDefinitionBuilder.rootBeanDefinition(Component.class); \u00a0    component.addPropertyValue(\"name\", element.getAttribute(\"name\")); \u00a0    return component.getBeanDefinition(); \u00a0  } \u00a0  private static void parseChildComponents(List<Element> childElements, BeanDefinitionBuilder factory) { \u00a0    ManagedList<BeanDefinition> children = new ManagedList<BeanDefinition>(childElements.size()); 467", "chunk_char_count": 1270, "chunk_word_count": 145, "chunk_token_count": 317.5}, {"page_number": 468, "sentence_chunk": "for (Element element : childElements) { \u00a0      children.add(parseComponentElement(element)); \u00a0    } \u00a0    factory.addPropertyValue(\"children\", children); \u00a0  } } 468", "chunk_char_count": 163, "chunk_word_count": 29, "chunk_token_count": 40.75}, {"page_number": 469, "sentence_chunk": "Kotlin package com.foo import org.springframework.beans.factory.config. BeanDefinition import org.springframework.beans.factory.support. AbstractBeanDefinition import org.springframework.beans.factory.support. BeanDefinitionBuilder import org.springframework.beans.factory.support. ManagedList import org.springframework.beans.factory.xml. AbstractBeanDefinitionParser import org.springframework.beans.factory.xml. ParserContext import org.springframework.util.xml. DomUtils import org.w3c.dom. Element import java.util. List class ComponentBeanDefinitionParser : AbstractBeanDefinitionParser() { \u00a0  override fun parseInternal(element: Element, parserContext: ParserContext): AbstractBeanDefinition? {", "chunk_char_count": 701, "chunk_word_count": 45, "chunk_token_count": 175.25}, {"page_number": 469, "sentence_chunk": "return parseComponentElement(element) \u00a0  } \u00a0  private fun parseComponentElement(element: Element): AbstractBeanDefinition { \u00a0    val factory = BeanDefinitionBuilder.rootBeanDefinition(ComponentFactoryBean::class.java) \u00a0    factory.addPropertyValue(\"parent\", parseComponent(element)) \u00a0    val childElements = DomUtils.getChildElementsByTagName(element, \"component\") \u00a0    if (childElements != null && childElements.size > 0) { \u00a0      parseChildComponents(childElements, factory) \u00a0    } \u00a0    return factory.getBeanDefinition() \u00a0  } \u00a0  private fun parseComponent(element: Element): BeanDefinition { \u00a0    val component = BeanDefinitionBuilder.rootBeanDefinition(Component::class.java) \u00a0    component.addPropertyValue(\"name\", element.getAttribute(\"name\")) \u00a0    return component.beanDefinition \u00a0  } \u00a0  private fun parseChildComponents(childElements: List<Element>, factory: BeanDefinitionBuilder) { \u00a0    val children = ManagedList<BeanDefinition>(childElements.size) \u00a0    for (element in childElements) { \u00a0      children.add(parseComponentElement(element)) \u00a0    } \u00a0    factory.addPropertyValue(\"children\", children) \u00a0  } } 469", "chunk_char_count": 1119, "chunk_word_count": 151, "chunk_token_count": 279.75}, {"page_number": 470, "sentence_chunk": "Finally, the various artifacts need to be registered with the Spring XML infrastructure, by modifying the META-INF/spring.handlers and META-INF/spring.schemas files, as follows: # in 'META-INF/spring.handlers' http\\://www.foo.example/schema/component=com.foo. ComponentNamespaceHandler # in 'META-INF/spring.schemas' http\\://www.foo.example/schema/component/component.xsd=com/foo/component.xsd Custom Attributes on \u201cNormal\u201d Elements Writing your own custom parser and the associated artifacts is not hard. However, it is sometimes not the right thing to do. Consider a scenario where you need to add metadata to already existing bean definitions. In this case, you certainly do not want to have to write your own entire custom extension. Rather, you merely want to add an additional attribute to the existing bean definition element. By way of another example, suppose that you define a bean definition for a service object that (unknown to it) accesses a clustered JCache, and you want to ensure that the named JCache instance is eagerly started within the surrounding cluster. The following listing shows such a definition: <bean id=\"checkingAccountService\" class=\"com.foo. DefaultCheckingAccountService\" \u00a0    jcache:cache-name=\"checking.account\"> \u00a0  <!--other dependencies here... --> </bean> We can then create another BeanDefinition when the 'jcache:cache-name' attribute is parsed.", "chunk_char_count": 1387, "chunk_word_count": 180, "chunk_token_count": 346.75}, {"page_number": 470, "sentence_chunk": "This BeanDefinition then initializes the named JCache for us. We can also modify the existing BeanDefinition for the 'checkingAccountService' so that it has a dependency on this new JCache- initializing BeanDefinition. The following listing shows our JCacheInitializer: 470", "chunk_char_count": 273, "chunk_word_count": 38, "chunk_token_count": 68.25}, {"page_number": 471, "sentence_chunk": "Java package com.foo; public class JCacheInitializer { \u00a0  private String name; \u00a0  public JCacheInitializer(String name) { \u00a0    this.name = name; \u00a0  } \u00a0  public void initialize() { \u00a0    // lots of JCache API calls to initialize the named cache... \u00a0  } } Kotlin package com.foo class JCacheInitializer(private val name: String) { \u00a0  fun initialize() { \u00a0    // lots of JCache API calls to initialize the named cache... \u00a0  } } Now we can move onto the custom extension. First, we need to author the XSD schema that describes the custom attribute, as follows: <?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?> <xsd:schema xmlns=\"http://www.foo.example/schema/jcache\" \u00a0    xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" \u00a0    targetNamespace=\"http://www.foo.example/schema/jcache\" \u00a0    elementFormDefault=\"qualified\"> \u00a0  <xsd:attribute name=\"cache-name\" type=\"xsd:string\"/> </xsd:schema> Next, we need to create the associated NamespaceHandler, as follows: 471", "chunk_char_count": 956, "chunk_word_count": 147, "chunk_token_count": 239.0}, {"page_number": 472, "sentence_chunk": "Java package com.foo; import org.springframework.beans.factory.xml. NamespaceHandlerSupport; public class JCacheNamespaceHandler extends NamespaceHandlerSupport { \u00a0  public void init() { \u00a0    super.registerBeanDefinitionDecoratorForAttribute(\"cache-name\", \u00a0      new JCacheInitializingBeanDefinitionDecorator()); \u00a0  } } Kotlin package com.foo import org.springframework.beans.factory.xml. NamespaceHandlerSupport class JCacheNamespaceHandler : NamespaceHandlerSupport() { \u00a0  override fun init() { \u00a0    super.registerBeanDefinitionDecoratorForAttribute(\"cache-name\", \u00a0        JCacheInitializingBeanDefinitionDecorator()) \u00a0  } } Next, we need to create the parser. Note that, in this case, because we are going to parse an XML attribute, we write a BeanDefinitionDecorator rather than a BeanDefinitionParser. The following listing shows our BeanDefinitionDecorator implementation: Java package com.foo; import org.springframework.beans.factory.config. BeanDefinitionHolder; import org.springframework.beans.factory.support. AbstractBeanDefinition; import org.springframework.beans.factory.support. BeanDefinitionBuilder; import org.springframework.beans.factory.xml. BeanDefinitionDecorator; import org.springframework.beans.factory.xml. ParserContext; import org.w3c.dom.", "chunk_char_count": 1270, "chunk_word_count": 126, "chunk_token_count": 317.5}, {"page_number": 473, "sentence_chunk": "public class JCacheInitializingBeanDefinitionDecorator implements BeanDefinitionDecorator { \u00a0  private static final String[] EMPTY_STRING_ARRAY = new String[0]; \u00a0  public BeanDefinitionHolder decorate(Node source, BeanDefinitionHolder holder, \u00a0      ParserContext ctx) { \u00a0    String initializerBeanName = registerJCacheInitializer(source, ctx); \u00a0    createDependencyOnJCacheInitializer(holder, initializerBeanName); \u00a0    return holder; \u00a0  } \u00a0  private void createDependencyOnJCacheInitializer(BeanDefinitionHolder holder, \u00a0      String initializerBeanName) { \u00a0    AbstractBeanDefinition definition = ((AbstractBeanDefinition) holder.getBeanDefinition()); \u00a0    String[] dependsOn = definition.getDependsOn(); \u00a0    if (dependsOn == null) { \u00a0      dependsOn = new String[]{initializerBeanName}; \u00a0    } else { \u00a0      List dependencies = new ArrayList(Arrays.asList(dependsOn)); \u00a0      dependencies.add(initializerBeanName); \u00a0      dependsOn = (String[]) dependencies.toArray(EMPTY_STRING_ARRAY); \u00a0    } \u00a0    definition.setDependsOn(dependsOn); \u00a0  } \u00a0  private String registerJCacheInitializer(Node source, ParserContext ctx) { \u00a0    String cacheName = ((Attr) source).getValue(); \u00a0    String beanName = cacheName + \"-initializer\"; \u00a0    if (!ctx.getRegistry().containsBeanDefinition(beanName)) { \u00a0      BeanDefinitionBuilder initializer = BeanDefinitionBuilder.rootBeanDefinition(JCacheInitializer.class); \u00a0      initializer.addConstructorArg(cacheName); \u00a0      ctx.getRegistry().registerBeanDefinition(beanName, initializer.getBeanDefinition()); \u00a0    } \u00a0    return beanName; \u00a0  } } 473", "chunk_char_count": 1580, "chunk_word_count": 232, "chunk_token_count": 395.0}, {"page_number": 474, "sentence_chunk": "Kotlin package com.foo import org.springframework.beans.factory.config. BeanDefinitionHolder import org.springframework.beans.factory.support. AbstractBeanDefinition import org.springframework.beans.factory.support. BeanDefinitionBuilder import org.springframework.beans.factory.xml. BeanDefinitionDecorator import org.springframework.beans.factory.xml. ParserContext import org.w3c.dom. Attr import org.w3c.dom. Node import java.util. ArrayList class JCacheInitializingBeanDefinitionDecorator : BeanDefinitionDecorator { \u00a0  override fun decorate(source: Node, holder: BeanDefinitionHolder, \u00a0            ctx: ParserContext): BeanDefinitionHolder { \u00a0    val initializerBeanName = registerJCacheInitializer(source, ctx) \u00a0    createDependencyOnJCacheInitializer(holder, initializerBeanName) \u00a0    return holder \u00a0  } \u00a0  private fun createDependencyOnJCacheInitializer(holder: BeanDefinitionHolder, \u00a0                          initializerBeanName: String) { \u00a0    val definition = holder.beanDefinition as AbstractBeanDefinition \u00a0    var dependsOn = definition.dependsOn \u00a0    dependsOn = if (dependsOn == null) { \u00a0      arrayOf(initializerBeanName) \u00a0    } else { \u00a0      val dependencies = ArrayList(listOf(*dependsOn)) \u00a0      dependencies.add(initializerBeanName) \u00a0      dependencies.toTypedArray() \u00a0    } \u00a0    definition.setDependsOn(*dependsOn) \u00a0  } \u00a0  private fun registerJCacheInitializer(source: Node, ctx: ParserContext): String { \u00a0    val cacheName = (source as Attr).value \u00a0    val beanName = \"$cacheName-initializer\" \u00a0    if (!ctx.registry.containsBeanDefinition(beanName)) { \u00a0      val initializer = BeanDefinitionBuilder.rootBeanDefinition(JCacheInitializer::class.java) \u00a0      initializer.addConstructorArg(cacheName) \u00a0      ctx.registry.registerBeanDefinition(beanName, initializer.getBeanDefinition()) \u00a0    } \u00a0    return beanName \u00a0  } } 474", "chunk_char_count": 1846, "chunk_word_count": 271, "chunk_token_count": 461.5}, {"page_number": 475, "sentence_chunk": "Finally, we need to register the various artifacts with the Spring XML infrastructure by modifying the META-INF/spring.handlers and META-INF/spring.schemas files, as follows: # in 'META-INF/spring.handlers' http\\://www.foo.example/schema/jcache=com.foo. JCacheNamespaceHandler # in 'META-INF/spring.schemas' http\\://www.foo.example/schema/jcache/jcache.xsd=com/foo/jcache.xsd 2.11.3. Application Startup Steps This part of the appendix lists the existing StartupSteps that the core container is instrumented with.\uf071 The name and detailed information about each startup step is not part of the public contract and is subject to change; this is considered as an implementation detail of the core container and will follow its behavior changes. Table 15. Application startup steps defined in the core container Name Description Tags spring.beans.instantiate Instantiation of a bean and its dependencies.beanName the name of the bean, beanType the type required at the injection point.spring.beans.smart-initialize Initialization of SmartInitializingSingleton beans.beanName the name of the bean.spring.context.annotated-bean- reader.create Creation of the AnnotatedBeanDefinitionReader.", "chunk_char_count": 1182, "chunk_word_count": 137, "chunk_token_count": 295.5}, {"page_number": 475, "sentence_chunk": "spring.context.base- packages.scan Scanning of base packages.packages array of base packages for scanning.spring.context.beans.post- process Beans post-processing phase.spring.context.bean- factory.post-process Invocation of the BeanFactoryPostProcessor beans.postProcessor the current post- processor.spring.context.beandef- registry.post-process Invocation of the BeanDefinitionRegistryPostProc essor beans.postProcessor the current post- processor.spring.context.component- classes.register Registration of component classes through AnnotationConfigApplicationCon text#register.classes array of given classes for registration.475", "chunk_char_count": 632, "chunk_word_count": 51, "chunk_token_count": 158.0}, {"page_number": 476, "sentence_chunk": "Name Description Tags spring.context.config- classes.enhance Enhancement of configuration classes with CGLIB proxies.classCount count of enhanced classes.spring.context.config- classes.parse Configuration classes parsing phase with the ConfigurationClassPostProcesso r. classCount count of processed classes.spring.context.refresh Application context refresh phase.476", "chunk_char_count": 368, "chunk_word_count": 34, "chunk_token_count": 92.0}, {"page_number": 477, "sentence_chunk": "Chapter 3. Testing This chapter covers Spring\u2019s support for integration testing and best practices for unit testing. The Spring team advocates test-driven development (TDD). The Spring team has found that the correct use of inversion of control (IoC) certainly does make both unit and integration testing easier (in that the presence of setter methods and appropriate constructors on classes makes them easier to wire together in a test without having to set up service locator registries and similar structures).3.1. Introduction to Spring Testing Testing is an integral part of enterprise software development. This chapter focuses on the value added by the IoC principle to unit testing and on the benefits of the Spring Framework\u2019s support for integration testing. (A thorough treatment of testing in the enterprise is beyond the scope of this reference manual.)3.2. Unit Testing Dependency injection should make your code less dependent on the container than it would be with traditional J2EE / Java EE development.", "chunk_char_count": 1020, "chunk_word_count": 158, "chunk_token_count": 255.0}, {"page_number": 477, "sentence_chunk": "The POJOs that make up your application should be testable in JUnit or TestNG tests, with objects instantiated by using the new operator, without Spring or any other container. You can use mock objects (in conjunction with other valuable testing techniques) to test your code in isolation. If you follow the architecture recommendations for Spring, the resulting clean layering and componentization of your codebase facilitate easier unit testing. For example, you can test service layer objects by stubbing or mocking DAO or repository interfaces, without needing to access persistent data while running unit tests. True unit tests typically run extremely quickly, as there is no runtime infrastructure to set up. Emphasizing true unit tests as part of your development methodology can boost your productivity. You may not need this section of the testing chapter to help you write effective unit tests for your IoC-based applications. For certain unit testing scenarios, however, the Spring Framework provides mock objects and testing support classes, which are described in this chapter.3.2.1. Mock Objects Spring includes a number of packages dedicated to mocking: \u2022 Environment \u2022 JNDI \u2022 Servlet API \u2022 Spring Web Reactive Environment The org.springframework.mock.env package contains mock implementations of the Environment and PropertySource abstractions (see Bean Definition Profiles and PropertySource Abstraction).", "chunk_char_count": 1422, "chunk_word_count": 209, "chunk_token_count": 355.5}, {"page_number": 478, "sentence_chunk": "that depends on environment-specific properties. JNDI The org.springframework.mock.jndi package contains a partial implementation of the JNDI SPI, which you can use to set up a simple JNDI environment for test suites or stand-alone applications. If, for example, JDBC DataSource instances get bound to the same JNDI names in test code as they do in a Jakarta EE container, you can reuse both application code and configuration in testing scenarios without modification.\uf071 The mock JNDI support in the org.springframework.mock.jndi package is officially deprecated as of Spring Framework 5.2 in favor of complete solutions from third parties such as Simple-JNDI. Servlet API The org.springframework.mock.web package contains a comprehensive set of Servlet API mock objects that are useful for testing web contexts, controllers, and filters. These mock objects are targeted at usage with Spring\u2019s Web MVC framework and are generally more convenient to use than dynamic mock objects (such as EasyMock) or alternative Servlet API mock objects (such as MockObjects).\uf0eb Since Spring Framework 6.0, the mock objects in org.springframework.mock.web are based on the Servlet 6.0 API. The Spring MVC Test framework builds on the mock Servlet API objects to provide an integration testing framework for Spring MVC. See MockMvc. Spring Web Reactive The org.springframework.mock.http.server.reactive package contains mock implementations of ServerHttpRequest and ServerHttpResponse for use in WebFlux applications.", "chunk_char_count": 1499, "chunk_word_count": 214, "chunk_token_count": 374.75}, {"page_number": 478, "sentence_chunk": "The org.springframework.mock.web.server package contains a mock ServerWebExchange that depends on those mock request and response objects. Both MockServerHttpRequest and MockServerHttpResponse extend from the same abstract base classes as server-specific implementations and share behavior with them. For example, a mock request is immutable once created, but you can use the mutate() method from ServerHttpRequest to create a modified instance. In order for the mock response to properly implement the write contract and return a write completion handle (that is, Mono<Void>), it by default uses a Flux with cache().then(), which buffers the data and makes it available for assertions in tests. Applications can set a custom write function (for example, to test an infinite stream). The WebTestClient builds on the mock request and response to provide support for testing WebFlux applications without an HTTP server. The client can also be used for end-to-end tests with a running server.478", "chunk_char_count": 992, "chunk_word_count": 146, "chunk_token_count": 248.0}, {"page_number": 479, "sentence_chunk": "3.2.2. Unit Testing Support Classes Spring includes a number of classes that can help with unit testing. They fall into two categories: \u2022 General Testing Utilities \u2022 Spring MVC Testing Utilities General Testing Utilities The org.springframework.test.util package contains several general purpose utilities for use in unit and integration testing. AopTestUtils is a collection of AOP-related utility methods. You can use these methods to obtain a reference to the underlying target object hidden behind one or more Spring proxies. For example, if you have configured a bean as a dynamic mock by using a library such as EasyMock or Mockito, and the mock is wrapped in a Spring proxy, you may need direct access to the underlying mock to configure expectations on it and perform verifications. For Spring\u2019s core AOP utilities, see AopUtils and AopProxyUtils. ReflectionTestUtils is a collection of reflection-based utility methods. You can use these methods in testing scenarios where you need to change the value of a constant, set a non-public field, invoke a non-public setter method, or invoke a non-public configuration or lifecycle callback method when testing application code for use cases such as the following: \u2022 ORM frameworks (such as JPA and Hibernate) that condone private or protected field access as opposed to public setter methods for properties in a domain entity. \u2022Spring\u2019s support for annotations (such as @Autowired, @Inject, and @Resource), that provide dependency injection for private or protected fields, setter methods, and configuration methods. \u2022", "chunk_char_count": 1572, "chunk_word_count": 241, "chunk_token_count": 393.0}, {"page_number": 479, "sentence_chunk": "Use of annotations such as @PostConstruct and @PreDestroy for lifecycle callback methods. TestSocketUtils is a simple utility for finding available TCP ports on localhost for use in integration testing scenarios.\uf05a TestSocketUtils can be used in integration tests which start an external server on an available random port. However, these utilities make no guarantee about the subsequent availability of a given port and are therefore unreliable. Instead of using TestSocketUtils to find an available local port for a server, it is recommended that you rely on a server\u2019s ability to start on a random ephemeral port that it selects or is assigned by the operating system. To interact with that server, you should query the server for the port it is currently using. Spring MVC Testing Utilities The org.springframework.test.web package contains ModelAndViewAssert, which you can use in combination with JUnit, TestNG, or any other testing framework for unit tests that deal with Spring MVC ModelAndView objects.479", "chunk_char_count": 1013, "chunk_word_count": 155, "chunk_token_count": 253.25}, {"page_number": 480, "sentence_chunk": "\uf0eb Unit testing Spring MVC Controllers To unit test your Spring MVC Controller classes as POJOs, use ModelAndViewAssert combined with MockHttpServletRequest, MockHttpSession, and so on from Spring\u2019s Servlet API mocks. For thorough integration testing of your Spring MVC and REST Controller classes in conjunction with your WebApplicationContext configuration for Spring MVC, use the Spring MVC Test Framework instead.3.3. Integration Testing This section (most of the rest of this chapter) covers integration testing for Spring applications. It includes the following topics: \u2022 Overview \u2022 Goals of Integration Testing \u2022 JDBC Testing Support \u2022 Annotations \u2022 Spring TestContext Framework \u2022 MockMvc 3.3.1. Overview It is important to be able to perform some integration testing without requiring deployment to your application server or connecting to other enterprise infrastructure. Doing so lets you test things such as: \u2022 The correct wiring of your Spring IoC container contexts. \u2022Data access using JDBC or an ORM tool. This can include such things as the correctness of SQL statements, Hibernate queries, JPA entity mappings, and so forth. The Spring Framework provides first-class support for integration testing in the spring-test module.", "chunk_char_count": 1240, "chunk_word_count": 183, "chunk_token_count": 310.0}, {"page_number": 480, "sentence_chunk": "The name of the actual JAR file might include the release version and might also be in the long org.springframework.test form, depending on where you get it from (see the section on Dependency Management for an explanation). This library includes the org.springframework.test package, which contains valuable classes for integration testing with a Spring container. This testing does not rely on an application server or other deployment environment. Such tests are slower to run than unit tests but much faster than the equivalent Selenium tests or remote tests that rely on deployment to an application server. Unit and integration testing support is provided in the form of the annotation-driven Spring TestContext Framework. The TestContext framework is agnostic of the actual testing framework in use, which allows instrumentation of tests in various environments, including JUnit, TestNG, and others.480", "chunk_char_count": 909, "chunk_word_count": 136, "chunk_token_count": 227.25}, {"page_number": 481, "sentence_chunk": "3.3.2. Goals of Integration Testing Spring\u2019s integration testing support has the following primary goals: \u2022 To manage Spring IoC container caching between tests. \u2022To provide Dependency Injection of test fixture instances. \u2022To provide transaction management appropriate to integration testing. \u2022To supply Spring-specific base classes that assist developers in writing integration tests. The next few sections describe each goal and provide links to implementation and configuration details. Context Management and Caching The Spring TestContext Framework provides consistent loading of Spring ApplicationContext instances and WebApplicationContext instances as well as caching of those contexts. Support for the caching of loaded contexts is important, because startup time can become an issue\u2009\u2014\u2009not because of the overhead of Spring itself, but because the objects instantiated by the Spring container take time to instantiate. For example, a project with 50 to 100 Hibernate mapping files might take 10 to 20 seconds to load the mapping files, and incurring that cost before running every test in every test fixture leads to slower overall test runs that reduce developer productivity. Test classes typically declare either an array of resource locations for XML or Groovy configuration metadata\u2009\u2014\u2009often in the classpath\u2009\u2014\u2009or an array of component classes that is used to configure the application.", "chunk_char_count": 1399, "chunk_word_count": 202, "chunk_token_count": 349.75}, {"page_number": 481, "sentence_chunk": "These locations or classes are the same as or similar to those specified in web.xml or other configuration files for production deployments. By default, once loaded, the configured ApplicationContext is reused for each test. Thus, the setup cost is incurred only once per test suite, and subsequent test execution is much faster. In this context, the term \u201ctest suite\u201d means all tests run in the same JVM\u2009\u2014\u2009for example, all tests run from an Ant, Maven, or Gradle build for a given project or module. In the unlikely case that a test corrupts the application context and requires reloading (for example, by modifying a bean definition or the state of an application object) the TestContext framework can be configured to reload the configuration and rebuild the application context before executing the next test. See Context Management and Context Caching with the TestContext framework. Dependency Injection of Test Fixtures When the TestContext framework loads your application context, it can optionally configure instances of your test classes by using Dependency Injection. This provides a convenient mechanism for setting up test fixtures by using preconfigured beans from your application context. A strong benefit here is that you can reuse application contexts across various testing scenarios (for example, for configuring Spring-managed object graphs, transactional proxies, DataSource instances, and others), thus avoiding the need to duplicate complex test fixture setup for individual test cases. As an example, consider a scenario where we have a class (HibernateTitleRepository) that implements data access logic for a Title domain entity.", "chunk_char_count": 1656, "chunk_word_count": 250, "chunk_token_count": 414.0}, {"page_number": 482, "sentence_chunk": "the following areas: \u2022 The Spring configuration: Basically, is everything related to the configuration of the HibernateTitleRepository bean correct and present? \u2022The Hibernate mapping file configuration: Is everything mapped correctly and are the correct lazy-loading settings in place? \u2022The logic of the HibernateTitleRepository: Does the configured instance of this class perform as anticipated?See dependency injection of test fixtures with the TestContext framework. Transaction Management One common issue in tests that access a real database is their effect on the state of the persistence store. Even when you use a development database, changes to the state may affect future tests. Also, many operations\u2009\u2014\u2009such as inserting or modifying persistent data\u2009\u2014\u2009cannot be performed (or verified) outside of a transaction. The TestContext framework addresses this issue. By default, the framework creates and rolls back a transaction for each test. You can write code that can assume the existence of a transaction.", "chunk_char_count": 1016, "chunk_word_count": 147, "chunk_token_count": 254.0}, {"page_number": 482, "sentence_chunk": "If you call transactionally proxied objects in your tests, they behave correctly, according to their configured transactional semantics. In addition, if a test method deletes the contents of selected tables while running within the transaction managed for the test, the transaction rolls back by default, and the database returns to its state prior to execution of the test. Transactional support is provided to a test by using a PlatformTransactionManager bean defined in the test\u2019s application context. If you want a transaction to commit (unusual, but occasionally useful when you want a particular test to populate or modify the database), you can tell the TestContext framework to cause the transaction to commit instead of roll back by using the @Commit annotation. See transaction management with the TestContext framework. Support Classes for Integration Testing The Spring TestContext Framework provides several abstract support classes that simplify the writing of integration tests. These base test classes provide well-defined hooks into the testing framework as well as convenient instance variables and methods, which let you access: \u2022 The ApplicationContext, for performing explicit bean lookups or testing the state of the context as a whole. \u2022A JdbcTemplate, for executing SQL statements to query the database. You can use such queries to confirm database state both before and after execution of database-related application code, and Spring ensures that such queries run in the scope of the same transaction as the application code. When used in conjunction with an ORM tool, be sure to avoid false positives.", "chunk_char_count": 1628, "chunk_word_count": 249, "chunk_token_count": 407.0}, {"page_number": 482, "sentence_chunk": "In addition, you may want to create your own custom, application-wide superclass with instance variables and methods specific to your project.482", "chunk_char_count": 145, "chunk_word_count": 21, "chunk_token_count": 36.25}, {"page_number": 483, "sentence_chunk": "See support classes for the TestContext framework.3.3.3. JDBC Testing Support The org.springframework.test.jdbc package contains JdbcTestUtils, which is a collection of JDBC- related utility functions intended to simplify standard database testing scenarios. Specifically, JdbcTestUtils provides the following static utility methods. \u2022countRowsInTable(..): Counts the number of rows in the given table. \u2022countRowsInTableWhere(..): Counts the number of rows in the given table by using the provided WHERE clause. \u2022deleteFromTables(..): Deletes all rows from the specified tables. \u2022deleteFromTableWhere(..): Deletes rows from the given table by using the provided WHERE clause. \u2022dropTables(..): Drops the specified tables.\uf0eb AbstractTransactionalJUnit4SpringContextTests and AbstractTransactionalTestNGSpringContextTests provide convenience methods that delegate to the aforementioned methods in JdbcTestUtils.", "chunk_char_count": 907, "chunk_word_count": 105, "chunk_token_count": 226.75}, {"page_number": 483, "sentence_chunk": "The spring-jdbc module provides support for configuring and launching an embedded database, which you can use in integration tests that interact with a database. For details, see Embedded Database Support and Testing Data Access Logic with an Embedded Database.3.3.4. Annotations This section covers annotations that you can use when you test Spring applications. It includes the following topics: \u2022 Spring Testing Annotations \u2022 Standard Annotation Support \u2022 Spring JUnit 4 Testing Annotations \u2022 Spring JUnit Jupiter Testing Annotations \u2022 Meta-Annotation Support for Testing Spring Testing Annotations The Spring Framework provides the following set of Spring-specific annotations that you can use in your unit and integration tests in conjunction with the TestContext framework. See the corresponding javadoc for further information, including default attribute values, attribute aliases, and other details. Spring\u2019s testing annotations include the following: \u2022 @BootstrapWith \u2022 @ContextConfiguration 483", "chunk_char_count": 1005, "chunk_word_count": 139, "chunk_token_count": 251.25}, {"page_number": 484, "sentence_chunk": "\u2022 @WebAppConfiguration \u2022 @ContextHierarchy \u2022 @ActiveProfiles \u2022 @TestPropertySource \u2022 @DynamicPropertySource \u2022 @DirtiesContext \u2022 @TestExecutionListeners \u2022 @RecordApplicationEvents \u2022 @Commit \u2022 @Rollback \u2022 @BeforeTransaction \u2022 @AfterTransaction \u2022 @Sql \u2022 @SqlConfig \u2022 @SqlMergeMode \u2022 @SqlGroup @BootstrapWith @BootstrapWith is a class-level annotation that you can use to configure how the Spring TestContext Framework is bootstrapped. Specifically, you can use @BootstrapWith to specify a custom TestContextBootstrapper. See the section on bootstrapping the TestContext framework for further details.@ContextConfiguration @ContextConfiguration defines class-level metadata that is used to determine how to load and configure an ApplicationContext for integration tests. Specifically, @ContextConfiguration declares the application context resource locations or the component classes used to load the context. Resource locations are typically XML configuration files or Groovy scripts located in the classpath, while component classes are typically @Configuration classes. However, resource locations can also refer to files and scripts in the file system, and component classes can be @Component classes, @Service classes, and so on. See Component Classes for further details. The following example shows a @ContextConfiguration annotation that refers to an XML file: Java @ContextConfiguration(\"/test-config.xml\") \u2460 class XmlApplicationContextTests { \u00a0  // class body... } 484", "chunk_char_count": 1474, "chunk_word_count": 187, "chunk_token_count": 368.5}, {"page_number": 485, "sentence_chunk": "\u2460 Referring to an XML file. Kotlin @ContextConfiguration(\"/test-config.xml\") \u2460 class XmlApplicationContextTests { \u00a0  // class body... } \u2460 Referring to an XML file. The following example shows a @ContextConfiguration annotation that refers to a class: Java @ContextConfiguration(classes = TestConfig.class) \u2460 class ConfigClassApplicationContextTests { \u00a0  // class body... } \u2460 Referring to a class. Kotlin @ContextConfiguration(classes = [TestConfig::class]) \u2460 class ConfigClassApplicationContextTests { \u00a0  // class body... } \u2460 Referring to a class. As an alternative or in addition to declaring resource locations or component classes, you can use @ContextConfiguration to declare ApplicationContextInitializer classes. The following example shows such a case: Java @ContextConfiguration(initializers = CustomContextInitializer.class) \u2460 class ContextInitializerTests { \u00a0  // class body... } \u2460 Declaring an initializer class. Kotlin @ContextConfiguration(initializers = [CustomContextInitializer::class]) \u2460 class ContextInitializerTests { \u00a0  // class body... } 485", "chunk_char_count": 1062, "chunk_word_count": 136, "chunk_token_count": 265.5}, {"page_number": 486, "sentence_chunk": "\u2460 Declaring an initializer class. You can optionally use @ContextConfiguration to declare the ContextLoader strategy as well. Note, however, that you typically do not need to explicitly configure the loader, since the default loader supports initializers and either resource locations or component classes. The following example uses both a location and a loader: Java @ContextConfiguration(locations = \"/test-context.xml\", loader = CustomContextLoader.class) \u2460 class CustomLoaderXmlApplicationContextTests { \u00a0  // class body... } \u2460 Configuring both a location and a custom loader. Kotlin @ContextConfiguration(\"/test-context.xml\", loader = CustomContextLoader::class) \u2460 class CustomLoaderXmlApplicationContextTests { \u00a0  // class body... } \u2460 Configuring both a location and a custom loader.\uf05a @ContextConfiguration provides support for inheriting resource locations or configuration classes as well as context initializers that are declared by superclasses or enclosing classes. See Context Management, @Nested test class configuration, and the @ContextConfiguration javadocs for further details.@WebAppConfiguration @WebAppConfiguration is a class-level annotation that you can use to declare that the ApplicationContext loaded for an integration test should be a WebApplicationContext. The mere presence of @WebAppConfiguration on a test class ensures that a WebApplicationContext is loaded for the test, using the default value of \"file:src/main/webapp\" for the path to the root of the web application (that is, the resource base path). The resource base path is used behind the scenes to create a MockServletContext, which serves as the ServletContext for the test\u2019s WebApplicationContext.", "chunk_char_count": 1692, "chunk_word_count": 225, "chunk_token_count": 423.0}, {"page_number": 487, "sentence_chunk": "Java @ContextConfiguration @WebAppConfiguration \u2460 class WebAppTests { \u00a0  // class body... } Kotlin @ContextConfiguration @WebAppConfiguration \u2460 class WebAppTests { \u00a0  // class body... } \u2460 The @WebAppConfiguration annotation. To override the default, you can specify a different base resource path by using the implicit value attribute. Both classpath: and file: resource prefixes are supported. If no resource prefix is supplied, the path is assumed to be a file system resource. The following example shows how to specify a classpath resource: Java @ContextConfiguration @WebAppConfiguration(\"classpath:test-web-resources\") \u2460 class WebAppTests { \u00a0  // class body... } \u2460 Specifying a classpath resource. Kotlin @ContextConfiguration @WebAppConfiguration(\"classpath:test-web-resources\") \u2460 class WebAppTests { \u00a0  // class body... } \u2460 Specifying a classpath resource. Note that @WebAppConfiguration must be used in conjunction with @ContextConfiguration, either within a single test class or within a test class hierarchy. See the @WebAppConfiguration javadoc for further details.@ContextHierarchy @ContextHierarchy is a class-level annotation that is used to define a hierarchy of ApplicationContext 487", "chunk_char_count": 1201, "chunk_word_count": 162, "chunk_token_count": 300.25}, {"page_number": 488, "sentence_chunk": "instances for integration tests.@ContextHierarchy should be declared with a list of one or more @ContextConfiguration instances, each of which defines a level in the context hierarchy. The following examples demonstrate the use of @ContextHierarchy within a single test class (@ContextHierarchy can also be used within a test class hierarchy): Java @ContextHierarchy({ \u00a0  @ContextConfiguration(\"/parent-config.xml\"), \u00a0  @ContextConfiguration(\"/child-config.xml\") }) class ContextHierarchyTests { \u00a0  // class body... } Kotlin @ContextHierarchy( \u00a0  ContextConfiguration(\"/parent-config.xml\"), \u00a0  ContextConfiguration(\"/child-config.xml\")) class ContextHierarchyTests { \u00a0  // class body... } Java @WebAppConfiguration @ContextHierarchy({ \u00a0  @ContextConfiguration(classes = AppConfig.class), \u00a0  @ContextConfiguration(classes = WebConfig.class) }) class WebIntegrationTests { \u00a0  // class body... } Kotlin @WebAppConfiguration @ContextHierarchy( \u00a0    ContextConfiguration(classes = [AppConfig::class]), \u00a0    ContextConfiguration(classes = [WebConfig::class])) class WebIntegrationTests { \u00a0  // class body... } If you need to merge or override the configuration for a given level of the context hierarchy within a test class hierarchy, you must explicitly name that level by supplying the same value to the name attribute in @ContextConfiguration at each corresponding level in the class hierarchy. See Context 488", "chunk_char_count": 1407, "chunk_word_count": 183, "chunk_token_count": 351.75}, {"page_number": 489, "sentence_chunk": "Hierarchies and the @ContextHierarchy javadoc for further examples.@ActiveProfiles @ActiveProfiles is a class-level annotation that is used to declare which bean definition profiles should be active when loading an ApplicationContext for an integration test. The following example indicates that the dev profile should be active: Java @ContextConfiguration @ActiveProfiles(\"dev\") \u2460 class DeveloperTests { \u00a0  // class body... } \u2460 Indicate that the dev profile should be active. Kotlin @ContextConfiguration @ActiveProfiles(\"dev\") \u2460 class DeveloperTests { \u00a0  // class body... } \u2460 Indicate that the dev profile should be active. The following example indicates that both the dev and the integration profiles should be active: Java @ContextConfiguration @ActiveProfiles({\"dev\", \"integration\"}) \u2460 class DeveloperIntegrationTests { \u00a0  // class body... } \u2460 Indicate that the dev and integration profiles should be active. Kotlin @ContextConfiguration @ActiveProfiles([\"dev\", \"integration\"]) \u2460 class DeveloperIntegrationTests { \u00a0  // class body... } \u2460 Indicate that the dev and integration profiles should be active.489", "chunk_char_count": 1111, "chunk_word_count": 153, "chunk_token_count": 277.75}, {"page_number": 490, "sentence_chunk": "\uf05a @ActiveProfiles provides support for inheriting active bean definition profiles declared by superclasses and enclosing classes by default. You can also resolve active bean definition profiles programmatically by implementing a custom ActiveProfilesResolver and registering it by using the resolver attribute of @ActiveProfiles. See Context Configuration with Environment Profiles, @Nested test class configuration, and the @ActiveProfiles javadoc for examples and further details.@TestPropertySource @TestPropertySource is a class-level annotation that you can use to configure the locations of properties files and inlined properties to be added to the set of PropertySources in the Environment for an ApplicationContext loaded for an integration test. The following example demonstrates how to declare a properties file from the classpath: Java @ContextConfiguration @TestPropertySource(\"/test.properties\") \u2460 class MyIntegrationTests { \u00a0  // class body... } \u2460 Get properties from test.properties in the root of the classpath. Kotlin @ContextConfiguration @TestPropertySource(\"/test.properties\") \u2460 class MyIntegrationTests { \u00a0  // class body... } \u2460 Get properties from test.properties in the root of the classpath. The following example demonstrates how to declare inlined properties: Java @ContextConfiguration @TestPropertySource(properties = { \"timezone = GMT\", \"port: 4242\" }) \u2460 class MyIntegrationTests { \u00a0  // class body... } \u2460 Declare timezone and port properties.490", "chunk_char_count": 1477, "chunk_word_count": 196, "chunk_token_count": 369.25}, {"page_number": 491, "sentence_chunk": "Kotlin @ContextConfiguration @TestPropertySource(properties = [\"timezone = GMT\", \"port: 4242\"]) \u2460 class MyIntegrationTests { \u00a0  // class body... } \u2460 Declare timezone and port properties. See Context Configuration with Test Property Sources for examples and further details.@DynamicPropertySource @DynamicPropertySource is a method-level annotation that you can use to register dynamic properties to be added to the set of PropertySources in the Environment for an ApplicationContext loaded for an integration test. Dynamic properties are useful when you do not know the value of the properties upfront \u2013 for example, if the properties are managed by an external resource such as for a container managed by the Testcontainers project. The following example demonstrates how to register a dynamic property: Java @ContextConfiguration class MyIntegrationTests { \u00a0  static MyExternalServer server = // ... \u00a0  @DynamicPropertySource \u2460 \u00a0  static void dynamicProperties(DynamicPropertyRegistry registry) { \u2461 \u00a0    registry.add(\"server.port\", server::getPort); \u2462 \u00a0  } \u00a0  // tests ... } \u2460 Annotate a static method with @DynamicPropertySource.\u2461 Accept a DynamicPropertyRegistry as an argument.\u2462 Register a dynamic server.port property to be retrieved lazily from the server.491", "chunk_char_count": 1266, "chunk_word_count": 182, "chunk_token_count": 316.5}, {"page_number": 492, "sentence_chunk": "Kotlin @ContextConfiguration class MyIntegrationTests { \u00a0  companion object { \u00a0    @JvmStatic \u00a0    val server: MyExternalServer = // ... \u00a0    @DynamicPropertySource \u2460 \u00a0    @JvmStatic \u00a0    fun dynamicProperties(registry: DynamicPropertyRegistry) { \u2461 \u00a0      registry.add(\"server.port\", server::getPort) \u2462 \u00a0    } \u00a0  } \u00a0  // tests ... } \u2460 Annotate a static method with @DynamicPropertySource.\u2461 Accept a DynamicPropertyRegistry as an argument.\u2462 Register a dynamic server.port property to be retrieved lazily from the server. See Context Configuration with Dynamic Property Sources for further details.@DirtiesContext @DirtiesContext indicates that the underlying Spring ApplicationContext has been dirtied during the execution of a test (that is, the test modified or corrupted it in some manner\u2009\u2014\u2009for example, by changing the state of a singleton bean) and should be closed. When an application context is marked as dirty, it is removed from the testing framework\u2019s cache and closed. As a consequence, the underlying Spring container is rebuilt for any subsequent test that requires a context with the same configuration metadata. You can use @DirtiesContext as both a class-level and a method-level annotation within the same class or class hierarchy. In such scenarios, the ApplicationContext is marked as dirty before or after any such annotated method as well as before or after the current test class, depending on the configured methodMode and classMode. The following examples explain when the context would be dirtied for various configuration scenarios: \u2022 Before the current test class, when declared on a class with class mode set to BEFORE_CLASS.", "chunk_char_count": 1653, "chunk_word_count": 266, "chunk_token_count": 413.25}, {"page_number": 493, "sentence_chunk": "Java @DirtiesContext(classMode = BEFORE_CLASS) \u2460 class FreshContextTests { \u00a0  // some tests that require a new Spring container } \u2460 Dirty the context before the current test class. Kotlin @DirtiesContext(classMode = BEFORE_CLASS) \u2460 class FreshContextTests { \u00a0  // some tests that require a new Spring container } \u2460 Dirty the context before the current test class. \u2022After the current test class, when declared on a class with class mode set to AFTER_CLASS (i.e., the default class mode). Java @DirtiesContext \u2460 class ContextDirtyingTests { \u00a0  // some tests that result in the Spring container being dirtied } \u2460 Dirty the context after the current test class. Kotlin @DirtiesContext \u2460 class ContextDirtyingTests { \u00a0  // some tests that result in the Spring container being dirtied } \u2460 Dirty the context after the current test class. \u2022Before each test method in the current test class, when declared on a class with class mode set to BEFORE_EACH_TEST_METHOD. Java @DirtiesContext(classMode = BEFORE_EACH_TEST_METHOD) \u2460 class FreshContextTests { \u00a0  // some tests that require a new Spring container } \u2460 Dirty the context before each test method.493", "chunk_char_count": 1144, "chunk_word_count": 185, "chunk_token_count": 286.0}, {"page_number": 494, "sentence_chunk": "Kotlin @DirtiesContext(classMode = BEFORE_EACH_TEST_METHOD) \u2460 class FreshContextTests { \u00a0  // some tests that require a new Spring container } \u2460 Dirty the context before each test method. \u2022After each test method in the current test class, when declared on a class with class mode set to AFTER_EACH_TEST_METHOD. Java @DirtiesContext(classMode = AFTER_EACH_TEST_METHOD) \u2460 class ContextDirtyingTests { \u00a0  // some tests that result in the Spring container being dirtied } \u2460 Dirty the context after each test method. Kotlin @DirtiesContext(classMode = AFTER_EACH_TEST_METHOD) \u2460 class ContextDirtyingTests { \u00a0  // some tests that result in the Spring container being dirtied } \u2460 Dirty the context after each test method. \u2022Before the current test, when declared on a method with the method mode set to BEFORE_METHOD. Java @DirtiesContext(methodMode = BEFORE_METHOD) \u2460 @Test void testProcessWhichRequiresFreshAppCtx() { \u00a0  // some logic that requires a new Spring container } \u2460 Dirty the context before the current test method. Kotlin @DirtiesContext(methodMode = BEFORE_METHOD) \u2460 @Test fun testProcessWhichRequiresFreshAppCtx() { \u00a0  // some logic that requires a new Spring container } \u2460 Dirty the context before the current test method.494", "chunk_char_count": 1233, "chunk_word_count": 184, "chunk_token_count": 308.25}, {"page_number": 495, "sentence_chunk": "\u2022 After the current test, when declared on a method with the method mode set to AFTER_METHOD (i.e., the default method mode). Java @DirtiesContext \u2460 @Test void testProcessWhichDirtiesAppCtx() { \u00a0  // some logic that results in the Spring container being dirtied } \u2460 Dirty the context after the current test method. Kotlin @DirtiesContext \u2460 @Test fun testProcessWhichDirtiesAppCtx() { \u00a0  // some logic that results in the Spring container being dirtied } \u2460 Dirty the context after the current test method. If you use @DirtiesContext in a test whose context is configured as part of a context hierarchy with @ContextHierarchy, you can use the hierarchyMode flag to control how the context cache is cleared. By default, an exhaustive algorithm is used to clear the context cache, including not only the current level but also all other context hierarchies that share an ancestor context common to the current test. All ApplicationContext instances that reside in a sub-hierarchy of the common ancestor context are removed from the context cache and closed. If the exhaustive algorithm is overkill for a particular use case, you can specify the simpler current level algorithm, as the following example shows.495", "chunk_char_count": 1208, "chunk_word_count": 194, "chunk_token_count": 302.0}, {"page_number": 496, "sentence_chunk": "Java @ContextHierarchy({ \u00a0  @ContextConfiguration(\"/parent-config.xml\"), \u00a0  @ContextConfiguration(\"/child-config.xml\") }) class BaseTests { \u00a0  // class body... } class ExtendedTests extends BaseTests { \u00a0  @Test \u00a0  @DirtiesContext(hierarchyMode = CURRENT_LEVEL) \u2460 \u00a0  void test() { \u00a0    // some logic that results in the child context being dirtied \u00a0  } } \u2460 Use the current-level algorithm. Kotlin @ContextHierarchy( \u00a0  ContextConfiguration(\"/parent-config.xml\"), \u00a0  ContextConfiguration(\"/child-config.xml\")) open class BaseTests { \u00a0  // class body... } class ExtendedTests : BaseTests() { \u00a0  @Test \u00a0  @DirtiesContext(hierarchyMode = CURRENT_LEVEL) \u2460 \u00a0  fun test() { \u00a0    // some logic that results in the child context being dirtied \u00a0  } } \u2460 Use the current-level algorithm. For further details regarding the EXHAUSTIVE and CURRENT_LEVEL algorithms, see the DirtiesContext. HierarchyMode javadoc.@TestExecutionListeners @TestExecutionListeners is used to register listeners for a particular test class, its subclasses, and its nested classes. If you wish to register a listener globally, you should register it via the automatic discovery mechanism described in TestExecutionListener Configuration. The following example shows how to register two TestExecutionListener implementations: 496", "chunk_char_count": 1289, "chunk_word_count": 185, "chunk_token_count": 322.25}, {"page_number": 497, "sentence_chunk": "Java @ContextConfiguration @TestExecutionListeners({CustomTestExecutionListener.class, AnotherTestExecutionListener.class}) \u2460 class CustomTestExecutionListenerTests { \u00a0  // class body... } \u2460 Register two TestExecutionListener implementations. Kotlin @ContextConfiguration @TestExecutionListeners(CustomTestExecutionListener::class, AnotherTestExecutionListener::class) \u2460 class CustomTestExecutionListenerTests { \u00a0  // class body... } \u2460 Register two TestExecutionListener implementations. By default, @TestExecutionListeners provides support for inheriting listeners from superclasses or enclosing classes. See @Nested test class configuration and the @TestExecutionListeners javadoc for an example and further details. If you discover that you need to switch back to using the default TestExecutionListener implementations, see the note in Registering TestExecutionListener Implementations.@RecordApplicationEvents @RecordApplicationEvents is a class-level annotation that is used to instruct the Spring TestContext Framework to record all application events that are published in the ApplicationContext during the execution of a single test. The recorded events can be accessed via the ApplicationEvents API within tests. See Application Events and the @RecordApplicationEvents javadoc for an example and further details.@Commit @Commit indicates that the transaction for a transactional test method should be committed after the test method has completed. You can use @Commit as a direct replacement for @Rollback(false) to more explicitly convey the intent of the code.", "chunk_char_count": 1572, "chunk_word_count": 183, "chunk_token_count": 393.0}, {"page_number": 497, "sentence_chunk": "Analogous to @Rollback, @Commit can also be declared as a class-level or method-level annotation. The following example shows how to use the @Commit annotation: 497", "chunk_char_count": 164, "chunk_word_count": 25, "chunk_token_count": 41.0}, {"page_number": 498, "sentence_chunk": "Java @Commit \u2460 @Test void testProcessWithoutRollback() { \u00a0  // ... } \u2460 Commit the result of the test to the database. Kotlin @Commit \u2460 @Test fun testProcessWithoutRollback() { \u00a0  // ... } \u2460 Commit the result of the test to the database.@Rollback @Rollback indicates whether the transaction for a transactional test method should be rolled back after the test method has completed. If true, the transaction is rolled back. Otherwise, the transaction is committed (see also @Commit). Rollback for integration tests in the Spring TestContext Framework defaults to true even if @Rollback is not explicitly declared. When declared as a class-level annotation, @Rollback defines the default rollback semantics for all test methods within the test class hierarchy. When declared as a method-level annotation, @Rollback defines rollback semantics for the specific test method, potentially overriding class-level @Rollback or @Commit semantics. The following example causes a test method\u2019s result to not be rolled back (that is, the result is committed to the database): Java @Rollback(false) \u2460 @Test void testProcessWithoutRollback() { \u00a0  // ... } \u2460 Do not roll back the result.498", "chunk_char_count": 1173, "chunk_word_count": 182, "chunk_token_count": 293.25}, {"page_number": 499, "sentence_chunk": "Kotlin @Rollback(false) \u2460 @Test fun testProcessWithoutRollback() { \u00a0  // ... } \u2460 Do not roll back the result.@BeforeTransaction @BeforeTransaction indicates that the annotated void method should be run before a transaction is started, for test methods that have been configured to run within a transaction by using Spring\u2019s @Transactional annotation.@BeforeTransaction methods are not required to be public and may be declared on Java 8-based interface default methods. The following example shows how to use the @BeforeTransaction annotation: Java @BeforeTransaction \u2460 void beforeTransaction() { \u00a0  // logic to be run before a transaction is started } \u2460 Run this method before a transaction. Kotlin @BeforeTransaction \u2460 fun beforeTransaction() { \u00a0  // logic to be run before a transaction is started } \u2460 Run this method before a transaction.@AfterTransaction @AfterTransaction indicates that the annotated void method should be run after a transaction is ended, for test methods that have been configured to run within a transaction by using Spring\u2019s @Transactional annotation.@AfterTransaction methods are not required to be public and may be declared on Java 8-based interface default methods. Java @AfterTransaction \u2460 void afterTransaction() { \u00a0  // logic to be run after a transaction has ended } 499", "chunk_char_count": 1305, "chunk_word_count": 199, "chunk_token_count": 326.25}, {"page_number": 500, "sentence_chunk": "\u2460 Run this method after a transaction. Kotlin @AfterTransaction \u2460 fun afterTransaction() { \u00a0  // logic to be run after a transaction has ended } \u2460 Run this method after a transaction.@Sql @Sql is used to annotate a test class or test method to configure SQL scripts to be run against a given database during integration tests. The following example shows how to use it: Java @Test @Sql({\"/test-schema.sql\", \"/test-user-data.sql\"}) \u2460 void userTest() { \u00a0  // run code that relies on the test schema and test data } \u2460 Run two scripts for this test. Kotlin @Test @Sql(\"/test-schema.sql\", \"/test-user-data.sql\") \u2460 fun userTest() { \u00a0  // run code that relies on the test schema and test data } \u2460 Run two scripts for this test. See Executing SQL scripts declaratively with @Sql for further details.@SqlConfig @SqlConfig defines metadata that is used to determine how to parse and run SQL scripts configured with the @Sql annotation. The following example shows how to use it: 500", "chunk_char_count": 972, "chunk_word_count": 165, "chunk_token_count": 243.0}, {"page_number": 501, "sentence_chunk": "Java @Test @Sql( \u00a0  scripts = \"/test-user-data.sql\", \u00a0  config = @SqlConfig(commentPrefix = \"`\", separator = \"@@\") \u2460 ) void userTest() { \u00a0  // run code that relies on the test data } \u2460 Set the comment prefix and the separator in SQL scripts. Kotlin @Test @Sql(\"/test-user-data.sql\", config = SqlConfig(commentPrefix = \"`\", separator = \"@@\")) \u2460 fun userTest() { \u00a0  // run code that relies on the test data } \u2460 Set the comment prefix and the separator in SQL scripts.@SqlMergeMode @SqlMergeMode is used to annotate a test class or test method to configure whether method-level @Sql declarations are merged with class-level @Sql declarations. If @SqlMergeMode is not declared on a test class or test method, the OVERRIDE merge mode will be used by default. With the OVERRIDE mode, method-level @Sql declarations will effectively override class-level @Sql declarations. Note that a method-level @SqlMergeMode declaration overrides a class-level declaration. The following example shows how to use @SqlMergeMode at the class level. Java @SpringJUnitConfig(TestConfig.class) @Sql(\"/test-schema.sql\") @SqlMergeMode(MERGE) \u2460 class UserTests { \u00a0  @Test \u00a0  @Sql(\"/user-test-data-001.sql\") \u00a0  void standardUserProfile() { \u00a0    // run code that relies on test data set 001 \u00a0  } } \u2460 Set the @Sql merge mode to MERGE for all test methods in the class.501", "chunk_char_count": 1340, "chunk_word_count": 215, "chunk_token_count": 335.0}, {"page_number": 502, "sentence_chunk": "Kotlin @SpringJUnitConfig(TestConfig::class) @Sql(\"/test-schema.sql\") @SqlMergeMode(MERGE) \u2460 class UserTests { \u00a0  @Test \u00a0  @Sql(\"/user-test-data-001.sql\") \u00a0  fun standardUserProfile() { \u00a0    // run code that relies on test data set 001 \u00a0  } } \u2460 Set the @Sql merge mode to MERGE for all test methods in the class. The following example shows how to use @SqlMergeMode at the method level. Java @SpringJUnitConfig(TestConfig.class) @Sql(\"/test-schema.sql\") class UserTests { \u00a0  @Test \u00a0  @Sql(\"/user-test-data-001.sql\") \u00a0  @SqlMergeMode(MERGE) \u2460 \u00a0  void standardUserProfile() { \u00a0    // run code that relies on test data set 001 \u00a0  } } \u2460 Set the @Sql merge mode to MERGE for a specific test method. Kotlin @SpringJUnitConfig(TestConfig::class) @Sql(\"/test-schema.sql\") class UserTests { \u00a0  @Test \u00a0  @Sql(\"/user-test-data-001.sql\") \u00a0  @SqlMergeMode(MERGE) \u2460 \u00a0  fun standardUserProfile() { \u00a0    // run code that relies on test data set 001 \u00a0  } } \u2460 Set the @Sql merge mode to MERGE for a specific test method.502", "chunk_char_count": 1005, "chunk_word_count": 168, "chunk_token_count": 251.25}, {"page_number": 503, "sentence_chunk": "@SqlGroup @SqlGroup is a container annotation that aggregates several @Sql annotations. You can use @SqlGroup natively to declare several nested @Sql annotations, or you can use it in conjunction with Java 8\u2019s support for repeatable annotations, where @Sql can be declared several times on the same class or method, implicitly generating this container annotation. The following example shows how to declare an SQL group: Java @Test @SqlGroup({ \u2460 \u00a0  @Sql(scripts = \"/test-schema.sql\", config = @SqlConfig(commentPrefix = \"`\")), \u00a0  @Sql(\"/test-user-data.sql\") )} void userTest() { \u00a0  // run code that uses the test schema and test data } \u2460 Declare a group of SQL scripts. Kotlin @Test @SqlGroup( \u2460 \u00a0  Sql(\"/test-schema.sql\", config = SqlConfig(commentPrefix = \"`\")), \u00a0  Sql(\"/test-user-data.sql\")) fun userTest() { \u00a0  // run code that uses the test schema and test data } \u2460 Declare a group of SQL scripts. Standard Annotation Support The following annotations are supported with standard semantics for all configurations of the Spring TestContext Framework. Note that these annotations are not specific to tests and can be used anywhere in the Spring Framework. \u2022@Autowired \u2022 @Qualifier \u2022 @Value \u2022 @Resource (jakarta.annotation) if JSR-250 is present \u2022 @ManagedBean (jakarta.annotation) if JSR-250 is present \u2022 @Inject (jakarta.inject) if JSR-330 is present \u2022 @Named (jakarta.inject) if JSR-330 is present \u2022 @PersistenceContext (jakarta.persistence) if JPA is present 503", "chunk_char_count": 1470, "chunk_word_count": 223, "chunk_token_count": 367.5}, {"page_number": 504, "sentence_chunk": "\u2022 @PersistenceUnit (jakarta.persistence) if JPA is present \u2022 @Transactional (org.springframework.transaction.annotation) with limited attribute support \uf05a JSR-250 Lifecycle Annotations In the Spring TestContext Framework, you can use @PostConstruct and @PreDestroy with standard semantics on any application components configured in the ApplicationContext. However, these lifecycle annotations have limited usage within an actual test class. If a method within a test class is annotated with @PostConstruct, that method runs before any before methods of the underlying test framework (for example, methods annotated with JUnit Jupiter\u2019s @BeforeEach), and that applies for every test method in the test class. On the other hand, if a method within a test class is annotated with @PreDestroy, that method never runs. Therefore, within a test class, we recommend that you use test lifecycle callbacks from the underlying test framework instead of @PostConstruct and @PreDestroy. Spring JUnit 4 Testing Annotations The following annotations are supported only when used in conjunction with the SpringRunner, Spring\u2019s JUnit 4 rules, or Spring\u2019s JUnit 4 support classes: \u2022 @IfProfileValue \u2022 @ProfileValueSourceConfiguration \u2022 @Timed \u2022 @Repeat @IfProfileValue @IfProfileValue indicates that the annotated test is enabled for a specific testing environment. If the configured ProfileValueSource returns a matching value for the provided name, the test is enabled. Otherwise, the test is disabled and, effectively, ignored. You can apply @IfProfileValue at the class level, the method level, or both. Class-level usage of @IfProfileValue takes precedence over method-level usage for any methods within that class or its subclasses.", "chunk_char_count": 1721, "chunk_word_count": 241, "chunk_token_count": 430.25}, {"page_number": 504, "sentence_chunk": "Specifically, a test is enabled if it is enabled both at the class level and at the method level. The absence of @IfProfileValue means the test is implicitly enabled. This is analogous to the semantics of JUnit 4\u2019s @Ignore annotation, except that the presence of @Ignore always disables a test. The following example shows a test that has an @IfProfileValue annotation: 504", "chunk_char_count": 373, "chunk_word_count": 62, "chunk_token_count": 93.25}, {"page_number": 505, "sentence_chunk": "Java @IfProfileValue(name=\"java.vendor\", value=\"Oracle Corporation\") \u2460 @Test public void testProcessWhichRunsOnlyOnOracleJvm() { \u00a0  // some logic that should run only on Java VMs from Oracle Corporation } \u2460 Run this test only when the Java vendor is \"Oracle Corporation\". Kotlin @IfProfileValue(name=\"java.vendor\", value=\"Oracle Corporation\") \u2460 @Test fun testProcessWhichRunsOnlyOnOracleJvm() { \u00a0  // some logic that should run only on Java VMs from Oracle Corporation } \u2460 Run this test only when the Java vendor is \"Oracle Corporation\". Alternatively, you can configure @IfProfileValue with a list of values (with OR semantics) to achieve TestNG-like support for test groups in a JUnit 4 environment. Consider the following example: Java @IfProfileValue(name=\"test-groups\", values={\"unit-tests\", \"integration-tests\"}) \u2460 @Test public void testProcessWhichRunsForUnitOrIntegrationTestGroups() { \u00a0  // some logic that should run only for unit and integration test groups } \u2460 Run this test for unit tests and integration tests. Kotlin @IfProfileValue(name=\"test-groups\", values=[\"unit-tests\", \"integration-tests\"]) \u2460 @Test fun testProcessWhichRunsForUnitOrIntegrationTestGroups() { \u00a0  // some logic that should run only for unit and integration test groups } \u2460 Run this test for unit tests and integration tests.@ProfileValueSourceConfiguration @ProfileValueSourceConfiguration is a class-level annotation that specifies what type of ProfileValueSource to use when retrieving profile values configured through the @IfProfileValue annotation. If @ProfileValueSourceConfiguration is not declared for a test, SystemProfileValueSource is used by default. The following example shows how to use @ProfileValueSourceConfiguration: 505", "chunk_char_count": 1724, "chunk_word_count": 219, "chunk_token_count": 431.0}, {"page_number": 506, "sentence_chunk": "Java @ProfileValueSourceConfiguration(CustomProfileValueSource.class) \u2460 public class CustomProfileValueSourceTests { \u00a0  // class body... } \u2460 Use a custom profile value source. Kotlin @ProfileValueSourceConfiguration(CustomProfileValueSource::class) \u2460 class CustomProfileValueSourceTests { \u00a0  // class body... } \u2460 Use a custom profile value source.@Timed @Timed indicates that the annotated test method must finish execution in a specified time period (in milliseconds). If the text execution time exceeds the specified time period, the test fails. The time period includes running the test method itself, any repetitions of the test (see @Repeat), as well as any setting up or tearing down of the test fixture. The following example shows how to use it: Java @Timed(millis = 1000) \u2460 public void testProcessWithOneSecondTimeout() { \u00a0  // some logic that should not take longer than 1 second to run } \u2460 Set the time period for the test to one second. Kotlin @Timed(millis = 1000) \u2460 fun testProcessWithOneSecondTimeout() { \u00a0  // some logic that should not take longer than 1 second to run } \u2460 Set the time period for the test to one second. Spring\u2019s @Timed annotation has different semantics than JUnit 4\u2019s @Test(timeout=\u2026) support. Specifically, due to the manner in which JUnit 4 handles test execution timeouts (that is, by executing the test method in a separate Thread), @Test(timeout=\u2026) preemptively fails the test if the test takes too long. Spring\u2019s @Timed, on the other hand, does not preemptively fail the test but rather waits for the test to complete before failing.", "chunk_char_count": 1575, "chunk_word_count": 245, "chunk_token_count": 393.75}, {"page_number": 507, "sentence_chunk": "@Repeat @Repeat indicates that the annotated test method must be run repeatedly. The number of times that the test method is to be run is specified in the annotation. The scope of execution to be repeated includes execution of the test method itself as well as any setting up or tearing down of the test fixture. When used with the SpringMethodRule, the scope additionally includes preparation of the test instance by TestExecutionListener implementations. The following example shows how to use the @Repeat annotation: Java @Repeat(10) \u2460 @Test public void testProcessRepeatedly() { \u00a0  // ... } \u2460 Repeat this test ten times. Kotlin @Repeat(10) \u2460 @Test fun testProcessRepeatedly() { \u00a0  // ... } \u2460 Repeat this test ten times. Spring JUnit Jupiter Testing Annotations The following annotations are supported when used in conjunction with the SpringExtension and JUnit Jupiter (that is, the programming model in JUnit 5): \u2022 @SpringJUnitConfig \u2022 @SpringJUnitWebConfig \u2022 @TestConstructor \u2022 @NestedTestConfiguration \u2022 @EnabledIf \u2022 @DisabledIf @SpringJUnitConfig @SpringJUnitConfig is a composed annotation that combines @ExtendWith(SpringExtension.class) from JUnit Jupiter with @ContextConfiguration from the Spring TestContext Framework. It can be used at the class level as a drop-in replacement for @ContextConfiguration. With regard to configuration options, the only difference between @ContextConfiguration and @SpringJUnitConfig is that component classes may be declared with the value attribute in @SpringJUnitConfig.507", "chunk_char_count": 1522, "chunk_word_count": 218, "chunk_token_count": 380.5}, {"page_number": 508, "sentence_chunk": "The following example shows how to use the @SpringJUnitConfig annotation to specify a configuration class: Java @SpringJUnitConfig(TestConfig.class) \u2460 class ConfigurationClassJUnitJupiterSpringTests { \u00a0  // class body... } \u2460 Specify the configuration class. Kotlin @SpringJUnitConfig(TestConfig::class) \u2460 class ConfigurationClassJUnitJupiterSpringTests { \u00a0  // class body... } \u2460 Specify the configuration class. The following example shows how to use the @SpringJUnitConfig annotation to specify the location of a configuration file: Java @SpringJUnitConfig(locations = \"/test-config.xml\") \u2460 class XmlJUnitJupiterSpringTests { \u00a0  // class body... } \u2460 Specify the location of a configuration file. Kotlin @SpringJUnitConfig(locations = [\"/test-config.xml\"]) \u2460 class XmlJUnitJupiterSpringTests { \u00a0  // class body... } \u2460 Specify the location of a configuration file. See Context Management as well as the javadoc for @SpringJUnitConfig and @ContextConfiguration for further details.@SpringJUnitWebConfig @SpringJUnitWebConfig is a composed annotation that combines @ExtendWith(SpringExtension.class) from JUnit Jupiter with @ContextConfiguration and @WebAppConfiguration from the Spring TestContext Framework. You can use it at the class level as a drop-in replacement for @ContextConfiguration and @WebAppConfiguration. With regard to configuration options, the only 508", "chunk_char_count": 1368, "chunk_word_count": 170, "chunk_token_count": 342.0}, {"page_number": 509, "sentence_chunk": "difference between @ContextConfiguration and @SpringJUnitWebConfig is that you can declare component classes by using the value attribute in @SpringJUnitWebConfig. In addition, you can override the value attribute from @WebAppConfiguration only by using the resourcePath attribute in @SpringJUnitWebConfig. The following example shows how to use the @SpringJUnitWebConfig annotation to specify a configuration class: Java @SpringJUnitWebConfig(TestConfig.class) \u2460 class ConfigurationClassJUnitJupiterSpringWebTests { \u00a0  // class body... } \u2460 Specify the configuration class. Kotlin @SpringJUnitWebConfig(TestConfig::class) \u2460 class ConfigurationClassJUnitJupiterSpringWebTests { \u00a0  // class body... } \u2460 Specify the configuration class. The following example shows how to use the @SpringJUnitWebConfig annotation to specify the location of a configuration file: Java @SpringJUnitWebConfig(locations = \"/test-config.xml\") \u2460 class XmlJUnitJupiterSpringWebTests { \u00a0  // class body... } \u2460 Specify the location of a configuration file. Kotlin @SpringJUnitWebConfig(locations = [\"/test-config.xml\"]) \u2460 class XmlJUnitJupiterSpringWebTests { \u00a0  // class body... } \u2460 Specify the location of a configuration file. See Context Management as well as the javadoc for @SpringJUnitWebConfig, @ContextConfiguration, and @WebAppConfiguration for further details.509", "chunk_char_count": 1345, "chunk_word_count": 164, "chunk_token_count": 336.25}, {"page_number": 510, "sentence_chunk": "@TestConstructor @TestConstructor is a type-level annotation that is used to configure how the parameters of a test class constructor are autowired from components in the test\u2019s ApplicationContext. If @TestConstructor is not present or meta-present on a test class, the default test constructor autowire mode will be used. See the tip below for details on how to change the default mode. Note, however, that a local declaration of @Autowired on a constructor takes precedence over both @TestConstructor and the default mode.\uf0eb Changing the default test constructor autowire mode The default test constructor autowire mode can be changed by setting the spring.test.constructor.autowire.mode JVM system property to all. Alternatively, the default mode may be set via the SpringProperties mechanism. As of Spring Framework 5.3, the default mode may also be configured as a JUnit Platform configuration parameter. If the spring.test.constructor.autowire.mode property is not set, test class constructors will not be automatically autowired.\uf05a As of Spring Framework 5.2, @TestConstructor is only supported in conjunction with the SpringExtension for use with JUnit Jupiter. Note that the SpringExtension is often automatically registered for you \u2013 for example, when using annotations such as @SpringJUnitConfig and @SpringJUnitWebConfig or various test-related annotations from Spring Boot Test.", "chunk_char_count": 1389, "chunk_word_count": 197, "chunk_token_count": 347.25}, {"page_number": 510, "sentence_chunk": "@NestedTestConfiguration @NestedTestConfiguration is a type-level annotation that is used to configure how Spring test configuration annotations are processed within enclosing class hierarchies for inner test classes. If @NestedTestConfiguration is not present or meta-present on a test class, in its supertype hierarchy, or in its enclosing class hierarchy, the default enclosing configuration inheritance mode will be used. See the tip below for details on how to change the default mode.\uf0eb Changing the default enclosing configuration inheritance mode The default enclosing configuration inheritance mode is INHERIT, but it can be changed by setting the spring.test.enclosing.configuration JVM system property to OVERRIDE. Alternatively, the default mode may be set via the SpringProperties mechanism. The Spring TestContext Framework honors @NestedTestConfiguration semantics for the following annotations. \u2022@BootstrapWith \u2022 @ContextConfiguration \u2022 @WebAppConfiguration 510", "chunk_char_count": 976, "chunk_word_count": 126, "chunk_token_count": 244.0}, {"page_number": 511, "sentence_chunk": "\u2022 @ContextHierarchy \u2022 @ActiveProfiles \u2022 @TestPropertySource \u2022 @DynamicPropertySource \u2022 @DirtiesContext \u2022 @TestExecutionListeners \u2022 @RecordApplicationEvents \u2022 @Transactional \u2022 @Commit \u2022 @Rollback \u2022 @Sql \u2022 @SqlConfig \u2022 @SqlMergeMode \u2022 @TestConstructor \uf05a The use of @NestedTestConfiguration typically only makes sense in conjunction with @Nested test classes in JUnit Jupiter; however, there may be other testing frameworks with support for Spring and nested test classes that make use of this annotation. See @Nested test class configuration for an example and further details.@EnabledIf @EnabledIf is used to signal that the annotated JUnit Jupiter test class or test method is enabled and should be run if the supplied expression evaluates to true. Specifically, if the expression evaluates to Boolean. TRUE or a String equal to true (ignoring case), the test is enabled. When applied at the class level, all test methods within that class are automatically enabled by default as well. Expressions can be any of the following: \u2022 Spring Expression Language (SpEL) expression. For example: @EnabledIf(\"#{systemProperties['os.name'].toLowerCase().contains('mac')}\") \u2022 Placeholder for a property available in the Spring Environment. For example: @EnabledIf(\"${smoke.tests.enabled}\") \u2022 Text literal. For example: @EnabledIf(\"true\") Note, however, that a text literal that is not the result of dynamic resolution of a property placeholder is of zero practical value, since @EnabledIf(\"false\") is equivalent to @Disabled and @EnabledIf(\"true\") is logically meaningless.", "chunk_char_count": 1562, "chunk_word_count": 214, "chunk_token_count": 390.5}, {"page_number": 511, "sentence_chunk": "You can use @EnabledIf as a meta-annotation to create custom composed annotations. For example, you can create a custom @EnabledOnMac annotation as follows: 511", "chunk_char_count": 160, "chunk_word_count": 24, "chunk_token_count": 40.0}, {"page_number": 512, "sentence_chunk": "Java @Target({ElementType. TYPE, ElementType. METHOD}) @Retention(RetentionPolicy. RUNTIME) @EnabledIf( \u00a0  expression = \"#{systemProperties['os.name'].toLowerCase().contains('mac')}\", \u00a0  reason = \"Enabled on Mac OS\" ) public @interface EnabledOnMac {} Kotlin @Target(AnnotationTarget. TYPE, AnnotationTarget. FUNCTION) @Retention(AnnotationRetention. RUNTIME) @EnabledIf( \u00a0    expression = \"#{systemProperties['os.name'].toLowerCase().contains('mac')}\", \u00a0    reason = \"Enabled on Mac OS\" ) annotation class EnabledOnMac {} \uf05a @EnabledOnMac is meant only as an example of what is possible. If you have that exact use case, please use the built-in @EnabledOnOs(MAC) support in JUnit Jupiter.\uf071 Since JUnit 5.7, JUnit Jupiter also has a condition annotation named @EnabledIf. Thus, if you wish to use Spring\u2019s @EnabledIf support make sure you import the annotation type from the correct package.", "chunk_char_count": 890, "chunk_word_count": 116, "chunk_token_count": 222.5}, {"page_number": 512, "sentence_chunk": "@DisabledIf @DisabledIf is used to signal that the annotated JUnit Jupiter test class or test method is disabled and should not be run if the supplied expression evaluates to true. Specifically, if the expression evaluates to Boolean. TRUE or a String equal to true (ignoring case), the test is disabled. When applied at the class level, all test methods within that class are automatically disabled as well. Expressions can be any of the following: \u2022 Spring Expression Language (SpEL) expression. For example: @DisabledIf(\"#{systemProperties['os.name'].toLowerCase().contains('mac')}\") \u2022 Placeholder for a property available in the Spring Environment. For example: @DisabledIf(\"${smoke.tests.disabled}\") \u2022 Text literal. For example: @DisabledIf(\"true\") Note, however, that a text literal that is not the result of dynamic resolution of a property placeholder is of zero practical value, since @DisabledIf(\"true\") is equivalent to @Disabled and @DisabledIf(\"false\") is logically meaningless. You can use @DisabledIf as a meta-annotation to create custom composed annotations. For example, you can create a custom @DisabledOnMac annotation as follows: 512", "chunk_char_count": 1154, "chunk_word_count": 160, "chunk_token_count": 288.5}, {"page_number": 513, "sentence_chunk": "Java @Target({ElementType. TYPE, ElementType. METHOD}) @Retention(RetentionPolicy. RUNTIME) @DisabledIf( \u00a0  expression = \"#{systemProperties['os.name'].toLowerCase().contains('mac')}\", \u00a0  reason = \"Disabled on Mac OS\" ) public @interface DisabledOnMac {} Kotlin @Target(AnnotationTarget. TYPE, AnnotationTarget. FUNCTION) @Retention(AnnotationRetention. RUNTIME) @DisabledIf( \u00a0    expression = \"#{systemProperties['os.name'].toLowerCase().contains('mac')}\", \u00a0    reason = \"Disabled on Mac OS\" ) annotation class DisabledOnMac {} \uf05a @DisabledOnMac is meant only as an example of what is possible. If you have that exact use case, please use the built-in @DisabledOnOs(MAC) support in JUnit Jupiter.\uf071 Since JUnit 5.7, JUnit Jupiter also has a condition annotation named @DisabledIf. Thus, if you wish to use Spring\u2019s @DisabledIf support make sure you import the annotation type from the correct package.", "chunk_char_count": 900, "chunk_word_count": 116, "chunk_token_count": 225.0}, {"page_number": 513, "sentence_chunk": "Meta-Annotation Support for Testing You can use most test-related annotations as meta-annotations to create custom composed annotations and reduce configuration duplication across a test suite. You can use each of the following as a meta-annotation in conjunction with the TestContext framework. \u2022@BootstrapWith \u2022 @ContextConfiguration \u2022 @ContextHierarchy \u2022 @ActiveProfiles \u2022 @TestPropertySource \u2022 @DirtiesContext \u2022 @WebAppConfiguration \u2022 @TestExecutionListeners \u2022 @Transactional 513", "chunk_char_count": 483, "chunk_word_count": 59, "chunk_token_count": 120.75}, {"page_number": 514, "sentence_chunk": "\u2022 @BeforeTransaction \u2022 @AfterTransaction \u2022 @Commit \u2022 @Rollback \u2022 @Sql \u2022 @SqlConfig \u2022 @SqlMergeMode \u2022 @SqlGroup \u2022 @Repeat (only supported on JUnit 4) \u2022 @Timed (only supported on JUnit 4) \u2022 @IfProfileValue (only supported on JUnit 4) \u2022 @ProfileValueSourceConfiguration (only supported on JUnit 4) \u2022 @SpringJUnitConfig (only supported on JUnit Jupiter) \u2022 @SpringJUnitWebConfig (only supported on JUnit Jupiter) \u2022 @TestConstructor (only supported on JUnit Jupiter) \u2022 @NestedTestConfiguration (only supported on JUnit Jupiter) \u2022 @EnabledIf (only supported on JUnit Jupiter) \u2022 @DisabledIf (only supported on JUnit Jupiter) Consider the following example: Java @RunWith(SpringRunner.class) @ContextConfiguration({\"/app-config.xml\", \"/test-data-access-config.xml\"}) @ActiveProfiles(\"dev\") @Transactional public class OrderRepositoryTests { } @RunWith(SpringRunner.class) @ContextConfiguration({\"/app-config.xml\", \"/test-data-access-config.xml\"}) @ActiveProfiles(\"dev\") @Transactional public class UserRepositoryTests { } 514", "chunk_char_count": 1016, "chunk_word_count": 112, "chunk_token_count": 254.0}, {"page_number": 515, "sentence_chunk": "Kotlin @RunWith(SpringRunner::class) @ContextConfiguration(\"/app-config.xml\", \"/test-data-access-config.xml\") @ActiveProfiles(\"dev\") @Transactional class OrderRepositoryTests { } @RunWith(SpringRunner::class) @ContextConfiguration(\"/app-config.xml\", \"/test-data-access-config.xml\") @ActiveProfiles(\"dev\") @Transactional class UserRepositoryTests { } If we discover that we are repeating the preceding configuration across our JUnit 4-based test suite, we can reduce the duplication by introducing a custom composed annotation that centralizes the common test configuration for Spring, as follows: Java @Target(ElementType. TYPE) @Retention(RetentionPolicy. RUNTIME) @ContextConfiguration({\"/app-config.xml\", \"/test-data-access-config.xml\"}) @ActiveProfiles(\"dev\") @Transactional public @interface TransactionalDevTestConfig { } Kotlin @Target(AnnotationTarget. TYPE) @Retention(AnnotationRetention. RUNTIME) @ContextConfiguration(\"/app-config.xml\", \"/test-data-access-config.xml\") @ActiveProfiles(\"dev\") @Transactional annotation class TransactionalDevTestConfig { } Then we can use our custom @TransactionalDevTestConfig annotation to simplify the configuration of individual JUnit 4 based test classes, as follows: Java @RunWith(SpringRunner.class) @TransactionalDevTestConfig public class OrderRepositoryTests { } @RunWith(SpringRunner.class) @TransactionalDevTestConfig public class UserRepositoryTests { } 515", "chunk_char_count": 1414, "chunk_word_count": 121, "chunk_token_count": 353.5}, {"page_number": 516, "sentence_chunk": "Kotlin @RunWith(SpringRunner::class) @TransactionalDevTestConfig class OrderRepositoryTests @RunWith(SpringRunner::class) @TransactionalDevTestConfig class UserRepositoryTests If we write tests that use JUnit Jupiter, we can reduce code duplication even further, since annotations in JUnit 5 can also be used as meta-annotations. Consider the following example: Java @ExtendWith(SpringExtension.class) @ContextConfiguration({\"/app-config.xml\", \"/test-data-access-config.xml\"}) @ActiveProfiles(\"dev\") @Transactional class OrderRepositoryTests { } @ExtendWith(SpringExtension.class) @ContextConfiguration({\"/app-config.xml\", \"/test-data-access-config.xml\"}) @ActiveProfiles(\"dev\") @Transactional class UserRepositoryTests { } Kotlin @ExtendWith(SpringExtension::class) @ContextConfiguration(\"/app-config.xml\", \"/test-data-access-config.xml\") @ActiveProfiles(\"dev\") @Transactional class OrderRepositoryTests { } @ExtendWith(SpringExtension::class) @ContextConfiguration(\"/app-config.xml\", \"/test-data-access-config.xml\") @ActiveProfiles(\"dev\") @Transactional class UserRepositoryTests { } If we discover that we are repeating the preceding configuration across our JUnit Jupiter-based test suite, we can reduce the duplication by introducing a custom composed annotation that centralizes the common test configuration for Spring and JUnit Jupiter, as follows: 516", "chunk_char_count": 1360, "chunk_word_count": 118, "chunk_token_count": 340.0}, {"page_number": 517, "sentence_chunk": "Java @Target(ElementType. TYPE) @Retention(RetentionPolicy. RUNTIME) @ExtendWith(SpringExtension.class) @ContextConfiguration({\"/app-config.xml\", \"/test-data-access-config.xml\"}) @ActiveProfiles(\"dev\") @Transactional public @interface TransactionalDevTestConfig { } Kotlin @Target(AnnotationTarget. TYPE) @Retention(AnnotationRetention. RUNTIME) @ExtendWith(SpringExtension::class) @ContextConfiguration(\"/app-config.xml\", \"/test-data-access-config.xml\") @ActiveProfiles(\"dev\") @Transactional annotation class TransactionalDevTestConfig { } Then we can use our custom @TransactionalDevTestConfig annotation to simplify the configuration of individual JUnit Jupiter based test classes, as follows: Java @TransactionalDevTestConfig class OrderRepositoryTests { } @TransactionalDevTestConfig class UserRepositoryTests { } Kotlin @TransactionalDevTestConfig class OrderRepositoryTests { } @TransactionalDevTestConfig class UserRepositoryTests { } Since JUnit Jupiter supports the use of @Test, @RepeatedTest, ParameterizedTest, and others as meta- annotations, you can also create custom composed annotations at the test method level. For example, if we wish to create a composed annotation that combines the @Test and @Tag annotations from JUnit Jupiter with the @Transactional annotation from Spring, we could create an @TransactionalIntegrationTest annotation, as follows: 517", "chunk_char_count": 1375, "chunk_word_count": 135, "chunk_token_count": 343.75}, {"page_number": 518, "sentence_chunk": "Java @Target(ElementType. METHOD) @Retention(RetentionPolicy. RUNTIME) @Transactional @Tag(\"integration-test\") // org.junit.jupiter.api. Tag @Test // org.junit.jupiter.api. Test public @interface TransactionalIntegrationTest { } Kotlin @Target(AnnotationTarget. TYPE) @Retention(AnnotationRetention. RUNTIME) @Transactional @Tag(\"integration-test\") // org.junit.jupiter.api. Tag @Test // org.junit.jupiter.api. Test annotation class TransactionalIntegrationTest { } Then we can use our custom @TransactionalIntegrationTest annotation to simplify the configuration of individual JUnit Jupiter based test methods, as follows: Java @TransactionalIntegrationTest void saveOrder() { } @TransactionalIntegrationTest void deleteOrder() { } Kotlin @TransactionalIntegrationTest fun saveOrder() { } @TransactionalIntegrationTest fun deleteOrder() { } For further details, see the Spring Annotation Programming Model wiki page.3.3.5.", "chunk_char_count": 923, "chunk_word_count": 92, "chunk_token_count": 230.75}, {"page_number": 518, "sentence_chunk": "Spring TestContext Framework The Spring TestContext Framework (located in the org.springframework.test.context package) provides generic, annotation-driven unit and integration testing support that is agnostic of the testing framework in use. The TestContext framework also places a great deal of importance on convention over configuration, with reasonable defaults that you can override through annotation- based configuration. In addition to generic testing infrastructure, the TestContext framework provides explicit support 518", "chunk_char_count": 532, "chunk_word_count": 67, "chunk_token_count": 133.0}, {"page_number": 519, "sentence_chunk": "for JUnit 4, JUnit Jupiter (AKA JUnit 5), and TestNG. For JUnit 4 and TestNG, Spring provides abstract support classes. Furthermore, Spring provides a custom JUnit Runner and custom JUnit Rules for JUnit 4 and a custom Extension for JUnit Jupiter that let you write so-called POJO test classes. POJO test classes are not required to extend a particular class hierarchy, such as the abstract support classes. The following section provides an overview of the internals of the TestContext framework. If you are interested only in using the framework and are not interested in extending it with your own custom listeners or custom loaders, feel free to go directly to the configuration (context management, dependency injection, transaction management), support classes, and annotation support sections. Key Abstractions The core of the framework consists of the TestContextManager class and the TestContext, TestExecutionListener, and SmartContextLoader interfaces. A TestContextManager is created for each test class (for example, for the execution of all test methods within a single test class in JUnit Jupiter). The TestContextManager, in turn, manages a TestContext that holds the context of the current test. The TestContextManager also updates the state of the TestContext as the test progresses and delegates to TestExecutionListener implementations, which instrument the actual test execution by providing dependency injection, managing transactions, and so on.", "chunk_char_count": 1468, "chunk_word_count": 216, "chunk_token_count": 367.0}, {"page_number": 519, "sentence_chunk": "A SmartContextLoader is responsible for loading an ApplicationContext for a given test class. See the javadoc and the Spring test suite for further information and examples of various implementations. TestContext TestContext encapsulates the context in which a test is run (agnostic of the actual testing framework in use) and provides context management and caching support for the test instance for which it is responsible. The TestContext also delegates to a SmartContextLoader to load an ApplicationContext if requested. TestContextManager TestContextManager is the main entry point into the Spring TestContext Framework and is responsible for managing a single TestContext and signaling events to each registered TestExecutionListener at well-defined test execution points: \u2022 Prior to any \u201cbefore class\u201d or \u201cbefore all\u201d methods of a particular testing framework. \u2022Test instance post-processing. \u2022Prior to any \u201cbefore\u201d or \u201cbefore each\u201d methods of a particular testing framework. \u2022Immediately before execution of the test method but after test setup. \u2022Immediately after execution of the test method but before test tear down. \u2022After any \u201cafter\u201d or \u201cafter each\u201d methods of a particular testing framework. \u2022", "chunk_char_count": 1208, "chunk_word_count": 176, "chunk_token_count": 302.0}, {"page_number": 519, "sentence_chunk": "After any \u201cafter class\u201d or \u201cafter all\u201d methods of a particular testing framework. TestExecutionListener TestExecutionListener defines the API for reacting to test-execution events published by the 519", "chunk_char_count": 200, "chunk_word_count": 27, "chunk_token_count": 50.0}, {"page_number": 520, "sentence_chunk": "TestContextManager with which the listener is registered. See TestExecutionListener Configuration. Context Loaders ContextLoader is a strategy interface for loading an ApplicationContext for an integration test managed by the Spring TestContext Framework. You should implement SmartContextLoader instead of this interface to provide support for component classes, active bean definition profiles, test property sources, context hierarchies, and WebApplicationContext support. SmartContextLoader is an extension of the ContextLoader interface that supersedes the original minimal ContextLoader SPI. Specifically, a SmartContextLoader can choose to process resource locations, component classes, or context initializers. Furthermore, a SmartContextLoader can set active bean definition profiles and test property sources in the context that it loads. Spring provides the following implementations: \u2022 DelegatingSmartContextLoader: One of two default loaders, it delegates internally to an AnnotationConfigContextLoader, a GenericXmlContextLoader, or a GenericGroovyXmlContextLoader, depending either on the configuration declared for the test class or on the presence of default locations or default configuration classes. Groovy support is enabled only if Groovy is on the classpath. \u2022WebDelegatingSmartContextLoader: One of two default loaders, it delegates internally to an AnnotationConfigWebContextLoader, a GenericXmlWebContextLoader, or a GenericGroovyXmlWebContextLoader, depending either on the configuration declared for the test class or on the presence of default locations or default configuration classes.", "chunk_char_count": 1616, "chunk_word_count": 198, "chunk_token_count": 404.0}, {"page_number": 520, "sentence_chunk": "A web ContextLoader is used only if @WebAppConfiguration is present on the test class. Groovy support is enabled only if Groovy is on the classpath. \u2022AnnotationConfigContextLoader: Loads a standard ApplicationContext from component classes. \u2022AnnotationConfigWebContextLoader: Loads a WebApplicationContext from component classes. \u2022GenericGroovyXmlContextLoader: Loads a standard ApplicationContext from resource locations that are either Groovy scripts or XML configuration files. \u2022GenericGroovyXmlWebContextLoader: Loads a WebApplicationContext from resource locations that are either Groovy scripts or XML configuration files. \u2022GenericXmlContextLoader: Loads a standard ApplicationContext from XML resource locations. \u2022GenericXmlWebContextLoader: Loads a WebApplicationContext from XML resource locations. Bootstrapping the TestContext Framework The default configuration for the internals of the Spring TestContext Framework is sufficient for all common use cases. However, there are times when a development team or third party framework would like to change the default ContextLoader, implement a custom TestContext or ContextCache, augment the default sets of ContextCustomizerFactory and TestExecutionListener implementations, and so on.", "chunk_char_count": 1244, "chunk_word_count": 149, "chunk_token_count": 311.0}, {"page_number": 520, "sentence_chunk": "For such low-level control over how the TestContext framework operates, Spring provides a bootstrapping strategy. TestContextBootstrapper defines the SPI for bootstrapping the TestContext framework. A TestContextBootstrapper is used by the TestContextManager to load the TestExecutionListener 520", "chunk_char_count": 296, "chunk_word_count": 36, "chunk_token_count": 74.0}, {"page_number": 521, "sentence_chunk": "implementations for the current test and to build the TestContext that it manages. You can configure a custom bootstrapping strategy for a test class (or test class hierarchy) by using @BootstrapWith, either directly or as a meta-annotation. If a bootstrapper is not explicitly configured by using @BootstrapWith, either the DefaultTestContextBootstrapper or the WebTestContextBootstrapper is used, depending on the presence of @WebAppConfiguration. Since the TestContextBootstrapper SPI is likely to change in the future (to accommodate new requirements), we strongly encourage implementers not to implement this interface directly but rather to extend AbstractTestContextBootstrapper or one of its concrete subclasses instead. TestExecutionListener Configuration Spring provides the following TestExecutionListener implementations that are registered by default, exactly in the following order: \u2022 ServletTestExecutionListener: Configures Servlet API mocks for a WebApplicationContext. \u2022DirtiesContextBeforeModesTestExecutionListener: Handles the @DirtiesContext annotation for \u201cbefore\u201d modes. \u2022ApplicationEventsTestExecutionListener: Provides support for ApplicationEvents. \u2022DependencyInjectionTestExecutionListener: Provides dependency injection for the test instance. \u2022DirtiesContextTestExecutionListener: Handles the @DirtiesContext annotation for \u201cafter\u201d modes. \u2022TransactionalTestExecutionListener: Provides transactional test execution with default rollback semantics. \u2022", "chunk_char_count": 1477, "chunk_word_count": 164, "chunk_token_count": 369.25}, {"page_number": 521, "sentence_chunk": "SqlScriptsTestExecutionListener: Runs SQL scripts configured by using the @Sql annotation. \u2022EventPublishingTestExecutionListener: Publishes test execution events to the test\u2019s ApplicationContext (see Test Execution Events). Registering TestExecutionListener Implementations You can register TestExecutionListener implementations explicitly for a test class, its subclasses, and its nested classes by using the @TestExecutionListeners annotation. See annotation support and the javadoc for @TestExecutionListeners for details and examples.521", "chunk_char_count": 541, "chunk_word_count": 59, "chunk_token_count": 135.25}, {"page_number": 522, "sentence_chunk": "\uf05a Switching to default TestExecutionListener implementations If you extend a class that is annotated with @TestExecutionListeners and you need to switch to using the default set of listeners, you can annotate your class with the following. Java // Switch to default listeners @TestExecutionListeners( \u00a0  listeners = {}, \u00a0  inheritListeners = false, \u00a0  mergeMode = MERGE_WITH_DEFAULTS) class MyTest extends BaseTest { \u00a0  // class body... } Kotlin // Switch to default listeners @TestExecutionListeners( \u00a0  listeners = [], \u00a0  inheritListeners = false, \u00a0  mergeMode = MERGE_WITH_DEFAULTS) class MyTest : BaseTest { \u00a0  // class body... } Automatic Discovery of Default TestExecutionListener Implementations Registering TestExecutionListener implementations by using @TestExecutionListeners is suitable for custom listeners that are used in limited testing scenarios. However, it can become cumbersome if a custom listener needs to be used across an entire test suite. This issue is addressed through support for automatic discovery of default TestExecutionListener implementations through the SpringFactoriesLoader mechanism. Specifically, the spring-test module declares all core default TestExecutionListener implementations under the org.springframework.test.context. TestExecutionListener key in its META-INF/spring.factories properties file. Third-party frameworks and developers can contribute their own TestExecutionListener implementations to the list of default listeners in the same manner through their own META-INF/spring.factories properties file. Ordering TestExecutionListener Implementations When the TestContext framework discovers default TestExecutionListener implementations through the aforementioned SpringFactoriesLoader mechanism, the instantiated listeners are sorted by using Spring\u2019s AnnotationAwareOrderComparator, which honors Spring\u2019s Ordered interface and @Order annotation for ordering. AbstractTestExecutionListener and all default TestExecutionListener implementations provided by Spring implement Ordered with appropriate 522", "chunk_char_count": 2056, "chunk_word_count": 256, "chunk_token_count": 514.0}, {"page_number": 523, "sentence_chunk": "values. Third-party frameworks and developers should therefore make sure that their default TestExecutionListener implementations are registered in the proper order by implementing Ordered or declaring @Order. See the javadoc for the getOrder() methods of the core default TestExecutionListener implementations for details on what values are assigned to each core listener. Merging TestExecutionListener Implementations If a custom TestExecutionListener is registered via @TestExecutionListeners, the default listeners are not registered. In most common testing scenarios, this effectively forces the developer to manually declare all default listeners in addition to any custom listeners. The following listing demonstrates this style of configuration: Java @ContextConfiguration @TestExecutionListeners({ \u00a0  MyCustomTestExecutionListener.class, \u00a0  ServletTestExecutionListener.class, \u00a0  DirtiesContextBeforeModesTestExecutionListener.class, \u00a0  DependencyInjectionTestExecutionListener.class, \u00a0  DirtiesContextTestExecutionListener.class, \u00a0  TransactionalTestExecutionListener.class, \u00a0  SqlScriptsTestExecutionListener.class }) class MyTest { \u00a0  // class body... } Kotlin @ContextConfiguration @TestExecutionListeners( \u00a0  MyCustomTestExecutionListener::class, \u00a0  ServletTestExecutionListener::class, \u00a0  DirtiesContextBeforeModesTestExecutionListener::class, \u00a0  DependencyInjectionTestExecutionListener::class, \u00a0  DirtiesContextTestExecutionListener::class, \u00a0  TransactionalTestExecutionListener::class, \u00a0  SqlScriptsTestExecutionListener::class ) class MyTest { \u00a0  // class body... } The challenge with this approach is that it requires that the developer know exactly which listeners are registered by default. Moreover, the set of default listeners can change from release to release\u2009\u2014\u2009for example, SqlScriptsTestExecutionListener was introduced in Spring Framework 4.1, and DirtiesContextBeforeModesTestExecutionListener was introduced in Spring Framework 4.2.523", "chunk_char_count": 1967, "chunk_word_count": 213, "chunk_token_count": 491.75}, {"page_number": 524, "sentence_chunk": "Furthermore, third-party frameworks like Spring Boot and Spring Security register their own default TestExecutionListener implementations by using the aforementioned automatic discovery mechanism. To avoid having to be aware of and re-declare all default listeners, you can set the mergeMode attribute of @TestExecutionListeners to MergeMode. MERGE_WITH_DEFAULTS. MERGE_WITH_DEFAULTS indicates that locally declared listeners should be merged with the default listeners. The merging algorithm ensures that duplicates are removed from the list and that the resulting set of merged listeners is sorted according to the semantics of AnnotationAwareOrderComparator, as described in Ordering TestExecutionListener Implementations. If a listener implements Ordered or is annotated with @Order, it can influence the position in which it is merged with the defaults. Otherwise, locally declared listeners are appended to the list of default listeners when merged. For example, if the MyCustomTestExecutionListener class in the previous example configures its order value (for example, 500) to be less than the order of the ServletTestExecutionListener (which happens to be 1000), the MyCustomTestExecutionListener can then be automatically merged with the list of defaults in front of the ServletTestExecutionListener, and the previous example could be replaced with the following: Java @ContextConfiguration @TestExecutionListeners( \u00a0  listeners = MyCustomTestExecutionListener.class, \u00a0  mergeMode = MERGE_WITH_DEFAULTS ) class MyTest { \u00a0  // class body... } Kotlin @ContextConfiguration @TestExecutionListeners( \u00a0    listeners = [MyCustomTestExecutionListener::class], \u00a0    mergeMode = MERGE_WITH_DEFAULTS ) class MyTest { \u00a0  // class body... } Application Events Since Spring Framework 5.3.3, the TestContext framework provides support for recording application events published in the ApplicationContext so that assertions can be performed against those events within tests. All events published during the execution of a single test are made available via the ApplicationEvents API which allows you to process the events as a java.util. Stream.", "chunk_char_count": 2141, "chunk_word_count": 294, "chunk_token_count": 535.25}, {"page_number": 525, "sentence_chunk": "To use ApplicationEvents in your tests, do the following. \u2022Ensure that your test class is annotated or meta-annotated with @RecordApplicationEvents. \u2022Ensure that the ApplicationEventsTestExecutionListener is registered. Note, however, that ApplicationEventsTestExecutionListener is registered by default and only needs to be manually registered if you have custom configuration via @TestExecutionListeners that does not include the default listeners. \u2022Annotate a field of type ApplicationEvents with @Autowired and use that instance of ApplicationEvents in your test and lifecycle methods (such as @BeforeEach and @AfterEach methods in JUnit Jupiter).\u25e6 When using the SpringExtension for JUnit Jupiter, you may declare a method parameter of type ApplicationEvents in a test or lifecycle method as an alternative to an @Autowired field in the test class. The following test class uses the SpringExtension for JUnit Jupiter and AssertJ to assert the types of application events published while invoking a method in a Spring-managed component: Java @SpringJUnitConfig(/* ... */) @RecordApplicationEvents \u2460 class OrderServiceTests { \u00a0  @Autowired \u00a0  OrderService orderService; \u00a0  @Autowired \u00a0  ApplicationEvents events; \u2461 \u00a0  @Test \u00a0  void submitOrder() { \u00a0    // Invoke method in OrderService that publishes an event \u00a0    orderService.submitOrder(new Order(/* ... */)); \u00a0    // Verify that an OrderSubmitted event was published \u00a0    long numEvents = events.stream(OrderSubmitted.class).count(); \u2462 \u00a0    assertThat(numEvents).isEqualTo(1); \u00a0  } } \u2460 Annotate the test class with @RecordApplicationEvents.\u2461 Inject the ApplicationEvents instance for the current test.\u2462 Use the ApplicationEvents API to count how many OrderSubmitted events were published.525", "chunk_char_count": 1748, "chunk_word_count": 255, "chunk_token_count": 437.0}, {"page_number": 526, "sentence_chunk": "Kotlin @SpringJUnitConfig(/* ... */) @RecordApplicationEvents \u2460 class OrderServiceTests { \u00a0  @Autowired \u00a0  lateinit var orderService: OrderService \u00a0  @Autowired \u00a0  lateinit var events: ApplicationEvents \u2461 \u00a0  @Test \u00a0  fun submitOrder() { \u00a0    // Invoke method in OrderService that publishes an event \u00a0    orderService.submitOrder(Order(/* ... */)) \u00a0    // Verify that an OrderSubmitted event was published \u00a0    val numEvents = events.stream(OrderSubmitted::class).count() \u2462 \u00a0    assertThat(numEvents).isEqualTo(1) \u00a0  } } \u2460 Annotate the test class with @RecordApplicationEvents.\u2461 Inject the ApplicationEvents instance for the current test.\u2462 Use the ApplicationEvents API to count how many OrderSubmitted events were published. See the ApplicationEvents javadoc for further details regarding the ApplicationEvents API. Test Execution Events The EventPublishingTestExecutionListener introduced in Spring Framework 5.2 offers an alternative approach to implementing a custom TestExecutionListener. Components in the test\u2019s ApplicationContext can listen to the following events published by the EventPublishingTestExecutionListener, each of which corresponds to a method in the TestExecutionListener API. \u2022BeforeTestClassEvent \u2022 PrepareTestInstanceEvent \u2022 BeforeTestMethodEvent \u2022 BeforeTestExecutionEvent \u2022 AfterTestExecutionEvent \u2022 AfterTestMethodEvent \u2022 AfterTestClassEvent These events may be consumed for various reasons, such as resetting mock beans or tracing test execution. One advantage of consuming test execution events rather than implementing a custom TestExecutionListener is that test execution events may be consumed by any Spring bean registered 526", "chunk_char_count": 1660, "chunk_word_count": 226, "chunk_token_count": 415.0}, {"page_number": 527, "sentence_chunk": "in the test ApplicationContext, and such beans may benefit directly from dependency injection and other features of the ApplicationContext. In contrast, a TestExecutionListener is not a bean in the ApplicationContext.\uf05a The EventPublishingTestExecutionListener is registered by default; however, it only publishes events if the ApplicationContext has already been loaded. This prevents the ApplicationContext from being loaded unnecessarily or too early. Consequently, a BeforeTestClassEvent will not be published until after the ApplicationContext has been loaded by another TestExecutionListener. For example, with the default set of TestExecutionListener implementations registered, a BeforeTestClassEvent will not be published for the first test class that uses a particular test ApplicationContext, but a BeforeTestClassEvent will be published for any subsequent test class in the same test suite that uses the same test ApplicationContext since the context will already have been loaded when subsequent test classes run (as long as the context has not been removed from the ContextCache via @DirtiesContext or the max-size eviction policy). If you wish to ensure that a BeforeTestClassEvent is always published for every test class, you need to register a TestExecutionListener that loads the ApplicationContext in the beforeTestClass callback, and that TestExecutionListener must be registered before the EventPublishingTestExecutionListener. Similarly, if @DirtiesContext is used to remove the ApplicationContext from the context cache after the last test method in a given test class, the AfterTestClassEvent will not be published for that test class. In order to listen to test execution events, a Spring bean may choose to implement the org.springframework.context. ApplicationListener interface.", "chunk_char_count": 1806, "chunk_word_count": 247, "chunk_token_count": 451.5}, {"page_number": 527, "sentence_chunk": "Alternatively, listener methods can be annotated with @EventListener and configured to listen to one of the particular event types listed above (see Annotation-based Event Listeners). Due to the popularity of this approach, Spring provides the following dedicated @EventListener annotations to simplify registration of test execution event listeners. These annotations reside in the org.springframework.test.context.event.annotation package. \u2022@BeforeTestClass \u2022 @PrepareTestInstance \u2022 @BeforeTestMethod \u2022 @BeforeTestExecution \u2022 @AfterTestExecution \u2022 @AfterTestMethod \u2022 @AfterTestClass Exception Handling By default, if a test execution event listener throws an exception while consuming an event, that exception will propagate to the underlying testing framework in use (such as JUnit or TestNG). For 527", "chunk_char_count": 804, "chunk_word_count": 102, "chunk_token_count": 201.0}, {"page_number": 528, "sentence_chunk": "example, if the consumption of a BeforeTestMethodEvent results in an exception, the corresponding test method will fail as a result of the exception. In contrast, if an asynchronous test execution event listener throws an exception, the exception will not propagate to the underlying testing framework. For further details on asynchronous exception handling, consult the class-level javadoc for @EventListener. Asynchronous Listeners If you want a particular test execution event listener to process events asynchronously, you can use Spring\u2019s regular @Async support. For further details, consult the class-level javadoc for @EventListener. Context Management Each TestContext provides context management and caching support for the test instance for which it is responsible. Test instances do not automatically receive access to the configured ApplicationContext. However, if a test class implements the ApplicationContextAware interface, a reference to the ApplicationContext is supplied to the test instance. Note that AbstractJUnit4SpringContextTests and AbstractTestNGSpringContextTests implement ApplicationContextAware and, therefore, provide access to the ApplicationContext automatically.\uf0eb @Autowired ApplicationContext As an alternative to implementing the ApplicationContextAware interface, you can inject the application context for your test class through the @Autowired annotation on either a field or setter method, as the following example shows: Java @SpringJUnitConfig class MyTest { \u00a0  @Autowired \u2460 \u00a0  ApplicationContext applicationContext; \u00a0  // class body... } \u2460 Injecting the ApplicationContext.", "chunk_char_count": 1617, "chunk_word_count": 213, "chunk_token_count": 404.25}, {"page_number": 528, "sentence_chunk": "Kotlin @SpringJUnitConfig class MyTest { \u00a0  @Autowired \u2460 \u00a0  lateinit var applicationContext: ApplicationContext \u00a0  // class body... } 528", "chunk_char_count": 137, "chunk_word_count": 22, "chunk_token_count": 34.25}, {"page_number": 529, "sentence_chunk": "\u2460 Injecting the ApplicationContext. Similarly, if your test is configured to load a WebApplicationContext, you can inject the web application context into your test, as follows: Java @SpringJUnitWebConfig \u2460 class MyWebAppTest { \u00a0  @Autowired \u2461 \u00a0  WebApplicationContext wac; \u00a0  // class body... } \u2460 Configuring the WebApplicationContext.\u2461 Injecting the WebApplicationContext. Kotlin @SpringJUnitWebConfig \u2460 class MyWebAppTest { \u00a0  @Autowired \u2461 \u00a0  lateinit var wac: WebApplicationContext \u00a0  // class body... } \u2460 Configuring the WebApplicationContext.\u2461 Injecting the WebApplicationContext. Dependency injection by using @Autowired is provided by the DependencyInjectionTestExecutionListener, which is configured by default (see Dependency Injection of Test Fixtures). Test classes that use the TestContext framework do not need to extend any particular class or implement a specific interface to configure their application context. Instead, configuration is achieved by declaring the @ContextConfiguration annotation at the class level. If your test class does not explicitly declare application context resource locations or component classes, the configured ContextLoader determines how to load a context from a default location or default configuration classes. In addition to context resource locations and component classes, an application context can also be configured through application context initializers.", "chunk_char_count": 1415, "chunk_word_count": 193, "chunk_token_count": 353.75}, {"page_number": 529, "sentence_chunk": "The following sections explain how to use Spring\u2019s @ContextConfiguration annotation to configure a test ApplicationContext by using XML configuration files, Groovy scripts, component classes (typically @Configuration classes), or context initializers. Alternatively, you can implement and configure your own custom SmartContextLoader for advanced use cases.529", "chunk_char_count": 360, "chunk_word_count": 44, "chunk_token_count": 90.0}, {"page_number": 530, "sentence_chunk": "\u2022 Context Configuration with XML resources \u2022 Context Configuration with Groovy Scripts \u2022 Context Configuration with Component Classes \u2022 Mixing XML, Groovy Scripts, and Component Classes \u2022 Context Configuration with Context Initializers \u2022 Context Configuration Inheritance \u2022 Context Configuration with Environment Profiles \u2022 Context Configuration with Test Property Sources \u2022 Context Configuration with Dynamic Property Sources \u2022 Loading a WebApplicationContext \u2022 Context Caching \u2022 Context Hierarchies Context Configuration with XML resources To load an ApplicationContext for your tests by using XML configuration files, annotate your test class with @ContextConfiguration and configure the locations attribute with an array that contains the resource locations of XML configuration metadata. A plain or relative path (for example, context.xml) is treated as a classpath resource that is relative to the package in which the test class is defined. A path starting with a slash is treated as an absolute classpath location (for example, /org/example/config.xml). A path that represents a resource URL (i.e., a path prefixed with classpath:, file:, http:, etc.)is used as is. Java @ExtendWith(SpringExtension.class) // ApplicationContext will be loaded from \"/app-config.xml\" and // \"/test-config.xml\" in the root of the classpath @ContextConfiguration(locations={\"/app-config.xml\", \"/test-config.xml\"}) \u2460 class MyTest { \u00a0  // class body... } \u2460 Setting the locations attribute to a list of XML files. Kotlin @ExtendWith(SpringExtension::class) // ApplicationContext will be loaded from \"/app-config.xml\" and // \"/test-config.xml\" in the root of the classpath @ContextConfiguration(\"/app-config.xml\", \"/test-config.xml\") \u2460 class MyTest { \u00a0  // class body... } 530", "chunk_char_count": 1760, "chunk_word_count": 240, "chunk_token_count": 440.0}, {"page_number": 531, "sentence_chunk": "\u2460 Setting the locations attribute to a list of XML files.@ContextConfiguration supports an alias for the locations attribute through the standard Java value attribute. Thus, if you do not need to declare additional attributes in @ContextConfiguration, you can omit the declaration of the locations attribute name and declare the resource locations by using the shorthand format demonstrated in the following example: Java @ExtendWith(SpringExtension.class) @ContextConfiguration({\"/app-config.xml\", \"/test-config.xml\"}) \u2460 class MyTest { \u00a0  // class body... } \u2460 Specifying XML files without using the location attribute. Kotlin @ExtendWith(SpringExtension::class) @ContextConfiguration(\"/app-config.xml\", \"/test-config.xml\") \u2460 class MyTest { \u00a0  // class body... } \u2460 Specifying XML files without using the location attribute. If you omit both the locations and the value attributes from the @ContextConfiguration annotation, the TestContext framework tries to detect a default XML resource location. Specifically, GenericXmlContextLoader and GenericXmlWebContextLoader detect a default location based on the name of the test class. If your class is named com.example. MyTest, GenericXmlContextLoader loads your application context from \"classpath:com/example/MyTest-context.xml\". The following example shows how to do so: Java @ExtendWith(SpringExtension.class) // ApplicationContext will be loaded from // \"classpath:com/example/MyTest-context.xml\" @ContextConfiguration \u2460 class MyTest { \u00a0  // class body... } \u2460 Loading configuration from the default location.531", "chunk_char_count": 1562, "chunk_word_count": 198, "chunk_token_count": 390.5}, {"page_number": 532, "sentence_chunk": "Kotlin @ExtendWith(SpringExtension::class) // ApplicationContext will be loaded from // \"classpath:com/example/MyTest-context.xml\" @ContextConfiguration \u2460 class MyTest { \u00a0  // class body... } \u2460 Loading configuration from the default location. Context Configuration with Groovy Scripts To load an ApplicationContext for your tests by using Groovy scripts that use the Groovy Bean Definition DSL, you can annotate your test class with @ContextConfiguration and configure the locations or value attribute with an array that contains the resource locations of Groovy scripts. Resource lookup semantics for Groovy scripts are the same as those described for XML configuration files.\uf0eb Enabling Groovy script support Support for using Groovy scripts to load an ApplicationContext in the Spring TestContext Framework is enabled automatically if Groovy is on the classpath. The following example shows how to specify Groovy configuration files: Java @ExtendWith(SpringExtension.class) // ApplicationContext will be loaded from \"/AppConfig.groovy\" and // \"/TestConfig.groovy\" in the root of the classpath @ContextConfiguration({\"/AppConfig.groovy\", \"/TestConfig. Groovy\"}) \u2460 class MyTest { \u00a0  // class body... } Kotlin @ExtendWith(SpringExtension::class) // ApplicationContext will be loaded from \"/AppConfig.groovy\" and // \"/TestConfig.groovy\" in the root of the classpath @ContextConfiguration(\"/AppConfig.groovy\", \"/TestConfig. Groovy\") \u2460 class MyTest { \u00a0  // class body... } \u2460 Specifying the location of Groovy configuration files. If you omit both the locations and value attributes from the @ContextConfiguration annotation, the 532", "chunk_char_count": 1628, "chunk_word_count": 215, "chunk_token_count": 407.0}, {"page_number": 533, "sentence_chunk": "TestContext framework tries to detect a default Groovy script. Specifically, GenericGroovyXmlContextLoader and GenericGroovyXmlWebContextLoader detect a default location based on the name of the test class. If your class is named com.example. MyTest, the Groovy context loader loads your application context from \"classpath:com/example/MyTestContext.groovy\". The following example shows how to use the default: Java @ExtendWith(SpringExtension.class) // ApplicationContext will be loaded from // \"classpath:com/example/MyTestContext.groovy\" @ContextConfiguration \u2460 class MyTest { \u00a0  // class body... } \u2460 Loading configuration from the default location. Kotlin @ExtendWith(SpringExtension::class) // ApplicationContext will be loaded from // \"classpath:com/example/MyTestContext.groovy\" @ContextConfiguration \u2460 class MyTest { \u00a0  // class body... } \u2460 Loading configuration from the default location.533", "chunk_char_count": 900, "chunk_word_count": 107, "chunk_token_count": 225.0}, {"page_number": 534, "sentence_chunk": "\uf0eb Declaring XML configuration and Groovy scripts simultaneously You can declare both XML configuration files and Groovy scripts simultaneously by using the locations or value attribute of @ContextConfiguration. If the path to a configured resource location ends with .xml, it is loaded by using an XmlBeanDefinitionReader. Otherwise, it is loaded by using a GroovyBeanDefinitionReader. The following listing shows how to combine both in an integration test: Java @ExtendWith(SpringExtension.class) // ApplicationContext will be loaded from // \"/app-config.xml\" and \"/TestConfig.groovy\" @ContextConfiguration({ \"/app-config.xml\", \"/TestConfig.groovy\" }) class MyTest { \u00a0  // class body... } Kotlin @ExtendWith(SpringExtension::class) // ApplicationContext will be loaded from // \"/app-config.xml\" and \"/TestConfig.groovy\" @ContextConfiguration(\"/app-config.xml\", \"/TestConfig.groovy\") class MyTest { \u00a0  // class body... } Context Configuration with Component Classes To load an ApplicationContext for your tests by using component classes (see Java-based container configuration), you can annotate your test class with @ContextConfiguration and configure the classes attribute with an array that contains references to component classes. The following example shows how to do so: Java @ExtendWith(SpringExtension.class) // ApplicationContext will be loaded from AppConfig and TestConfig @ContextConfiguration(classes = {AppConfig.class, TestConfig.class}) \u2460 class MyTest { \u00a0  // class body... } \u2460 Specifying component classes.534", "chunk_char_count": 1528, "chunk_word_count": 193, "chunk_token_count": 382.0}, {"page_number": 535, "sentence_chunk": "Kotlin @ExtendWith(SpringExtension::class) // ApplicationContext will be loaded from AppConfig and TestConfig @ContextConfiguration(classes = [AppConfig::class, TestConfig::class]) \u2460 class MyTest { \u00a0  // class body... } \u2460 Specifying component classes.\uf0eb Component Classes The term \u201ccomponent class\u201d can refer to any of the following: \u2022 A class annotated with @Configuration. \u2022A component (that is, a class annotated with @Component, @Service, @Repository, or other stereotype annotations). \u2022A JSR-330 compliant class that is annotated with jakarta.inject annotations. \u2022Any class that contains @Bean-methods. \u2022Any other class that is intended to be registered as a Spring component (i.e., a Spring bean in the ApplicationContext), potentially taking advantage of automatic autowiring of a single constructor without the use of Spring annotations. See the javadoc of @Configuration and @Bean for further information regarding the configuration and semantics of component classes, paying special attention to the discussion of @Bean Lite Mode. If you omit the classes attribute from the @ContextConfiguration annotation, the TestContext framework tries to detect the presence of default configuration classes. Specifically, AnnotationConfigContextLoader and AnnotationConfigWebContextLoader detect all static nested classes of the test class that meet the requirements for configuration class implementations, as specified in the @Configuration javadoc. Note that the name of the configuration class is arbitrary.", "chunk_char_count": 1509, "chunk_word_count": 201, "chunk_token_count": 377.25}, {"page_number": 535, "sentence_chunk": "In addition, a test class can contain more than one static nested configuration class if desired. In the following example, the OrderServiceTest class declares a static nested configuration class named Config that is automatically used to load the ApplicationContext for the test class: 535", "chunk_char_count": 290, "chunk_word_count": 44, "chunk_token_count": 72.5}, {"page_number": 536, "sentence_chunk": "Java @SpringJUnitConfig \u2460 // ApplicationContext will be loaded from the // static nested Config class class OrderServiceTest { \u00a0  @Configuration \u00a0  static class Config { \u00a0    // this bean will be injected into the OrderServiceTest class \u00a0    @Bean \u00a0    OrderService orderService() { \u00a0      OrderService orderService = new OrderServiceImpl(); \u00a0      // set properties, etc.\u00a0      return orderService; \u00a0    } \u00a0  } \u00a0  @Autowired \u00a0  OrderService orderService; \u00a0  @Test \u00a0  void testOrderService() { \u00a0    // test the orderService \u00a0  } } \u2460 Loading configuration information from the nested Config class.536", "chunk_char_count": 599, "chunk_word_count": 125, "chunk_token_count": 149.75}, {"page_number": 537, "sentence_chunk": "Kotlin @SpringJUnitConfig \u2460 // ApplicationContext will be loaded from the nested Config class class OrderServiceTest { \u00a0  @Autowired \u00a0  lateinit var orderService: OrderService \u00a0  @Configuration \u00a0  class Config { \u00a0    // this bean will be injected into the OrderServiceTest class \u00a0    @Bean \u00a0    fun orderService(): OrderService { \u00a0      // set properties, etc.\u00a0      return OrderServiceImpl() \u00a0    } \u00a0  } \u00a0  @Test \u00a0  fun testOrderService() { \u00a0    // test the orderService \u00a0  } } \u2460 Loading configuration information from the nested Config class. Mixing XML, Groovy Scripts, and Component Classes It may sometimes be desirable to mix XML configuration files, Groovy scripts, and component classes (typically @Configuration classes) to configure an ApplicationContext for your tests. For example, if you use XML configuration in production, you may decide that you want to use @Configuration classes to configure specific Spring-managed components for your tests, or vice versa. Furthermore, some third-party frameworks (such as Spring Boot) provide first-class support for loading an ApplicationContext from different types of resources simultaneously (for example, XML configuration files, Groovy scripts, and @Configuration classes). The Spring Framework, historically, has not supported this for standard deployments. Consequently, most of the SmartContextLoader implementations that the Spring Framework delivers in the spring-test module support only one resource type for each test context. However, this does not mean that you cannot use both. One exception to the general rule is that the GenericGroovyXmlContextLoader and GenericGroovyXmlWebContextLoader support both XML configuration files and Groovy scripts simultaneously. Furthermore, third-party frameworks may choose to support the declaration of both locations and classes through @ContextConfiguration, and, with the standard testing support in the TestContext framework, you have the following options.", "chunk_char_count": 1969, "chunk_word_count": 304, "chunk_token_count": 492.25}, {"page_number": 537, "sentence_chunk": "If you want to use resource locations (for example, XML or Groovy) and @Configuration classes to configure your tests, you must pick one as the entry point, and that one must include or import the 537", "chunk_char_count": 200, "chunk_word_count": 36, "chunk_token_count": 50.0}, {"page_number": 538, "sentence_chunk": "other. For example, in XML or Groovy scripts, you can include @Configuration classes by using component scanning or defining them as normal Spring beans, whereas, in a @Configuration class, you can use @ImportResource to import XML configuration files or Groovy scripts. Note that this behavior is semantically equivalent to how you configure your application in production: In production configuration, you define either a set of XML or Groovy resource locations or a set of @Configuration classes from which your production ApplicationContext is loaded, but you still have the freedom to include or import the other type of configuration. Context Configuration with Context Initializers To configure an ApplicationContext for your tests by using context initializers, annotate your test class with @ContextConfiguration and configure the initializers attribute with an array that contains references to classes that implement ApplicationContextInitializer. The declared context initializers are then used to initialize the ConfigurableApplicationContext that is loaded for your tests. Note that the concrete ConfigurableApplicationContext type supported by each declared initializer must be compatible with the type of ApplicationContext created by the SmartContextLoader in use (typically a GenericApplicationContext). Furthermore, the order in which the initializers are invoked depends on whether they implement Spring\u2019s Ordered interface or are annotated with Spring\u2019s @Order annotation or the standard @Priority annotation. The following example shows how to use initializers: Java @ExtendWith(SpringExtension.class) // ApplicationContext will be loaded from TestConfig // and initialized by TestAppCtxInitializer @ContextConfiguration( \u00a0  classes = TestConfig.class, \u00a0  initializers = TestAppCtxInitializer.class) \u2460 class MyTest { \u00a0  // class body... } \u2460 Specifying configuration by using a configuration class and an initializer. Kotlin @ExtendWith(SpringExtension::class) // ApplicationContext will be loaded from TestConfig // and initialized by TestAppCtxInitializer @ContextConfiguration( \u00a0    classes = [TestConfig::class], \u00a0    initializers = [TestAppCtxInitializer::class]) \u2460 class MyTest { \u00a0  // class body... } \u2460 Specifying configuration by using a configuration class and an initializer. You can also omit the declaration of XML configuration files, Groovy scripts, or component classes 538", "chunk_char_count": 2409, "chunk_word_count": 330, "chunk_token_count": 602.25}, {"page_number": 539, "sentence_chunk": "in @ContextConfiguration entirely and instead declare only ApplicationContextInitializer classes, which are then responsible for registering beans in the context\u2009\u2014\u2009for example, by programmatically loading bean definitions from XML files or configuration classes. The following example shows how to do so: Java @ExtendWith(SpringExtension.class) // ApplicationContext will be initialized by EntireAppInitializer // which presumably registers beans in the context @ContextConfiguration(initializers = EntireAppInitializer.class) \u2460 class MyTest { \u00a0  // class body... } \u2460 Specifying configuration by using only an initializer. Kotlin @ExtendWith(SpringExtension::class) // ApplicationContext will be initialized by EntireAppInitializer // which presumably registers beans in the context @ContextConfiguration(initializers = [EntireAppInitializer::class]) \u2460 class MyTest { \u00a0  // class body... } \u2460 Specifying configuration by using only an initializer. Context Configuration Inheritance @ContextConfiguration supports boolean inheritLocations and inheritInitializers attributes that denote whether resource locations or component classes and context initializers declared by superclasses should be inherited. The default value for both flags is true. This means that a test class inherits the resource locations or component classes as well as the context initializers declared by any superclasses. Specifically, the resource locations or component classes for a test class are appended to the list of resource locations or annotated classes declared by superclasses. Similarly, the initializers for a given test class are added to the set of initializers defined by test superclasses. Thus, subclasses have the option of extending the resource locations, component classes, or context initializers. If the inheritLocations or inheritInitializers attribute in @ContextConfiguration is set to false, the resource locations or component classes and the context initializers, respectively, for the test class shadow and effectively replace the configuration defined by superclasses.", "chunk_char_count": 2073, "chunk_word_count": 268, "chunk_token_count": 518.25}, {"page_number": 539, "sentence_chunk": "\uf05a As of Spring Framework 5.3, test configuration may also be inherited from enclosing classes. See @Nested test class configuration for details. In the next example, which uses XML resource locations, the ApplicationContext for ExtendedTest is loaded from base-config.xml and extended-config.xml, in that order. Beans defined in extended- 539", "chunk_char_count": 342, "chunk_word_count": 49, "chunk_token_count": 85.5}, {"page_number": 540, "sentence_chunk": "config.xml can, therefore, override (that is, replace) those defined in base-config.xml. The following example shows how one class can extend another and use both its own configuration file and the superclass\u2019s configuration file: Java @ExtendWith(SpringExtension.class) // ApplicationContext will be loaded from \"/base-config.xml\" // in the root of the classpath @ContextConfiguration(\"/base-config.xml\") \u2460 class BaseTest { \u00a0  // class body... } // ApplicationContext will be loaded from \"/base-config.xml\" and // \"/extended-config.xml\" in the root of the classpath @ContextConfiguration(\"/extended-config.xml\") \u2461 class ExtendedTest extends BaseTest { \u00a0  // class body... } \u2460 Configuration file defined in the superclass.\u2461 Configuration file defined in the subclass. Kotlin @ExtendWith(SpringExtension::class) // ApplicationContext will be loaded from \"/base-config.xml\" // in the root of the classpath @ContextConfiguration(\"/base-config.xml\") \u2460 open class BaseTest { \u00a0  // class body... } // ApplicationContext will be loaded from \"/base-config.xml\" and // \"/extended-config.xml\" in the root of the classpath @ContextConfiguration(\"/extended-config.xml\") \u2461 class ExtendedTest : BaseTest() { \u00a0  // class body... } \u2460 Configuration file defined in the superclass.\u2461 Configuration file defined in the subclass. Similarly, in the next example, which uses component classes, the ApplicationContext for ExtendedTest is loaded from the BaseConfig and ExtendedConfig classes, in that order. Beans defined in ExtendedConfig can, therefore, override (that is, replace) those defined in BaseConfig. The following example shows how one class can extend another and use both its own configuration class and the superclass\u2019s configuration class: 540", "chunk_char_count": 1736, "chunk_word_count": 233, "chunk_token_count": 434.0}, {"page_number": 541, "sentence_chunk": "Java // ApplicationContext will be loaded from BaseConfig @SpringJUnitConfig(BaseConfig.class) \u2460 class BaseTest { \u00a0  // class body... } // ApplicationContext will be loaded from BaseConfig and ExtendedConfig @SpringJUnitConfig(ExtendedConfig.class) \u2461 class ExtendedTest extends BaseTest { \u00a0  // class body... } \u2460 Configuration class defined in the superclass.\u2461 Configuration class defined in the subclass. Kotlin // ApplicationContext will be loaded from BaseConfig @SpringJUnitConfig(BaseConfig::class) \u2460 open class BaseTest { \u00a0  // class body... } // ApplicationContext will be loaded from BaseConfig and ExtendedConfig @SpringJUnitConfig(ExtendedConfig::class) \u2461 class ExtendedTest : BaseTest() { \u00a0  // class body... } \u2460 Configuration class defined in the superclass.\u2461 Configuration class defined in the subclass. In the next example, which uses context initializers, the ApplicationContext for ExtendedTest is initialized by using BaseInitializer and ExtendedInitializer. Note, however, that the order in which the initializers are invoked depends on whether they implement Spring\u2019s Ordered interface or are annotated with Spring\u2019s @Order annotation or the standard @Priority annotation. The following example shows how one class can extend another and use both its own initializer and the superclass\u2019s initializer: 541", "chunk_char_count": 1323, "chunk_word_count": 180, "chunk_token_count": 330.75}, {"page_number": 542, "sentence_chunk": "Java // ApplicationContext will be initialized by BaseInitializer @SpringJUnitConfig(initializers = BaseInitializer.class) \u2460 class BaseTest { \u00a0  // class body... } // ApplicationContext will be initialized by BaseInitializer // and ExtendedInitializer @SpringJUnitConfig(initializers = ExtendedInitializer.class) \u2461 class ExtendedTest extends BaseTest { \u00a0  // class body... } \u2460 Initializer defined in the superclass.\u2461 Initializer defined in the subclass. Kotlin // ApplicationContext will be initialized by BaseInitializer @SpringJUnitConfig(initializers = [BaseInitializer::class]) \u2460 open class BaseTest { \u00a0  // class body... } // ApplicationContext will be initialized by BaseInitializer // and ExtendedInitializer @SpringJUnitConfig(initializers = [ExtendedInitializer::class]) \u2461 class ExtendedTest : BaseTest() { \u00a0  // class body... } \u2460 Initializer defined in the superclass.\u2461 Initializer defined in the subclass. Context Configuration with Environment Profiles The Spring Framework has first-class support for the notion of environments and profiles (AKA \"bean definition profiles\"), and integration tests can be configured to activate particular bean definition profiles for various testing scenarios. This is achieved by annotating a test class with the @ActiveProfiles annotation and supplying a list of profiles that should be activated when loading the ApplicationContext for the test.\uf05a You can use @ActiveProfiles with any implementation of the SmartContextLoader SPI, but @ActiveProfiles is not supported with implementations of the older ContextLoader SPI. Consider two examples with XML configuration and @Configuration classes: 542", "chunk_char_count": 1645, "chunk_word_count": 215, "chunk_token_count": 411.25}, {"page_number": 543, "sentence_chunk": "<!--app-config.xml --> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\" \u00a0  xmlns:jee=\"http://www.springframework.org/schema/jee\" \u00a0  xsi:schemaLocation=\"...\"> \u00a0  <bean id=\"transferService\" \u00a0      class=\"com.bank.service.internal. DefaultTransferService\"> \u00a0    <constructor-arg ref=\"accountRepository\"/> \u00a0    <constructor-arg ref=\"feePolicy\"/> \u00a0  </bean> \u00a0  <bean id=\"accountRepository\" \u00a0      class=\"com.bank.repository.internal. JdbcAccountRepository\"> \u00a0    <constructor-arg ref=\"dataSource\"/> \u00a0  </bean> \u00a0  <bean id=\"feePolicy\" \u00a0    class=\"com.bank.service.internal. ZeroFeePolicy\"/> \u00a0  <beans profile=\"dev\"> \u00a0    <jdbc:embedded-database id=\"dataSource\"> \u00a0      <jdbc:script \u00a0        location=\"classpath:com/bank/config/sql/schema.sql\"/> \u00a0      <jdbc:script \u00a0        location=\"classpath:com/bank/config/sql/test-data.sql\"/> \u00a0    </jdbc:embedded-database> \u00a0  </beans> \u00a0  <beans profile=\"production\"> \u00a0    <jee:jndi-lookup id=\"dataSource\" jndi-name=\"java:comp/env/jdbc/datasource\"/> \u00a0  </beans> \u00a0  <beans profile=\"default\"> \u00a0    <jdbc:embedded-database id=\"dataSource\"> \u00a0      <jdbc:script \u00a0        location=\"classpath:com/bank/config/sql/schema.sql\"/> \u00a0    </jdbc:embedded-database> \u00a0  </beans> </beans> 543", "chunk_char_count": 1333, "chunk_word_count": 174, "chunk_token_count": 333.25}, {"page_number": 544, "sentence_chunk": "Java @ExtendWith(SpringExtension.class) // ApplicationContext will be loaded from \"classpath:/app-config.xml\" @ContextConfiguration(\"/app-config.xml\") @ActiveProfiles(\"dev\") class TransferServiceTest { \u00a0  @Autowired \u00a0  TransferService transferService; \u00a0  @Test \u00a0  void testTransferService() { \u00a0    // test the transferService \u00a0  } } Kotlin @ExtendWith(SpringExtension::class) // ApplicationContext will be loaded from \"classpath:/app-config.xml\" @ContextConfiguration(\"/app-config.xml\") @ActiveProfiles(\"dev\") class TransferServiceTest { \u00a0  @Autowired \u00a0  lateinit var transferService: TransferService \u00a0  @Test \u00a0  fun testTransferService() { \u00a0    // test the transferService \u00a0  } } When TransferServiceTest is run, its ApplicationContext is loaded from the app-config.xml configuration file in the root of the classpath. If you inspect app-config.xml, you can see that the accountRepository bean has a dependency on a dataSource bean. However, dataSource is not defined as a top-level bean. Instead, dataSource is defined three times: in the production profile, in the dev profile, and in the default profile. By annotating TransferServiceTest with @ActiveProfiles(\"dev\"), we instruct the Spring TestContext Framework to load the ApplicationContext with the active profiles set to {\"dev\"}. As a result, an embedded database is created and populated with test data, and the accountRepository bean is wired with a reference to the development DataSource. That is likely what we want in an integration test. It is sometimes useful to assign beans to a default profile. Beans within the default profile are included only when no other profile is specifically activated. You can use this to define \u201cfallback\u201d beans to be used in the application\u2019s default state.", "chunk_char_count": 1755, "chunk_word_count": 249, "chunk_token_count": 438.75}, {"page_number": 545, "sentence_chunk": "source for dev and production profiles, but define an in-memory data source as a default when neither of these is active. The following code listings demonstrate how to implement the same configuration and integration test with @Configuration classes instead of XML: Java @Configuration @Profile(\"dev\") public class StandaloneDataConfig { \u00a0  @Bean \u00a0  public DataSource dataSource() { \u00a0    return new EmbeddedDatabaseBuilder() \u00a0      .setType(EmbeddedDatabaseType. HSQL) \u00a0      .addScript(\"classpath:com/bank/config/sql/schema.sql\") \u00a0      .addScript(\"classpath:com/bank/config/sql/test-data.sql\") \u00a0      .build(); \u00a0  } } Kotlin @Configuration @Profile(\"dev\") class StandaloneDataConfig { \u00a0  @Bean \u00a0  fun dataSource(): DataSource { \u00a0    return EmbeddedDatabaseBuilder() \u00a0        .setType(EmbeddedDatabaseType. HSQL) \u00a0        .addScript(\"classpath:com/bank/config/sql/schema.sql\") \u00a0        .addScript(\"classpath:com/bank/config/sql/test-data.sql\") \u00a0        .build() \u00a0  } } 545", "chunk_char_count": 974, "chunk_word_count": 160, "chunk_token_count": 243.5}, {"page_number": 546, "sentence_chunk": "Java @Configuration @Profile(\"production\") public class JndiDataConfig { \u00a0  @Bean(destroyMethod=\"\") \u00a0  public DataSource dataSource() throws Exception { \u00a0    Context ctx = new InitialContext(); \u00a0    return (DataSource) ctx.lookup(\"java:comp/env/jdbc/datasource\"); \u00a0  } } Kotlin @Configuration @Profile(\"production\") class JndiDataConfig { \u00a0  @Bean(destroyMethod = \"\") \u00a0  fun dataSource(): DataSource { \u00a0    val ctx = InitialContext() \u00a0    return ctx.lookup(\"java:comp/env/jdbc/datasource\") as DataSource \u00a0  } } Java @Configuration @Profile(\"default\") public class DefaultDataConfig { \u00a0  @Bean \u00a0  public DataSource dataSource() { \u00a0    return new EmbeddedDatabaseBuilder() \u00a0      .setType(EmbeddedDatabaseType. HSQL) \u00a0      .addScript(\"classpath:com/bank/config/sql/schema.sql\") \u00a0      .build(); \u00a0  } } 546", "chunk_char_count": 804, "chunk_word_count": 125, "chunk_token_count": 201.0}, {"page_number": 547, "sentence_chunk": "Kotlin @Configuration @Profile(\"default\") class DefaultDataConfig { \u00a0  @Bean \u00a0  fun dataSource(): DataSource { \u00a0    return EmbeddedDatabaseBuilder() \u00a0        .setType(EmbeddedDatabaseType. HSQL) \u00a0        .addScript(\"classpath:com/bank/config/sql/schema.sql\") \u00a0        .build() \u00a0  } } Java @Configuration public class TransferServiceConfig { \u00a0  @Autowired DataSource dataSource; \u00a0  @Bean \u00a0  public TransferService transferService() { \u00a0    return new DefaultTransferService(accountRepository(), feePolicy()); \u00a0  } \u00a0  @Bean \u00a0  public AccountRepository accountRepository() { \u00a0    return new JdbcAccountRepository(dataSource); \u00a0  } \u00a0  @Bean \u00a0  public FeePolicy feePolicy() { \u00a0    return new ZeroFeePolicy(); \u00a0  } } 547", "chunk_char_count": 713, "chunk_word_count": 124, "chunk_token_count": 178.25}, {"page_number": 548, "sentence_chunk": "Kotlin @Configuration class TransferServiceConfig { \u00a0  @Autowired \u00a0  lateinit var dataSource: DataSource \u00a0  @Bean \u00a0  fun transferService(): TransferService { \u00a0    return DefaultTransferService(accountRepository(), feePolicy()) \u00a0  } \u00a0  @Bean \u00a0  fun accountRepository(): AccountRepository { \u00a0    return JdbcAccountRepository(dataSource) \u00a0  } \u00a0  @Bean \u00a0  fun feePolicy(): FeePolicy { \u00a0    return ZeroFeePolicy() \u00a0  } } Java @SpringJUnitConfig({ \u00a0    TransferServiceConfig.class, \u00a0    StandaloneDataConfig.class, \u00a0    JndiDataConfig.class, \u00a0    DefaultDataConfig.class}) @ActiveProfiles(\"dev\") class TransferServiceTest { \u00a0  @Autowired \u00a0  TransferService transferService; \u00a0  @Test \u00a0  void testTransferService() { \u00a0    // test the transferService \u00a0  } } 548", "chunk_char_count": 752, "chunk_word_count": 124, "chunk_token_count": 188.0}, {"page_number": 549, "sentence_chunk": "Kotlin @SpringJUnitConfig( \u00a0    TransferServiceConfig::class, \u00a0    StandaloneDataConfig::class, \u00a0    JndiDataConfig::class, \u00a0    DefaultDataConfig::class) @ActiveProfiles(\"dev\") class TransferServiceTest { \u00a0  @Autowired \u00a0  lateinit var transferService: TransferService \u00a0  @Test \u00a0  fun testTransferService() { \u00a0    // test the transferService \u00a0  } } In this variation, we have split the XML configuration into four independent @Configuration classes: \u2022 TransferServiceConfig: Acquires a dataSource through dependency injection by using @Autowired. \u2022StandaloneDataConfig: Defines a dataSource for an embedded database suitable for developer tests. \u2022JndiDataConfig: Defines a dataSource that is retrieved from JNDI in a production environment. \u2022DefaultDataConfig: Defines a dataSource for a default embedded database, in case no profile is active. As with the XML-based configuration example, we still annotate TransferServiceTest with @ActiveProfiles(\"dev\"), but this time we specify all four configuration classes by using the @ContextConfiguration annotation. The body of the test class itself remains completely unchanged. It is often the case that a single set of profiles is used across multiple test classes within a given project. Thus, to avoid duplicate declarations of the @ActiveProfiles annotation, you can declare @ActiveProfiles once on a base class, and subclasses automatically inherit the @ActiveProfiles configuration from the base class. In the following example, the declaration of @ActiveProfiles (as well as other annotations) has been moved to an abstract superclass, AbstractIntegrationTest: \uf05a As of Spring Framework 5.3, test configuration may also be inherited from enclosing classes. See @Nested test class configuration for details.", "chunk_char_count": 1758, "chunk_word_count": 249, "chunk_token_count": 439.5}, {"page_number": 550, "sentence_chunk": "Java @SpringJUnitConfig({ \u00a0    TransferServiceConfig.class, \u00a0    StandaloneDataConfig.class, \u00a0    JndiDataConfig.class, \u00a0    DefaultDataConfig.class}) @ActiveProfiles(\"dev\") abstract class AbstractIntegrationTest { } Kotlin @SpringJUnitConfig( \u00a0    TransferServiceConfig::class, \u00a0    StandaloneDataConfig::class, \u00a0    JndiDataConfig::class, \u00a0    DefaultDataConfig::class) @ActiveProfiles(\"dev\") abstract class AbstractIntegrationTest { } Java // \"dev\" profile inherited from superclass class TransferServiceTest extends AbstractIntegrationTest { \u00a0  @Autowired \u00a0  TransferService transferService; \u00a0  @Test \u00a0  void testTransferService() { \u00a0    // test the transferService \u00a0  } } 550", "chunk_char_count": 680, "chunk_word_count": 96, "chunk_token_count": 170.0}, {"page_number": 551, "sentence_chunk": "Kotlin // \"dev\" profile inherited from superclass class TransferServiceTest : AbstractIntegrationTest() { \u00a0  @Autowired \u00a0  lateinit var transferService: TransferService \u00a0  @Test \u00a0  fun testTransferService() { \u00a0    // test the transferService \u00a0  } } @ActiveProfiles also supports an inheritProfiles attribute that can be used to disable the inheritance of active profiles, as the following example shows: Java // \"dev\" profile overridden with \"production\" @ActiveProfiles(profiles = \"production\", inheritProfiles = false) class ProductionTransferServiceTest extends AbstractIntegrationTest { \u00a0  // test body } Kotlin // \"dev\" profile overridden with \"production\" @ActiveProfiles(\"production\", inheritProfiles = false) class ProductionTransferServiceTest : AbstractIntegrationTest() { \u00a0  // test body } Furthermore, it is sometimes necessary to resolve active profiles for tests programmatically instead of declaratively\u2009\u2014\u2009for example, based on: \u2022 The current operating system. \u2022Whether tests are being run on a continuous integration build server. \u2022The presence of certain environment variables. \u2022The presence of custom class-level annotations. \u2022Other concerns. To resolve active bean definition profiles programmatically, you can implement a custom ActiveProfilesResolver and register it by using the resolver attribute of @ActiveProfiles. For further information, see the corresponding javadoc. The following example demonstrates how to implement and register a custom OperatingSystemActiveProfilesResolver: 551", "chunk_char_count": 1512, "chunk_word_count": 200, "chunk_token_count": 378.0}, {"page_number": 552, "sentence_chunk": "Java // \"dev\" profile overridden programmatically via a custom resolver @ActiveProfiles( \u00a0    resolver = OperatingSystemActiveProfilesResolver.class, \u00a0    inheritProfiles = false) class TransferServiceTest extends AbstractIntegrationTest { \u00a0  // test body } Kotlin // \"dev\" profile overridden programmatically via a custom resolver @ActiveProfiles( \u00a0    resolver = OperatingSystemActiveProfilesResolver::class, \u00a0    inheritProfiles = false) class TransferServiceTest : AbstractIntegrationTest() { \u00a0  // test body } Java public class OperatingSystemActiveProfilesResolver implements ActiveProfilesResolver { \u00a0  @Override \u00a0  public String[] resolve(Class<?> testClass) { \u00a0    String profile = ...; \u00a0    // determine the value of profile based on the operating system \u00a0    return new String[] {profile}; \u00a0  } } Kotlin class OperatingSystemActiveProfilesResolver : ActiveProfilesResolver { \u00a0  override fun resolve(testClass: Class<*>): Array<String> { \u00a0    val profile: String = ... \u00a0    // determine the value of profile based on the operating system \u00a0    return arrayOf(profile) \u00a0  } } Context Configuration with Test Property Sources The Spring Framework has first-class support for the notion of an environment with a hierarchy of property sources, and you can configure integration tests with test-specific property sources. In contrast to the @PropertySource annotation used on @Configuration classes, you can declare the 552", "chunk_char_count": 1427, "chunk_word_count": 221, "chunk_token_count": 356.75}, {"page_number": 553, "sentence_chunk": "@TestPropertySource annotation on a test class to declare resource locations for test properties files or inlined properties. These test property sources are added to the set of PropertySources in the Environment for the ApplicationContext loaded for the annotated integration test.\uf05a You can use @TestPropertySource with any implementation of the SmartContextLoader SPI, but @TestPropertySource is not supported with implementations of the older ContextLoader SPI. Implementations of SmartContextLoader gain access to merged test property source values through the getPropertySourceLocations() and getPropertySourceProperties() methods in MergedContextConfiguration. Declaring Test Property Sources You can configure test properties files by using the locations or value attribute of @TestPropertySource. Both traditional and XML-based properties file formats are supported\u2009\u2014\u2009for example, \"classpath:/com/example/test.properties\" or \"file:///path/to/file.xml\". Each path is interpreted as a Spring Resource. A plain path (for example, \"test.properties\") is treated as a classpath resource that is relative to the package in which the test class is defined. A path starting with a slash is treated as an absolute classpath resource (for example: \"/org/example/test.xml\"). A path that references a URL (for example, a path prefixed with classpath:, file:, or http:) is loaded by using the specified resource protocol.", "chunk_char_count": 1415, "chunk_word_count": 187, "chunk_token_count": 353.75}, {"page_number": 553, "sentence_chunk": "Resource location wildcards (such as */.properties) are not permitted: Each location must evaluate to exactly one .properties or .xml resource. The following example uses a test properties file: Java @ContextConfiguration @TestPropertySource(\"/test.properties\") \u2460 class MyIntegrationTests { \u00a0  // class body... } \u2460 Specifying a properties file with an absolute path. Kotlin @ContextConfiguration @TestPropertySource(\"/test.properties\") \u2460 class MyIntegrationTests { \u00a0  // class body... } \u2460 Specifying a properties file with an absolute path.553", "chunk_char_count": 543, "chunk_word_count": 72, "chunk_token_count": 135.75}, {"page_number": 554, "sentence_chunk": "You can configure inlined properties in the form of key-value pairs by using the properties attribute of @TestPropertySource, as shown in the next example. All key-value pairs are added to the enclosing Environment as a single test PropertySource with the highest precedence. The supported syntax for key-value pairs is the same as the syntax defined for entries in a Java properties file: \u2022 key=value \u2022 key:value \u2022 key value The following example sets two inlined properties: Java @ContextConfiguration @TestPropertySource(properties = {\"timezone = GMT\", \"port: 4242\"}) \u2460 class MyIntegrationTests { \u00a0  // class body... } \u2460 Setting two properties by using two variations of the key-value syntax. Kotlin @ContextConfiguration @TestPropertySource(properties = [\"timezone = GMT\", \"port: 4242\"]) \u2460 class MyIntegrationTests { \u00a0  // class body... } \u2460 Setting two properties by using two variations of the key-value syntax.\uf05a As of Spring Framework 5.2, @TestPropertySource can be used as repeatable annotation. That means that you can have multiple declarations of @TestPropertySource on a single test class, with the locations and properties from later @TestPropertySource annotations overriding those from previous @TestPropertySource annotations. In addition, you may declare multiple composed annotations on a test class that are each meta-annotated with @TestPropertySource, and all of those @TestPropertySource declarations will contribute to your test property sources. Directly present @TestPropertySource annotations always take precedence over meta-present @TestPropertySource annotations. In other words, locations and properties from a directly present @TestPropertySource annotation will override the locations and properties from a @TestPropertySource annotation used as a meta-annotation.554", "chunk_char_count": 1799, "chunk_word_count": 248, "chunk_token_count": 449.75}, {"page_number": 555, "sentence_chunk": "Default Properties File Detection If @TestPropertySource is declared as an empty annotation (that is, without explicit values for the locations or properties attributes), an attempt is made to detect a default properties file relative to the class that declared the annotation. For example, if the annotated test class is com.example. MyTest, the corresponding default properties file is classpath:com/example/MyTest.properties. If the default cannot be detected, an IllegalStateException is thrown. Precedence Test properties have higher precedence than those defined in the operating system\u2019s environment, Java system properties, or property sources added by the application declaratively by using @PropertySource or programmatically. Thus, test properties can be used to selectively override properties loaded from system and application property sources. Furthermore, inlined properties have higher precedence than properties loaded from resource locations. Note, however, that properties registered via @DynamicPropertySource have higher precedence than those loaded via @TestPropertySource. In the next example, the timezone and port properties and any properties defined in \"/test.properties\" override any properties of the same name that are defined in system and application property sources. Furthermore, if the \"/test.properties\" file defines entries for the timezone and port properties those are overridden by the inlined properties declared by using the properties attribute.", "chunk_char_count": 1489, "chunk_word_count": 199, "chunk_token_count": 372.25}, {"page_number": 555, "sentence_chunk": "The following example shows how to specify properties both in a file and inline: Java @ContextConfiguration @TestPropertySource( \u00a0  locations = \"/test.properties\", \u00a0  properties = {\"timezone = GMT\", \"port: 4242\"} ) class MyIntegrationTests { \u00a0  // class body... } Kotlin @ContextConfiguration @TestPropertySource(\"/test.properties\", \u00a0    properties = [\"timezone = GMT\", \"port: 4242\"] ) class MyIntegrationTests { \u00a0  // class body... } Inheriting and Overriding Test Property Sources @TestPropertySource supports boolean inheritLocations and inheritProperties attributes that 555", "chunk_char_count": 578, "chunk_word_count": 80, "chunk_token_count": 144.5}, {"page_number": 556, "sentence_chunk": "denote whether resource locations for properties files and inlined properties declared by superclasses should be inherited. The default value for both flags is true. This means that a test class inherits the locations and inlined properties declared by any superclasses. Specifically, the locations and inlined properties for a test class are appended to the locations and inlined properties declared by superclasses. Thus, subclasses have the option of extending the locations and inlined properties. Note that properties that appear later shadow (that is, override) properties of the same name that appear earlier. In addition, the aforementioned precedence rules apply for inherited test property sources as well. If the inheritLocations or inheritProperties attribute in @TestPropertySource is set to false, the locations or inlined properties, respectively, for the test class shadow and effectively replace the configuration defined by superclasses.\uf05a As of Spring Framework 5.3, test configuration may also be inherited from enclosing classes. See @Nested test class configuration for details.", "chunk_char_count": 1099, "chunk_word_count": 157, "chunk_token_count": 274.75}, {"page_number": 556, "sentence_chunk": "In the next example, the ApplicationContext for BaseTest is loaded by using only the base.properties file as a test property source. In contrast, the ApplicationContext for ExtendedTest is loaded by using the base.properties and extended.properties files as test property source locations. The following example shows how to define properties in both a subclass and its superclass by using properties files: Java @TestPropertySource(\"base.properties\") @ContextConfiguration class BaseTest { \u00a0  // ... } @TestPropertySource(\"extended.properties\") @ContextConfiguration class ExtendedTest extends BaseTest { \u00a0  // ... } Kotlin @TestPropertySource(\"base.properties\") @ContextConfiguration open class BaseTest { \u00a0  // ... } @TestPropertySource(\"extended.properties\") @ContextConfiguration class ExtendedTest : BaseTest() { \u00a0  // ... } 556", "chunk_char_count": 834, "chunk_word_count": 108, "chunk_token_count": 208.5}, {"page_number": 557, "sentence_chunk": "In the next example, the ApplicationContext for BaseTest is loaded by using only the inlined key1 property. In contrast, the ApplicationContext for ExtendedTest is loaded by using the inlined key1 and key2 properties. The following example shows how to define properties in both a subclass and its superclass by using inline properties: Java @TestPropertySource(properties = \"key1 = value1\") @ContextConfiguration class BaseTest { \u00a0  // ... } @TestPropertySource(properties = \"key2 = value2\") @ContextConfiguration class ExtendedTest extends BaseTest { \u00a0  // ... } Kotlin @TestPropertySource(properties = [\"key1 = value1\"]) @ContextConfiguration open class BaseTest { \u00a0  // ... } @TestPropertySource(properties = [\"key2 = value2\"]) @ContextConfiguration class ExtendedTest : BaseTest() { \u00a0  // ... } Context Configuration with Dynamic Property Sources As of Spring Framework 5.2.5, the TestContext framework provides support for dynamic properties via the @DynamicPropertySource annotation. This annotation can be used in integration tests that need to add properties with dynamic values to the set of PropertySources in the Environment for the ApplicationContext loaded for the integration test.\uf05a The @DynamicPropertySource annotation and its supporting infrastructure were originally designed to allow properties from Testcontainers based tests to be exposed easily to Spring integration tests. However, this feature may also be used with any form of external resource whose lifecycle is maintained outside the test\u2019s ApplicationContext. In contrast to the @TestPropertySource annotation that is applied at the class level, @DynamicPropertySource must be applied to a static method that accepts a single DynamicPropertyRegistry argument which is used to add name-value pairs to the Environment. Values 557", "chunk_char_count": 1807, "chunk_word_count": 255, "chunk_token_count": 451.75}, {"page_number": 558, "sentence_chunk": "are dynamic and provided via a Supplier which is only invoked when the property is resolved. Typically, method references are used to supply values, as can be seen in the following example which uses the Testcontainers project to manage a Redis container outside of the Spring ApplicationContext. The IP address and port of the managed Redis container are made available to components within the test\u2019s ApplicationContext via the redis.host and redis.port properties. These properties can be accessed via Spring\u2019s Environment abstraction or injected directly into Spring- managed components \u2013 for example, via @Value(\"${redis.host}\") and @Value(\"${redis.port}\"), respectively.\uf0eb If you use @DynamicPropertySource in a base class and discover that tests in subclasses fail because the dynamic properties change between subclasses, you may need to annotate your base class with @DirtiesContext to ensure that each subclass gets its own ApplicationContext with the correct dynamic properties. Java @SpringJUnitConfig(/* ... */) @Testcontainers class ExampleIntegrationTests { \u00a0  @Container \u00a0  static RedisContainer redis = new RedisContainer(); \u00a0  @DynamicPropertySource \u00a0  static void redisProperties(DynamicPropertyRegistry registry) { \u00a0    registry.add(\"redis.host\", redis::getHost); \u00a0    registry.add(\"redis.port\", redis::getMappedPort); \u00a0  } \u00a0  // tests ... } 558", "chunk_char_count": 1364, "chunk_word_count": 193, "chunk_token_count": 341.0}, {"page_number": 559, "sentence_chunk": "Kotlin @SpringJUnitConfig(/* ... */) @Testcontainers class ExampleIntegrationTests { \u00a0  companion object { \u00a0    @Container \u00a0    @JvmStatic \u00a0    val redis: RedisContainer = RedisContainer() \u00a0    @DynamicPropertySource \u00a0    @JvmStatic \u00a0    fun redisProperties(registry: DynamicPropertyRegistry) { \u00a0      registry.add(\"redis.host\", redis::getHost) \u00a0      registry.add(\"redis.port\", redis::getMappedPort) \u00a0    } \u00a0  } \u00a0  // tests ... } Precedence Dynamic properties have higher precedence than those loaded from @TestPropertySource, the operating system\u2019s environment, Java system properties, or property sources added by the application declaratively by using @PropertySource or programmatically. Thus, dynamic properties can be used to selectively override properties loaded via @TestPropertySource, system property sources, and application property sources. Loading a WebApplicationContext To instruct the TestContext framework to load a WebApplicationContext instead of a standard ApplicationContext, you can annotate the respective test class with @WebAppConfiguration. The presence of @WebAppConfiguration on your test class instructs the TestContext framework (TCF) that a WebApplicationContext (WAC) should be loaded for your integration tests. In the background, the TCF makes sure that a MockServletContext is created and supplied to your test\u2019s WAC. By default, the base resource path for your MockServletContext is set to src/main/webapp. This is interpreted as a path relative to the root of your JVM (normally the path to your project). If you are familiar with the directory structure of a web application in a Maven project, you know that src/main/webapp is the default location for the root of your WAR. If you need to override this default, you can provide an alternate path to the @WebAppConfiguration annotation (for example, @WebAppConfiguration(\"src/test/webapp\")). If you wish to reference a base resource path from the classpath instead of the file system, you can use Spring\u2019s classpath: prefix.", "chunk_char_count": 2015, "chunk_word_count": 304, "chunk_token_count": 503.75}, {"page_number": 559, "sentence_chunk": "Note that Spring\u2019s testing support for WebApplicationContext implementations is on par with its support for standard ApplicationContext implementations. When testing with a 559", "chunk_char_count": 176, "chunk_word_count": 23, "chunk_token_count": 44.0}, {"page_number": 560, "sentence_chunk": "WebApplicationContext, you are free to declare XML configuration files, Groovy scripts, or @Configuration classes by using @ContextConfiguration. You are also free to use any other test annotations, such as @ActiveProfiles, @TestExecutionListeners, @Sql, @Rollback, and others. The remaining examples in this section show some of the various configuration options for loading a WebApplicationContext. The following example shows the TestContext framework\u2019s support for convention over configuration: Java @ExtendWith(SpringExtension.class) // defaults to \"file:src/main/webapp\" @WebAppConfiguration // detects \"WacTests-context.xml\" in the same package // or static nested @Configuration classes @ContextConfiguration class WacTests { \u00a0  //... } Kotlin @ExtendWith(SpringExtension::class) // defaults to \"file:src/main/webapp\" @WebAppConfiguration // detects \"WacTests-context.xml\" in the same package // or static nested @Configuration classes @ContextConfiguration class WacTests { \u00a0  //... } If you annotate a test class with @WebAppConfiguration without specifying a resource base path, the resource path effectively defaults to file:src/main/webapp. Similarly, if you declare @ContextConfiguration without specifying resource locations, component classes, or context initializers, Spring tries to detect the presence of your configuration by using conventions (that is, WacTests-context.xml in the same package as the WacTests class or static nested @Configuration classes). The following example shows how to explicitly declare a resource base path with @WebAppConfiguration and an XML resource location with @ContextConfiguration: 560", "chunk_char_count": 1641, "chunk_word_count": 205, "chunk_token_count": 410.25}, {"page_number": 561, "sentence_chunk": "Java @ExtendWith(SpringExtension.class) // file system resource @WebAppConfiguration(\"webapp\") // classpath resource @ContextConfiguration(\"/spring/test-servlet-config.xml\") class WacTests { \u00a0  //... } Kotlin @ExtendWith(SpringExtension::class) // file system resource @WebAppConfiguration(\"webapp\") // classpath resource @ContextConfiguration(\"/spring/test-servlet-config.xml\") class WacTests { \u00a0  //... } The important thing to note here is the different semantics for paths with these two annotations. By default, @WebAppConfiguration resource paths are file system based, whereas @ContextConfiguration resource locations are classpath based. The following example shows that we can override the default resource semantics for both annotations by specifying a Spring resource prefix: Java @ExtendWith(SpringExtension.class) // classpath resource @WebAppConfiguration(\"classpath:test-web-resources\") // file system resource @ContextConfiguration(\"file:src/main/webapp/WEB-INF/servlet-config.xml\") class WacTests { \u00a0  //... } 561", "chunk_char_count": 1030, "chunk_word_count": 108, "chunk_token_count": 257.5}, {"page_number": 562, "sentence_chunk": "Kotlin @ExtendWith(SpringExtension::class) // classpath resource @WebAppConfiguration(\"classpath:test-web-resources\") // file system resource @ContextConfiguration(\"file:src/main/webapp/WEB-INF/servlet-config.xml\") class WacTests { \u00a0  //... } Contrast the comments in this example with the previous example. Working with Web Mocks To provide comprehensive web testing support, the TestContext framework has a ServletTestExecutionListener that is enabled by default. When testing against a WebApplicationContext, this TestExecutionListener sets up default thread-local state by using Spring Web\u2019s RequestContextHolder before each test method and creates a MockHttpServletRequest, a MockHttpServletResponse, and a ServletWebRequest based on the base resource path configured with @WebAppConfiguration. ServletTestExecutionListener also ensures that the MockHttpServletResponse and ServletWebRequest can be injected into the test instance, and, once the test is complete, it cleans up thread-local state. Once you have a WebApplicationContext loaded for your test, you might find that you need to interact with the web mocks\u2009\u2014\u2009for example, to set up your test fixture or to perform assertions after invoking your web component. The following example shows which mocks can be autowired into your test instance. Note that the WebApplicationContext and MockServletContext are both cached across the test suite, whereas the other mocks are managed per test method by the ServletTestExecutionListener.562", "chunk_char_count": 1496, "chunk_word_count": 189, "chunk_token_count": 374.0}, {"page_number": 563, "sentence_chunk": "Java @SpringJUnitWebConfig class WacTests { \u00a0  @Autowired \u00a0  WebApplicationContext wac; // cached \u00a0  @Autowired \u00a0  MockServletContext servletContext; // cached \u00a0  @Autowired \u00a0  MockHttpSession session; \u00a0  @Autowired \u00a0  MockHttpServletRequest request; \u00a0  @Autowired \u00a0  MockHttpServletResponse response; \u00a0  @Autowired \u00a0  ServletWebRequest webRequest; \u00a0  //... } 563", "chunk_char_count": 363, "chunk_word_count": 56, "chunk_token_count": 90.75}, {"page_number": 564, "sentence_chunk": "Kotlin @SpringJUnitWebConfig class WacTests { \u00a0  @Autowired \u00a0  lateinit var wac: WebApplicationContext // cached \u00a0  @Autowired \u00a0  lateinit var servletContext: MockServletContext // cached \u00a0  @Autowired \u00a0  lateinit var session: MockHttpSession \u00a0  @Autowired \u00a0  lateinit var request: MockHttpServletRequest \u00a0  @Autowired \u00a0  lateinit var response: MockHttpServletResponse \u00a0  @Autowired \u00a0  lateinit var webRequest: ServletWebRequest \u00a0  //... } Context Caching Once the TestContext framework loads an ApplicationContext (or WebApplicationContext) for a test, that context is cached and reused for all subsequent tests that declare the same unique context configuration within the same test suite. To understand how caching works, it is important to understand what is meant by \u201cunique\u201d and \u201ctest suite.\u201dAn ApplicationContext can be uniquely identified by the combination of configuration parameters that is used to load it. Consequently, the unique combination of configuration parameters is used to generate a key under which the context is cached. The TestContext framework uses the following configuration parameters to build the context cache key: \u2022 locations (from @ContextConfiguration) \u2022 classes (from @ContextConfiguration) \u2022 contextInitializerClasses (from @ContextConfiguration) \u2022 contextCustomizers (from ContextCustomizerFactory) \u2013 this includes @DynamicPropertySource methods as well as various features from Spring Boot\u2019s testing support such as @MockBean and @SpyBean. \u2022contextLoader (from @ContextConfiguration) \u2022 parent (from @ContextHierarchy) \u2022 activeProfiles (from @ActiveProfiles) 564", "chunk_char_count": 1600, "chunk_word_count": 219, "chunk_token_count": 400.0}, {"page_number": 565, "sentence_chunk": "\u2022 propertySourceLocations (from @TestPropertySource) \u2022 propertySourceProperties (from @TestPropertySource) \u2022 resourceBasePath (from @WebAppConfiguration) For example, if TestClassA specifies {\"app-config.xml\", \"test-config.xml\"} for the locations (or value) attribute of @ContextConfiguration, the TestContext framework loads the corresponding ApplicationContext and stores it in a static context cache under a key that is based solely on those locations. So, if TestClassB also defines {\"app-config.xml\", \"test-config.xml\"} for its locations (either explicitly or implicitly through inheritance) but does not define @WebAppConfiguration, a different ContextLoader, different active profiles, different context initializers, different test property sources, or a different parent context, then the same ApplicationContext is shared by both test classes. This means that the setup cost for loading an application context is incurred only once (per test suite), and subsequent test execution is much faster.\uf05a Test suites and forked processes The Spring TestContext framework stores application contexts in a static cache. This means that the context is literally stored in a static variable. In other words, if tests run in separate processes, the static cache is cleared between each test execution, which effectively disables the caching mechanism. To benefit from the caching mechanism, all tests must run within the same process or test suite. This can be achieved by executing all tests as a group within an IDE. Similarly, when executing tests with a build framework such as Ant, Maven, or Gradle, it is important to make sure that the build framework does not fork between tests. For example, if the forkMode for the Maven Surefire plug-in is set to always or pertest, the TestContext framework cannot cache application contexts between test classes, and the build process runs significantly more slowly as a result.", "chunk_char_count": 1921, "chunk_word_count": 275, "chunk_token_count": 480.25}, {"page_number": 565, "sentence_chunk": "The size of the context cache is bounded with a default maximum size of 32. Whenever the maximum size is reached, a least recently used (LRU) eviction policy is used to evict and close stale contexts. You can configure the maximum size from the command line or a build script by setting a JVM system property named spring.test.context.cache.maxSize. As an alternative, you can set the same property via the SpringProperties mechanism. Since having a large number of application contexts loaded within a given test suite can cause the suite to take an unnecessarily long time to run, it is often beneficial to know exactly how many contexts have been loaded and cached. To view the statistics for the underlying context cache, you can set the log level for the org.springframework.test.context.cache logging category to DEBUG. In the unlikely case that a test corrupts the application context and requires reloading (for example, by modifying a bean definition or the state of an application object), you can annotate your test class or test method with @DirtiesContext (see the discussion of @DirtiesContext in Spring Testing Annotations). This instructs Spring to remove the context from the cache and rebuild the application context before running the next test that requires the same application context. Note that support for the @DirtiesContext annotation is provided by the DirtiesContextBeforeModesTestExecutionListener and the DirtiesContextTestExecutionListener, which are enabled by default.565", "chunk_char_count": 1504, "chunk_word_count": 228, "chunk_token_count": 376.0}, {"page_number": 566, "sentence_chunk": "\uf05a ApplicationContext lifecycle and console logging When you need to debug a test executed with the Spring TestContext Framework, it can be useful to analyze the console output (that is, output to the SYSOUT and SYSERR streams). Some build tools and IDEs are able to associate console output with a given test; however, some console output cannot be easily associated with a given test. With regard to console logging triggered by the Spring Framework itself or by components registered in the ApplicationContext, it is important to understand the lifecycle of an ApplicationContext that has been loaded by the Spring TestContext Framework within a test suite. The ApplicationContext for a test is typically loaded when an instance of the test class is being prepared\u2009\u2014\u2009for example, to perform dependency injection into @Autowired fields of the test instance. This means that any console logging triggered during the initialization of the ApplicationContext typically cannot be associated with an individual test method. However, if the context is closed immediately before the execution of a test method according to @DirtiesContext semantics, a new instance of the context will be loaded just prior to execution of the test method. In the latter scenario, an IDE or build tool may potentially associate console logging with the individual test method. The ApplicationContext for a test can be closed via one of the following scenarios. \u2022The context is closed according to @DirtiesContext semantics. \u2022The context is closed because it has been automatically evicted from the cache according to the LRU eviction policy. \u2022", "chunk_char_count": 1619, "chunk_word_count": 253, "chunk_token_count": 404.75}, {"page_number": 566, "sentence_chunk": "The context is closed via a JVM shutdown hook when the JVM for the test suite terminates. If the context is closed according to @DirtiesContext semantics after a particular test method, an IDE or build tool may potentially associate console logging with the individual test method. If the context is closed according to @DirtiesContext semantics after a test class, any console logging triggered during the shutdown of the ApplicationContext cannot be associated with an individual test method. Similarly, any console logging triggered during the shutdown phase via a JVM shutdown hook cannot be associated with an individual test method. When a Spring ApplicationContext is closed via a JVM shutdown hook, callbacks executed during the shutdown phase are executed on a thread named SpringContextShutdownHook. So, if you wish to disable console logging triggered when the ApplicationContext is closed via a JVM shutdown hook, you may be able to register a custom filter with your logging framework that allows you to ignore any logging initiated by that thread. Context Hierarchies When writing integration tests that rely on a loaded Spring ApplicationContext, it is often sufficient 566", "chunk_char_count": 1188, "chunk_word_count": 184, "chunk_token_count": 297.0}, {"page_number": 567, "sentence_chunk": "to test against a single context. However, there are times when it is beneficial or even necessary to test against a hierarchy of ApplicationContext instances. For example, if you are developing a Spring MVC web application, you typically have a root WebApplicationContext loaded by Spring\u2019s ContextLoaderListener and a child WebApplicationContext loaded by Spring\u2019s DispatcherServlet. This results in a parent-child context hierarchy where shared components and infrastructure configuration are declared in the root context and consumed in the child context by web-specific components. Another use case can be found in Spring Batch applications, where you often have a parent context that provides configuration for shared batch infrastructure and a child context for the configuration of a specific batch job. You can write integration tests that use context hierarchies by declaring context configuration with the @ContextHierarchy annotation, either on an individual test class or within a test class hierarchy. If a context hierarchy is declared on multiple classes within a test class hierarchy, you can also merge or override the context configuration for a specific, named level in the context hierarchy. When merging configuration for a given level in the hierarchy, the configuration resource type (that is, XML configuration files or component classes) must be consistent. Otherwise, it is perfectly acceptable to have different levels in a context hierarchy configured using different resource types. The remaining JUnit Jupiter based examples in this section show common configuration scenarios for integration tests that require the use of context hierarchies.", "chunk_char_count": 1674, "chunk_word_count": 245, "chunk_token_count": 418.5}, {"page_number": 567, "sentence_chunk": "Single test class with context hierarchy ControllerIntegrationTests represents a typical integration testing scenario for a Spring MVC web application by declaring a context hierarchy that consists of two levels, one for the root WebApplicationContext (loaded by using the TestAppConfig @Configuration class) and one for the dispatcher servlet WebApplicationContext (loaded by using the WebConfig @Configuration class). The WebApplicationContext that is autowired into the test instance is the one for the child context (that is, the lowest context in the hierarchy). The following listing shows this configuration scenario: Java @ExtendWith(SpringExtension.class) @WebAppConfiguration @ContextHierarchy({ \u00a0  @ContextConfiguration(classes = TestAppConfig.class), \u00a0  @ContextConfiguration(classes = WebConfig.class) }) class ControllerIntegrationTests { \u00a0  @Autowired \u00a0  WebApplicationContext wac; \u00a0  // ... } 567", "chunk_char_count": 912, "chunk_word_count": 117, "chunk_token_count": 228.0}, {"page_number": 568, "sentence_chunk": "Kotlin @ExtendWith(SpringExtension::class) @WebAppConfiguration @ContextHierarchy( \u00a0  ContextConfiguration(classes = [TestAppConfig::class]), \u00a0  ContextConfiguration(classes = [WebConfig::class])) class ControllerIntegrationTests { \u00a0  @Autowired \u00a0  lateinit var wac: WebApplicationContext \u00a0  // ... } Class hierarchy with implicit parent context The test classes in this example define a context hierarchy within a test class hierarchy. AbstractWebTests declares the configuration for a root WebApplicationContext in a Spring-powered web application. Note, however, that AbstractWebTests does not declare @ContextHierarchy. Consequently, subclasses of AbstractWebTests can optionally participate in a context hierarchy or follow the standard semantics for @ContextConfiguration. SoapWebServiceTests and RestWebServiceTests both extend AbstractWebTests and define a context hierarchy by using @ContextHierarchy. The result is that three application contexts are loaded (one for each declaration of @ContextConfiguration), and the application context loaded based on the configuration in AbstractWebTests is set as the parent context for each of the contexts loaded for the concrete subclasses. The following listing shows this configuration scenario: Java @ExtendWith(SpringExtension.class) @WebAppConfiguration @ContextConfiguration(\"file:src/main/webapp/WEB-INF/applicationContext.xml\") public abstract class AbstractWebTests {} @ContextHierarchy(@ContextConfiguration(\"/spring/soap-ws-config.xml\")) public class SoapWebServiceTests extends AbstractWebTests {} @ContextHierarchy(@ContextConfiguration(\"/spring/rest-ws-config.xml\")) public class RestWebServiceTests extends AbstractWebTests {} 568", "chunk_char_count": 1697, "chunk_word_count": 178, "chunk_token_count": 424.25}, {"page_number": 569, "sentence_chunk": "Kotlin @ExtendWith(SpringExtension::class) @WebAppConfiguration @ContextConfiguration(\"file:src/main/webapp/WEB-INF/applicationContext.xml\") abstract class AbstractWebTests @ContextHierarchy(ContextConfiguration(\"/spring/soap-ws-config.xml\")) class SoapWebServiceTests : AbstractWebTests() @ContextHierarchy(ContextConfiguration(\"/spring/rest-ws-config.xml\")) class RestWebServiceTests : AbstractWebTests() Class hierarchy with merged context hierarchy configuration The classes in this example show the use of named hierarchy levels in order to merge the configuration for specific levels in a context hierarchy. BaseTests defines two levels in the hierarchy, parent and child. ExtendedTests extends BaseTests and instructs the Spring TestContext Framework to merge the context configuration for the child hierarchy level, by ensuring that the names declared in the name attribute in @ContextConfiguration are both child. The result is that three application contexts are loaded: one for /app-config.xml, one for /user-config.xml, and one for {\"/user-config.xml\", \"/order-config.xml\"}. As with the previous example, the application context loaded from /app-config.xml is set as the parent context for the contexts loaded from /user- config.xml and {\"/user-config.xml\", \"/order-config.xml\"}. The following listing shows this configuration scenario: Java @ExtendWith(SpringExtension.class) @ContextHierarchy({ \u00a0  @ContextConfiguration(name = \"parent\", locations = \"/app-config.xml\"), \u00a0  @ContextConfiguration(name = \"child\", locations = \"/user-config.xml\") }) class BaseTests {} @ContextHierarchy( \u00a0  @ContextConfiguration(name = \"child\", locations = \"/order-config.xml\") ) class ExtendedTests extends BaseTests {} 569", "chunk_char_count": 1717, "chunk_word_count": 186, "chunk_token_count": 429.25}, {"page_number": 570, "sentence_chunk": "Kotlin @ExtendWith(SpringExtension::class) @ContextHierarchy( \u00a0  ContextConfiguration(name = \"parent\", locations = [\"/app-config.xml\"]), \u00a0  ContextConfiguration(name = \"child\", locations = [\"/user-config.xml\"])) open class BaseTests {} @ContextHierarchy( \u00a0  ContextConfiguration(name = \"child\", locations = [\"/order-config.xml\"]) ) class ExtendedTests : BaseTests() {} Class hierarchy with overridden context hierarchy configuration In contrast to the previous example, this example demonstrates how to override the configuration for a given named level in a context hierarchy by setting the inheritLocations flag in @ContextConfiguration to false. Consequently, the application context for ExtendedTests is loaded only from /test-user-config.xml and has its parent set to the context loaded from /app-config.xml. The following listing shows this configuration scenario: Java @ExtendWith(SpringExtension.class) @ContextHierarchy({ \u00a0  @ContextConfiguration(name = \"parent\", locations = \"/app-config.xml\"), \u00a0  @ContextConfiguration(name = \"child\", locations = \"/user-config.xml\") }) class BaseTests {} @ContextHierarchy( \u00a0  @ContextConfiguration( \u00a0    name = \"child\", \u00a0    locations = \"/test-user-config.xml\", \u00a0    inheritLocations = false )) class ExtendedTests extends BaseTests {} 570", "chunk_char_count": 1285, "chunk_word_count": 161, "chunk_token_count": 321.25}, {"page_number": 571, "sentence_chunk": "Kotlin @ExtendWith(SpringExtension::class) @ContextHierarchy( \u00a0  ContextConfiguration(name = \"parent\", locations = [\"/app-config.xml\"]), \u00a0  ContextConfiguration(name = \"child\", locations = [\"/user-config.xml\"])) open class BaseTests {} @ContextHierarchy( \u00a0    ContextConfiguration( \u00a0        name = \"child\", \u00a0        locations = [\"/test-user-config.xml\"], \u00a0        inheritLocations = false \u00a0    )) class ExtendedTests : BaseTests() {} \uf05a Dirtying a context within a context hierarchy If you use @DirtiesContext in a test whose context is configured as part of a context hierarchy, you can use the hierarchyMode flag to control how the context cache is cleared. For further details, see the discussion of @DirtiesContext in Spring Testing Annotations and the @DirtiesContext javadoc. Dependency Injection of Test Fixtures When you use the DependencyInjectionTestExecutionListener (which is configured by default), the dependencies of your test instances are injected from beans in the application context that you configured with @ContextConfiguration or related annotations. You may use setter injection, field injection, or both, depending on which annotations you choose and whether you place them on setter methods or fields. If you are using JUnit Jupiter you may also optionally use constructor injection (see Dependency Injection with SpringExtension). For consistency with Spring\u2019s annotation-based injection support, you may also use Spring\u2019s @Autowired annotation or the @Inject annotation from JSR-330 for field and setter injection.\uf0eb For testing frameworks other than JUnit Jupiter, the TestContext framework does not participate in instantiation of the test class. Thus, the use of @Autowired or @Inject for constructors has no effect for test classes.\uf05a Although field injection is discouraged in production code, field injection is actually quite natural in test code. The rationale for the difference is that you will never instantiate your test class directly.", "chunk_char_count": 1973, "chunk_word_count": 298, "chunk_token_count": 493.25}, {"page_number": 571, "sentence_chunk": "Consequently, there is no need to be able to invoke a public constructor or setter method on your test class. Because @Autowired is used to perform autowiring by type, if you have multiple bean definitions of the same type, you cannot rely on this approach for those particular beans. In that case, you can use @Autowired in conjunction with @Qualifier. You can also choose to use @Inject in conjunction with @Named. Alternatively, if your test class has access to its ApplicationContext, you can perform an explicit lookup by using (for example) a call to applicationContext.getBean(\"titleRepository\", 571", "chunk_char_count": 606, "chunk_word_count": 96, "chunk_token_count": 151.5}, {"page_number": 572, "sentence_chunk": "TitleRepository.class). If you do not want dependency injection applied to your test instances, do not annotate fields or setter methods with @Autowired or @Inject. Alternatively, you can disable dependency injection altogether by explicitly configuring your class with @TestExecutionListeners and omitting DependencyInjectionTestExecutionListener.class from the list of listeners. Consider the scenario of testing a HibernateTitleRepository class, as outlined in the Goals section. The next two code listings demonstrate the use of @Autowired on fields and setter methods. The application context configuration is presented after all sample code listings.\uf05a The dependency injection behavior in the following code listings is not specific to JUnit Jupiter. The same DI techniques can be used in conjunction with any supported testing framework. The following examples make calls to static assertion methods, such as assertNotNull(), but without prepending the call with Assertions. In such cases, assume that the method was properly imported through an import static declaration that is not shown in the example.", "chunk_char_count": 1112, "chunk_word_count": 156, "chunk_token_count": 278.0}, {"page_number": 572, "sentence_chunk": "The first code listing shows a JUnit Jupiter based implementation of the test class that uses @Autowired for field injection: Java @ExtendWith(SpringExtension.class) // specifies the Spring configuration to load for this test fixture @ContextConfiguration(\"repository-config.xml\") class HibernateTitleRepositoryTests { \u00a0  // this instance will be dependency injected by type \u00a0  @Autowired \u00a0  HibernateTitleRepository titleRepository; \u00a0  @Test \u00a0  void findById() { \u00a0    Title title = titleRepository.findById(new Long(10)); \u00a0    assertNotNull(title); \u00a0  } } 572", "chunk_char_count": 560, "chunk_word_count": 82, "chunk_token_count": 140.0}, {"page_number": 573, "sentence_chunk": "Kotlin @ExtendWith(SpringExtension::class) // specifies the Spring configuration to load for this test fixture @ContextConfiguration(\"repository-config.xml\") class HibernateTitleRepositoryTests { \u00a0  // this instance will be dependency injected by type \u00a0  @Autowired \u00a0  lateinit var titleRepository: HibernateTitleRepository \u00a0  @Test \u00a0  fun findById() { \u00a0    val title = titleRepository.findById(10) \u00a0    assertNotNull(title) \u00a0  } } Alternatively, you can configure the class to use @Autowired for setter injection, as follows: Java @ExtendWith(SpringExtension.class) // specifies the Spring configuration to load for this test fixture @ContextConfiguration(\"repository-config.xml\") class HibernateTitleRepositoryTests { \u00a0  // this instance will be dependency injected by type \u00a0  HibernateTitleRepository titleRepository; \u00a0  @Autowired \u00a0  void setTitleRepository(HibernateTitleRepository titleRepository) { \u00a0    this.titleRepository = titleRepository; \u00a0  } \u00a0  @Test \u00a0  void findById() { \u00a0    Title title = titleRepository.findById(new Long(10)); \u00a0    assertNotNull(title); \u00a0  } } 573", "chunk_char_count": 1082, "chunk_word_count": 154, "chunk_token_count": 270.5}, {"page_number": 574, "sentence_chunk": "Kotlin @ExtendWith(SpringExtension::class) // specifies the Spring configuration to load for this test fixture @ContextConfiguration(\"repository-config.xml\") class HibernateTitleRepositoryTests { \u00a0  // this instance will be dependency injected by type \u00a0  lateinit var titleRepository: HibernateTitleRepository \u00a0  @Autowired \u00a0  fun setTitleRepository(titleRepository: HibernateTitleRepository) { \u00a0    this.titleRepository = titleRepository \u00a0  } \u00a0  @Test \u00a0  fun findById() { \u00a0    val title = titleRepository.findById(10) \u00a0    assertNotNull(title) \u00a0  } } The preceding code listings use the same XML context file referenced by the @ContextConfiguration annotation (that is, repository-config.xml). The following shows this configuration: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xsi:schemaLocation=\"http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd\"> \u00a0  <!--this bean will be injected into the HibernateTitleRepositoryTests class --> \u00a0  <bean id=\"titleRepository\" class=\"com.foo.repository.hibernate. HibernateTitleRepository\"> \u00a0    <property name=\"sessionFactory\" ref=\"sessionFactory\"/> \u00a0  </bean> \u00a0  <bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate5. LocalSessionFactoryBean\"> \u00a0    <!--configuration elided for brevity --> \u00a0  </bean> </beans> 574", "chunk_char_count": 1441, "chunk_word_count": 165, "chunk_token_count": 360.25}, {"page_number": 575, "sentence_chunk": "\uf05a If you are extending from a Spring-provided test base class that happens to use @Autowired on one of its setter methods, you might have multiple beans of the affected type defined in your application context (for example, multiple DataSource beans). In such a case, you can override the setter method and use the @Qualifier annotation to indicate a specific target bean, as follows (but make sure to delegate to the overridden method in the superclass as well): Java // ... \u00a0  @Autowired \u00a0  @Override \u00a0  public void setDataSource(@Qualifier(\"myDataSource\") DataSource dataSource) { \u00a0    super.setDataSource(dataSource); \u00a0  } // ... Kotlin // ... \u00a0  @Autowired \u00a0  override fun setDataSource(@Qualifier(\"myDataSource\") dataSource: DataSource) { \u00a0    super.setDataSource(dataSource) \u00a0  } // ... The specified qualifier value indicates the specific DataSource bean to inject, narrowing the set of type matches to a specific bean. Its value is matched against <qualifier> declarations within the corresponding <bean> definitions. The bean name is used as a fallback qualifier value, so you can effectively also point to a specific bean by name there (as shown earlier, assuming that myDataSource is the bean id). Testing Request- and Session-scoped Beans Spring has supported Request- and session-scoped beans since the early years, and you can test your request-scoped and session-scoped beans by following these steps: \u2022 Ensure that a WebApplicationContext is loaded for your test by annotating your test class with @WebAppConfiguration. \u2022Inject the mock request or session into your test instance and prepare your test fixture as appropriate.575", "chunk_char_count": 1645, "chunk_word_count": 258, "chunk_token_count": 411.25}, {"page_number": 576, "sentence_chunk": "\u2022 Invoke your web component that you retrieved from the configured WebApplicationContext (with dependency injection). \u2022Perform assertions against the mocks. The next code snippet shows the XML configuration for a login use case. Note that the userService bean has a dependency on a request-scoped loginAction bean. Also, the LoginAction is instantiated by using SpEL expressions that retrieve the username and password from the current HTTP request. In our test, we want to configure these request parameters through the mock managed by the TestContext framework. The following listing shows the configuration for this use case: Request-scoped bean configuration <beans> \u00a0  <bean id=\"userService\" class=\"com.example. SimpleUserService\" \u00a0      c:loginAction-ref=\"loginAction\"/> \u00a0  <bean id=\"loginAction\" class=\"com.example. LoginAction\" \u00a0      c:username=\"#{request.getParameter('user')}\" \u00a0      c:password=\"#{request.getParameter('pswd')}\" \u00a0      scope=\"request\"> \u00a0    <aop:scoped-proxy/> \u00a0  </bean> </beans> In RequestScopedBeanTests, we inject both the UserService (that is, the subject under test) and the MockHttpServletRequest into our test instance. Within our requestScope() test method, we set up our test fixture by setting request parameters in the provided MockHttpServletRequest.", "chunk_char_count": 1291, "chunk_word_count": 186, "chunk_token_count": 322.75}, {"page_number": 576, "sentence_chunk": "When the loginUser() method is invoked on our userService, we are assured that the user service has access to the request-scoped loginAction for the current MockHttpServletRequest (that is, the one in which we just set parameters). We can then perform assertions against the results based on the known inputs for the username and password. The following listing shows how to do so: 576", "chunk_char_count": 385, "chunk_word_count": 63, "chunk_token_count": 96.25}, {"page_number": 577, "sentence_chunk": "Java @SpringJUnitWebConfig class RequestScopedBeanTests { \u00a0  @Autowired UserService userService; \u00a0  @Autowired MockHttpServletRequest request; \u00a0  @Test \u00a0  void requestScope() { \u00a0    request.setParameter(\"user\", \"enigma\"); \u00a0    request.setParameter(\"pswd\", \"$pr!ng\"); \u00a0    LoginResults results = userService.loginUser(); \u00a0    // assert results \u00a0  } } Kotlin @SpringJUnitWebConfig class RequestScopedBeanTests { \u00a0  @Autowired lateinit var userService: UserService \u00a0  @Autowired lateinit var request: MockHttpServletRequest \u00a0  @Test \u00a0  fun requestScope() { \u00a0    request.setParameter(\"user\", \"enigma\") \u00a0    request.setParameter(\"pswd\", \"\\$pr!ng\") \u00a0    val results = userService.loginUser() \u00a0    // assert results \u00a0  } } The following code snippet is similar to the one we saw earlier for a request-scoped bean. However, this time, the userService bean has a dependency on a session-scoped userPreferences bean. Note that the UserPreferences bean is instantiated by using a SpEL expression that retrieves the theme from the current HTTP session. In our test, we need to configure a theme in the mock session managed by the TestContext framework. The following example shows how to do so: 577", "chunk_char_count": 1186, "chunk_word_count": 190, "chunk_token_count": 296.5}, {"page_number": 578, "sentence_chunk": "Session-scoped bean configuration <beans> \u00a0  <bean id=\"userService\" class=\"com.example. SimpleUserService\" \u00a0      c:userPreferences-ref=\"userPreferences\" /> \u00a0  <bean id=\"userPreferences\" class=\"com.example. UserPreferences\" \u00a0      c:theme=\"#{session.getAttribute('theme')}\" \u00a0      scope=\"session\"> \u00a0    <aop:scoped-proxy/> \u00a0  </bean> </beans> In SessionScopedBeanTests, we inject the UserService and the MockHttpSession into our test instance. Within our sessionScope() test method, we set up our test fixture by setting the expected theme attribute in the provided MockHttpSession. When the processUserPreferences() method is invoked on our userService, we are assured that the user service has access to the session-scoped userPreferences for the current MockHttpSession, and we can perform assertions against the results based on the configured theme. The following example shows how to do so: Java @SpringJUnitWebConfig class SessionScopedBeanTests { \u00a0  @Autowired UserService userService; \u00a0  @Autowired MockHttpSession session; \u00a0  @Test \u00a0  void sessionScope() throws Exception { \u00a0    session.setAttribute(\"theme\", \"blue\"); \u00a0    Results results = userService.processUserPreferences(); \u00a0    // assert results \u00a0  } } 578", "chunk_char_count": 1222, "chunk_word_count": 179, "chunk_token_count": 305.5}, {"page_number": 579, "sentence_chunk": "Kotlin @SpringJUnitWebConfig class SessionScopedBeanTests { \u00a0  @Autowired lateinit var userService: UserService \u00a0  @Autowired lateinit var session: MockHttpSession \u00a0  @Test \u00a0  fun sessionScope() { \u00a0    session.setAttribute(\"theme\", \"blue\") \u00a0    val results = userService.processUserPreferences() \u00a0    // assert results \u00a0  } } Transaction Management In the TestContext framework, transactions are managed by the TransactionalTestExecutionListener, which is configured by default, even if you do not explicitly declare @TestExecutionListeners on your test class. To enable support for transactions, however, you must configure a PlatformTransactionManager bean in the ApplicationContext that is loaded with @ContextConfiguration semantics (further details are provided later). In addition, you must declare Spring\u2019s @Transactional annotation either at the class or the method level for your tests. Test-managed Transactions Test-managed transactions are transactions that are managed declaratively by using the TransactionalTestExecutionListener or programmatically by using TestTransaction (described later). You should not confuse such transactions with Spring-managed transactions (those managed directly by Spring within the ApplicationContext loaded for tests) or application-managed transactions (those managed programmatically within application code that is invoked by tests). Spring-managed and application-managed transactions typically participate in test-managed transactions. However, you should use caution if Spring-managed or application-managed transactions are configured with any propagation type other than REQUIRED or SUPPORTS (see the discussion on transaction propagation for details).579", "chunk_char_count": 1709, "chunk_word_count": 219, "chunk_token_count": 427.25}, {"page_number": 580, "sentence_chunk": "\uf071 Preemptive timeouts and test-managed transactions Caution must be taken when using any form of preemptive timeouts from a testing framework in conjunction with Spring\u2019s test-managed transactions. Specifically, Spring\u2019s testing support binds transaction state to the current thread (via a java.lang. ThreadLocal variable) before the current test method is invoked. If a testing framework invokes the current test method in a new thread in order to support a preemptive timeout, any actions performed within the current test method will not be invoked within the test-managed transaction. Consequently, the result of any such actions will not be rolled back with the test-managed transaction. On the contrary, such actions will be committed to the persistent store\u2009\u2014\u2009for example, a relational database\u2009\u2014\u2009even though the test-managed transaction is properly rolled back by Spring. Situations in which this can occur include but are not limited to the following. \u2022JUnit 4\u2019s @Test(timeout = \u2026) support and TimeOut rule \u2022 JUnit Jupiter\u2019s assertTimeoutPreemptively(\u2026) methods in the org.junit.jupiter.api. Assertions class \u2022 TestNG\u2019s @Test(timeOut = \u2026) support Enabling and Disabling Transactions Annotating a test method with @Transactional causes the test to be run within a transaction that is, by default, automatically rolled back after completion of the test. If a test class is annotated with @Transactional, each test method within that class hierarchy runs within a transaction.", "chunk_char_count": 1482, "chunk_word_count": 217, "chunk_token_count": 370.5}, {"page_number": 580, "sentence_chunk": "Test methods that are not annotated with @Transactional (at the class or method level) are not run within a transaction. Note that @Transactional is not supported on test lifecycle methods \u2014 for example, methods annotated with JUnit Jupiter\u2019s @BeforeAll, @BeforeEach, etc. Furthermore, tests that are annotated with @Transactional but have the propagation attribute set to NOT_SUPPORTED or NEVER are not run within a transaction. Table 16.@Transactional attribute support Attribute Supported for test-managed transactions value and transactionManager yes propagation only Propagation. NOT_SUPPORTED and Propagation. NEVER are supported isolation no timeout no readOnly no rollbackFor and rollbackForClassName no: use TestTransaction.flagForRollback() instead noRollbackFor and noRollbackForClassName no: use TestTransaction.flagForCommit() instead 580", "chunk_char_count": 851, "chunk_word_count": 107, "chunk_token_count": 212.75}, {"page_number": 581, "sentence_chunk": "\uf0eb Method-level lifecycle methods \u2014 for example, methods annotated with JUnit Jupiter\u2019s @BeforeEach or @AfterEach \u2014 are run within a test-managed transaction. On the other hand, suite-level and class-level lifecycle methods \u2014 for example, methods annotated with JUnit Jupiter\u2019s @BeforeAll or @AfterAll and methods annotated with TestNG\u2019s @BeforeSuite, @AfterSuite, @BeforeClass, or @AfterClass \u2014 are not run within a test-managed transaction. If you need to run code in a suite-level or class-level lifecycle method within a transaction, you may wish to inject a corresponding PlatformTransactionManager into your test class and then use that with a TransactionTemplate for programmatic transaction management. Note that AbstractTransactionalJUnit4SpringContextTests and AbstractTransactionalTestNGSpringContextTests are preconfigured for transactional support at the class level. The following example demonstrates a common scenario for writing an integration test for a Hibernate-based UserRepository: 581", "chunk_char_count": 1006, "chunk_word_count": 130, "chunk_token_count": 251.5}, {"page_number": 582, "sentence_chunk": "Java @SpringJUnitConfig(TestConfig.class) @Transactional class HibernateUserRepositoryTests { \u00a0  @Autowired \u00a0  HibernateUserRepository repository; \u00a0  @Autowired \u00a0  SessionFactory sessionFactory; \u00a0  JdbcTemplate jdbcTemplate; \u00a0  @Autowired \u00a0  void setDataSource(DataSource dataSource) { \u00a0    this.jdbcTemplate = new JdbcTemplate(dataSource); \u00a0  } \u00a0  @Test \u00a0  void createUser() { \u00a0    // track initial state in test database: \u00a0    final int count = countRowsInTable(\"user\"); \u00a0    User user = new User(...); \u00a0    repository.save(user); \u00a0    // Manual flush is required to avoid false positive in test \u00a0    sessionFactory.getCurrentSession().flush(); \u00a0    assertNumUsers(count + 1); \u00a0  } \u00a0  private int countRowsInTable(String tableName) { \u00a0    return JdbcTestUtils.countRowsInTable(this.jdbcTemplate, tableName); \u00a0  } \u00a0  private void assertNumUsers(int expected) { \u00a0    assertEquals(\"Number of rows in the [user] table.\",expected, countRowsInTable(\"user\")); \u00a0  } } 582", "chunk_char_count": 965, "chunk_word_count": 157, "chunk_token_count": 241.25}, {"page_number": 583, "sentence_chunk": "Kotlin @SpringJUnitConfig(TestConfig::class) @Transactional class HibernateUserRepositoryTests { \u00a0  @Autowired \u00a0  lateinit var repository: HibernateUserRepository \u00a0  @Autowired \u00a0  lateinit var sessionFactory: SessionFactory \u00a0  lateinit var jdbcTemplate: JdbcTemplate \u00a0  @Autowired \u00a0  fun setDataSource(dataSource: DataSource) { \u00a0    this.jdbcTemplate = JdbcTemplate(dataSource) \u00a0  } \u00a0  @Test \u00a0  fun createUser() { \u00a0    // track initial state in test database: \u00a0    val count = countRowsInTable(\"user\") \u00a0    val user = User() \u00a0    repository.save(user) \u00a0    // Manual flush is required to avoid false positive in test \u00a0    sessionFactory.getCurrentSession().flush() \u00a0    assertNumUsers(count + 1) \u00a0  } \u00a0  private fun countRowsInTable(tableName: String): Int { \u00a0    return JdbcTestUtils.countRowsInTable(jdbcTemplate, tableName) \u00a0  } \u00a0  private fun assertNumUsers(expected: Int) { \u00a0    assertEquals(\"Number of rows in the [user] table.\",expected, countRowsInTable(\"user\")) \u00a0  } } As explained in Transaction Rollback and Commit Behavior, there is no need to clean up the database after the createUser() method runs, since any changes made to the database are automatically rolled back by the TransactionalTestExecutionListener. Transaction Rollback and Commit Behavior By default, test transactions will be automatically rolled back after completion of the test; however, transactional commit and rollback behavior can be configured declaratively via the @Commit and 583", "chunk_char_count": 1468, "chunk_word_count": 230, "chunk_token_count": 367.0}, {"page_number": 584, "sentence_chunk": "@Rollback annotations. See the corresponding entries in the annotation support section for further details. Programmatic Transaction Management You can interact with test-managed transactions programmatically by using the static methods in TestTransaction. For example, you can use TestTransaction within test methods, before methods, and after methods to start or end the current test-managed transaction or to configure the current test-managed transaction for rollback or commit. Support for TestTransaction is automatically available whenever the TransactionalTestExecutionListener is enabled. The following example demonstrates some of the features of TestTransaction. See the javadoc for TestTransaction for further details. Java @ContextConfiguration(classes = TestConfig.class) public class ProgrammaticTransactionManagementTests extends \u00a0    AbstractTransactionalJUnit4SpringContextTests { \u00a0  @Test \u00a0  public void transactionalTest() { \u00a0    // assert initial state in test database: \u00a0    assertNumUsers(2); \u00a0    deleteFromTables(\"user\"); \u00a0    // changes to the database will be committed!\u00a0    TestTransaction.flagForCommit(); \u00a0    TestTransaction.end(); \u00a0    assertFalse(TestTransaction.isActive()); \u00a0    assertNumUsers(0); \u00a0    TestTransaction.start(); \u00a0    // perform other actions against the database that will \u00a0    // be automatically rolled back after the test completes... \u00a0  } \u00a0  protected void assertNumUsers(int expected) { \u00a0    assertEquals(\"Number of rows in the [user] table.\",expected, countRowsInTable(\"user\")); \u00a0  } } 584", "chunk_char_count": 1546, "chunk_word_count": 226, "chunk_token_count": 386.5}, {"page_number": 585, "sentence_chunk": "Kotlin @ContextConfiguration(classes = [TestConfig::class]) class ProgrammaticTransactionManagementTests : AbstractTransactionalJUnit4SpringContextTests() { \u00a0  @Test \u00a0  fun transactionalTest() { \u00a0    // assert initial state in test database: \u00a0    assertNumUsers(2) \u00a0    deleteFromTables(\"user\") \u00a0    // changes to the database will be committed!\u00a0    TestTransaction.flagForCommit() \u00a0    TestTransaction.end() \u00a0    assertFalse(TestTransaction.isActive()) \u00a0    assertNumUsers(0) \u00a0    TestTransaction.start() \u00a0    // perform other actions against the database that will \u00a0    // be automatically rolled back after the test completes... \u00a0  } \u00a0  protected fun assertNumUsers(expected: Int) { \u00a0    assertEquals(\"Number of rows in the [user] table.\",expected, countRowsInTable(\"user\")) \u00a0  } } Running Code Outside of a Transaction Occasionally, you may need to run certain code before or after a transactional test method but outside the transactional context\u2009\u2014\u2009for example, to verify the initial database state prior to running your test or to verify expected transactional commit behavior after your test runs (if the test was configured to commit the transaction). TransactionalTestExecutionListener supports the @BeforeTransaction and @AfterTransaction annotations for exactly such scenarios. You can annotate any void method in a test class or any void default method in a test interface with one of these annotations, and the TransactionalTestExecutionListener ensures that your before transaction method or after transaction method runs at the appropriate time.\uf0eb Any before methods (such as methods annotated with JUnit Jupiter\u2019s @BeforeEach) and any after methods (such as methods annotated with JUnit Jupiter\u2019s @AfterEach) are run within a transaction. In addition, methods annotated with @BeforeTransaction or @AfterTransaction are not run for test methods that are not configured to run within a transaction.585", "chunk_char_count": 1914, "chunk_word_count": 288, "chunk_token_count": 478.5}, {"page_number": 586, "sentence_chunk": "Configuring a Transaction Manager TransactionalTestExecutionListener expects a PlatformTransactionManager bean to be defined in the Spring ApplicationContext for the test. If there are multiple instances of PlatformTransactionManager within the test\u2019s ApplicationContext, you can declare a qualifier by using @Transactional(\"myTxMgr\") or @Transactional(transactionManager = \"myTxMgr\"), or TransactionManagementConfigurer can be implemented by an @Configuration class. Consult the javadoc for TestContextTransactionUtils.retrieveTransactionManager() for details on the algorithm used to look up a transaction manager in the test\u2019s ApplicationContext. Demonstration of All Transaction-related Annotations The following JUnit Jupiter based example displays a fictitious integration testing scenario that highlights all transaction-related annotations. The example is not intended to demonstrate best practices but rather to demonstrate how these annotations can be used. See the annotation support section for further information and configuration examples. Transaction management for @Sql contains an additional example that uses @Sql for declarative SQL script execution with default transaction rollback semantics. The following example shows the relevant annotations: 586", "chunk_char_count": 1272, "chunk_word_count": 153, "chunk_token_count": 318.0}, {"page_number": 587, "sentence_chunk": "Java @SpringJUnitConfig @Transactional(transactionManager = \"txMgr\") @Commit class FictitiousTransactionalTest { \u00a0  @BeforeTransaction \u00a0  void verifyInitialDatabaseState() { \u00a0    // logic to verify the initial state before a transaction is started \u00a0  } \u00a0  @BeforeEach \u00a0  void setUpTestDataWithinTransaction() { \u00a0    // set up test data within the transaction \u00a0  } \u00a0  @Test \u00a0  // overrides the class-level @Commit setting \u00a0  @Rollback \u00a0  void modifyDatabaseWithinTransaction() { \u00a0    // logic which uses the test data and modifies database state \u00a0  } \u00a0  @AfterEach \u00a0  void tearDownWithinTransaction() { \u00a0    // run \"tear down\" logic within the transaction \u00a0  } \u00a0  @AfterTransaction \u00a0  void verifyFinalDatabaseState() { \u00a0    // logic to verify the final state after transaction has rolled back \u00a0  } } 587", "chunk_char_count": 802, "chunk_word_count": 148, "chunk_token_count": 200.5}, {"page_number": 588, "sentence_chunk": "Kotlin @SpringJUnitConfig @Transactional(transactionManager = \"txMgr\") @Commit class FictitiousTransactionalTest { \u00a0  @BeforeTransaction \u00a0  fun verifyInitialDatabaseState() { \u00a0    // logic to verify the initial state before a transaction is started \u00a0  } \u00a0  @BeforeEach \u00a0  fun setUpTestDataWithinTransaction() { \u00a0    // set up test data within the transaction \u00a0  } \u00a0  @Test \u00a0  // overrides the class-level @Commit setting \u00a0  @Rollback \u00a0  fun modifyDatabaseWithinTransaction() { \u00a0    // logic which uses the test data and modifies database state \u00a0  } \u00a0  @AfterEach \u00a0  fun tearDownWithinTransaction() { \u00a0    // run \"tear down\" logic within the transaction \u00a0  } \u00a0  @AfterTransaction \u00a0  fun verifyFinalDatabaseState() { \u00a0    // logic to verify the final state after transaction has rolled back \u00a0  } } \uf05a Avoid false positives when testing ORM code When you test application code that manipulates the state of a Hibernate session or JPA persistence context, make sure to flush the underlying unit of work within test methods that run that code. Failing to flush the underlying unit of work can produce false positives: Your test passes, but the same code throws an exception in a live, production environment. Note that this applies to any ORM framework that maintains an in-memory unit of work. In the following Hibernate-based example test case, one method demonstrates a false positive, and the other method correctly exposes the results of flushing the session: 588", "chunk_char_count": 1462, "chunk_word_count": 256, "chunk_token_count": 365.5}, {"page_number": 589, "sentence_chunk": "Java // ... @Autowired SessionFactory sessionFactory; @Transactional @Test // no expected exception!public void falsePositive() { \u00a0  updateEntityInHibernateSession(); \u00a0  // False positive: an exception will be thrown once the Hibernate \u00a0  // Session is finally flushed (i.e., in production code) } @Transactional @Test(expected = ...) public void updateWithSessionFlush() { \u00a0  updateEntityInHibernateSession(); \u00a0  // Manual flush is required to avoid false positive in test \u00a0  sessionFactory.getCurrentSession().flush(); } // ... Kotlin // ... @Autowired lateinit var sessionFactory: SessionFactory @Transactional @Test // no expected exception!fun falsePositive() { \u00a0  updateEntityInHibernateSession() \u00a0  // False positive: an exception will be thrown once the Hibernate \u00a0  // Session is finally flushed (i.e., in production code) } @Transactional @Test(expected = ...) fun updateWithSessionFlush() { \u00a0  updateEntityInHibernateSession() \u00a0  // Manual flush is required to avoid false positive in test \u00a0  sessionFactory.getCurrentSession().flush() } // ... 589", "chunk_char_count": 1059, "chunk_word_count": 147, "chunk_token_count": 264.75}, {"page_number": 590, "sentence_chunk": "The following example shows matching methods for JPA: Java // ... @PersistenceContext EntityManager entityManager; @Transactional @Test // no expected exception!public void falsePositive() { \u00a0  updateEntityInJpaPersistenceContext(); \u00a0  // False positive: an exception will be thrown once the JPA \u00a0  // EntityManager is finally flushed (i.e., in production code) } @Transactional @Test(expected = ...) public void updateWithEntityManagerFlush() { \u00a0  updateEntityInJpaPersistenceContext(); \u00a0  // Manual flush is required to avoid false positive in test \u00a0  entityManager.flush(); } // ... 590", "chunk_char_count": 589, "chunk_word_count": 82, "chunk_token_count": 147.25}, {"page_number": 591, "sentence_chunk": "Kotlin // ... @PersistenceContext lateinit var entityManager:EntityManager @Transactional @Test // no expected exception!fun falsePositive() { \u00a0  updateEntityInJpaPersistenceContext() \u00a0  // False positive: an exception will be thrown once the JPA \u00a0  // EntityManager is finally flushed (i.e., in production code) } @Transactional @Test(expected = ...) void updateWithEntityManagerFlush() { \u00a0  updateEntityInJpaPersistenceContext() \u00a0  // Manual flush is required to avoid false positive in test \u00a0  entityManager.flush() } // ... \uf05a Testing ORM entity lifecycle callbacks Similar to the note about avoiding false positives when testing ORM code, if your application makes use of entity lifecycle callbacks (also known as entity listeners), make sure to flush the underlying unit of work within test methods that run that code. Failing to flush or clear the underlying unit of work can result in certain lifecycle callbacks not being invoked. For example, when using JPA, @PostPersist, @PreUpdate, and @PostUpdate callbacks will not be called unless entityManager.flush() is invoked after an entity has been saved or updated. Similarly, if an entity is already attached to the current unit of work (associated with the current persistence context), an attempt to reload the entity will not result in a @PostLoad callback unless entityManager.clear() is invoked before the attempt to reload the entity. The following example shows how to flush the EntityManager to ensure that @PostPersist callbacks are invoked when an entity is persisted. An entity listener with a @PostPersist callback method has been registered for the Person entity used in the example.591", "chunk_char_count": 1656, "chunk_word_count": 248, "chunk_token_count": 414.0}, {"page_number": 592, "sentence_chunk": "Java // ... @Autowired JpaPersonRepository repo; @PersistenceContext EntityManager entityManager; @Transactional @Test void savePerson() { \u00a0  // EntityManager#persist(...) results in @PrePersist but not @PostPersist \u00a0  repo.save(new Person(\"Jane\")); \u00a0  // Manual flush is required for @PostPersist callback to be invoked \u00a0  entityManager.flush(); \u00a0  // Test code that relies on the @PostPersist callback \u00a0  // having been invoked... } // ... 592", "chunk_char_count": 445, "chunk_word_count": 65, "chunk_token_count": 111.25}, {"page_number": 593, "sentence_chunk": "Kotlin // ... @Autowired lateinit var repo: JpaPersonRepository @PersistenceContext lateinit var entityManager: EntityManager @Transactional @Test fun savePerson() { \u00a0  // EntityManager#persist(...) results in @PrePersist but not @PostPersist \u00a0  repo.save(Person(\"Jane\")) \u00a0  // Manual flush is required for @PostPersist callback to be invoked \u00a0  entityManager.flush() \u00a0  // Test code that relies on the @PostPersist callback \u00a0  // having been invoked... } // ... See JpaEntityListenerTests in the Spring Framework test suite for working examples using all JPA lifecycle callbacks. Executing SQL Scripts When writing integration tests against a relational database, it is often beneficial to run SQL scripts to modify the database schema or insert test data into tables. The spring-jdbc module provides support for initializing an embedded or existing database by executing SQL scripts when the Spring ApplicationContext is loaded. See Embedded database support and Testing data access logic with an embedded database for details. Although it is very useful to initialize a database for testing once when the ApplicationContext is loaded, sometimes it is essential to be able to modify the database during integration tests. The following sections explain how to run SQL scripts programmatically and declaratively during integration tests. Executing SQL scripts programmatically Spring provides the following options for executing SQL scripts programmatically within integration test methods. \u2022org.springframework.jdbc.datasource.init. ScriptUtils \u2022 org.springframework.jdbc.datasource.init. ResourceDatabasePopulator 593", "chunk_char_count": 1620, "chunk_word_count": 220, "chunk_token_count": 405.0}, {"page_number": 594, "sentence_chunk": "\u2022 org.springframework.test.context.junit4. AbstractTransactionalJUnit4SpringContextTests \u2022 org.springframework.test.context.testng. AbstractTransactionalTestNGSpringContextTests ScriptUtils provides a collection of static utility methods for working with SQL scripts and is mainly intended for internal use within the framework. However, if you require full control over how SQL scripts are parsed and run, ScriptUtils may suit your needs better than some of the other alternatives described later. See the javadoc for individual methods in ScriptUtils for further details. ResourceDatabasePopulator provides an object-based API for programmatically populating, initializing, or cleaning up a database by using SQL scripts defined in external resources. ResourceDatabasePopulator provides options for configuring the character encoding, statement separator, comment delimiters, and error handling flags used when parsing and running the scripts. Each of the configuration options has a reasonable default value. See the javadoc for details on default values. To run the scripts configured in a ResourceDatabasePopulator, you can invoke either the populate(Connection) method to run the populator against a java.sql. Connection or the execute(DataSource) method to run the populator against a javax.sql.", "chunk_char_count": 1302, "chunk_word_count": 165, "chunk_token_count": 325.5}, {"page_number": 594, "sentence_chunk": "DataSource. The following example specifies SQL scripts for a test schema and test data, sets the statement separator to @@, and run the scripts against a DataSource: Java @Test void databaseTest() { \u00a0  ResourceDatabasePopulator populator = new ResourceDatabasePopulator(); \u00a0  populator.addScripts( \u00a0      new ClassPathResource(\"test-schema.sql\"), \u00a0      new ClassPathResource(\"test-data.sql\")); \u00a0  populator.setSeparator(\"@@\"); \u00a0  populator.execute(this.dataSource); \u00a0  // run code that uses the test schema and data } Kotlin @Test fun databaseTest() { \u00a0  val populator = ResourceDatabasePopulator() \u00a0  populator.addScripts( \u00a0      ClassPathResource(\"test-schema.sql\"), \u00a0      ClassPathResource(\"test-data.sql\")) \u00a0  populator.setSeparator(\"@@\") \u00a0  populator.execute(dataSource) \u00a0  // run code that uses the test schema and data } Note that ResourceDatabasePopulator internally delegates to ScriptUtils for parsing and running SQL scripts. Similarly, the executeSqlScript(..) methods in AbstractTransactionalJUnit4SpringContextTests and AbstractTransactionalTestNGSpringContextTests 594", "chunk_char_count": 1086, "chunk_word_count": 146, "chunk_token_count": 271.5}, {"page_number": 595, "sentence_chunk": "internally use a ResourceDatabasePopulator to run SQL scripts. See the Javadoc for the various executeSqlScript(..) methods for further details. Executing SQL scripts declaratively with @Sql In addition to the aforementioned mechanisms for running SQL scripts programmatically, you can declaratively configure SQL scripts in the Spring TestContext Framework. Specifically, you can declare the @Sql annotation on a test class or test method to configure individual SQL statements or the resource paths to SQL scripts that should be run against a given database before or after an integration test method. Support for @Sql is provided by the SqlScriptsTestExecutionListener, which is enabled by default.\uf05a Method-level @Sql declarations override class-level declarations by default. As of Spring Framework 5.2, however, this behavior may be configured per test class or per test method via @SqlMergeMode. See Merging and Overriding Configuration with @SqlMergeMode for further details. Path Resource Semantics Each path is interpreted as a Spring Resource. A plain path (for example, \"schema.sql\") is treated as a classpath resource that is relative to the package in which the test class is defined.", "chunk_char_count": 1197, "chunk_word_count": 175, "chunk_token_count": 299.25}, {"page_number": 595, "sentence_chunk": "A path starting with a slash is treated as an absolute classpath resource (for example, \"/org/example/schema.sql\"). A path that references a URL (for example, a path prefixed with classpath:, file:, http:) is loaded by using the specified resource protocol. The following example shows how to use @Sql at the class level and at the method level within a JUnit Jupiter based integration test class: Java @SpringJUnitConfig @Sql(\"/test-schema.sql\") class DatabaseTests { \u00a0  @Test \u00a0  void emptySchemaTest() { \u00a0    // run code that uses the test schema without any test data \u00a0  } \u00a0  @Test \u00a0  @Sql({\"/test-schema.sql\", \"/test-user-data.sql\"}) \u00a0  void userTest() { \u00a0    // run code that uses the test schema and test data \u00a0  } } 595", "chunk_char_count": 726, "chunk_word_count": 129, "chunk_token_count": 181.5}, {"page_number": 596, "sentence_chunk": "Kotlin @SpringJUnitConfig @Sql(\"/test-schema.sql\") class DatabaseTests { \u00a0  @Test \u00a0  fun emptySchemaTest() { \u00a0    // run code that uses the test schema without any test data \u00a0  } \u00a0  @Test \u00a0  @Sql(\"/test-schema.sql\", \"/test-user-data.sql\") \u00a0  fun userTest() { \u00a0    // run code that uses the test schema and test data \u00a0  } } Default Script Detection If no SQL scripts or statements are specified, an attempt is made to detect a default script, depending on where @Sql is declared. If a default cannot be detected, an IllegalStateException is thrown. \u2022Class-level declaration: If the annotated test class is com.example. MyTest, the corresponding default script is classpath:com/example/MyTest.sql. \u2022Method-level declaration: If the annotated test method is named testMethod() and is defined in the class com.example. MyTest, the corresponding default script is classpath:com/example/MyTest.testMethod.sql. Declaring Multiple @Sql Sets If you need to configure multiple sets of SQL scripts for a given test class or test method but with different syntax configuration, different error handling rules, or different execution phases per set, you can declare multiple instances of @Sql. With Java 8, you can use @Sql as a repeatable annotation. Otherwise, you can use the @SqlGroup annotation as an explicit container for declaring multiple instances of @Sql. The following example shows how to use @Sql as a repeatable annotation with Java 8: Java @Test @Sql(scripts = \"/test-schema.sql\", config = @SqlConfig(commentPrefix = \"`\")) @Sql(\"/test-user-data.sql\") void userTest() { \u00a0  // run code that uses the test schema and test data } 596", "chunk_char_count": 1632, "chunk_word_count": 256, "chunk_token_count": 408.0}, {"page_number": 597, "sentence_chunk": "Kotlin // Repeatable annotations with non-SOURCE retention are not yet supported by Kotlin In the scenario presented in the preceding example, the test-schema.sql script uses a different syntax for single-line comments. The following example is identical to the preceding example, except that the @Sql declarations are grouped together within @SqlGroup. With Java 8 and above, the use of @SqlGroup is optional, but you may need to use @SqlGroup for compatibility with other JVM languages such as Kotlin. Java @Test @SqlGroup({ \u00a0  @Sql(scripts = \"/test-schema.sql\", config = @SqlConfig(commentPrefix = \"`\")), \u00a0  @Sql(\"/test-user-data.sql\") )} void userTest() { \u00a0  // run code that uses the test schema and test data } Kotlin @Test @SqlGroup( \u00a0  Sql(\"/test-schema.sql\", config = SqlConfig(commentPrefix = \"`\")), \u00a0  Sql(\"/test-user-data.sql\")) fun userTest() { \u00a0  // Run code that uses the test schema and test data } Script Execution Phases By default, SQL scripts are run before the corresponding test method. However, if you need to run a particular set of scripts after the test method (for example, to clean up database state), you can use the executionPhase attribute in @Sql, as the following example shows: 597", "chunk_char_count": 1215, "chunk_word_count": 192, "chunk_token_count": 303.75}, {"page_number": 598, "sentence_chunk": "Java @Test @Sql( \u00a0  scripts = \"create-test-data.sql\", \u00a0  config = @SqlConfig(transactionMode = ISOLATED) ) @Sql( \u00a0  scripts = \"delete-test-data.sql\", \u00a0  config = @SqlConfig(transactionMode = ISOLATED), \u00a0  executionPhase = AFTER_TEST_METHOD ) void userTest() { \u00a0  // run code that needs the test data to be committed \u00a0  // to the database outside of the test's transaction } Kotlin @Test @SqlGroup( \u00a0  Sql(\"create-test-data.sql\", \u00a0    config = SqlConfig(transactionMode = ISOLATED)), \u00a0  Sql(\"delete-test-data.sql\", \u00a0    config = SqlConfig(transactionMode = ISOLATED), \u00a0    executionPhase = AFTER_TEST_METHOD)) fun userTest() { \u00a0  // run code that needs the test data to be committed \u00a0  // to the database outside of the test's transaction } Note that ISOLATED and AFTER_TEST_METHOD are statically imported from Sql. TransactionMode and Sql. ExecutionPhase, respectively. Script Configuration with @SqlConfig You can configure script parsing and error handling by using the @SqlConfig annotation. When declared as a class-level annotation on an integration test class, @SqlConfig serves as global configuration for all SQL scripts within the test class hierarchy. When declared directly by using the config attribute of the @Sql annotation, @SqlConfig serves as local configuration for the SQL scripts declared within the enclosing @Sql annotation. Every attribute in @SqlConfig has an implicit default value, which is documented in the javadoc of the corresponding attribute. Due to the rules defined for annotation attributes in the Java Language Specification, it is, unfortunately, not possible to assign a value of null to an annotation attribute. Thus, in order to support overrides of inherited global configuration, @SqlConfig attributes have an explicit default value of either \"\" (for Strings), {} (for arrays), or DEFAULT (for enumerations). This approach lets local declarations of @SqlConfig selectively override individual attributes from global declarations of @SqlConfig by providing a value other than \"\", {}, or DEFAULT.", "chunk_char_count": 2036, "chunk_word_count": 311, "chunk_token_count": 509.0}, {"page_number": 598, "sentence_chunk": "Global @SqlConfig attributes are inherited whenever local @SqlConfig attributes do not supply an explicit value other than \"\", {}, or DEFAULT. Explicit local 598", "chunk_char_count": 161, "chunk_word_count": 24, "chunk_token_count": 40.25}, {"page_number": 599, "sentence_chunk": "configuration, therefore, overrides global configuration. The configuration options provided by @Sql and @SqlConfig are equivalent to those supported by ScriptUtils and ResourceDatabasePopulator but are a superset of those provided by the <jdbc:initialize-database/> XML namespace element. See the javadoc of individual attributes in @Sql and @SqlConfig for details. Transaction management for @Sql By default, the SqlScriptsTestExecutionListener infers the desired transaction semantics for scripts configured by using @Sql. Specifically, SQL scripts are run without a transaction, within an existing Spring-managed transaction (for example, a transaction managed by the TransactionalTestExecutionListener for a test annotated with @Transactional), or within an isolated transaction, depending on the configured value of the transactionMode attribute in @SqlConfig and the presence of a PlatformTransactionManager in the test\u2019s ApplicationContext. As a bare minimum, however, a javax.sql. DataSource must be present in the test\u2019s ApplicationContext. If the algorithms used by SqlScriptsTestExecutionListener to detect a DataSource and PlatformTransactionManager and infer the transaction semantics do not suit your needs, you can specify explicit names by setting the dataSource and transactionManager attributes of @SqlConfig. Furthermore, you can control the transaction propagation behavior by setting the transactionMode attribute of @SqlConfig (for example, whether scripts should be run in an isolated transaction). Although a thorough discussion of all supported options for transaction management with @Sql is beyond the scope of this reference manual, the javadoc for @SqlConfig and SqlScriptsTestExecutionListener provide detailed information, and the following example shows a typical testing scenario that uses JUnit Jupiter and transactional tests with @Sql: 599", "chunk_char_count": 1876, "chunk_word_count": 245, "chunk_token_count": 469.0}, {"page_number": 600, "sentence_chunk": "Java @SpringJUnitConfig(TestDatabaseConfig.class) @Transactional class TransactionalSqlScriptsTests { \u00a0  final JdbcTemplate jdbcTemplate; \u00a0  @Autowired \u00a0  TransactionalSqlScriptsTests(DataSource dataSource) { \u00a0    this.jdbcTemplate = new JdbcTemplate(dataSource); \u00a0  } \u00a0  @Test \u00a0  @Sql(\"/test-data.sql\") \u00a0  void usersTest() { \u00a0    // verify state in test database: \u00a0    assertNumUsers(2); \u00a0    // run code that uses the test data... \u00a0  } \u00a0  int countRowsInTable(String tableName) { \u00a0    return JdbcTestUtils.countRowsInTable(this.jdbcTemplate, tableName); \u00a0  } \u00a0  void assertNumUsers(int expected) { \u00a0    assertEquals(expected, countRowsInTable(\"user\"), \u00a0      \"Number of rows in the [user] table.\");\u00a0  } } 600", "chunk_char_count": 710, "chunk_word_count": 116, "chunk_token_count": 177.5}, {"page_number": 601, "sentence_chunk": "Kotlin @SpringJUnitConfig(TestDatabaseConfig::class) @Transactional class TransactionalSqlScriptsTests @Autowired constructor(dataSource: DataSource) { \u00a0  val jdbcTemplate: JdbcTemplate = JdbcTemplate(dataSource) \u00a0  @Test \u00a0  @Sql(\"/test-data.sql\") \u00a0  fun usersTest() { \u00a0    // verify state in test database: \u00a0    assertNumUsers(2) \u00a0    // run code that uses the test data... \u00a0  } \u00a0  fun countRowsInTable(tableName: String): Int { \u00a0    return JdbcTestUtils.countRowsInTable(jdbcTemplate, tableName) \u00a0  } \u00a0  fun assertNumUsers(expected: Int) { \u00a0    assertEquals(expected, countRowsInTable(\"user\"), \u00a0        \"Number of rows in the [user] table.\")\u00a0  } } Note that there is no need to clean up the database after the usersTest() method is run, since any changes made to the database (either within the test method or within the /test-data.sql script) are automatically rolled back by the TransactionalTestExecutionListener (see transaction management for details). Merging and Overriding Configuration with @SqlMergeMode As of Spring Framework 5.2, it is possible to merge method-level @Sql declarations with class-level declarations. For example, this allows you to provide the configuration for a database schema or some common test data once per test class and then provide additional, use case specific test data per test method. To enable @Sql merging, annotate either your test class or test method with @SqlMergeMode(MERGE). To disable merging for a specific test method (or specific test subclass), you can switch back to the default mode via @SqlMergeMode(OVERRIDE). Consult the @SqlMergeMode annotation documentation section for examples and further details. Parallel Test Execution Spring Framework 5.0 introduced basic support for executing tests in parallel within a single JVM when using the Spring TestContext Framework. In general, this means that most test classes or test methods can be run in parallel without any changes to test code or configuration.\uf0eb For details on how to set up parallel test execution, see the documentation for your testing framework, build tool, or IDE.", "chunk_char_count": 2091, "chunk_word_count": 322, "chunk_token_count": 522.75}, {"page_number": 602, "sentence_chunk": "Keep in mind that the introduction of concurrency into your test suite can result in unexpected side effects, strange runtime behavior, and tests that fail intermittently or seemingly randomly. The Spring Team therefore provides the following general guidelines for when not to run tests in parallel. Do not run tests in parallel if the tests: \u2022 Use Spring Framework\u2019s @DirtiesContext support. \u2022Use Spring Boot\u2019s @MockBean or @SpyBean support. \u2022Use JUnit 4\u2019s @FixMethodOrder support or any testing framework feature that is designed to ensure that test methods run in a particular order. Note, however, that this does not apply if entire test classes are run in parallel. \u2022Change the state of shared services or systems such as a database, message broker, filesystem, and others. This applies to both embedded and external systems.\uf0eb If parallel test execution fails with an exception stating that the ApplicationContext for the current test is no longer active, this typically means that the ApplicationContext was removed from the ContextCache in a different thread. This may be due to the use of @DirtiesContext or due to automatic eviction from the ContextCache.", "chunk_char_count": 1165, "chunk_word_count": 183, "chunk_token_count": 291.25}, {"page_number": 602, "sentence_chunk": "If @DirtiesContext is the culprit, you either need to find a way to avoid using @DirtiesContext or exclude such tests from parallel execution. If the maximum size of the ContextCache has been exceeded, you can increase the maximum size of the cache. See the discussion on context caching for details.\uf071 Parallel test execution in the Spring TestContext Framework is only possible if the underlying TestContext implementation provides a copy constructor, as explained in the javadoc for TestContext. The DefaultTestContext used in Spring provides such a constructor. However, if you use a third-party library that provides a custom TestContext implementation, you need to verify that it is suitable for parallel test execution. TestContext Framework Support Classes This section describes the various classes that support the Spring TestContext Framework. Spring JUnit 4 Runner The Spring TestContext Framework offers full integration with JUnit 4 through a custom runner (supported on JUnit 4.12 or higher). By annotating test classes with @RunWith(SpringJUnit4ClassRunner.class) or the shorter @RunWith(SpringRunner.class) variant, developers can implement standard JUnit 4-based unit and integration tests and simultaneously reap the benefits of the TestContext framework, such as support for loading application contexts, dependency injection of test instances, transactional test method execution, and so on. If you want to use the Spring TestContext Framework with an alternative runner (such as JUnit 4\u2019s Parameterized runner) or third-party runners (such as the MockitoJUnitRunner), you can, optionally, use Spring\u2019s support for JUnit rules instead.", "chunk_char_count": 1655, "chunk_word_count": 236, "chunk_token_count": 413.75}, {"page_number": 603, "sentence_chunk": "The following code listing shows the minimal requirements for configuring a test class to run with the custom Spring Runner: Java @RunWith(SpringRunner.class) @TestExecutionListeners({}) public class SimpleTest { \u00a0  @Test \u00a0  public void testMethod() { \u00a0    // test logic... \u00a0  } } Kotlin @RunWith(SpringRunner::class) @TestExecutionListeners class SimpleTest { \u00a0  @Test \u00a0  fun testMethod() { \u00a0    // test logic... \u00a0  } } In the preceding example, @TestExecutionListeners is configured with an empty list, to disable the default listeners, which otherwise would require an ApplicationContext to be configured through @ContextConfiguration. Spring JUnit 4 Rules The org.springframework.test.context.junit4.rules package provides the following JUnit 4 rules (supported on JUnit 4.12 or higher): \u2022 SpringClassRule \u2022 SpringMethodRule SpringClassRule is a JUnit TestRule that supports class-level features of the Spring TestContext Framework, whereas SpringMethodRule is a JUnit MethodRule that supports instance-level and method-level features of the Spring TestContext Framework. In contrast to the SpringRunner, Spring\u2019s rule-based JUnit support has the advantage of being independent of any org.junit.runner. Runner implementation and can, therefore, be combined with existing alternative runners (such as JUnit 4\u2019s Parameterized) or third-party runners (such as the MockitoJUnitRunner). To support the full functionality of the TestContext framework, you must combine a 603", "chunk_char_count": 1472, "chunk_word_count": 208, "chunk_token_count": 368.0}, {"page_number": 604, "sentence_chunk": "SpringClassRule with a SpringMethodRule. The following example shows the proper way to declare these rules in an integration test: Java // Optionally specify a non-Spring Runner via @RunWith(...) @ContextConfiguration public class IntegrationTest { \u00a0  @ClassRule \u00a0  public static final SpringClassRule springClassRule = new SpringClassRule(); \u00a0  @Rule \u00a0  public final SpringMethodRule springMethodRule = new SpringMethodRule(); \u00a0  @Test \u00a0  public void testMethod() { \u00a0    // test logic... \u00a0  } } Kotlin // Optionally specify a non-Spring Runner via @RunWith(...) @ContextConfiguration class IntegrationTest { \u00a0  @Rule \u00a0  val springMethodRule = SpringMethodRule() \u00a0  @Test \u00a0  fun testMethod() { \u00a0    // test logic... \u00a0  } \u00a0  companion object { \u00a0    @ClassRule \u00a0    val springClassRule = SpringClassRule() \u00a0  } } JUnit 4 Support Classes The org.springframework.test.context.junit4 package provides the following support classes for JUnit 4-based test cases (supported on JUnit 4.12 or higher): \u2022 AbstractJUnit4SpringContextTests \u2022 AbstractTransactionalJUnit4SpringContextTests AbstractJUnit4SpringContextTests is an abstract base test class that integrates the Spring 604", "chunk_char_count": 1169, "chunk_word_count": 179, "chunk_token_count": 292.25}, {"page_number": 605, "sentence_chunk": "TestContext Framework with explicit ApplicationContext testing support in a JUnit 4 environment. When you extend AbstractJUnit4SpringContextTests, you can access a protected applicationContext instance variable that you can use to perform explicit bean lookups or to test the state of the context as a whole. AbstractTransactionalJUnit4SpringContextTests is an abstract transactional extension of AbstractJUnit4SpringContextTests that adds some convenience functionality for JDBC access. This class expects a javax.sql. DataSource bean and a PlatformTransactionManager bean to be defined in the ApplicationContext. When you extend AbstractTransactionalJUnit4SpringContextTests, you can access a protected jdbcTemplate instance variable that you can use to run SQL statements to query the database. You can use such queries to confirm database state both before and after running database-related application code, and Spring ensures that such queries run in the scope of the same transaction as the application code. When used in conjunction with an ORM tool, be sure to avoid false positives. As mentioned in JDBC Testing Support, AbstractTransactionalJUnit4SpringContextTests also provides convenience methods that delegate to methods in JdbcTestUtils by using the aforementioned jdbcTemplate. Furthermore, AbstractTransactionalJUnit4SpringContextTests provides an executeSqlScript(..) method for running SQL scripts against the configured DataSource.", "chunk_char_count": 1453, "chunk_word_count": 186, "chunk_token_count": 363.25}, {"page_number": 605, "sentence_chunk": "\uf0eb These classes are a convenience for extension. If you do not want your test classes to be tied to a Spring-specific class hierarchy, you can configure your own custom test classes by using @RunWith(SpringRunner.class) or Spring\u2019s JUnit rules. SpringExtension for JUnit Jupiter The Spring TestContext Framework offers full integration with the JUnit Jupiter testing framework, introduced in JUnit 5. By annotating test classes with @ExtendWith(SpringExtension.class), you can implement standard JUnit Jupiter-based unit and integration tests and simultaneously reap the benefits of the TestContext framework, such as support for loading application contexts, dependency injection of test instances, transactional test method execution, and so on. Furthermore, thanks to the rich extension API in JUnit Jupiter, Spring provides the following features above and beyond the feature set that Spring supports for JUnit 4 and TestNG: \u2022 Dependency injection for test constructors, test methods, and test lifecycle callback methods. See Dependency Injection with SpringExtension for further details. \u2022Powerful support for conditional test execution based on SpEL expressions, environment variables, system properties, and so on. See the documentation for @EnabledIf and @DisabledIf in Spring JUnit Jupiter Testing Annotations for further details and examples. \u2022Custom composed annotations that combine annotations from Spring and JUnit Jupiter. See the @TransactionalDevTestConfig and @TransactionalIntegrationTest examples in Meta-Annotation Support for Testing for further details.", "chunk_char_count": 1576, "chunk_word_count": 214, "chunk_token_count": 394.0}, {"page_number": 605, "sentence_chunk": "The following code listing shows how to configure a test class to use the SpringExtension in conjunction with @ContextConfiguration: 605", "chunk_char_count": 136, "chunk_word_count": 20, "chunk_token_count": 34.0}, {"page_number": 606, "sentence_chunk": "Java // Instructs JUnit Jupiter to extend the test with Spring support.@ExtendWith(SpringExtension.class) // Instructs Spring to load an ApplicationContext from TestConfig.class @ContextConfiguration(classes = TestConfig.class) class SimpleTests { \u00a0  @Test \u00a0  void testMethod() { \u00a0    // test logic... \u00a0  } } Kotlin // Instructs JUnit Jupiter to extend the test with Spring support.@ExtendWith(SpringExtension::class) // Instructs Spring to load an ApplicationContext from TestConfig::class @ContextConfiguration(classes = [TestConfig::class]) class SimpleTests { \u00a0  @Test \u00a0  fun testMethod() { \u00a0    // test logic... \u00a0  } } Since you can also use annotations in JUnit 5 as meta-annotations, Spring provides the @SpringJUnitConfig and @SpringJUnitWebConfig composed annotations to simplify the configuration of the test ApplicationContext and JUnit Jupiter. The following example uses @SpringJUnitConfig to reduce the amount of configuration used in the previous example: Java // Instructs Spring to register the SpringExtension with JUnit // Jupiter and load an ApplicationContext from TestConfig.class @SpringJUnitConfig(TestConfig.class) class SimpleTests { \u00a0  @Test \u00a0  void testMethod() { \u00a0    // test logic... \u00a0  } } 606", "chunk_char_count": 1224, "chunk_word_count": 180, "chunk_token_count": 306.0}, {"page_number": 607, "sentence_chunk": "Kotlin // Instructs Spring to register the SpringExtension with JUnit // Jupiter and load an ApplicationContext from TestConfig.class @SpringJUnitConfig(TestConfig::class) class SimpleTests { \u00a0  @Test \u00a0  fun testMethod() { \u00a0    // test logic... \u00a0  } } Similarly, the following example uses @SpringJUnitWebConfig to create a WebApplicationContext for use with JUnit Jupiter: Java // Instructs Spring to register the SpringExtension with JUnit // Jupiter and load a WebApplicationContext from TestWebConfig.class @SpringJUnitWebConfig(TestWebConfig.class) class SimpleWebTests { \u00a0  @Test \u00a0  void testMethod() { \u00a0    // test logic... \u00a0  } } Kotlin // Instructs Spring to register the SpringExtension with JUnit // Jupiter and load a WebApplicationContext from TestWebConfig::class @SpringJUnitWebConfig(TestWebConfig::class) class SimpleWebTests { \u00a0  @Test \u00a0  fun testMethod() { \u00a0    // test logic... \u00a0  } } See the documentation for @SpringJUnitConfig and @SpringJUnitWebConfig in Spring JUnit Jupiter Testing Annotations for further details. Dependency Injection with SpringExtension SpringExtension implements the ParameterResolver extension API from JUnit Jupiter, which lets Spring provide dependency injection for test constructors, test methods, and test lifecycle callback 607", "chunk_char_count": 1281, "chunk_word_count": 183, "chunk_token_count": 320.25}, {"page_number": 608, "sentence_chunk": "methods. Specifically, SpringExtension can inject dependencies from the test\u2019s ApplicationContext into test constructors and methods that are annotated with @BeforeAll, @AfterAll, @BeforeEach, @AfterEach, @Test, @RepeatedTest, @ParameterizedTest, and others. Constructor Injection If a specific parameter in a constructor for a JUnit Jupiter test class is of type ApplicationContext (or a sub-type thereof) or is annotated or meta-annotated with @Autowired, @Qualifier, or @Value, Spring injects the value for that specific parameter with the corresponding bean or value from the test\u2019s ApplicationContext. Spring can also be configured to autowire all arguments for a test class constructor if the constructor is considered to be autowirable. A constructor is considered to be autowirable if one of the following conditions is met (in order of precedence). \u2022The constructor is annotated with @Autowired. \u2022@TestConstructor is present or meta-present on the test class with the autowireMode attribute set to ALL. \u2022The default test constructor autowire mode has been changed to ALL. See @TestConstructor for details on the use of @TestConstructor and how to change the global test constructor autowire mode.\uf071 If the constructor for a test class is considered to be autowirable, Spring assumes the responsibility for resolving arguments for all parameters in the constructor.", "chunk_char_count": 1372, "chunk_word_count": 197, "chunk_token_count": 343.0}, {"page_number": 608, "sentence_chunk": "Consequently, no other ParameterResolver registered with JUnit Jupiter can resolve parameters for such a constructor.\uf071 Constructor injection for test classes must not be used in conjunction with JUnit Jupiter\u2019s @TestInstance(PER_CLASS) support if @DirtiesContext is used to close the test\u2019s ApplicationContext before or after test methods. The reason is that @TestInstance(PER_CLASS) instructs JUnit Jupiter to cache the test instance between test method invocations. Consequently, the test instance will retain references to beans that were originally injected from an ApplicationContext that has been subsequently closed. Since the constructor for the test class will only be invoked once in such scenarios, dependency injection will not occur again, and subsequent tests will interact with beans from the closed ApplicationContext which may result in errors. To use @DirtiesContext with \"before test method\" or \"after test method\" modes in conjunction with @TestInstance(PER_CLASS), one must configure dependencies from Spring to be supplied via field or setter injection so that they can be re- injected between test method invocations. In the following example, Spring injects the OrderService bean from the ApplicationContext loaded 608", "chunk_char_count": 1242, "chunk_word_count": 175, "chunk_token_count": 310.5}, {"page_number": 609, "sentence_chunk": "from TestConfig.class into the OrderServiceIntegrationTests constructor. Java @SpringJUnitConfig(TestConfig.class) class OrderServiceIntegrationTests { \u00a0  private final OrderService orderService; \u00a0  @Autowired \u00a0  OrderServiceIntegrationTests(OrderService orderService) { \u00a0    this.orderService = orderService; \u00a0  } \u00a0  // tests that use the injected OrderService } Kotlin @SpringJUnitConfig(TestConfig::class) class OrderServiceIntegrationTests @Autowired constructor(private val orderService: OrderService){ \u00a0  // tests that use the injected OrderService } Note that this feature lets test dependencies be final and therefore immutable. If the spring.test.constructor.autowire.mode property is to all (see @TestConstructor), we can omit the declaration of @Autowired on the constructor in the previous example, resulting in the following. Java @SpringJUnitConfig(TestConfig.class) class OrderServiceIntegrationTests { \u00a0  private final OrderService orderService; \u00a0  OrderServiceIntegrationTests(OrderService orderService) { \u00a0    this.orderService = orderService; \u00a0  } \u00a0  // tests that use the injected OrderService } 609", "chunk_char_count": 1119, "chunk_word_count": 140, "chunk_token_count": 279.75}, {"page_number": 610, "sentence_chunk": "Kotlin @SpringJUnitConfig(TestConfig::class) class OrderServiceIntegrationTests(val orderService:OrderService) { \u00a0  // tests that use the injected OrderService } Method Injection If a parameter in a JUnit Jupiter test method or test lifecycle callback method is of type ApplicationContext (or a sub-type thereof) or is annotated or meta-annotated with @Autowired, @Qualifier, or @Value, Spring injects the value for that specific parameter with the corresponding bean from the test\u2019s ApplicationContext. In the following example, Spring injects the OrderService from the ApplicationContext loaded from TestConfig.class into the deleteOrder() test method: Java @SpringJUnitConfig(TestConfig.class) class OrderServiceIntegrationTests { \u00a0  @Test \u00a0  void deleteOrder(@Autowired OrderService orderService) { \u00a0    // use orderService from the test's ApplicationContext \u00a0  } } Kotlin @SpringJUnitConfig(TestConfig::class) class OrderServiceIntegrationTests { \u00a0  @Test \u00a0  fun deleteOrder(@Autowired orderService: OrderService) { \u00a0    // use orderService from the test's ApplicationContext \u00a0  } } Due to the robustness of the ParameterResolver support in JUnit Jupiter, you can also have multiple dependencies injected into a single method, not only from Spring but also from JUnit Jupiter itself or other third-party extensions. The following example shows how to have both Spring and JUnit Jupiter inject dependencies into the placeOrderRepeatedly() test method simultaneously.610", "chunk_char_count": 1473, "chunk_word_count": 201, "chunk_token_count": 368.25}, {"page_number": 611, "sentence_chunk": "Java @SpringJUnitConfig(TestConfig.class) class OrderServiceIntegrationTests { \u00a0  @RepeatedTest(10) \u00a0  void placeOrderRepeatedly(RepetitionInfo repetitionInfo, \u00a0      @Autowired OrderService orderService) { \u00a0    // use orderService from the test's ApplicationContext \u00a0    // and repetitionInfo from JUnit Jupiter \u00a0  } } Kotlin @SpringJUnitConfig(TestConfig::class) class OrderServiceIntegrationTests { \u00a0  @RepeatedTest(10) \u00a0  fun placeOrderRepeatedly(repetitionInfo:RepetitionInfo, @Autowired orderService:OrderService) { \u00a0    // use orderService from the test's ApplicationContext \u00a0    // and repetitionInfo from JUnit Jupiter \u00a0  } } Note that the use of @RepeatedTest from JUnit Jupiter lets the test method gain access to the RepetitionInfo.@Nested test class configuration The Spring TestContext Framework has supported the use of test-related annotations on @Nested test classes in JUnit Jupiter since Spring Framework 5.0; however, until Spring Framework 5.3 class- level test configuration annotations were not inherited from enclosing classes like they are from superclasses. Spring Framework 5.3 introduces first-class support for inheriting test class configuration from enclosing classes, and such configuration will be inherited by default. To change from the default INHERIT mode to OVERRIDE mode, you may annotate an individual @Nested test class with @NestedTestConfiguration(EnclosingConfiguration. OVERRIDE). An explicit @NestedTestConfiguration declaration will apply to the annotated test class as well as any of its subclasses and nested classes. Thus, you may annotate a top-level test class with @NestedTestConfiguration, and that will apply to all of its nested test classes recursively. In order to allow development teams to change the default to OVERRIDE \u2013 for example, for compatibility with Spring Framework 5.0 through 5.2 \u2013 the default mode can be changed globally via a JVM system property or a spring.properties file in the root of the classpath. See the \"Changing 611", "chunk_char_count": 2000, "chunk_word_count": 288, "chunk_token_count": 500.0}, {"page_number": 612, "sentence_chunk": "the default enclosing configuration inheritance mode\" note for details. Although the following \"Hello World\" example is very simplistic, it shows how to declare common configuration on a top-level class that is inherited by its @Nested test classes. In this particular example, only the TestConfig configuration class is inherited. Each nested test class provides its own set of active profiles, resulting in a distinct ApplicationContext for each nested test class (see Context Caching for details). Consult the list of supported annotations to see which annotations can be inherited in @Nested test classes. Java @SpringJUnitConfig(TestConfig.class) class GreetingServiceTests { \u00a0  @Nested \u00a0  @ActiveProfiles(\"lang_en\") \u00a0  class EnglishGreetings { \u00a0    @Test \u00a0    void hello(@Autowired GreetingService service) { \u00a0      assertThat(service.greetWorld()).isEqualTo(\"Hello World\"); \u00a0    } \u00a0  } \u00a0  @Nested \u00a0  @ActiveProfiles(\"lang_de\") \u00a0  class GermanGreetings { \u00a0    @Test \u00a0    void hello(@Autowired GreetingService service) { \u00a0      assertThat(service.greetWorld()).isEqualTo(\"Hallo Welt\"); \u00a0    } \u00a0  } } 612", "chunk_char_count": 1108, "chunk_word_count": 180, "chunk_token_count": 277.0}, {"page_number": 613, "sentence_chunk": "Kotlin @SpringJUnitConfig(TestConfig::class) class GreetingServiceTests { \u00a0  @Nested \u00a0  @ActiveProfiles(\"lang_en\") \u00a0  inner class EnglishGreetings { \u00a0    @Test \u00a0    fun hello(@Autowired service:GreetingService) { \u00a0      assertThat(service.greetWorld()).isEqualTo(\"Hello World\") \u00a0    } \u00a0  } \u00a0  @Nested \u00a0  @ActiveProfiles(\"lang_de\") \u00a0  inner class GermanGreetings { \u00a0    @Test \u00a0    fun hello(@Autowired service:GreetingService) { \u00a0      assertThat(service.greetWorld()).isEqualTo(\"Hallo Welt\") \u00a0    } \u00a0  } } TestNG Support Classes The org.springframework.test.context.testng package provides the following support classes for TestNG based test cases: \u2022 AbstractTestNGSpringContextTests \u2022 AbstractTransactionalTestNGSpringContextTests AbstractTestNGSpringContextTests is an abstract base test class that integrates the Spring TestContext Framework with explicit ApplicationContext testing support in a TestNG environment. When you extend AbstractTestNGSpringContextTests, you can access a protected applicationContext instance variable that you can use to perform explicit bean lookups or to test the state of the context as a whole. AbstractTransactionalTestNGSpringContextTests is an abstract transactional extension of AbstractTestNGSpringContextTests that adds some convenience functionality for JDBC access. This class expects a javax.sql. DataSource bean and a PlatformTransactionManager bean to be defined in the ApplicationContext. When you extend AbstractTransactionalTestNGSpringContextTests, you can access a protected jdbcTemplate instance variable that you can use to run SQL statements to query the database. You can use such queries to confirm database state both before and after running database-related application code, and Spring ensures that such queries run in the scope of the same transaction as the application code. When used in conjunction with an ORM tool, be sure to avoid false positives. As mentioned in JDBC Testing Support, 613", "chunk_char_count": 1957, "chunk_word_count": 275, "chunk_token_count": 489.25}, {"page_number": 614, "sentence_chunk": "AbstractTransactionalTestNGSpringContextTests also provides convenience methods that delegate to methods in JdbcTestUtils by using the aforementioned jdbcTemplate. Furthermore, AbstractTransactionalTestNGSpringContextTests provides an executeSqlScript(..) method for running SQL scripts against the configured DataSource.\uf0eb These classes are a convenience for extension. If you do not want your test classes to be tied to a Spring-specific class hierarchy, you can configure your own custom test classes by using @ContextConfiguration, @TestExecutionListeners, and so on and by manually instrumenting your test class with a TestContextManager. See the source code of AbstractTestNGSpringContextTests for an example of how to instrument your test class. Ahead of Time Support for Tests This chapter covers Spring\u2019s Ahead of Time (AOT) support for integration tests using the Spring TestContext Framework. The testing support extends Spring\u2019s core AOT support with the following features. \u2022Build-time detection of all integration tests in the current project that use the TestContext framework to load an ApplicationContext.\u25e6 Provides explicit support for test classes based on JUnit Jupiter and JUnit 4 as well as implicit support for TestNG and other testing frameworks that use Spring\u2019s core testing annotations\u2009\u2014\u2009as long as the tests are run using a JUnit Platform TestEngine that is registered for the current project. \u2022Build-time AOT processing: each unique test ApplicationContext in the current project will be refreshed for AOT processing. \u2022", "chunk_char_count": 1547, "chunk_word_count": 214, "chunk_token_count": 386.75}, {"page_number": 614, "sentence_chunk": "Runtime AOT support: when executing in AOT runtime mode, a Spring integration test will use an AOT-optimized ApplicationContext that participates transparently with the context cache.\uf071 The @ContextHierarchy annotation is currently not supported in AOT mode. To provide test-specific runtime hints for use within a GraalVM native image, you have the following options. \u2022Implement a custom TestRuntimeHintsRegistrar and register it globally via META- INF/spring/aot.factories. \u2022Implement a custom RuntimeHintsRegistrar and register it globally via META- INF/spring/aot.factories or locally on a test class via @ImportRuntimeHints. \u2022Annotate a test class with @Reflective or @RegisterReflectionForBinding. \u2022See Runtime Hints for details on Spring\u2019s core runtime hints and annotation support.\uf0eb The TestRuntimeHintsRegistrar API serves as a companion to the core RuntimeHintsRegistrar API. If you need to register global hints for testing support that are not specific to particular test classes, favor implementing RuntimeHintsRegistrar over the test-specific API.614", "chunk_char_count": 1063, "chunk_word_count": 140, "chunk_token_count": 265.75}, {"page_number": 615, "sentence_chunk": "If you implement a custom ContextLoader, it must implement AotContextLoader in order to provide AOT build-time processing and AOT runtime execution support. Note, however, that all context loader implementations provided by the Spring Framework and Spring Boot already implement AotContextLoader. If you implement a custom TestExecutionListener, it must implement AotTestExecutionListener in order to participate in AOT processing. See the SqlScriptsTestExecutionListener in the spring-test module for an example.3.3.6. WebTestClient WebTestClient is an HTTP client designed for testing server applications. It wraps Spring\u2019s WebClient and uses it to perform requests but exposes a testing facade for verifying responses. WebTestClient can be used to perform end-to-end HTTP tests. It can also be used to test Spring MVC and Spring WebFlux applications without a running server via mock server request and response objects.\uf0eb Kotlin users: See this section related to use of the WebTestClient.", "chunk_char_count": 992, "chunk_word_count": 140, "chunk_token_count": 248.0}, {"page_number": 615, "sentence_chunk": "Setup To set up a WebTestClient you need to choose a server setup to bind to. This can be one of several mock server setup choices or a connection to a live server. Bind to Controller This setup allows you to test specific controller(s) via mock request and response objects, without a running server. For WebFlux applications, use the following which loads infrastructure equivalent to the WebFlux Java config, registers the given controller(s), and creates a WebHandler chain to handle requests: Java WebTestClient client = \u00a0    WebTestClient.bindToController(new TestController()).build(); Kotlin val client = WebTestClient.bindToController(TestController()).build() For Spring MVC, use the following which delegates to the StandaloneMockMvcBuilder to load infrastructure equivalent to the WebMvc Java config, registers the given controller(s), and creates an instance of MockMvc to handle requests: Java WebTestClient client = \u00a0    MockMvcWebTestClient.bindToController(new TestController()).build(); 615", "chunk_char_count": 1008, "chunk_word_count": 140, "chunk_token_count": 252.0}, {"page_number": 616, "sentence_chunk": "Kotlin val client = MockMvcWebTestClient.bindToController(TestController()).build() Bind to ApplicationContext This setup allows you to load Spring configuration with Spring MVC or Spring WebFlux infrastructure and controller declarations and use it to handle requests via mock request and response objects, without a running server. For WebFlux, use the following where the Spring ApplicationContext is passed to WebHttpHandlerBuilder to create the WebHandler chain to handle requests: Java @SpringJUnitConfig(WebConfig.class) \u2460 class MyTests { \u00a0  WebTestClient client; \u00a0  @BeforeEach \u00a0  void setUp(ApplicationContext context) { \u2461 \u00a0    client = WebTestClient.bindToApplicationContext(context).build(); \u2462 \u00a0  } } \u2460 Specify the configuration to load \u2461 Inject the configuration \u2462 Create the WebTestClient Kotlin @SpringJUnitConfig(WebConfig::class) \u2460 class MyTests { \u00a0  lateinit var client: WebTestClient \u00a0  @BeforeEach \u00a0  fun setUp(context: ApplicationContext) { \u2461 \u00a0    client = WebTestClient.bindToApplicationContext(context).build() \u2462 \u00a0  } } \u2460 Specify the configuration to load \u2461 Inject the configuration \u2462 Create the WebTestClient For Spring MVC, use the following where the Spring ApplicationContext is passed to 616", "chunk_char_count": 1218, "chunk_word_count": 171, "chunk_token_count": 304.5}, {"page_number": 617, "sentence_chunk": "MockMvcBuilders.webAppContextSetup to create a MockMvc instance to handle requests: Java @ExtendWith(SpringExtension.class) @WebAppConfiguration(\"classpath:META-INF/web-resources\") \u2460 @ContextHierarchy({ \u00a0  @ContextConfiguration(classes = RootConfig.class), \u00a0  @ContextConfiguration(classes = WebConfig.class) }) class MyTests { \u00a0  @Autowired \u00a0  WebApplicationContext wac; \u2461 \u00a0  WebTestClient client; \u00a0  @BeforeEach \u00a0  void setUp() { \u00a0    client = MockMvcWebTestClient.bindToApplicationContext(this.wac).build(); \u2462 \u00a0  } } \u2460 Specify the configuration to load \u2461 Inject the configuration \u2462 Create the WebTestClient Kotlin @ExtendWith(SpringExtension.class) @WebAppConfiguration(\"classpath:META-INF/web-resources\") \u2460 @ContextHierarchy({ \u00a0  @ContextConfiguration(classes = RootConfig.class), \u00a0  @ContextConfiguration(classes = WebConfig.class) }) class MyTests { \u00a0  @Autowired \u00a0  lateinit var wac: WebApplicationContext; \u2461 \u00a0  lateinit var client: WebTestClient \u00a0  @BeforeEach \u00a0  fun setUp() { \u2461 \u00a0    client = MockMvcWebTestClient.bindToApplicationContext(wac).build() \u2462 \u00a0  } } \u2460 Specify the configuration to load 617", "chunk_char_count": 1109, "chunk_word_count": 137, "chunk_token_count": 277.25}, {"page_number": 618, "sentence_chunk": "\u2461 Inject the configuration \u2462 Create the WebTestClient Bind to Router Function This setup allows you to test functional endpoints via mock request and response objects, without a running server. For WebFlux, use the following which delegates to RouterFunctions.toWebHandler to create a server setup to handle requests: Java RouterFunction<?> route = ... client = WebTestClient.bindToRouterFunction(route).build(); Kotlin val route: RouterFunction<*> = ... val client = WebTestClient.bindToRouterFunction(route).build() For Spring MVC there are currently no options to test WebMvc functional endpoints. Bind to Server This setup connects to a running server to perform full, end-to-end HTTP tests: Java client = WebTestClient.bindToServer().baseUrl(\"http://localhost:8080\").build(); Kotlin client = WebTestClient.bindToServer().baseUrl(\"http://localhost:8080\").build() Client Config In addition to the server setup options described earlier, you can also configure client options, including base URL, default headers, client filters, and others. These options are readily available following bindToServer(). For all other configuration options, you need to use configureClient() to transition from server to client configuration, as follows: Java client = WebTestClient.bindToController(new TestController()) \u00a0    .configureClient() \u00a0    .baseUrl(\"/test\") \u00a0    .build(); 618", "chunk_char_count": 1372, "chunk_word_count": 175, "chunk_token_count": 343.0}, {"page_number": 619, "sentence_chunk": "Kotlin client = WebTestClient.bindToController(TestController()) \u00a0    .configureClient() \u00a0    .baseUrl(\"/test\") \u00a0    .build() Writing Tests WebTestClient provides an API identical to WebClient up to the point of performing a request by using exchange(). See the WebClient documentation for examples on how to prepare a request with any content including form data, multipart data, and more. After the call to exchange(), WebTestClient diverges from the WebClient and instead continues with a workflow to verify responses. To assert the response status and headers, use the following: Java client.get().uri(\"/persons/1\") \u00a0  .accept(MediaType. APPLICATION_JSON) \u00a0  .exchange() \u00a0  .expectStatus().isOk() \u00a0  .expectHeader().contentType(MediaType. APPLICATION_JSON); Kotlin client.get().uri(\"/persons/1\") \u00a0  .accept(MediaType. APPLICATION_JSON) \u00a0  .exchange() \u00a0  .expectStatus().isOk() \u00a0  .expectHeader().contentType(MediaType. APPLICATION_JSON) If you would like for all expectations to be asserted even if one of them fails, you can use expectAll(..) instead of multiple chained expect*(..) calls. This feature is similar to the soft assertions support in AssertJ and the assertAll() support in JUnit Jupiter. Java client.get().uri(\"/persons/1\") \u00a0  .accept(MediaType.", "chunk_char_count": 1264, "chunk_word_count": 171, "chunk_token_count": 316.0}, {"page_number": 619, "sentence_chunk": "APPLICATION_JSON) \u00a0  .exchange() \u00a0  .expectAll( \u00a0    spec -> spec.expectStatus().isOk(), \u00a0    spec -> spec.expectHeader().contentType(MediaType. APPLICATION_JSON) \u00a0  ); You can then choose to decode the response body through one of the following: 619", "chunk_char_count": 250, "chunk_word_count": 40, "chunk_token_count": 62.5}, {"page_number": 620, "sentence_chunk": "\u2022 expectBody(Class<T>): Decode to single object. \u2022expectBodyList(Class<T>): Decode and collect objects to List<T>. \u2022expectBody(): Decode to byte[] for JSON Content or an empty body. And perform assertions on the resulting higher level Object(s): Java client.get().uri(\"/persons\") \u00a0    .exchange() \u00a0    .expectStatus().isOk() \u00a0    .expectBodyList(Person.class).hasSize(3).contains(person); Kotlin import org.springframework.test.web.reactive.server.expectBodyList client.get().uri(\"/persons\") \u00a0    .exchange() \u00a0    .expectStatus().isOk() \u00a0    .expectBodyList<Person>().hasSize(3).contains(person) If the built-in assertions are insufficient, you can consume the object instead and perform any other assertions: Java import org.springframework.test.web.reactive.server.expectBody client.get().uri(\"/persons/1\") \u00a0    .exchange() \u00a0    .expectStatus().isOk() \u00a0    .expectBody(Person.class) \u00a0    .consumeWith(result -> { \u00a0      // custom assertions (e.g. AssertJ)... \u00a0    }); Kotlin client.get().uri(\"/persons/1\") \u00a0    .exchange() \u00a0    .expectStatus().isOk() \u00a0    .expectBody<Person>() \u00a0    .consumeWith { \u00a0      // custom assertions (e.g. AssertJ)... \u00a0    } Or you can exit the workflow and obtain an EntityExchangeResult: 620", "chunk_char_count": 1221, "chunk_word_count": 178, "chunk_token_count": 305.25}, {"page_number": 621, "sentence_chunk": "Java EntityExchangeResult<Person> result = client.get().uri(\"/persons/1\") \u00a0    .exchange() \u00a0    .expectStatus().isOk() \u00a0    .expectBody(Person.class) \u00a0    .returnResult(); Kotlin import org.springframework.test.web.reactive.server.expectBody val result = client.get().uri(\"/persons/1\") \u00a0    .exchange() \u00a0    .expectStatus().isOk \u00a0    .expectBody<Person>() \u00a0    .returnResult() \uf0eb When you need to decode to a target type with generics, look for the overloaded methods that accept ParameterizedTypeReference instead of Class<T>. No Content If the response is not expected to have content, you can assert that as follows: Java client.post().uri(\"/persons\") \u00a0    .body(personMono, Person.class) \u00a0    .exchange() \u00a0    .expectStatus().isCreated() \u00a0    .expectBody().isEmpty(); Kotlin client.post().uri(\"/persons\") \u00a0    .bodyValue(person) \u00a0    .exchange() \u00a0    .expectStatus().isCreated() \u00a0    .expectBody().isEmpty() If you want to ignore the response content, the following releases the content without any assertions: 621", "chunk_char_count": 1017, "chunk_word_count": 154, "chunk_token_count": 254.25}, {"page_number": 622, "sentence_chunk": "Java client.get().uri(\"/persons/123\") \u00a0    .exchange() \u00a0    .expectStatus().isNotFound() \u00a0    .expectBody(Void.class); Kotlin client.get().uri(\"/persons/123\") \u00a0    .exchange() \u00a0    .expectStatus().isNotFound \u00a0    .expectBody<Unit>() JSON Content You can use expectBody() without a target type to perform assertions on the raw content rather than through higher level Object(s). To verify the full JSON content with JSONAssert: Java client.get().uri(\"/persons/1\") \u00a0    .exchange() \u00a0    .expectStatus().isOk() \u00a0    .expectBody() \u00a0    .json(\"{\\\"name\\\":\\\"Jane\\\"}\") Kotlin client.get().uri(\"/persons/1\") \u00a0    .exchange() \u00a0    .expectStatus().isOk() \u00a0    .expectBody() \u00a0    .json(\"{\\\"name\\\":\\\"Jane\\\"}\") To verify JSON content with JSONPath: Java client.get().uri(\"/persons\") \u00a0    .exchange() \u00a0    .expectStatus().isOk() \u00a0    .expectBody() \u00a0    .jsonPath(\"$[0].name\").isEqualTo(\"Jane\") \u00a0    .jsonPath(\"$[1].name\").isEqualTo(\"Jason\"); 622", "chunk_char_count": 930, "chunk_word_count": 143, "chunk_token_count": 232.5}, {"page_number": 623, "sentence_chunk": "Kotlin client.get().uri(\"/persons\") \u00a0    .exchange() \u00a0    .expectStatus().isOk() \u00a0    .expectBody() \u00a0    .jsonPath(\"$[0].name\").isEqualTo(\"Jane\") \u00a0    .jsonPath(\"$[1].name\").isEqualTo(\"Jason\") Streaming Responses To test potentially infinite streams such as \"text/event-stream\" or \"application/x-ndjson\", start by verifying the response status and headers, and then obtain a FluxExchangeResult: Java FluxExchangeResult<MyEvent> result = client.get().uri(\"/events\") \u00a0    .accept(TEXT_EVENT_STREAM) \u00a0    .exchange() \u00a0    .expectStatus().isOk() \u00a0    .returnResult(MyEvent.class); Kotlin import org.springframework.test.web.reactive.server.returnResult val result = client.get().uri(\"/events\") \u00a0    .accept(TEXT_EVENT_STREAM) \u00a0    .exchange() \u00a0    .expectStatus().isOk() \u00a0    .returnResult<MyEvent>() Now you\u2019re ready to consume the response stream with StepVerifier from reactor-test: Java Flux<Event> eventFlux = result.getResponseBody(); StepVerifier.create(eventFlux) \u00a0    .expectNext(person) \u00a0    .expectNextCount(4) \u00a0    .consumeNextWith(p -> ...) \u00a0    .thenCancel() \u00a0    .verify(); 623", "chunk_char_count": 1088, "chunk_word_count": 150, "chunk_token_count": 272.0}, {"page_number": 624, "sentence_chunk": "Kotlin val eventFlux = result.getResponseBody() StepVerifier.create(eventFlux) \u00a0    .expectNext(person) \u00a0    .expectNextCount(4) \u00a0    .consumeNextWith { p -> ... } \u00a0    .thenCancel() \u00a0    .verify() MockMvc Assertions WebTestClient is an HTTP client and as such it can only verify what is in the client response including status, headers, and body. When testing a Spring MVC application with a MockMvc server setup, you have the extra choice to perform further assertions on the server response. To do that start by obtaining an ExchangeResult after asserting the body: Java // For a response with a body EntityExchangeResult<Person> result = client.get().uri(\"/persons/1\") \u00a0    .exchange() \u00a0    .expectStatus().isOk() \u00a0    .expectBody(Person.class) \u00a0    .returnResult(); // For a response without a body EntityExchangeResult<Void> result = client.get().uri(\"/path\") \u00a0    .exchange() \u00a0    .expectBody().isEmpty(); Kotlin // For a response with a body val result = client.get().uri(\"/persons/1\") \u00a0    .exchange() \u00a0    .expectStatus().isOk() \u00a0    .expectBody(Person.class) \u00a0    .returnResult(); // For a response without a body val result = client.get().uri(\"/path\") \u00a0    .exchange() \u00a0    .expectBody().isEmpty(); Then switch to MockMvc server response assertions: 624", "chunk_char_count": 1265, "chunk_word_count": 211, "chunk_token_count": 316.25}, {"page_number": 625, "sentence_chunk": "Java MockMvcWebTestClient.resultActionsFor(result) \u00a0    .andExpect(model().attribute(\"integer\", 3)) \u00a0    .andExpect(model().attribute(\"string\", \"a string value\")); Kotlin MockMvcWebTestClient.resultActionsFor(result) \u00a0    .andExpect(model().attribute(\"integer\", 3)) \u00a0    .andExpect(model().attribute(\"string\", \"a string value\")); 3.3.7. MockMvc The Spring MVC Test framework, also known as MockMvc, provides support for testing Spring MVC applications. It performs full Spring MVC request handling but via mock request and response objects instead of a running server. MockMvc can be used on its own to perform requests and verify responses. It can also be used through the WebTestClient where MockMvc is plugged in as the server to handle requests with. The advantage of WebTestClient is the option to work with higher level objects instead of raw data as well as the ability to switch to full, end-to-end HTTP tests against a live server and use the same test API. Overview You can write plain unit tests for Spring MVC by instantiating a controller, injecting it with dependencies, and calling its methods. However such tests do not verify request mappings, data binding, message conversion, type conversion, validation, and nor do they involve any of the supporting @InitBinder, @ModelAttribute, or @ExceptionHandler methods. The Spring MVC Test framework, also known as MockMvc, aims to provide more complete testing for Spring MVC controllers without a running server. It does that by invoking the DispatcherServlet and passing \u201cmock\u201d implementations of the Servlet API from the spring-test module which replicates the full Spring MVC request handling without a running server.", "chunk_char_count": 1683, "chunk_word_count": 246, "chunk_token_count": 420.75}, {"page_number": 625, "sentence_chunk": "MockMvc is a server side test framework that lets you verify most of the functionality of a Spring MVC application using lightweight and targeted tests. You can use it on its own to perform requests and to verify responses, or you can also use it through the WebTestClient API with MockMvc plugged in as the server to handle requests with. Static Imports When using MockMvc directly to perform requests, you\u2019ll need static imports for: \u2022 MockMvcBuilders.* \u2022MockMvcRequestBuilders.* \u2022MockMvcResultMatchers.*625", "chunk_char_count": 509, "chunk_word_count": 78, "chunk_token_count": 127.25}, {"page_number": 626, "sentence_chunk": "\u2022 MockMvcResultHandlers.*An easy way to remember that is search for MockMvc*. If using Eclipse be sure to also add the above as \u201cfavorite static members\u201d in the Eclipse preferences. When using MockMvc through the WebTestClient you do not need static imports. The WebTestClient provides a fluent API without static imports. Setup Choices MockMvc can be setup in one of two ways. One is to point directly to the controllers you want to test and programmatically configure Spring MVC infrastructure. The second is to point to Spring configuration with Spring MVC and controller infrastructure in it. To set up MockMvc for testing a specific controller, use the following: Java class MyWebTests { \u00a0  MockMvc mockMvc; \u00a0  @BeforeEach \u00a0  void setup() { \u00a0    this.mockMvc = MockMvcBuilders.standaloneSetup(new AccountController()).build(); \u00a0  } \u00a0  // ... } Kotlin class MyWebTests { \u00a0  lateinit var mockMvc : MockMvc \u00a0  @BeforeEach \u00a0  fun setup() { \u00a0    mockMvc = MockMvcBuilders.standaloneSetup(AccountController()).build() \u00a0  } \u00a0  // ... } Or you can also use this setup when testing through the WebTestClient which delegates to the same builder as shown above.626", "chunk_char_count": 1158, "chunk_word_count": 194, "chunk_token_count": 289.5}, {"page_number": 627, "sentence_chunk": "To set up MockMvc through Spring configuration, use the following: Java @SpringJUnitWebConfig(locations = \"my-servlet-context.xml\") class MyWebTests { \u00a0  MockMvc mockMvc; \u00a0  @BeforeEach \u00a0  void setup(WebApplicationContext wac) { \u00a0    this.mockMvc = MockMvcBuilders.webAppContextSetup(wac).build(); \u00a0  } \u00a0  // ... } Kotlin @SpringJUnitWebConfig(locations = [\"my-servlet-context.xml\"]) class MyWebTests { \u00a0  lateinit var mockMvc: MockMvc \u00a0  @BeforeEach \u00a0  fun setup(wac: WebApplicationContext) { \u00a0    mockMvc = MockMvcBuilders.webAppContextSetup(wac).build() \u00a0  } \u00a0  // ... } Or you can also use this setup when testing through the WebTestClient which delegates to the same builder as shown above. Which setup option should you use?The webAppContextSetup loads your actual Spring MVC configuration, resulting in a more complete integration test. Since the TestContext framework caches the loaded Spring configuration, it helps keep tests running fast, even as you introduce more tests in your test suite. Furthermore, you can inject mock services into controllers through Spring configuration to remain focused on testing the web layer. The following example declares a mock service with Mockito: <bean id=\"accountService\" class=\"org.mockito. Mockito\" factory-method=\"mock\"> \u00a0  <constructor-arg value=\"org.example. AccountService\"/> </bean> 627", "chunk_char_count": 1342, "chunk_word_count": 188, "chunk_token_count": 335.5}, {"page_number": 628, "sentence_chunk": "You can then inject the mock service into the test to set up and verify your expectations, as the following example shows: Java @SpringJUnitWebConfig(locations = \"test-servlet-context.xml\") class AccountTests { \u00a0  @Autowired \u00a0  AccountService accountService; \u00a0  MockMvc mockMvc; \u00a0  @BeforeEach \u00a0  void setup(WebApplicationContext wac) { \u00a0    this.mockMvc = MockMvcBuilders.webAppContextSetup(wac).build(); \u00a0  } \u00a0  // ... } Kotlin @SpringJUnitWebConfig(locations = [\"test-servlet-context.xml\"]) class AccountTests { \u00a0  @Autowired \u00a0  lateinit var accountService: AccountService \u00a0  lateinit mockMvc: MockMvc \u00a0  @BeforeEach \u00a0  fun setup(wac: WebApplicationContext) { \u00a0    mockMvc = MockMvcBuilders.webAppContextSetup(wac).build() \u00a0  } \u00a0  // ... } The standaloneSetup, on the other hand, is a little closer to a unit test. It tests one controller at a time. You can manually inject the controller with mock dependencies, and it does not involve loading Spring configuration. Such tests are more focused on style and make it easier to see which controller is being tested, whether any specific Spring MVC configuration is required to work, and so on. The standaloneSetup is also a very convenient way to write ad-hoc tests to verify specific behavior or to debug an issue. As with most \u201cintegration versus unit testing\u201d debates, there is no right or wrong answer. However, 628", "chunk_char_count": 1370, "chunk_word_count": 216, "chunk_token_count": 342.5}, {"page_number": 629, "sentence_chunk": "using the standaloneSetup does imply the need for additional webAppContextSetup tests in order to verify your Spring MVC configuration. Alternatively, you can write all your tests with webAppContextSetup, in order to always test against your actual Spring MVC configuration. Setup Features No matter which MockMvc builder you use, all MockMvcBuilder implementations provide some common and very useful features. For example, you can declare an Accept header for all requests and expect a status of 200 as well as a Content-Type header in all responses, as follows: Java // static import of MockMvcBuilders.standaloneSetup MockMvc mockMvc = standaloneSetup(new MusicController()) \u00a0  .defaultRequest(get(\"/\").accept(MediaType. APPLICATION_JSON)) \u00a0  .alwaysExpect(status().isOk()) \u00a0  .alwaysExpect(content().contentType(\"application/json;charset=UTF-8\")) \u00a0  .build(); Kotlin // Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed In addition, third-party frameworks (and applications) can pre-package setup instructions, such as those in a MockMvcConfigurer. The Spring Framework has one such built-in implementation that helps to save and re-use the HTTP session across requests. You can use it as follows: Java // static import of SharedHttpSessionConfigurer.sharedHttpSession MockMvc mockMvc = MockMvcBuilders.standaloneSetup(new TestController()) \u00a0    .apply(sharedHttpSession()) \u00a0    .build(); // Use mockMvc to perform requests... Kotlin // Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed See the javadoc for ConfigurableMockMvcBuilder for a list of all MockMvc builder features or use the IDE to explore the available options. Performing Requests This section shows how to use MockMvc on its own to perform requests and verify responses. If using MockMvc through the WebTestClient please see the corresponding section on Writing Tests 629", "chunk_char_count": 1910, "chunk_word_count": 253, "chunk_token_count": 477.5}, {"page_number": 630, "sentence_chunk": "instead. To perform requests that use any HTTP method, as the following example shows: Java // static import of MockMvcRequestBuilders.*mockMvc.perform(post(\"/hotels/{id}\", 42).accept(MediaType. APPLICATION_JSON)); Kotlin import org.springframework.test.web.servlet.post mockMvc.post(\"/hotels/{id}\", 42) { \u00a0  accept = MediaType. APPLICATION_JSON } You can also perform file upload requests that internally use MockMultipartHttpServletRequest so that there is no actual parsing of a multipart request. Rather, you have to set it up to be similar to the following example: Java mockMvc.perform(multipart(\"/doc\").file(\"a1\", \"ABC\".getBytes(\"UTF-8\"))); Kotlin import org.springframework.test.web.servlet.multipart mockMvc.multipart(\"/doc\") { \u00a0  file(\"a1\", \"ABC\".toByteArray(charset(\"UTF8\"))) } You can specify query parameters in URI template style, as the following example shows: Java mockMvc.perform(get(\"/hotels?thing={thing}\", \"somewhere\")); Kotlin mockMvc.get(\"/hotels?thing={thing}\", \"somewhere\") You can also add Servlet request parameters that represent either query or form parameters, as the following example shows: 630", "chunk_char_count": 1126, "chunk_word_count": 124, "chunk_token_count": 281.5}, {"page_number": 631, "sentence_chunk": "Java mockMvc.perform(get(\"/hotels\").param(\"thing\", \"somewhere\")); Kotlin import org.springframework.test.web.servlet.get mockMvc.get(\"/hotels\") { \u00a0  param(\"thing\", \"somewhere\") } If application code relies on Servlet request parameters and does not check the query string explicitly (as is most often the case), it does not matter which option you use. Keep in mind, however, that query parameters provided with the URI template are decoded while request parameters provided through the param(\u2026) method are expected to already be decoded. In most cases, it is preferable to leave the context path and the Servlet path out of the request URI. If you must test with the full request URI, be sure to set the contextPath and servletPath accordingly so that request mappings work, as the following example shows: Java mockMvc.perform(get(\"/app/main/hotels/{id}\").contextPath(\"/app\").servletPath(\"/main\")) Kotlin import org.springframework.test.web.servlet.get mockMvc.get(\"/app/main/hotels/{id}\") { \u00a0  contextPath = \"/app\" \u00a0  servletPath = \"/main\" } In the preceding example, it would be cumbersome to set the contextPath and servletPath with every performed request. Instead, you can set up default request properties, as the following example shows: 631", "chunk_char_count": 1250, "chunk_word_count": 169, "chunk_token_count": 312.5}, {"page_number": 632, "sentence_chunk": "Java class MyWebTests { \u00a0  MockMvc mockMvc; \u00a0  @BeforeEach \u00a0  void setup() { \u00a0    mockMvc = standaloneSetup(new AccountController()) \u00a0      .defaultRequest(get(\"/\") \u00a0      .contextPath(\"/app\").servletPath(\"/main\") \u00a0      .accept(MediaType. APPLICATION_JSON)).build(); \u00a0  } } Kotlin // Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed The preceding properties affect every request performed through the MockMvc instance. If the same property is also specified on a given request, it overrides the default value. That is why the HTTP method and URI in the default request do not matter, since they must be specified on every request. Defining Expectations You can define expectations by appending one or more andExpect(..) calls after performing a request, as the following example shows. As soon as one expectation fails, no other expectations will be asserted. Java // static import of MockMvcRequestBuilders.*and MockMvcResultMatchers.*mockMvc.perform(get(\"/accounts/1\")).andExpect(status().isOk()); Kotlin import org.springframework.test.web.servlet.get mockMvc.get(\"/accounts/1\").andExpect { \u00a0  status { isOk() } } You can define multiple expectations by appending andExpectAll(..) after performing a request, as the following example shows. In contrast to andExpect(..), andExpectAll(..) guarantees that all supplied expectations will be asserted and that all failures will be tracked and reported.", "chunk_char_count": 1437, "chunk_word_count": 202, "chunk_token_count": 359.25}, {"page_number": 633, "sentence_chunk": "Java // static import of MockMvcRequestBuilders.*and MockMvcResultMatchers.*mockMvc.perform(get(\"/accounts/1\")).andExpectAll( \u00a0  status().isOk(), \u00a0  content().contentType(\"application/json;charset=UTF-8\")); MockMvcResultMatchers.*provides a number of expectations, some of which are further nested with more detailed expectations. Expectations fall in two general categories. The first category of assertions verifies properties of the response (for example, the response status, headers, and content). These are the most important results to assert. The second category of assertions goes beyond the response. These assertions let you inspect Spring MVC specific aspects, such as which controller method processed the request, whether an exception was raised and handled, what the content of the model is, what view was selected, what flash attributes were added, and so on. They also let you inspect Servlet specific aspects, such as request and session attributes.", "chunk_char_count": 967, "chunk_word_count": 126, "chunk_token_count": 241.75}, {"page_number": 633, "sentence_chunk": "The following test asserts that binding or validation failed: Java mockMvc.perform(post(\"/persons\")) \u00a0  .andExpect(status().isOk()) \u00a0  .andExpect(model().attributeHasErrors(\"person\")); Kotlin import org.springframework.test.web.servlet.post mockMvc.post(\"/persons\").andExpect { \u00a0  status { isOk() } \u00a0  model { \u00a0    attributeHasErrors(\"person\") \u00a0  } } Many times, when writing tests, it is useful to dump the results of the performed request. You can do so as follows, where print() is a static import from MockMvcResultHandlers: 633", "chunk_char_count": 532, "chunk_word_count": 72, "chunk_token_count": 133.0}, {"page_number": 634, "sentence_chunk": "Java mockMvc.perform(post(\"/persons\")) \u00a0  .andDo(print()) \u00a0  .andExpect(status().isOk()) \u00a0  .andExpect(model().attributeHasErrors(\"person\")); Kotlin import org.springframework.test.web.servlet.post mockMvc.post(\"/persons\").andDo { \u00a0    print() \u00a0  }.andExpect { \u00a0    status { isOk() } \u00a0    model { \u00a0      attributeHasErrors(\"person\") \u00a0    } \u00a0  } As long as request processing does not cause an unhandled exception, the print() method prints all the available result data to System.out. There is also a log() method and two additional variants of the print() method, one that accepts an OutputStream and one that accepts a Writer. For example, invoking print(System.err) prints the result data to System.err, while invoking print(myWriter) prints the result data to a custom writer. If you want to have the result data logged instead of printed, you can invoke the log() method, which logs the result data as a single DEBUG message under the org.springframework.test.web.servlet.result logging category. In some cases, you may want to get direct access to the result and verify something that cannot be verified otherwise. This can be achieved by appending .andReturn() after all other expectations, as the following example shows: Java MvcResult mvcResult = mockMvc.perform(post(\"/persons\")).andExpect(status().isOk()).andReturn(); // ... Kotlin var mvcResult = mockMvc.post(\"/persons\").andExpect { status { isOk() } }.andReturn() // ... If all tests repeat the same expectations, you can set up common expectations once when building the MockMvc instance, as the following example shows: 634", "chunk_char_count": 1591, "chunk_word_count": 237, "chunk_token_count": 397.75}, {"page_number": 635, "sentence_chunk": "Java standaloneSetup(new SimpleController()) \u00a0  .alwaysExpect(status().isOk()) \u00a0  .alwaysExpect(content().contentType(\"application/json;charset=UTF-8\")) \u00a0  .build() Kotlin // Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed Note that common expectations are always applied and cannot be overridden without creating a separate MockMvc instance. When a JSON response content contains hypermedia links created with Spring HATEOAS, you can verify the resulting links by using JsonPath expressions, as the following example shows: Java mockMvc.perform(get(\"/people\").accept(MediaType. APPLICATION_JSON)) \u00a0  .andExpect(jsonPath(\"$.links[?(@.rel == 'self')].href\").value(\"http://localhost:8080/people\")); Kotlin mockMvc.get(\"/people\") { \u00a0  accept(MediaType. APPLICATION_JSON) }.andExpect { \u00a0  jsonPath(\"$.links[?(@.rel == 'self')].href\") { \u00a0    value(\"http://localhost:8080/people\") \u00a0  } } When XML response content contains hypermedia links created with Spring HATEOAS, you can verify the resulting links by using XPath expressions: Java Map<String, String> ns = Collections.singletonMap(\"ns\", \"http://www.w3.org/2005/Atom\"); mockMvc.perform(get(\"/handle\").accept(MediaType. APPLICATION_XML)) \u00a0  .andExpect(xpath(\"/person/ns:link[@rel='self']/@href\", ns).string(\"http://localhost:8080/people\")); 635", "chunk_char_count": 1328, "chunk_word_count": 133, "chunk_token_count": 332.0}, {"page_number": 636, "sentence_chunk": "Kotlin val ns = mapOf(\"ns\" to \"http://www.w3.org/2005/Atom\") mockMvc.get(\"/handle\") { \u00a0  accept(MediaType. APPLICATION_XML) }.andExpect { \u00a0  xpath(\"/person/ns:link[@rel='self']/@href\", ns) { \u00a0    string(\"http://localhost:8080/people\") \u00a0  } } Async Requests This section shows how to use MockMvc on its own to test asynchronous request handling. If using MockMvc through the WebTestClient, there is nothing special to do to make asynchronous requests work as the WebTestClient automatically does what is described in this section. Servlet asynchronous requests, supported in Spring MVC, work by exiting the Servlet container thread and allowing the application to compute the response asynchronously, after which an async dispatch is made to complete processing on a Servlet container thread. In Spring MVC Test, async requests can be tested by asserting the produced async value first, then manually performing the async dispatch, and finally verifying the response. Below is an example test for controller methods that return DeferredResult, Callable, or reactive type such as Reactor Mono: Java // static import of MockMvcRequestBuilders.*and MockMvcResultMatchers.*@Test void test() throws Exception { \u00a0  MvcResult mvcResult = this.mockMvc.perform(get(\"/path\")) \u00a0      .andExpect(status().isOk()) \u2460 \u00a0      .andExpect(request().asyncStarted()) \u2461 \u00a0      .andExpect(request().asyncResult(\"body\")) \u2462 \u00a0      .andReturn(); \u00a0  this.mockMvc.perform(asyncDispatch(mvcResult)) \u2463 \u00a0      .andExpect(status().isOk()) \u2464 \u00a0      .andExpect(content().string(\"body\")); } \u2460 Check response status is still unchanged \u2461 Async processing must have started \u2462 Wait and assert the async result \u2463 Manually perform an ASYNC dispatch (as there is no running container) \u2464 Verify the final response 636", "chunk_char_count": 1774, "chunk_word_count": 265, "chunk_token_count": 443.5}, {"page_number": 637, "sentence_chunk": "Kotlin @Test fun test() { \u00a0  var mvcResult = mockMvc.get(\"/path\").andExpect { \u00a0    status { isOk() } \u2460 \u00a0    request { asyncStarted() } \u2461 \u00a0    // TODO Remove unused generic parameter \u00a0    request { asyncResult<Nothing>(\"body\") } \u2462 \u00a0  }.andReturn() \u00a0  mockMvc.perform(asyncDispatch(mvcResult)) \u2463 \u00a0      .andExpect { \u00a0        status { isOk() } \u2464 \u00a0        content().string(\"body\") \u00a0      } } \u2460 Check response status is still unchanged \u2461 Async processing must have started \u2462 Wait and assert the async result \u2463 Manually perform an ASYNC dispatch (as there is no running container) \u2464 Verify the final response Streaming Responses The best way to test streaming responses such as Server-Sent Events is through the WebTestClient which can be used as a test client to connect to a MockMvc instance to perform tests on Spring MVC controllers without a running server. For example: 637", "chunk_char_count": 873, "chunk_word_count": 176, "chunk_token_count": 218.25}, {"page_number": 638, "sentence_chunk": "Java WebTestClient client = MockMvcWebTestClient.bindToController(new SseController()).build(); FluxExchangeResult<Person> exchangeResult = client.get() \u00a0    .uri(\"/persons\") \u00a0    .exchange() \u00a0    .expectStatus().isOk() \u00a0    .expectHeader().contentType(\"text/event-stream\") \u00a0    .returnResult(Person.class); // Use StepVerifier from Project Reactor to test the streaming response StepVerifier.create(exchangeResult.getResponseBody()) \u00a0    .expectNext(new Person(\"N0\"), new Person(\"N1\"), new Person(\"N2\")) \u00a0    .expectNextCount(4) \u00a0    .consumeNextWith(person -> assertThat(person.getName()).endsWith(\"7\")) \u00a0    .thenCancel() \u00a0    .verify(); WebTestClient can also connect to a live server and perform full end-to-end integration tests. This is also supported in Spring Boot where you can test a running server. Filter Registrations When setting up a MockMvc instance, you can register one or more Servlet Filter instances, as the following example shows: Java mockMvc = standaloneSetup(new PersonController()).addFilters(new CharacterEncodingFilter()).build(); Kotlin // Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed Registered filters are invoked through the MockFilterChain from spring-test, and the last filter delegates to the DispatcherServlet. MockMvc vs End-to-End Tests MockMVc is built on Servlet API mock implementations from the spring-test module and does not rely on a running container. Therefore, there are some differences when compared to full end-to- end integration tests with an actual client and a live server running. The easiest way to think about this is by starting with a blank MockHttpServletRequest. Whatever you add to it is what the request becomes. Things that may catch you by surprise are that there is 638", "chunk_char_count": 1777, "chunk_word_count": 244, "chunk_token_count": 444.25}, {"page_number": 639, "sentence_chunk": "no context path by default; no jsessionid cookie; no forwarding, error, or async dispatches; and, therefore, no actual JSP rendering. Instead, \u201cforwarded\u201d and \u201credirected\u201d URLs are saved in the MockHttpServletResponse and can be asserted with expectations. This means that, if you use JSPs, you can verify the JSP page to which the request was forwarded, but no HTML is rendered. In other words, the JSP is not invoked. Note, however, that all other rendering technologies that do not rely on forwarding, such as Thymeleaf and Freemarker, render HTML to the response body as expected. The same is true for rendering JSON, XML, and other formats through @ResponseBody methods. Alternatively, you may consider the full end-to-end integration testing support from Spring Boot with @SpringBootTest. See the Spring Boot Reference Guide. There are pros and cons for each approach. The options provided in Spring MVC Test are different stops on the scale from classic unit testing to full integration testing.", "chunk_char_count": 1002, "chunk_word_count": 158, "chunk_token_count": 250.5}, {"page_number": 639, "sentence_chunk": "To be certain, none of the options in Spring MVC Test fall under the category of classic unit testing, but they are a little closer to it. For example, you can isolate the web layer by injecting mocked services into controllers, in which case you are testing the web layer only through the DispatcherServlet but with actual Spring configuration, as you might test the data access layer in isolation from the layers above it. Also, you can use the stand-alone setup, focusing on one controller at a time and manually providing the configuration required to make it work. Another important distinction when using Spring MVC Test is that, conceptually, such tests are the server-side, so you can check what handler was used, if an exception was handled with a HandlerExceptionResolver, what the content of the model is, what binding errors there were, and other details. That means that it is easier to write expectations, since the server is not an opaque box, as it is when testing it through an actual HTTP client. This is generally an advantage of classic unit testing: It is easier to write, reason about, and debug but does not replace the need for full integration tests. At the same time, it is important not to lose sight of the fact that the response is the most important thing to check. In short, there is room here for multiple styles and strategies of testing even within the same project. Further Examples The framework\u2019s own tests include many sample tests intended to show how to use MockMvc on its own or through the WebTestClient. Browse these examples for further ideas.", "chunk_char_count": 1587, "chunk_word_count": 273, "chunk_token_count": 396.75}, {"page_number": 639, "sentence_chunk": "HtmlUnit Integration Spring provides integration between MockMvc and HtmlUnit. This simplifies performing end-to- end testing when using HTML-based views. This integration lets you: \u2022 Easily test HTML pages by using tools such as HtmlUnit, WebDriver, and Geb without the need to deploy to a Servlet container. \u2022Test JavaScript within pages. \u2022Optionally, test using mock services to speed up testing. \u2022Share logic between in-container end-to-end tests and out-of-container integration tests.639", "chunk_char_count": 493, "chunk_word_count": 69, "chunk_token_count": 123.25}, {"page_number": 640, "sentence_chunk": "\uf05a MockMvc works with templating technologies that do not rely on a Servlet Container (for example, Thymeleaf, FreeMarker, and others), but it does not work with JSPs, since they rely on the Servlet container. Why HtmlUnit Integration?The most obvious question that comes to mind is \u201cWhy do I need this?\u201dThe answer is best found by exploring a very basic sample application. Assume you have a Spring MVC web application that supports CRUD operations on a Message object. The application also supports paging through all messages. How would you go about testing it?With Spring MVC Test, we can easily test if we are able to create a Message, as follows: Java MockHttpServletRequestBuilder createMessage = post(\"/messages/\") \u00a0    .param(\"summary\", \"Spring Rocks\") \u00a0    .param(\"text\", \"In case you didn't know, Spring Rocks!\");mockMvc.perform(createMessage) \u00a0    .andExpect(status().is3xxRedirection()) \u00a0    .andExpect(redirectedUrl(\"/messages/123\")); Kotlin @Test fun test() { \u00a0  mockMvc.post(\"/messages/\") { \u00a0    param(\"summary\", \"Spring Rocks\") \u00a0    param(\"text\", \"In case you didn't know, Spring Rocks!\")\u00a0  }.andExpect { \u00a0    status().is3xxRedirection() \u00a0    redirectedUrl(\"/messages/123\") \u00a0  } } What if we want to test the form view that lets us create the message?", "chunk_char_count": 1267, "chunk_word_count": 203, "chunk_token_count": 316.75}, {"page_number": 641, "sentence_chunk": "<form id=\"messageForm\" action=\"/messages/\" method=\"post\"> \u00a0  <div class=\"pull-right\"><a href=\"/messages/\">Messages</a></div> \u00a0  <label for=\"summary\">Summary</label> \u00a0  <input type=\"text\" class=\"required\" id=\"summary\" name=\"summary\" value=\"\" /> \u00a0  <label for=\"text\">Message</label> \u00a0  <textarea id=\"text\" name=\"text\"></textarea> \u00a0  <div class=\"form-actions\"> \u00a0    <input type=\"submit\" value=\"Create\" /> \u00a0  </div> </form> How do we ensure that our form produce the correct request to create a new message?A naive attempt might resemble the following: Java mockMvc.perform(get(\"/messages/form\")) \u00a0    .andExpect(xpath(\"//input[@name='summary']\").exists()) \u00a0    .andExpect(xpath(\"//textarea[@name='text']\").exists()); Kotlin mockMvc.get(\"/messages/form\").andExpect { \u00a0  xpath(\"//input[@name='summary']\") { exists() } \u00a0  xpath(\"//textarea[@name='text']\") { exists() } } This test has some obvious drawbacks. If we update our controller to use the parameter message instead of text, our form test continues to pass, even though the HTML form is out of synch with the controller. To resolve this we can combine our two tests, as follows: 641", "chunk_char_count": 1134, "chunk_word_count": 146, "chunk_token_count": 283.5}, {"page_number": 642, "sentence_chunk": "Java String summaryParamName = \"summary\"; String textParamName = \"text\"; mockMvc.perform(get(\"/messages/form\")) \u00a0    .andExpect(xpath(\"//input[@name='\" + summaryParamName + \"']\").exists()) \u00a0    .andExpect(xpath(\"//textarea[@name='\" + textParamName + \"']\").exists()); MockHttpServletRequestBuilder createMessage = post(\"/messages/\") \u00a0    .param(summaryParamName, \"Spring Rocks\") \u00a0    .param(textParamName, \"In case you didn't know, Spring Rocks!\");mockMvc.perform(createMessage) \u00a0    .andExpect(status().is3xxRedirection()) \u00a0    .andExpect(redirectedUrl(\"/messages/123\")); Kotlin val summaryParamName = \"summary\"; val textParamName = \"text\"; mockMvc.get(\"/messages/form\").andExpect { \u00a0  xpath(\"//input[@name='$summaryParamName']\") { exists() } \u00a0  xpath(\"//textarea[@name='$textParamName']\") { exists() } } mockMvc.post(\"/messages/\") { \u00a0  param(summaryParamName, \"Spring Rocks\") \u00a0  param(textParamName, \"In case you didn't know, Spring Rocks!\") }.andExpect { \u00a0  status().is3xxRedirection() \u00a0  redirectedUrl(\"/messages/123\") } This would reduce the risk of our test incorrectly passing, but there are still some problems: \u2022 What if we have multiple forms on our page?Admittedly, we could update our XPath expressions, but they get more complicated as we take more factors into account: Are the fields the correct type?Are the fields enabled?And so on. \u2022Another issue is that we are doing double the work we would expect. We must first verify the view, and then we submit the view with the same parameters we just verified. Ideally, this could be done all at once. \u2022Finally, we still cannot account for some things.", "chunk_char_count": 1611, "chunk_word_count": 214, "chunk_token_count": 402.75}, {"page_number": 642, "sentence_chunk": "For example, what if the form has JavaScript validation that we wish to test as well?The overall problem is that testing a web page does not involve a single interaction. Instead, it is a combination of how the user interacts with a web page and how that web page interacts with other resources. For example, the result of a form view is used as the input to a user for creating a message. In addition, our form view can potentially use additional resources that impact the behavior of the page, such as JavaScript validation.642", "chunk_char_count": 529, "chunk_word_count": 94, "chunk_token_count": 132.25}, {"page_number": 643, "sentence_chunk": "Integration Testing to the Rescue?To resolve the issues mentioned earlier, we could perform end-to-end integration testing, but this has some drawbacks. Consider testing the view that lets us page through the messages. We might need the following tests: \u2022 Does our page display a notification to the user to indicate that no results are available when the messages are empty? \u2022Does our page properly display a single message? \u2022Does our page properly support paging?To set up these tests, we need to ensure our database contains the proper messages. This leads to a number of additional challenges: \u2022 Ensuring the proper messages are in the database can be tedious. (Consider foreign key constraints.) \u2022Testing can become slow, since each test would need to ensure that the database is in the correct state. \u2022", "chunk_char_count": 808, "chunk_word_count": 132, "chunk_token_count": 202.0}, {"page_number": 643, "sentence_chunk": "Since our database needs to be in a specific state, we cannot run tests in parallel. \u2022Performing assertions on such items as auto-generated ids, timestamps, and others can be difficult. These challenges do not mean that we should abandon end-to-end integration testing altogether. Instead, we can reduce the number of end-to-end integration tests by refactoring our detailed tests to use mock services that run much faster, more reliably, and without side effects. We can then implement a small number of true end-to-end integration tests that validate simple workflows to ensure that everything works together properly. Enter HtmlUnit Integration So how can we achieve a balance between testing the interactions of our pages and still retain good performance within our test suite?The answer is: \u201cBy integrating MockMvc with HtmlUnit.\u201dHtmlUnit Integration Options You have a number of options when you want to integrate MockMvc with HtmlUnit: \u2022 MockMvc and HtmlUnit: Use this option if you want to use the raw HtmlUnit libraries. \u2022MockMvc and WebDriver: Use this option to ease development and reuse code between integration and end-to-end testing. \u2022MockMvc and Geb: Use this option if you want to use Groovy for testing, ease development, and reuse code between integration and end-to-end testing.", "chunk_char_count": 1299, "chunk_word_count": 201, "chunk_token_count": 324.75}, {"page_number": 643, "sentence_chunk": "MockMvc and HtmlUnit This section describes how to integrate MockMvc and HtmlUnit. Use this option if you want to use the raw HtmlUnit libraries.643", "chunk_char_count": 148, "chunk_word_count": 24, "chunk_token_count": 37.0}, {"page_number": 644, "sentence_chunk": "MockMvc and HtmlUnit Setup First, make sure that you have included a test dependency on net.sourceforge.htmlunit:htmlunit. In order to use HtmlUnit with Apache HttpComponents 4.5+, you need to use HtmlUnit 2.18 or higher. We can easily create an HtmlUnit WebClient that integrates with MockMvc by using the MockMvcWebClientBuilder, as follows: Java WebClient webClient; @BeforeEach void setup(WebApplicationContext context) { \u00a0  webClient = MockMvcWebClientBuilder \u00a0      .webAppContextSetup(context) \u00a0      .build(); } Kotlin lateinit var webClient: WebClient @BeforeEach fun setup(context: WebApplicationContext) { \u00a0  webClient = MockMvcWebClientBuilder \u00a0      .webAppContextSetup(context) \u00a0      .build() } \uf05a This is a simple example of using MockMvcWebClientBuilder. For advanced usage, see Advanced MockMvcWebClientBuilder. This ensures that any URL that references localhost as the server is directed to our MockMvc instance without the need for a real HTTP connection. Any other URL is requested by using a network connection, as normal. This lets us easily test the use of CDNs. MockMvc and HtmlUnit Usage Now we can use HtmlUnit as we normally would but without the need to deploy our application to a Servlet container. For example, we can request the view to create a message with the following: Java HtmlPage createMsgFormPage = webClient.getPage(\"http://localhost/messages/form\"); 644", "chunk_char_count": 1397, "chunk_word_count": 214, "chunk_token_count": 349.25}, {"page_number": 645, "sentence_chunk": "Kotlin val createMsgFormPage = webClient.getPage(\"http://localhost/messages/form\") \uf05a The default context path is \"\". Alternatively, we can specify the context path, as described in Advanced MockMvcWebClientBuilder. Once we have a reference to the HtmlPage, we can then fill out the form and submit it to create a message, as the following example shows: Java HtmlForm form = createMsgFormPage.getHtmlElementById(\"messageForm\"); HtmlTextInput summaryInput = createMsgFormPage.getHtmlElementById(\"summary\"); summaryInput.setValueAttribute(\"Spring Rocks\"); HtmlTextArea textInput = createMsgFormPage.getHtmlElementById(\"text\"); textInput.setText(\"In case you didn't know, Spring Rocks!\");HtmlSubmitInput submit = form.getOneHtmlElementByAttribute(\"input\", \"type\", \"submit\"); HtmlPage newMessagePage = submit.click(); Kotlin val form = createMsgFormPage.getHtmlElementById(\"messageForm\") val summaryInput = createMsgFormPage.getHtmlElementById(\"summary\") summaryInput.setValueAttribute(\"Spring Rocks\") val textInput = createMsgFormPage.getHtmlElementById(\"text\") textInput.setText(\"In case you didn't know, Spring Rocks!\")val submit = form.getOneHtmlElementByAttribute(\"input\", \"type\", \"submit\") val newMessagePage = submit.click() Finally, we can verify that a new message was created successfully. The following assertions use the AssertJ library: Java assertThat(newMessagePage.getUrl().toString()).endsWith(\"/messages/123\"); String id = newMessagePage.getHtmlElementById(\"id\").getTextContent(); assertThat(id).isEqualTo(\"123\"); String summary = newMessagePage.getHtmlElementById(\"summary\").getTextContent(); assertThat(summary).isEqualTo(\"Spring Rocks\"); String text = newMessagePage.getHtmlElementById(\"text\").getTextContent(); assertThat(text).isEqualTo(\"In case you didn't know, Spring Rocks!\");645", "chunk_char_count": 1801, "chunk_word_count": 155, "chunk_token_count": 450.25}, {"page_number": 646, "sentence_chunk": "Kotlin assertThat(newMessagePage.getUrl().toString()).endsWith(\"/messages/123\") val id = newMessagePage.getHtmlElementById(\"id\").getTextContent() assertThat(id).isEqualTo(\"123\") val summary = newMessagePage.getHtmlElementById(\"summary\").getTextContent() assertThat(summary).isEqualTo(\"Spring Rocks\") val text = newMessagePage.getHtmlElementById(\"text\").getTextContent() assertThat(text).isEqualTo(\"In case you didn't know, Spring Rocks!\")The preceding code improves on our MockMvc test in a number of ways. First, we no longer have to explicitly verify our form and then create a request that looks like the form. Instead, we request the form, fill it out, and submit it, thereby significantly reducing the overhead. Another important factor is that HtmlUnit uses the Mozilla Rhino engine to evaluate JavaScript. This means that we can also test the behavior of JavaScript within our pages. See the HtmlUnit documentation for additional information about using HtmlUnit. Advanced MockMvcWebClientBuilder In the examples so far, we have used MockMvcWebClientBuilder in the simplest way possible, by building a WebClient based on the WebApplicationContext loaded for us by the Spring TestContext Framework. This approach is repeated in the following example: Java WebClient webClient; @BeforeEach void setup(WebApplicationContext context) { \u00a0  webClient = MockMvcWebClientBuilder \u00a0      .webAppContextSetup(context) \u00a0      .build(); } Kotlin lateinit var webClient: WebClient @BeforeEach fun setup(context: WebApplicationContext) { \u00a0  webClient = MockMvcWebClientBuilder \u00a0      .webAppContextSetup(context) \u00a0      .build() } We can also specify additional configuration options, as the following example shows: 646", "chunk_char_count": 1712, "chunk_word_count": 221, "chunk_token_count": 428.0}, {"page_number": 647, "sentence_chunk": "Java WebClient webClient; @BeforeEach void setup() { \u00a0  webClient = MockMvcWebClientBuilder \u00a0    // demonstrates applying a MockMvcConfigurer (Spring Security) \u00a0    .webAppContextSetup(context, springSecurity()) \u00a0    // for illustration only - defaults to \"\" \u00a0    .contextPath(\"\") \u00a0    // By default MockMvc is used for localhost only; \u00a0    // the following will use MockMvc for example.com and example.org as well \u00a0    .useMockMvcForHosts(\"example.com\",\"example.org\") \u00a0    .build(); } Kotlin lateinit var webClient: WebClient @BeforeEach fun setup() { \u00a0  webClient = MockMvcWebClientBuilder \u00a0    // demonstrates applying a MockMvcConfigurer (Spring Security) \u00a0    .webAppContextSetup(context, springSecurity()) \u00a0    // for illustration only - defaults to \"\" \u00a0    .contextPath(\"\") \u00a0    // By default MockMvc is used for localhost only; \u00a0    // the following will use MockMvc for example.com and example.org as well \u00a0    .useMockMvcForHosts(\"example.com\",\"example.org\") \u00a0    .build() } As an alternative, we can perform the exact same setup by configuring the MockMvc instance separately and supplying it to the MockMvcWebClientBuilder, as follows: 647", "chunk_char_count": 1151, "chunk_word_count": 199, "chunk_token_count": 287.75}, {"page_number": 648, "sentence_chunk": "Java MockMvc mockMvc = MockMvcBuilders \u00a0    .webAppContextSetup(context) \u00a0    .apply(springSecurity()) \u00a0    .build(); webClient = MockMvcWebClientBuilder \u00a0    .mockMvcSetup(mockMvc) \u00a0    // for illustration only - defaults to \"\" \u00a0    .contextPath(\"\") \u00a0    // By default MockMvc is used for localhost only; \u00a0    // the following will use MockMvc for example.com and example.org as well \u00a0    .useMockMvcForHosts(\"example.com\",\"example.org\") \u00a0    .build(); Kotlin // Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed This is more verbose, but, by building the WebClient with a MockMvc instance, we have the full power of MockMvc at our fingertips.\uf0eb For additional information on creating a MockMvc instance, see Setup Choices. MockMvc and WebDriver In the previous sections, we have seen how to use MockMvc in conjunction with the raw HtmlUnit APIs. In this section, we use additional abstractions within the Selenium WebDriver to make things even easier. Why WebDriver and MockMvc?We can already use HtmlUnit and MockMvc, so why would we want to use WebDriver?The Selenium WebDriver provides a very elegant API that lets us easily organize our code. To better show how it works, we explore an example in this section.\uf05a Despite being a part of Selenium, WebDriver does not require a Selenium Server to run your tests. Suppose we need to ensure that a message is created properly.", "chunk_char_count": 1410, "chunk_word_count": 238, "chunk_token_count": 352.5}, {"page_number": 648, "sentence_chunk": "The tests involve finding the HTML form input elements, filling them out, and making various assertions. This approach results in numerous separate tests because we want to test error conditions as well. For example, we want to ensure that we get an error if we fill out only part of the form. If we fill out the entire form, the newly created message should be displayed afterwards. If one of the fields were named \u201csummary\u201d, we might have something that resembles the following repeated in multiple places within our tests: 648", "chunk_char_count": 529, "chunk_word_count": 91, "chunk_token_count": 132.25}, {"page_number": 649, "sentence_chunk": "Java HtmlTextInput summaryInput = currentPage.getHtmlElementById(\"summary\"); summaryInput.setValueAttribute(summary); Kotlin val summaryInput = currentPage.getHtmlElementById(\"summary\") summaryInput.setValueAttribute(summary) So what happens if we change the id to smmry?Doing so would force us to update all of our tests to incorporate this change. This violates the DRY principle, so we should ideally extract this code into its own method, as follows: Java public HtmlPage createMessage(HtmlPage currentPage, String summary, String text) { \u00a0  setSummary(currentPage, summary); \u00a0  // ... } public void setSummary(HtmlPage currentPage, String summary) { \u00a0  HtmlTextInput summaryInput = currentPage.getHtmlElementById(\"summary\"); \u00a0  summaryInput.setValueAttribute(summary); } Kotlin fun createMessage(currentPage: HtmlPage, summary:String, text:String) :HtmlPage{ \u00a0  setSummary(currentPage, summary); \u00a0  // ... } fun setSummary(currentPage:HtmlPage , summary: String) { \u00a0  val summaryInput = currentPage.getHtmlElementById(\"summary\") \u00a0  summaryInput.setValueAttribute(summary) } Doing so ensures that we do not have to update all of our tests if we change the UI. We might even take this a step further and place this logic within an Object that represents the HtmlPage we are currently on, as the following example shows: 649", "chunk_char_count": 1326, "chunk_word_count": 170, "chunk_token_count": 331.5}, {"page_number": 650, "sentence_chunk": "Java public class CreateMessagePage { \u00a0  final HtmlPage currentPage; \u00a0  final HtmlTextInput summaryInput; \u00a0  final HtmlSubmitInput submit; \u00a0  public CreateMessagePage(HtmlPage currentPage) { \u00a0    this.currentPage = currentPage; \u00a0    this.summaryInput = currentPage.getHtmlElementById(\"summary\"); \u00a0    this.submit = currentPage.getHtmlElementById(\"submit\"); \u00a0  } \u00a0  public <T> T createMessage(String summary, String text) throws Exception { \u00a0    setSummary(summary); \u00a0    HtmlPage result = submit.click(); \u00a0    boolean error = CreateMessagePage.at(result); \u00a0    return (T) (error ?new CreateMessagePage(result) : new ViewMessagePage(result)); \u00a0  } \u00a0  public void setSummary(String summary) throws Exception { \u00a0    summaryInput.setValueAttribute(summary); \u00a0  } \u00a0  public static boolean at(HtmlPage page) { \u00a0    return \"Create Message\".equals(page.getTitleText()); \u00a0  } } 650", "chunk_char_count": 872, "chunk_word_count": 135, "chunk_token_count": 218.0}, {"page_number": 651, "sentence_chunk": "Kotlin \u00a0  class CreateMessagePage(private val currentPage: HtmlPage) { \u00a0    val summaryInput: HtmlTextInput = currentPage.getHtmlElementById(\"summary\") \u00a0    val submit: HtmlSubmitInput = currentPage.getHtmlElementById(\"submit\") \u00a0    fun <T> createMessage(summary: String, text: String): T { \u00a0      setSummary(summary) \u00a0      val result = submit.click() \u00a0      val error = at(result) \u00a0      return (if (error) CreateMessagePage(result) else ViewMessagePage(result)) as T \u00a0    } \u00a0    fun setSummary(summary: String) { \u00a0      summaryInput.setValueAttribute(summary) \u00a0    } \u00a0    fun at(page: HtmlPage): Boolean { \u00a0      return \"Create Message\" == page.getTitleText() \u00a0    } \u00a0  } } Formerly, this pattern was known as the Page Object Pattern. While we can certainly do this with HtmlUnit, WebDriver provides some tools that we explore in the following sections to make this pattern much easier to implement. MockMvc and WebDriver Setup To use Selenium WebDriver with the Spring MVC Test framework, make sure that your project includes a test dependency on org.seleniumhq.selenium:selenium-htmlunit-driver. We can easily create a Selenium WebDriver that integrates with MockMvc by using the MockMvcHtmlUnitDriverBuilder as the following example shows: Java WebDriver driver; @BeforeEach void setup(WebApplicationContext context) { \u00a0  driver = MockMvcHtmlUnitDriverBuilder \u00a0      .webAppContextSetup(context) \u00a0      .build(); } 651", "chunk_char_count": 1424, "chunk_word_count": 245, "chunk_token_count": 356.0}, {"page_number": 652, "sentence_chunk": "Kotlin lateinit var driver: WebDriver @BeforeEach fun setup(context: WebApplicationContext) { \u00a0  driver = MockMvcHtmlUnitDriverBuilder \u00a0      .webAppContextSetup(context) \u00a0      .build() } \uf05a This is a simple example of using MockMvcHtmlUnitDriverBuilder. For more advanced usage, see Advanced MockMvcHtmlUnitDriverBuilder. The preceding example ensures that any URL that references localhost as the server is directed to our MockMvc instance without the need for a real HTTP connection. Any other URL is requested by using a network connection, as normal. This lets us easily test the use of CDNs. MockMvc and WebDriver Usage Now we can use WebDriver as we normally would but without the need to deploy our application to a Servlet container. For example, we can request the view to create a message with the following: Java CreateMessagePage page = CreateMessagePage.to(driver); Kotlin val page = CreateMessagePage.to(driver) We can then fill out the form and submit it to create a message, as follows: Java ViewMessagePage viewMessagePage = \u00a0    page.createMessage(ViewMessagePage.class, expectedSummary, expectedText); Kotlin val viewMessagePage = \u00a0  page.createMessage(ViewMessagePage::class, expectedSummary, expectedText) This improves on the design of our HtmlUnit test by leveraging the Page Object Pattern. As we mentioned in Why WebDriver and MockMvc?,we can use the Page Object Pattern with HtmlUnit, but it is much easier with WebDriver. Consider the following CreateMessagePage implementation: 652", "chunk_char_count": 1510, "chunk_word_count": 223, "chunk_token_count": 377.5}, {"page_number": 653, "sentence_chunk": "Java public class CreateMessagePage \u00a0    extends AbstractPage { \u2460 \u00a0  \u2461 \u00a0  private WebElement summary; \u00a0  private WebElement text; \u00a0  \u2462 \u00a0  @FindBy(css = \"input[type=submit]\") \u00a0  private WebElement submit; \u00a0  public CreateMessagePage(WebDriver driver) { \u00a0    super(driver); \u00a0  } \u00a0  public <T> T createMessage(Class<T> resultPage, String summary, String details) { \u00a0    this.summary.sendKeys(summary); \u00a0    this.text.sendKeys(details); \u00a0    this.submit.click(); \u00a0    return PageFactory.initElements(driver, resultPage); \u00a0  } \u00a0  public static CreateMessagePage to(WebDriver driver) { \u00a0    driver.get(\"http://localhost:9990/mail/messages/form\"); \u00a0    return PageFactory.initElements(driver, CreateMessagePage.class); \u00a0  } } \u2460 CreateMessagePage extends the AbstractPage. We do not go over the details of AbstractPage, but, in summary, it contains common functionality for all of our pages. For example, if our application has a navigational bar, global error messages, and other features, we can place this logic in a shared location.\u2461 We have a member variable for each of the parts of the HTML page in which we are interested. These are of type WebElement. WebDriver\u2019s PageFactory lets us remove a lot of code from the HtmlUnit version of CreateMessagePage by automatically resolving each WebElement. The PageFactory#initElements(WebDriver,Class<T>) method automatically resolves each WebElement by using the field name and looking it up by the id or name of the element within the HTML page.\u2462 We can use the @FindBy annotation to override the default lookup behavior. Our example shows how to use the @FindBy annotation to look up our submit button with a css selector (input[type=submit]).653", "chunk_char_count": 1690, "chunk_word_count": 267, "chunk_token_count": 422.5}, {"page_number": 654, "sentence_chunk": "Kotlin class CreateMessagePage(private val driver: WebDriver) : AbstractPage(driver) { \u2460 \u00a0  \u2461 \u00a0  private lateinit var summary: WebElement \u00a0  private lateinit var text: WebElement \u00a0  \u2462 \u00a0  @FindBy(css = \"input[type=submit]\") \u00a0  private lateinit var submit: WebElement \u00a0  fun <T> createMessage(resultPage: Class<T>, summary: String, details: String): T { \u00a0    this.summary.sendKeys(summary) \u00a0    text.sendKeys(details) \u00a0    submit.click() \u00a0    return PageFactory.initElements(driver, resultPage) \u00a0  } \u00a0  companion object { \u00a0    fun to(driver: WebDriver): CreateMessagePage { \u00a0      driver.get(\"http://localhost:9990/mail/messages/form\") \u00a0      return PageFactory.initElements(driver, CreateMessagePage::class.java) \u00a0    } \u00a0  } } \u2460 CreateMessagePage extends the AbstractPage. We do not go over the details of AbstractPage, but, in summary, it contains common functionality for all of our pages. For example, if our application has a navigational bar, global error messages, and other features, we can place this logic in a shared location.\u2461 We have a member variable for each of the parts of the HTML page in which we are interested. These are of type WebElement. WebDriver\u2019s PageFactory lets us remove a lot of code from the HtmlUnit version of CreateMessagePage by automatically resolving each WebElement. The PageFactory#initElements(WebDriver,Class<T>) method automatically resolves each WebElement by using the field name and looking it up by the id or name of the element within the HTML page.\u2462 We can use the @FindBy annotation to override the default lookup behavior. Our example shows how to use the @FindBy annotation to look up our submit button with a css selector (input[type=submit]). Finally, we can verify that a new message was created successfully.", "chunk_char_count": 1762, "chunk_word_count": 283, "chunk_token_count": 440.5}, {"page_number": 654, "sentence_chunk": "The following assertions use the AssertJ assertion library: Java assertThat(viewMessagePage.getMessage()).isEqualTo(expectedMessage); assertThat(viewMessagePage.getSuccess()).isEqualTo(\"Successfully created a new message\"); 654", "chunk_char_count": 227, "chunk_word_count": 16, "chunk_token_count": 56.75}, {"page_number": 655, "sentence_chunk": "Kotlin assertThat(viewMessagePage.message).isEqualTo(expectedMessage) assertThat(viewMessagePage.success).isEqualTo(\"Successfully created a new message\") We can see that our ViewMessagePage lets us interact with our custom domain model. For example, it exposes a method that returns a Message object: Java public Message getMessage() throws ParseException { \u00a0  Message message = new Message(); \u00a0  message.setId(getId()); \u00a0  message.setCreated(getCreated()); \u00a0  message.setSummary(getSummary()); \u00a0  message.setText(getText()); \u00a0  return message; } Kotlin fun getMessage() = Message(getId(), getCreated(), getSummary(), getText()) We can then use the rich domain objects in our assertions. Lastly, we must not forget to close the WebDriver instance when the test is complete, as follows: Java @AfterEach void destroy() { \u00a0  if (driver != null) { \u00a0    driver.close(); \u00a0  } } Kotlin @AfterEach fun destroy() { \u00a0  if (driver != null) { \u00a0    driver.close() \u00a0  } } For additional information on using WebDriver, see the Selenium WebDriver documentation.655", "chunk_char_count": 1049, "chunk_word_count": 152, "chunk_token_count": 262.25}, {"page_number": 656, "sentence_chunk": "Advanced MockMvcHtmlUnitDriverBuilder In the examples so far, we have used MockMvcHtmlUnitDriverBuilder in the simplest way possible, by building a WebDriver based on the WebApplicationContext loaded for us by the Spring TestContext Framework. This approach is repeated here, as follows: Java WebDriver driver; @BeforeEach void setup(WebApplicationContext context) { \u00a0  driver = MockMvcHtmlUnitDriverBuilder \u00a0      .webAppContextSetup(context) \u00a0      .build(); } Kotlin lateinit var driver: WebDriver @BeforeEach fun setup(context: WebApplicationContext) { \u00a0  driver = MockMvcHtmlUnitDriverBuilder \u00a0      .webAppContextSetup(context) \u00a0      .build() } We can also specify additional configuration options, as follows: Java WebDriver driver; @BeforeEach void setup() { \u00a0  driver = MockMvcHtmlUnitDriverBuilder \u00a0      // demonstrates applying a MockMvcConfigurer (Spring Security) \u00a0      .webAppContextSetup(context, springSecurity()) \u00a0      // for illustration only - defaults to \"\" \u00a0      .contextPath(\"\") \u00a0      // By default MockMvc is used for localhost only; \u00a0      // the following will use MockMvc for example.com and example.org as well \u00a0      .useMockMvcForHosts(\"example.com\",\"example.org\") \u00a0      .build(); } 656", "chunk_char_count": 1222, "chunk_word_count": 209, "chunk_token_count": 305.5}, {"page_number": 657, "sentence_chunk": "Kotlin lateinit var driver: WebDriver @BeforeEach fun setup() { \u00a0  driver = MockMvcHtmlUnitDriverBuilder \u00a0      // demonstrates applying a MockMvcConfigurer (Spring Security) \u00a0      .webAppContextSetup(context, springSecurity()) \u00a0      // for illustration only - defaults to \"\" \u00a0      .contextPath(\"\") \u00a0      // By default MockMvc is used for localhost only; \u00a0      // the following will use MockMvc for example.com and example.org as well \u00a0      .useMockMvcForHosts(\"example.com\",\"example.org\") \u00a0      .build() } As an alternative, we can perform the exact same setup by configuring the MockMvc instance separately and supplying it to the MockMvcHtmlUnitDriverBuilder, as follows: Java MockMvc mockMvc = MockMvcBuilders \u00a0    .webAppContextSetup(context) \u00a0    .apply(springSecurity()) \u00a0    .build(); driver = MockMvcHtmlUnitDriverBuilder \u00a0    .mockMvcSetup(mockMvc) \u00a0    // for illustration only - defaults to \"\" \u00a0    .contextPath(\"\") \u00a0    // By default MockMvc is used for localhost only; \u00a0    // the following will use MockMvc for example.com and example.org as well \u00a0    .useMockMvcForHosts(\"example.com\",\"example.org\") \u00a0    .build(); Kotlin // Not possible in Kotlin until https://youtrack.jetbrains.com/issue/KT-22208 is fixed This is more verbose, but, by building the WebDriver with a MockMvc instance, we have the full power of MockMvc at our fingertips.\uf0eb For additional information on creating a MockMvc instance, see Setup Choices. MockMvc and Geb In the previous section, we saw how to use MockMvc with WebDriver. In this section, we use Geb to make our tests even Groovy-er.657", "chunk_char_count": 1589, "chunk_word_count": 283, "chunk_token_count": 397.25}, {"page_number": 658, "sentence_chunk": "Why Geb and MockMvc?Geb is backed by WebDriver, so it offers many of the same benefits that we get from WebDriver. However, Geb makes things even easier by taking care of some of the boilerplate code for us. MockMvc and Geb Setup We can easily initialize a Geb Browser with a Selenium WebDriver that uses MockMvc, as follows: def setup() { \u00a0  browser.driver = MockMvcHtmlUnitDriverBuilder \u00a0    .webAppContextSetup(context) \u00a0    .build() } \uf05a This is a simple example of using MockMvcHtmlUnitDriverBuilder. For more advanced usage, see Advanced MockMvcHtmlUnitDriverBuilder. This ensures that any URL referencing localhost as the server is directed to our MockMvc instance without the need for a real HTTP connection. Any other URL is requested by using a network connection as normal. This lets us easily test the use of CDNs. MockMvc and Geb Usage Now we can use Geb as we normally would but without the need to deploy our application to a Servlet container. For example, we can request the view to create a message with the following: to CreateMessagePage We can then fill out the form and submit it to create a message, as follows: when: form.summary = expectedSummary form.text = expectedMessage submit.click(ViewMessagePage) Any unrecognized method calls or property accesses or references that are not found are forwarded to the current page object.", "chunk_char_count": 1354, "chunk_word_count": 223, "chunk_token_count": 338.5}, {"page_number": 658, "sentence_chunk": "This removes a lot of the boilerplate code we needed when using WebDriver directly. As with direct WebDriver usage, this improves on the design of our HtmlUnit test by using the Page Object Pattern. As mentioned previously, we can use the Page Object Pattern with HtmlUnit and WebDriver, but it is even easier with Geb. Consider our new Groovy-based CreateMessagePage implementation: 658", "chunk_char_count": 387, "chunk_word_count": 62, "chunk_token_count": 96.75}, {"page_number": 659, "sentence_chunk": "class CreateMessagePage extends Page { \u00a0  static url = 'messages/form' \u00a0  static at = { assert title == 'Messages : Create'; true } \u00a0  static content = { \u00a0    submit { $('input[type=submit]') } \u00a0    form { $('form') } \u00a0    errors(required:false) { $('label.error, .alert-error')?.text() } \u00a0  } } Our CreateMessagePage extends Page. We do not go over the details of Page, but, in summary, it contains common functionality for all of our pages. We define a URL in which this page can be found. This lets us navigate to the page, as follows: to CreateMessagePage We also have an at closure that determines if we are at the specified page. It should return true if we are on the correct page. This is why we can assert that we are on the correct page, as follows: then: at CreateMessagePage errors.contains('This field is required.')\uf05a We use an assertion in the closure so that we can determine where things went wrong if we were at the wrong page. Next, we create a content closure that specifies all the areas of interest within the page. We can use a jQuery-ish Navigator API to select the content in which we are interested. Finally, we can verify that a new message was created successfully, as follows: then: at ViewMessagePage success == 'Successfully created a new message' id date summary == expectedSummary message == expectedMessage For further details on how to get the most out of Geb, see The Book of Geb user\u2019s manual.", "chunk_char_count": 1429, "chunk_word_count": 260, "chunk_token_count": 357.25}, {"page_number": 659, "sentence_chunk": "3.3.8. Testing Client Applications You can use client-side tests to test code that internally uses the RestTemplate. The idea is to declare expected requests and to provide \u201cstub\u201d responses so that you can focus on testing the code in 659", "chunk_char_count": 238, "chunk_word_count": 40, "chunk_token_count": 59.5}, {"page_number": 660, "sentence_chunk": "isolation (that is, without running a server). The following example shows how to do so: Java RestTemplate restTemplate = new RestTemplate(); MockRestServiceServer mockServer = MockRestServiceServer.bindTo(restTemplate).build(); mockServer.expect(requestTo(\"/greeting\")).andRespond(withSuccess()); // Test code that uses the above RestTemplate ... mockServer.verify(); Kotlin val restTemplate = RestTemplate() val mockServer = MockRestServiceServer.bindTo(restTemplate).build() mockServer.expect(requestTo(\"/greeting\")).andRespond(withSuccess()) // Test code that uses the above RestTemplate ... mockServer.verify() In the preceding example, MockRestServiceServer (the central class for client-side REST tests) configures the RestTemplate with a custom ClientHttpRequestFactory that asserts actual requests against expectations and returns \u201cstub\u201d responses. In this case, we expect a request to /greeting and want to return a 200 response with text/plain content. We can define additional expected requests and stub responses as needed. When we define expected requests and stub responses, the RestTemplate can be used in client-side code as usual. At the end of testing, mockServer.verify() can be used to verify that all expectations have been satisfied. By default, requests are expected in the order in which expectations were declared. You can set the ignoreExpectOrder option when building the server, in which case all expectations are checked (in order) to find a match for a given request. That means requests are allowed to come in any order. The following example uses ignoreExpectOrder: Java server = MockRestServiceServer.bindTo(restTemplate).ignoreExpectOrder(true).build(); Kotlin server = MockRestServiceServer.bindTo(restTemplate).ignoreExpectOrder(true).build() Even with unordered requests by default, each request is allowed to run once only.", "chunk_char_count": 1862, "chunk_word_count": 227, "chunk_token_count": 465.5}, {"page_number": 660, "sentence_chunk": "The expect method provides an overloaded variant that accepts an ExpectedCount argument that specifies a count range (for example, once, manyTimes, max, min, between, and so on). The following example uses 660", "chunk_char_count": 209, "chunk_word_count": 32, "chunk_token_count": 52.25}, {"page_number": 661, "sentence_chunk": "times: Java RestTemplate restTemplate = new RestTemplate(); MockRestServiceServer mockServer = MockRestServiceServer.bindTo(restTemplate).build(); mockServer.expect(times(2), requestTo(\"/something\")).andRespond(withSuccess()); mockServer.expect(times(3), requestTo(\"/somewhere\")).andRespond(withSuccess()); // ... mockServer.verify(); Kotlin val restTemplate = RestTemplate() val mockServer = MockRestServiceServer.bindTo(restTemplate).build() mockServer.expect(times(2), requestTo(\"/something\")).andRespond(withSuccess()) mockServer.expect(times(3), requestTo(\"/somewhere\")).andRespond(withSuccess()) // ... mockServer.verify() Note that, when ignoreExpectOrder is not set (the default), and, therefore, requests are expected in order of declaration, then that order applies only to the first of any expected request. For example if \"/something\" is expected two times followed by \"/somewhere\" three times, then there should be a request to \"/something\" before there is a request to \"/somewhere\", but, aside from that subsequent \"/something\" and \"/somewhere\", requests can come at any time. As an alternative to all of the above, the client-side test support also provides a ClientHttpRequestFactory implementation that you can configure into a RestTemplate to bind it to a MockMvc instance. That allows processing requests using actual server-side logic but without running a server. The following example shows how to do so: Java MockMvc mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build(); this.restTemplate = new RestTemplate(new MockMvcClientHttpRequestFactory(mockMvc)); // Test code that uses the above RestTemplate ... 661", "chunk_char_count": 1641, "chunk_word_count": 178, "chunk_token_count": 410.25}, {"page_number": 662, "sentence_chunk": "Kotlin val mockMvc = MockMvcBuilders.webAppContextSetup(this.wac).build() restTemplate = RestTemplate(MockMvcClientHttpRequestFactory(mockMvc)) // Test code that uses the above RestTemplate ... Static Imports As with server-side tests, the fluent API for client-side tests requires a few static imports. Those are easy to find by searching for MockRest*. Eclipse users should add MockRestRequestMatchers.*and MockRestResponseCreators.*as \u201cfavorite static members\u201d in the Eclipse preferences under Java \u2192 Editor \u2192 Content Assist \u2192 Favorites. That allows using content assist after typing the first character of the static method name. Other IDEs (such IntelliJ) may not require any additional configuration. Check for the support for code completion on static members. Further Examples of Client-side REST Tests Spring MVC Test\u2019s own tests include example tests of client-side REST tests.3.4.", "chunk_char_count": 891, "chunk_word_count": 118, "chunk_token_count": 222.75}, {"page_number": 662, "sentence_chunk": "Further Resources See the following resources for more information about testing: \u2022 JUnit: \u201cA programmer-friendly testing framework for Java\u201d. Used by the Spring Framework in its test suite and supported in the Spring TestContext Framework. \u2022TestNG: A testing framework inspired by JUnit with added support for test groups, data-driven testing, distributed testing, and other features. Supported in the Spring TestContext Framework \u2022 AssertJ: \u201cFluent assertions for Java\u201d, including support for Java 8 lambdas, streams, and other features. \u2022Mock Objects: Article in Wikipedia. \u2022MockObjects.com: Web site dedicated to mock objects, a technique for improving the design of code within test-driven development. \u2022Mockito: Java mock library based on the Test Spy pattern. Used by the Spring Framework in its test suite. \u2022EasyMock: Java library \u201cthat provides Mock Objects for interfaces (and objects through the class extension) by generating them on the fly using Java\u2019s proxy mechanism.\u201d \u2022JMock: Library that supports test-driven development of Java code with mock objects. \u2022", "chunk_char_count": 1072, "chunk_word_count": 157, "chunk_token_count": 268.0}, {"page_number": 662, "sentence_chunk": "DbUnit: JUnit extension (also usable with Ant and Maven) that is targeted at database-driven projects and, among other things, puts your database into a known state between test runs. \u2022Testcontainers: Java library that supports JUnit tests, providing lightweight, throwaway instances of common databases, Selenium web browsers, or anything else that can run in a Docker container. \u2022The Grinder: Java load testing framework.662", "chunk_char_count": 426, "chunk_word_count": 62, "chunk_token_count": 106.5}, {"page_number": 664, "sentence_chunk": "Chapter 4. Data Access This part of the reference documentation is concerned with data access and the interaction between the data access layer and the business or service layer. Spring\u2019s comprehensive transaction management support is covered in some detail, followed by thorough coverage of the various data access frameworks and technologies with which the Spring Framework integrates.4.1. Transaction Management Comprehensive transaction support is among the most compelling reasons to use the Spring Framework. The Spring Framework provides a consistent abstraction for transaction management that delivers the following benefits: \u2022 A consistent programming model across different transaction APIs, such as Java Transaction API (JTA), JDBC, Hibernate, and the Java Persistence API (JPA). \u2022Support for declarative transaction management. \u2022A simpler API for programmatic transaction management than complex transaction APIs, such as JTA. \u2022Excellent integration with Spring\u2019s data access abstractions. The following sections describe the Spring Framework\u2019s transaction features and technologies: \u2022 Advantages of the Spring Framework\u2019s transaction support model describes why you would use the Spring Framework\u2019s transaction abstraction instead of EJB Container-Managed Transactions (CMT) or choosing to drive local transactions through a proprietary API, such as Hibernate. \u2022", "chunk_char_count": 1377, "chunk_word_count": 187, "chunk_token_count": 344.25}, {"page_number": 664, "sentence_chunk": "Understanding the Spring Framework transaction abstraction outlines the core classes and describes how to configure and obtain DataSource instances from a variety of sources. \u2022Synchronizing resources with transactions describes how the application code ensures that resources are created, reused, and cleaned up properly. \u2022Declarative transaction management describes support for declarative transaction management. \u2022Programmatic transaction management covers support for programmatic (that is, explicitly coded) transaction management. \u2022Transaction bound event describes how you could use application events within a transaction. The chapter also includes discussions of best practices, application server integration, and solutions to common problems.4.1.1. Advantages of the Spring Framework\u2019s Transaction Support Model Traditionally, EE application developers have had two choices for transaction management: global or local transactions, both of which have profound limitations. Global and local transaction management is reviewed in the next two sections, followed by a discussion of how the Spring 664", "chunk_char_count": 1108, "chunk_word_count": 144, "chunk_token_count": 277.0}, {"page_number": 665, "sentence_chunk": "Framework\u2019s transaction management support addresses the limitations of the global and local transaction models. Global Transactions Global transactions let you work with multiple transactional resources, typically relational databases and message queues. The application server manages global transactions through the JTA, which is a cumbersome API (partly due to its exception model). Furthermore, a JTA UserTransaction normally needs to be sourced from JNDI, meaning that you also need to use JNDI in order to use JTA. The use of global transactions limits any potential reuse of application code, as JTA is normally only available in an application server environment. Previously, the preferred way to use global transactions was through EJB CMT (Container Managed Transaction). CMT is a form of declarative transaction management (as distinguished from programmatic transaction management). EJB CMT removes the need for transaction-related JNDI lookups, although the use of EJB itself necessitates the use of JNDI. It removes most but not all of the need to write Java code to control transactions. The significant downside is that CMT is tied to JTA and an application server environment.", "chunk_char_count": 1194, "chunk_word_count": 178, "chunk_token_count": 298.5}, {"page_number": 665, "sentence_chunk": "Also, it is only available if one chooses to implement business logic in EJBs (or at least behind a transactional EJB facade). The negatives of EJB in general are so great that this is not an attractive proposition, especially in the face of compelling alternatives for declarative transaction management. Local Transactions Local transactions are resource-specific, such as a transaction associated with a JDBC connection. Local transactions may be easier to use but have a significant disadvantage: They cannot work across multiple transactional resources. For example, code that manages transactions by using a JDBC connection cannot run within a global JTA transaction. Because the application server is not involved in transaction management, it cannot help ensure correctness across multiple resources. (It is worth noting that most applications use a single transaction resource.)Another downside is that local transactions are invasive to the programming model. Spring Framework\u2019s Consistent Programming Model Spring resolves the disadvantages of global and local transactions. It lets application developers use a consistent programming model in any environment.", "chunk_char_count": 1171, "chunk_word_count": 168, "chunk_token_count": 292.75}, {"page_number": 665, "sentence_chunk": "You write your code once, and it can benefit from different transaction management strategies in different environments. The Spring Framework provides both declarative and programmatic transaction management. Most users prefer declarative transaction management, which we recommend in most cases. With programmatic transaction management, developers work with the Spring Framework transaction abstraction, which can run over any underlying transaction infrastructure. With the preferred declarative model, developers typically write little or no code related to transaction management and, hence, do not depend on the Spring Framework transaction API or any other transaction API.665", "chunk_char_count": 683, "chunk_word_count": 91, "chunk_token_count": 170.75}, {"page_number": 666, "sentence_chunk": "Do you need an application server for transaction management?The Spring Framework\u2019s transaction management support changes traditional rules as to when an enterprise Java application requires an application server. In particular, you do not need an application server purely for declarative transactions through EJBs. In fact, even if your application server has powerful JTA capabilities, you may decide that the Spring Framework\u2019s declarative transactions offer more power and a more productive programming model than EJB CMT. Typically, you need an application server\u2019s JTA capability only if your application needs to handle transactions across multiple resources, which is not a requirement for many applications. Many high-end applications use a single, highly scalable database (such as Oracle RAC) instead. Stand-alone transaction managers (such as Atomikos Transactions and JOTM) are other options. Of course, you may need other application server capabilities, such as Java Message Service (JMS) and Jakarta EE Connector Architecture (JCA). The Spring Framework gives you the choice of when to scale your application to a fully loaded application server. Gone are the days when the only alternative to using EJB CMT or JTA was to write code with local transactions (such as those on JDBC connections) and face a hefty rework if you need that code to run within global, container-managed transactions.", "chunk_char_count": 1410, "chunk_word_count": 211, "chunk_token_count": 352.5}, {"page_number": 666, "sentence_chunk": "With the Spring Framework, only some of the bean definitions in your configuration file need to change (rather than your code).4.1.2. Understanding the Spring Framework Transaction Abstraction The key to the Spring transaction abstraction is the notion of a transaction strategy. A transaction strategy is defined by a TransactionManager, specifically the org.springframework.transaction. PlatformTransactionManager interface for imperative transaction management and the org.springframework.transaction. ReactiveTransactionManager interface for reactive transaction management. The following listing shows the definition of the PlatformTransactionManager API: public interface PlatformTransactionManager extends TransactionManager { \u00a0  TransactionStatus getTransaction(TransactionDefinition definition) throws TransactionException; \u00a0  void commit(TransactionStatus status) throws TransactionException; \u00a0  void rollback(TransactionStatus status) throws TransactionException; } This is primarily a service provider interface (SPI), although you can use it programmatically from your application code. Because PlatformTransactionManager is an interface, it can be easily mocked or stubbed as necessary. It is not tied to a lookup strategy, such as JNDI. PlatformTransactionManager implementations are defined like any other object (or bean) in the Spring Framework IoC 666", "chunk_char_count": 1370, "chunk_word_count": 164, "chunk_token_count": 342.5}, {"page_number": 667, "sentence_chunk": "container. This benefit alone makes Spring Framework transactions a worthwhile abstraction, even when you work with JTA. You can test transactional code much more easily than if it used JTA directly. Again, in keeping with Spring\u2019s philosophy, the TransactionException that can be thrown by any of the PlatformTransactionManager interface\u2019s methods is unchecked (that is, it extends the java.lang. RuntimeException class). Transaction infrastructure failures are almost invariably fatal. In rare cases where application code can actually recover from a transaction failure, the application developer can still choose to catch and handle TransactionException. The salient point is that developers are not forced to do so. The getTransaction(..) method returns a TransactionStatus object, depending on a TransactionDefinition parameter. The returned TransactionStatus might represent a new transaction or can represent an existing transaction, if a matching transaction exists in the current call stack.", "chunk_char_count": 1001, "chunk_word_count": 139, "chunk_token_count": 250.25}, {"page_number": 667, "sentence_chunk": "The implication in this latter case is that, as with Jakarta EE transaction contexts, a TransactionStatus is associated with a thread of execution. As of Spring Framework 5.2, Spring also provides a transaction management abstraction for reactive applications that make use of reactive types or Kotlin Coroutines. The following listing shows the transaction strategy defined by org.springframework.transaction. ReactiveTransactionManager: public interface ReactiveTransactionManager extends TransactionManager { \u00a0  Mono<ReactiveTransaction> getReactiveTransaction(TransactionDefinition definition) throws TransactionException; \u00a0  Mono<Void> commit(ReactiveTransaction status) throws TransactionException; \u00a0  Mono<Void> rollback(ReactiveTransaction status) throws TransactionException; } The reactive transaction manager is primarily a service provider interface (SPI), although you can use it programmatically from your application code. Because ReactiveTransactionManager is an interface, it can be easily mocked or stubbed as necessary. The TransactionDefinition interface specifies: \u2022 Propagation: Typically, all code within a transaction scope runs in that transaction. However, you can specify the behavior if a transactional method is run when a transaction context already exists. For example, code can continue running in the existing transaction (the common case), or the existing transaction can be suspended and a new transaction created. Spring offers all of the transaction propagation options familiar from EJB CMT. To read about the semantics of transaction propagation in Spring, see Transaction Propagation. \u2022", "chunk_char_count": 1626, "chunk_word_count": 207, "chunk_token_count": 406.5}, {"page_number": 667, "sentence_chunk": "Isolation: The degree to which this transaction is isolated from the work of other transactions. For example, can this transaction see uncommitted writes from other transactions? \u2022Timeout: How long this transaction runs before timing out and being automatically rolled back by the underlying transaction infrastructure.667", "chunk_char_count": 322, "chunk_word_count": 45, "chunk_token_count": 80.5}, {"page_number": 668, "sentence_chunk": "\u2022 Read-only status: You can use a read-only transaction when your code reads but does not modify data. Read-only transactions can be a useful optimization in some cases, such as when you use Hibernate. These settings reflect standard transactional concepts. If necessary, refer to resources that discuss transaction isolation levels and other core transaction concepts. Understanding these concepts is essential to using the Spring Framework or any transaction management solution. The TransactionStatus interface provides a simple way for transactional code to control transaction execution and query transaction status. The concepts should be familiar, as they are common to all transaction APIs. The following listing shows the TransactionStatus interface: public interface TransactionStatus extends TransactionExecution, SavepointManager, Flushable { \u00a0  @Override \u00a0  boolean isNewTransaction(); \u00a0  boolean hasSavepoint(); \u00a0  @Override \u00a0  void setRollbackOnly(); \u00a0  @Override \u00a0  boolean isRollbackOnly(); \u00a0  void flush(); \u00a0  @Override \u00a0  boolean isCompleted(); } Regardless of whether you opt for declarative or programmatic transaction management in Spring, defining the correct TransactionManager implementation is absolutely essential. You typically define this implementation through dependency injection. TransactionManager implementations normally require knowledge of the environment in which they work: JDBC, JTA, Hibernate, and so on.", "chunk_char_count": 1446, "chunk_word_count": 200, "chunk_token_count": 361.5}, {"page_number": 668, "sentence_chunk": "The following examples show how you can define a local PlatformTransactionManager implementation (in this case, with plain JDBC.)You can define a JDBC DataSource by creating a bean similar to the following: 668", "chunk_char_count": 210, "chunk_word_count": 32, "chunk_token_count": 52.5}, {"page_number": 669, "sentence_chunk": "<bean id=\"dataSource\" class=\"org.apache.commons.dbcp. BasicDataSource\" destroy- method=\"close\"> \u00a0  <property name=\"driverClassName\" value=\"${jdbc.driverClassName}\" /> \u00a0  <property name=\"url\" value=\"${jdbc.url}\" /> \u00a0  <property name=\"username\" value=\"${jdbc.username}\" /> \u00a0  <property name=\"password\" value=\"${jdbc.password}\" /> </bean> The related PlatformTransactionManager bean definition then has a reference to the DataSource definition. It should resemble the following example: <bean id=\"txManager\" class=\"org.springframework.jdbc.datasource. DataSourceTransactionManager\"> \u00a0  <property name=\"dataSource\" ref=\"dataSource\"/> </bean> If you use JTA in a Jakarta EE container, then you use a container DataSource, obtained through JNDI, in conjunction with Spring\u2019s JtaTransactionManager. The following example shows what the JTA and JNDI lookup version would look like: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:jee=\"http://www.springframework.org/schema/jee\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/jee \u00a0    https://www.springframework.org/schema/jee/spring-jee.xsd\"> \u00a0  <jee:jndi-lookup id=\"dataSource\" jndi-name=\"jdbc/jpetstore\"/> \u00a0  <bean id=\"txManager\" class=\"org.springframework.transaction.jta. JtaTransactionManager\" /> \u00a0  <!--other <bean/> definitions here --> </beans> The JtaTransactionManager does not need to know about the DataSource (or any other specific resources) because it uses the container\u2019s global transaction management infrastructure.\uf05a The preceding definition of the dataSource bean uses the <jndi-lookup/> tag from the jee namespace.", "chunk_char_count": 1829, "chunk_word_count": 190, "chunk_token_count": 457.25}, {"page_number": 670, "sentence_chunk": "\uf05a If you use JTA, your transaction manager definition should look the same, regardless of what data access technology you use, be it JDBC, Hibernate JPA, or any other supported technology. This is due to the fact that JTA transactions are global transactions, which can enlist any transactional resource. In all Spring transaction setups, application code does not need to change. You can change how transactions are managed merely by changing configuration, even if that change means moving from local to global transactions or vice versa. Hibernate Transaction Setup You can also easily use Hibernate local transactions, as shown in the following examples. In this case, you need to define a Hibernate LocalSessionFactoryBean, which your application code can use to obtain Hibernate Session instances. The DataSource bean definition is similar to the local JDBC example shown previously and, thus, is not shown in the following example.\uf05a If the DataSource (used by any non-JTA transaction manager) is looked up through JNDI and managed by a Jakarta EE container, it should be non-transactional, because the Spring Framework (rather than the Jakarta EE container) manages the transactions. The txManager bean in this case is of the HibernateTransactionManager type. In the same way as the DataSourceTransactionManager needs a reference to the DataSource, the HibernateTransactionManager needs a reference to the SessionFactory.", "chunk_char_count": 1428, "chunk_word_count": 216, "chunk_token_count": 357.0}, {"page_number": 670, "sentence_chunk": "The following example declares sessionFactory and txManager beans: <bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate5. LocalSessionFactoryBean\"> \u00a0  <property name=\"dataSource\" ref=\"dataSource\"/> \u00a0  <property name=\"mappingResources\"> \u00a0    <list> \u00a0 <value>org/springframework/samples/petclinic/hibernate/petclinic.hbm.xml</value> \u00a0    </list> \u00a0  </property> \u00a0  <property name=\"hibernateProperties\"> \u00a0    <value> \u00a0      hibernate.dialect=${hibernate.dialect} \u00a0    </value> \u00a0  </property> </bean> <bean id=\"txManager\" class=\"org.springframework.orm.hibernate5. HibernateTransactionManager\"> \u00a0  <property name=\"sessionFactory\" ref=\"sessionFactory\"/> </bean> 670", "chunk_char_count": 673, "chunk_word_count": 72, "chunk_token_count": 168.25}, {"page_number": 671, "sentence_chunk": "If you use Hibernate and Jakarta EE container-managed JTA transactions, you should use the same JtaTransactionManager as in the previous JTA example for JDBC, as the following example shows. Also, it is recommended to make Hibernate aware of JTA through its transaction coordinator and possibly also its connection release mode configuration: <bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate5. LocalSessionFactoryBean\"> \u00a0  <property name=\"dataSource\" ref=\"dataSource\"/> \u00a0  <property name=\"mappingResources\"> \u00a0    <list> \u00a0 <value>org/springframework/samples/petclinic/hibernate/petclinic.hbm.xml</value> \u00a0    </list> \u00a0  </property> \u00a0  <property name=\"hibernateProperties\"> \u00a0    <value> \u00a0      hibernate.dialect=${hibernate.dialect} \u00a0      hibernate.transaction.coordinator_class=jta \u00a0 hibernate.connection.handling_mode=DELAYED_ACQUISITION_AND_RELEASE_AFTER_STATEMENT \u00a0    </value> \u00a0  </property> </bean> <bean id=\"txManager\" class=\"org.springframework.transaction.jta. JtaTransactionManager\"/> Or alternatively, you may pass the JtaTransactionManager into your LocalSessionFactoryBean for enforcing the same defaults: 671", "chunk_char_count": 1139, "chunk_word_count": 133, "chunk_token_count": 284.75}, {"page_number": 672, "sentence_chunk": "<bean id=\"sessionFactory\" class=\"org.springframework.orm.hibernate5. LocalSessionFactoryBean\"> \u00a0  <property name=\"dataSource\" ref=\"dataSource\"/> \u00a0  <property name=\"mappingResources\"> \u00a0    <list> \u00a0 <value>org/springframework/samples/petclinic/hibernate/petclinic.hbm.xml</value> \u00a0    </list> \u00a0  </property> \u00a0  <property name=\"hibernateProperties\"> \u00a0    <value> \u00a0      hibernate.dialect=${hibernate.dialect} \u00a0    </value> \u00a0  </property> \u00a0  <property name=\"jtaTransactionManager\" ref=\"txManager\"/> </bean> <bean id=\"txManager\" class=\"org.springframework.transaction.jta. JtaTransactionManager\"/> 4.1.3. Synchronizing Resources with Transactions How to create different transaction managers and how they are linked to related resources that need to be synchronized to transactions (for example DataSourceTransactionManager to a JDBC DataSource, HibernateTransactionManager to a Hibernate SessionFactory, and so forth) should now be clear. This section describes how the application code (directly or indirectly, by using a persistence API such as JDBC, Hibernate, or JPA) ensures that these resources are created, reused, and cleaned up properly. The section also discusses how transaction synchronization is (optionally) triggered through the relevant TransactionManager. High-level Synchronization Approach The preferred approach is to use Spring\u2019s highest-level template-based persistence integration APIs or to use native ORM APIs with transaction-aware factory beans or proxies for managing the native resource factories. These transaction-aware solutions internally handle resource creation and reuse, cleanup, optional transaction synchronization of the resources, and exception mapping. Thus, user data access code does not have to address these tasks but can focus purely on non- boilerplate persistence logic. Generally, you use the native ORM API or take a template approach for JDBC access by using the JdbcTemplate. These solutions are detailed in subsequent sections of this reference documentation.", "chunk_char_count": 2009, "chunk_word_count": 256, "chunk_token_count": 502.25}, {"page_number": 672, "sentence_chunk": "Low-level Synchronization Approach Classes such as DataSourceUtils (for JDBC), EntityManagerFactoryUtils (for JPA), SessionFactoryUtils (for Hibernate), and so on exist at a lower level. When you want the application code to deal directly with the resource types of the native persistence APIs, you use these classes to ensure that proper Spring Framework-managed instances are obtained, transactions are (optionally) synchronized, and exceptions that occur in the process are properly mapped to a consistent API.672", "chunk_char_count": 516, "chunk_word_count": 72, "chunk_token_count": 129.0}, {"page_number": 673, "sentence_chunk": "For example, in the case of JDBC, instead of the traditional JDBC approach of calling the getConnection() method on the DataSource, you can instead use Spring\u2019s org.springframework.jdbc.datasource. DataSourceUtils class, as follows: Connection conn = DataSourceUtils.getConnection(dataSource); If an existing transaction already has a connection synchronized (linked) to it, that instance is returned. Otherwise, the method call triggers the creation of a new connection, which is (optionally) synchronized to any existing transaction and made available for subsequent reuse in that same transaction. As mentioned earlier, any SQLException is wrapped in a Spring Framework CannotGetJdbcConnectionException, one of the Spring Framework\u2019s hierarchy of unchecked DataAccessException types. This approach gives you more information than can be obtained easily from the SQLException and ensures portability across databases and even across different persistence technologies. This approach also works without Spring transaction management (transaction synchronization is optional), so you can use it whether or not you use Spring for transaction management. Of course, once you have used Spring\u2019s JDBC support, JPA support, or Hibernate support, you generally prefer not to use DataSourceUtils or the other helper classes, because you are much happier working through the Spring abstraction than directly with the relevant APIs. For example, if you use the Spring JdbcTemplate or jdbc.object package to simplify your use of JDBC, correct connection retrieval occurs behind the scenes and you need not write any special code. TransactionAwareDataSourceProxy At the very lowest level exists the TransactionAwareDataSourceProxy class. This is a proxy for a target DataSource, which wraps the target DataSource to add awareness of Spring-managed transactions.", "chunk_char_count": 1850, "chunk_word_count": 256, "chunk_token_count": 462.5}, {"page_number": 673, "sentence_chunk": "In this respect, it is similar to a transactional JNDI DataSource, as provided by a Jakarta EE server. You should almost never need or want to use this class, except when existing code must be called and passed a standard JDBC DataSource interface implementation. In that case, it is possible that this code is usable but is participating in Spring-managed transactions. You can write your new code by using the higher-level abstractions mentioned earlier.4.1.4. Declarative Transaction Management \uf05a Most Spring Framework users choose declarative transaction management. This option has the least impact on application code and, hence, is most consistent with the ideals of a non-invasive lightweight container. The Spring Framework\u2019s declarative transaction management is made possible with Spring aspect- oriented programming (AOP). However, as the transactional aspects code comes with the Spring Framework distribution and may be used in a boilerplate fashion, AOP concepts do not generally have to be understood to make effective use of this code. The Spring Framework\u2019s declarative transaction management is similar to EJB CMT, in that you can specify transaction behavior (or lack of it) down to the individual method level.", "chunk_char_count": 1231, "chunk_word_count": 187, "chunk_token_count": 307.75}, {"page_number": 674, "sentence_chunk": "setRollbackOnly() call within a transaction context, if necessary. The differences between the two types of transaction management are: \u2022 Unlike EJB CMT, which is tied to JTA, the Spring Framework\u2019s declarative transaction management works in any environment. It can work with JTA transactions or local transactions by using JDBC, JPA, or Hibernate by adjusting the configuration files. \u2022You can apply the Spring Framework declarative transaction management to any class, not merely special classes such as EJBs. \u2022The Spring Framework offers declarative rollback rules, a feature with no EJB equivalent. Both programmatic and declarative support for rollback rules is provided. \u2022The Spring Framework lets you customize transactional behavior by using AOP. For example, you can insert custom behavior in the case of transaction rollback. You can also add arbitrary advice, along with transactional advice. With EJB CMT, you cannot influence the container\u2019s transaction management, except with setRollbackOnly(). \u2022", "chunk_char_count": 1012, "chunk_word_count": 147, "chunk_token_count": 253.0}, {"page_number": 674, "sentence_chunk": "The Spring Framework does not support propagation of transaction contexts across remote calls, as high-end application servers do. If you need this feature, we recommend that you use EJB. However, consider carefully before using such a feature, because, normally, one does not want transactions to span remote calls. The concept of rollback rules is important. They let you specify which exceptions (and throwables) should cause automatic rollback. You can specify this declaratively, in configuration, not in Java code. So, although you can still call setRollbackOnly() on the TransactionStatus object to roll back the current transaction back, most often you can specify a rule that MyApplicationException must always result in rollback. The significant advantage to this option is that business objects do not depend on the transaction infrastructure. For example, they typically do not need to import Spring transaction APIs or other Spring APIs. Although EJB container default behavior automatically rolls back the transaction on a system exception (usually a runtime exception), EJB CMT does not roll back the transaction automatically on an application exception (that is, a checked exception other than java.rmi.", "chunk_char_count": 1220, "chunk_word_count": 182, "chunk_token_count": 305.0}, {"page_number": 674, "sentence_chunk": "RemoteException). While the Spring default behavior for declarative transaction management follows EJB convention (roll back is automatic only on unchecked exceptions), it is often useful to customize this behavior. Understanding the Spring Framework\u2019s Declarative Transaction Implementation It is not sufficient merely to tell you to annotate your classes with the @Transactional annotation, add @EnableTransactionManagement to your configuration, and expect you to understand how it all works. To provide a deeper understanding, this section explains the inner workings of the Spring Framework\u2019s declarative transaction infrastructure in the context of transaction-related issues. The most important concepts to grasp with regard to the Spring Framework\u2019s declarative transaction support are that this support is enabled via AOP proxies and that the transactional advice is driven by metadata (currently XML- or annotation-based). The combination of AOP with transactional metadata yields an AOP proxy that uses a TransactionInterceptor in conjunction with an appropriate TransactionManager implementation to drive transactions around method invocations.674", "chunk_char_count": 1159, "chunk_word_count": 155, "chunk_token_count": 289.75}, {"page_number": 675, "sentence_chunk": "\uf05a Spring AOP is covered in the AOP section. Spring Framework\u2019s TransactionInterceptor provides transaction management for imperative and reactive programming models. The interceptor detects the desired flavor of transaction management by inspecting the method return type. Methods returning a reactive type such as Publisher or Kotlin Flow (or a subtype of those) qualify for reactive transaction management. All other return types including void use the code path for imperative transaction management. Transaction management flavors impact which transaction manager is required. Imperative transactions require a PlatformTransactionManager, while reactive transactions use ReactiveTransactionManager implementations.\uf05a @Transactional commonly works with thread-bound transactions managed by PlatformTransactionManager, exposing a transaction to all data access operations within the current execution thread. Note: This does not propagate to newly started threads within the method. A reactive transaction managed by ReactiveTransactionManager uses the Reactor context instead of thread-local attributes.", "chunk_char_count": 1105, "chunk_word_count": 139, "chunk_token_count": 276.25}, {"page_number": 675, "sentence_chunk": "As a consequence, all participating data access operations need to execute within the same Reactor context in the same reactive pipeline. The following image shows a conceptual view of calling a method on a transactional proxy: Example of Declarative Transaction Implementation Consider the following interface and its attendant implementation. This example uses Foo and Bar classes as placeholders so that you can concentrate on the transaction usage without focusing on a particular domain model. For the purposes of this example, the fact that the DefaultFooService class throws UnsupportedOperationException instances in the body of each implemented method is good.675", "chunk_char_count": 672, "chunk_word_count": 98, "chunk_token_count": 168.0}, {"page_number": 676, "sentence_chunk": "That behavior lets you see transactions being created and then rolled back in response to the UnsupportedOperationException instance. The following listing shows the FooService interface: Java // the service interface that we want to make transactional package x.y.service; public interface FooService { \u00a0  Foo getFoo(String fooName); \u00a0  Foo getFoo(String fooName, String barName); \u00a0  void insertFoo(Foo foo); \u00a0  void updateFoo(Foo foo); } Kotlin // the service interface that we want to make transactional package x.y.service interface FooService { \u00a0  fun getFoo(fooName: String): Foo \u00a0  fun getFoo(fooName: String, barName: String): Foo \u00a0  fun insertFoo(foo: Foo) \u00a0  fun updateFoo(foo: Foo) } The following example shows an implementation of the preceding interface: 676", "chunk_char_count": 772, "chunk_word_count": 117, "chunk_token_count": 193.0}, {"page_number": 677, "sentence_chunk": "Java package x.y.service; public class DefaultFooService implements FooService { \u00a0  @Override \u00a0  public Foo getFoo(String fooName) { \u00a0    // ... \u00a0  } \u00a0  @Override \u00a0  public Foo getFoo(String fooName, String barName) { \u00a0    // ... \u00a0  } \u00a0  @Override \u00a0  public void insertFoo(Foo foo) { \u00a0    // ... \u00a0  } \u00a0  @Override \u00a0  public void updateFoo(Foo foo) { \u00a0    // ... \u00a0  } } Kotlin package x.y.service class DefaultFooService : FooService { \u00a0  override fun getFoo(fooName: String): Foo { \u00a0    // ... \u00a0  } \u00a0  override fun getFoo(fooName: String, barName: String): Foo { \u00a0    // ... \u00a0  } \u00a0  override fun insertFoo(foo: Foo) { \u00a0    // ... \u00a0  } \u00a0  override fun updateFoo(foo: Foo) { \u00a0    // ... \u00a0  } } 677", "chunk_char_count": 695, "chunk_word_count": 166, "chunk_token_count": 173.75}, {"page_number": 678, "sentence_chunk": "Assume that the first two methods of the FooService interface, getFoo(String) and getFoo(String, String), must run in the context of a transaction with read-only semantics and that the other methods, insertFoo(Foo) and updateFoo(Foo), must run in the context of a transaction with read- write semantics. The following configuration is explained in detail in the next few paragraphs: <!--from the file 'context.xml' --> <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:aop=\"http://www.springframework.org/schema/aop\" \u00a0  xmlns:tx=\"http://www.springframework.org/schema/tx\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/tx \u00a0    https://www.springframework.org/schema/tx/spring-tx.xsd \u00a0    http://www.springframework.org/schema/aop \u00a0    https://www.springframework.org/schema/aop/spring-aop.xsd\"> \u00a0  <!--this is the service object that we want to make transactional --> \u00a0  <bean id=\"fooService\" class=\"x.y.service. DefaultFooService\"/> \u00a0  <!--the transactional advice (what 'happens'; see the <aop:advisor/> bean below) --> \u00a0  <tx:advice id=\"txAdvice\" transaction-manager=\"txManager\"> \u00a0    <!--the transactional semantics... --> \u00a0    <tx:attributes> \u00a0      <!--all methods starting with 'get' are read-only --> \u00a0      <tx:method name=\"get*\" read-only=\"true\"/> \u00a0      <!--", "chunk_char_count": 1519, "chunk_word_count": 190, "chunk_token_count": 379.75}, {"page_number": 678, "sentence_chunk": "other methods use the default transaction settings (see below) --> \u00a0      <tx:method name=\"*\"/> \u00a0    </tx:attributes> \u00a0  </tx:advice> \u00a0  <!--ensure that the above transactional advice runs for any execution \u00a0    of an operation defined by the FooService interface --> \u00a0  <aop:config> \u00a0    <aop:pointcut id=\"fooServiceOperation\" expression=\"execution(* x.y.service. FooService.*(..))\"/> \u00a0    <aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"fooServiceOperation\"/> \u00a0  </aop:config> \u00a0  <!--don't forget the DataSource --> \u00a0  <bean id=\"dataSource\" class=\"org.apache.commons.dbcp. BasicDataSource\" destroy- method=\"close\"> \u00a0    <property name=\"driverClassName\" value=\"oracle.jdbc.driver. OracleDriver\"/> \u00a0    <property name=\"url\" value=\"jdbc:oracle:thin:@rj-t42:1521:elvis\"/> \u00a0    <property name=\"username\" value=\"scott\"/> \u00a0    <property name=\"password\" value=\"tiger\"/> \u00a0  </bean> 678", "chunk_char_count": 879, "chunk_word_count": 121, "chunk_token_count": 219.75}, {"page_number": 679, "sentence_chunk": "<!--similarly, don't forget the TransactionManager --> \u00a0  <bean id=\"txManager\" class=\"org.springframework.jdbc.datasource. DataSourceTransactionManager\"> \u00a0    <property name=\"dataSource\" ref=\"dataSource\"/> \u00a0  </bean> \u00a0  <!--other <bean/> definitions here --> </beans> Examine the preceding configuration. It assumes that you want to make a service object, the fooService bean, transactional. The transaction semantics to apply are encapsulated in the <tx:advice/> definition. The <tx:advice/> definition reads as \"all methods starting with get are to run in the context of a read-only transaction, and all other methods are to run with the default transaction semantics\". The transaction-manager attribute of the <tx:advice/> tag is set to the name of the TransactionManager bean that is going to drive the transactions (in this case, the txManager bean).\uf0eb You can omit the transaction-manager attribute in the transactional advice (<tx:advice/>) if the bean name of the TransactionManager that you want to wire in has the name transactionManager. If the TransactionManager bean that you want to wire in has any other name, you must use the transaction-manager attribute explicitly, as in the preceding example.", "chunk_char_count": 1211, "chunk_word_count": 174, "chunk_token_count": 302.75}, {"page_number": 679, "sentence_chunk": "The <aop:config/> definition ensures that the transactional advice defined by the txAdvice bean runs at the appropriate points in the program. First, you define a pointcut that matches the execution of any operation defined in the FooService interface (fooServiceOperation). Then you associate the pointcut with the txAdvice by using an advisor. The result indicates that, at the execution of a fooServiceOperation, the advice defined by txAdvice is run. The expression defined within the <aop:pointcut/> element is an AspectJ pointcut expression. See the AOP section for more details on pointcut expressions in Spring. A common requirement is to make an entire service layer transactional. The best way to do this is to change the pointcut expression to match any operation in your service layer. The following example shows how to do so: <aop:config> \u00a0  <aop:pointcut id=\"fooServiceMethods\" expression=\"execution(* x.y.service.*.*(..))\"/> \u00a0  <aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"fooServiceMethods\"/> </aop:config> \uf05a In the preceding example, it is assumed that all your service interfaces are defined in the x.y.service package. See the AOP section for more details.", "chunk_char_count": 1180, "chunk_word_count": 170, "chunk_token_count": 295.0}, {"page_number": 680, "sentence_chunk": "configuration actually do?\"The configuration shown earlier is used to create a transactional proxy around the object that is created from the fooService bean definition. The proxy is configured with the transactional advice so that, when an appropriate method is invoked on the proxy, a transaction is started, suspended, marked as read-only, and so on, depending on the transaction configuration associated with that method. Consider the following program that test drives the configuration shown earlier: Java public final class Boot { \u00a0  public static void main(final String[] args) throws Exception { \u00a0    ApplicationContext ctx = new ClassPathXmlApplicationContext(\"context.xml\"); \u00a0    FooService fooService = ctx.getBean(FooService.class); \u00a0    fooService.insertFoo(new Foo()); \u00a0  } } Kotlin import org.springframework.beans.factory.getBean fun main() { \u00a0  val ctx = ClassPathXmlApplicationContext(\"context.xml\") \u00a0  val fooService = ctx.getBean<FooService>(\"fooService\") \u00a0  fooService.insertFoo(Foo()) } The output from running the preceding program should resemble the following (the Log4J output and the stack trace from the UnsupportedOperationException thrown by the insertFoo(..) method of the DefaultFooService class have been truncated for clarity): 680", "chunk_char_count": 1266, "chunk_word_count": 176, "chunk_token_count": 316.5}, {"page_number": 681, "sentence_chunk": "<!--the Spring container is starting up... --> [AspectJInvocationContextExposingAdvisorAutoProxyCreator] - Creating implicit proxy for bean 'fooService' with 0 common interceptors and 1 specific interceptors <!--the DefaultFooService is actually proxied --> [JdkDynamicAopProxy] - Creating JDK dynamic proxy for [x.y.service. DefaultFooService] <!-- ...the insertFoo(..) method is now being invoked on the proxy --> [TransactionInterceptor] - Getting transaction for x.y.service. FooService.insertFoo <!--the transactional advice kicks in here... --> [DataSourceTransactionManager] - Creating new transaction with name [x.y.service. FooService.insertFoo] [DataSourceTransactionManager] - Acquired Connection [org.apache.commons.dbcp. PoolableConnection@a53de4] for JDBC transaction <!--the insertFoo(..) method from DefaultFooService throws an exception... --> [RuleBasedTransactionAttribute] - Applying rules to determine whether transaction should rollback on java.lang.", "chunk_char_count": 972, "chunk_word_count": 103, "chunk_token_count": 243.0}, {"page_number": 681, "sentence_chunk": "UnsupportedOperationException [TransactionInterceptor] - Invoking rollback for transaction on x.y.service. FooService.insertFoo due to throwable [java.lang. UnsupportedOperationException] <!--and the transaction is rolled back (by default, RuntimeException instances cause rollback) --> [DataSourceTransactionManager] - Rolling back JDBC transaction on Connection [org.apache.commons.dbcp. PoolableConnection@a53de4] [DataSourceTransactionManager] - Releasing JDBC Connection after transaction [DataSourceUtils] - Returning JDBC Connection to DataSource Exception in thread \"main\" java.lang. UnsupportedOperationException at x.y.service. DefaultFooService.insertFoo(DefaultFooService.java:14) <!--AOP infrastructure stack trace elements removed for clarity --> at $Proxy0.insertFoo(Unknown Source) at Boot.main(Boot.java:11) To use reactive transaction management the code has to use reactive types.\uf05a Spring Framework uses the ReactiveAdapterRegistry to determine whether a method return type is reactive. The following listing shows a modified version of the previously used FooService, but this time the code uses reactive types: 681", "chunk_char_count": 1135, "chunk_word_count": 122, "chunk_token_count": 283.75}, {"page_number": 682, "sentence_chunk": "Java // the reactive service interface that we want to make transactional package x.y.service; public interface FooService { \u00a0  Flux<Foo> getFoo(String fooName); \u00a0  Publisher<Foo> getFoo(String fooName, String barName); \u00a0  Mono<Void> insertFoo(Foo foo); \u00a0  Mono<Void> updateFoo(Foo foo); } Kotlin // the reactive service interface that we want to make transactional package x.y.service interface FooService { \u00a0  fun getFoo(fooName: String): Flow<Foo> \u00a0  fun getFoo(fooName: String, barName: String): Publisher<Foo> \u00a0  fun insertFoo(foo: Foo) : Mono<Void> \u00a0  fun updateFoo(foo: Foo) : Mono<Void> } The following example shows an implementation of the preceding interface: 682", "chunk_char_count": 674, "chunk_word_count": 98, "chunk_token_count": 168.5}, {"page_number": 683, "sentence_chunk": "Java package x.y.service; public class DefaultFooService implements FooService { \u00a0  @Override \u00a0  public Flux<Foo> getFoo(String fooName) { \u00a0    // ... \u00a0  } \u00a0  @Override \u00a0  public Publisher<Foo> getFoo(String fooName, String barName) { \u00a0    // ... \u00a0  } \u00a0  @Override \u00a0  public Mono<Void> insertFoo(Foo foo) { \u00a0    // ... \u00a0  } \u00a0  @Override \u00a0  public Mono<Void> updateFoo(Foo foo) { \u00a0    // ... \u00a0  } } Kotlin package x.y.service class DefaultFooService : FooService { \u00a0  override fun getFoo(fooName: String): Flow<Foo> { \u00a0    // ... \u00a0  } \u00a0  override fun getFoo(fooName: String, barName: String): Publisher<Foo> { \u00a0    // ... \u00a0  } \u00a0  override fun insertFoo(foo: Foo): Mono<Void> { \u00a0    // ... \u00a0  } \u00a0  override fun updateFoo(foo: Foo): Mono<Void> { \u00a0    // ... \u00a0  } } 683", "chunk_char_count": 765, "chunk_word_count": 168, "chunk_token_count": 191.25}, {"page_number": 684, "sentence_chunk": "Imperative and reactive transaction management share the same semantics for transaction boundary and transaction attribute definitions. The main difference between imperative and reactive transactions is the deferred nature of the latter. TransactionInterceptor decorates the returned reactive type with a transactional operator to begin and clean up the transaction. Therefore, calling a transactional reactive method defers the actual transaction management to a subscription type that activates processing of the reactive type. Another aspect of reactive transaction management relates to data escaping which is a natural consequence of the programming model. Method return values of imperative transactions are returned from transactional methods upon successful termination of a method so that partially computed results do not escape the method closure. Reactive transaction methods return a reactive wrapper type which represents a computation sequence along with a promise to begin and complete the computation. A Publisher can emit data while a transaction is ongoing but not necessarily completed. Therefore, methods that depend upon successful completion of an entire transaction need to ensure completion and buffer results in the calling code. Rolling Back a Declarative Transaction The previous section outlined the basics of how to specify transactional settings for classes, typically service layer classes, declaratively in your application.", "chunk_char_count": 1458, "chunk_word_count": 203, "chunk_token_count": 364.5}, {"page_number": 684, "sentence_chunk": "This section describes how you can control the rollback of transactions in a simple, declarative fashion in XML configuration. For details on controlling rollback semantics declaratively with the @Transactional annotation, see @Transactional Settings. The recommended way to indicate to the Spring Framework\u2019s transaction infrastructure that a transaction\u2019s work is to be rolled back is to throw an Exception from code that is currently executing in the context of a transaction. The Spring Framework\u2019s transaction infrastructure code catches any unhandled Exception as it bubbles up the call stack and makes a determination whether to mark the transaction for rollback. In its default configuration, the Spring Framework\u2019s transaction infrastructure code marks a transaction for rollback only in the case of runtime, unchecked exceptions. That is, when the thrown exception is an instance or subclass of RuntimeException. (Error instances also, by default, result in a rollback). Checked exceptions that are thrown from a transactional method do not result in rollback in the default configuration. You can configure exactly which Exception types mark a transaction for rollback, including checked exceptions by specifying rollback rules.684", "chunk_char_count": 1242, "chunk_word_count": 180, "chunk_token_count": 310.5}, {"page_number": 685, "sentence_chunk": "\uf05a Rollback rules Rollback rules determine if a transaction should be rolled back when a given exception is thrown, and the rules are based on exception types or exception patterns. Rollback rules may be configured in XML via the rollback-for and no-rollback-for attributes, which allow rules to be defined as patterns. When using @Transactional, rollback rules may be configured via the rollbackFor/noRollbackFor and rollbackForClassName/noRollbackForClassName attributes, which allow rules to be defined based on exception types or patterns, respectively. When a rollback rule is defined with an exception type, that type will be used to match against the type of a thrown exception and its super types, providing type safety and avoiding any unintentional matches that may occur when using a pattern. For example, a value of jakarta.servlet. ServletException.class will only match thrown exceptions of type jakarta.servlet. ServletException and its subclasses. When a rollback rule is defined with an exception pattern, the pattern can be a fully qualified class name or a substring of a fully qualified class name for an exception type (which must be a subclass of Throwable), with no wildcard support at present. For example, a value of \"jakarta.servlet. ServletException\" or \"ServletException\" will match jakarta.servlet. ServletException and its subclasses.", "chunk_char_count": 1363, "chunk_word_count": 201, "chunk_token_count": 340.75}, {"page_number": 685, "sentence_chunk": "\uf071 You must carefully consider how specific a pattern is and whether to include package information (which isn\u2019t mandatory). For example, \"Exception\" will match nearly anything and will probably hide other rules. \"java.lang. Exception\" would be correct if \"Exception\" were meant to define a rule for all checked exceptions. With more unique exception names such as \"BaseBusinessException\" there is likely no need to use the fully qualified class name for the exception pattern. Furthermore, pattern-based rollback rules may result in unintentional matches for similarly named exceptions and nested classes. This is due to the fact that a thrown exception is considered to be a match for a given pattern-based rollback rule if the name of the thrown exception contains the exception pattern configured for the rollback rule. For example, given a rule configured to match on \"com.example. CustomException\", that rule will match against an exception named com.example. CustomExceptionV2 (an exception in the same package as CustomException but with an additional suffix) or an exception named com.example.", "chunk_char_count": 1101, "chunk_word_count": 166, "chunk_token_count": 275.25}, {"page_number": 685, "sentence_chunk": "CustomException$AnotherException (an exception declared as a nested class in CustomException). The following XML snippet demonstrates how to configure rollback for a checked, application- specific Exception type by supplying an exception pattern via the rollback-for attribute: 685", "chunk_char_count": 281, "chunk_word_count": 36, "chunk_token_count": 70.25}, {"page_number": 686, "sentence_chunk": "<tx:advice id=\"txAdvice\" transaction-manager=\"txManager\"> \u00a0  <tx:attributes> \u00a0  <tx:method name=\"get*\" read-only=\"true\" rollback-for=\"NoProductInStockException\"/> \u00a0  <tx:method name=\"*\"/> \u00a0  </tx:attributes> </tx:advice> If you do not want a transaction rolled back when an exception is thrown, you can also specify 'no rollback' rules. The following example tells the Spring Framework\u2019s transaction infrastructure to commit the attendant transaction even in the face of an unhandled InstrumentNotFoundException: <tx:advice id=\"txAdvice\"> \u00a0  <tx:attributes> \u00a0  <tx:method name=\"updateStock\" no-rollback-for=\"InstrumentNotFoundException\"/> \u00a0  <tx:method name=\"*\"/> \u00a0  </tx:attributes> </tx:advice> When the Spring Framework\u2019s transaction infrastructure catches an exception and consults the configured rollback rules to determine whether to mark the transaction for rollback, the strongest matching rule wins. So, in the case of the following configuration, any exception other than an InstrumentNotFoundException results in a rollback of the attendant transaction: <tx:advice id=\"txAdvice\"> \u00a0  <tx:attributes> \u00a0  <tx:method name=\"*\" rollback-for=\"Throwable\" no-rollback- for=\"InstrumentNotFoundException\"/> \u00a0  </tx:attributes> </tx:advice> You can also indicate a required rollback programmatically. Although simple, this process is quite invasive and tightly couples your code to the Spring Framework\u2019s transaction infrastructure. The following example shows how to programmatically indicate a required rollback: Java public void resolvePosition() { \u00a0  try { \u00a0    // some business logic... \u00a0  } catch (NoProductInStockException ex) { \u00a0    // trigger rollback programmatically \u00a0    TransactionAspectSupport.currentTransactionStatus().setRollbackOnly(); \u00a0  } } 686", "chunk_char_count": 1763, "chunk_word_count": 227, "chunk_token_count": 440.75}, {"page_number": 687, "sentence_chunk": "Kotlin fun resolvePosition() { \u00a0  try { \u00a0    // some business logic... \u00a0  } catch (ex: NoProductInStockException) { \u00a0    // trigger rollback programmatically \u00a0    TransactionAspectSupport.currentTransactionStatus().setRollbackOnly(); \u00a0  } } You are strongly encouraged to use the declarative approach to rollback, if at all possible. Programmatic rollback is available should you absolutely need it, but its usage flies in the face of achieving a clean POJO-based architecture. Configuring Different Transactional Semantics for Different Beans Consider the scenario where you have a number of service layer objects, and you want to apply a totally different transactional configuration to each of them. You can do so by defining distinct <aop:advisor/> elements with differing pointcut and advice-ref attribute values. As a point of comparison, first assume that all of your service layer classes are defined in a root x.y.service package. To make all beans that are instances of classes defined in that package (or in subpackages) and that have names ending in Service have the default transactional configuration, you could write the following: 687", "chunk_char_count": 1150, "chunk_word_count": 181, "chunk_token_count": 287.5}, {"page_number": 688, "sentence_chunk": "<?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:aop=\"http://www.springframework.org/schema/aop\" \u00a0  xmlns:tx=\"http://www.springframework.org/schema/tx\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/tx \u00a0    https://www.springframework.org/schema/tx/spring-tx.xsd \u00a0    http://www.springframework.org/schema/aop \u00a0    https://www.springframework.org/schema/aop/spring-aop.xsd\"> \u00a0  <aop:config> \u00a0    <aop:pointcut id=\"serviceOperation\" \u00a0        expression=\"execution(* x.y.service..*Service.*(..))\"/> \u00a0    <aop:advisor pointcut-ref=\"serviceOperation\" advice-ref=\"txAdvice\"/> \u00a0  </aop:config> \u00a0  <!--these two beans will be transactional... --> \u00a0  <bean id=\"fooService\" class=\"x.y.service. DefaultFooService\"/> \u00a0  <bean id=\"barService\" class=\"x.y.service.extras. SimpleBarService\"/> \u00a0  <!-- ...and these two beans won't --> \u00a0  <bean id=\"anotherService\" class=\"org.xyz. SomeService\"/> <!-- (not in the right package) --> \u00a0  <bean id=\"barManager\" class=\"x.y.service. SimpleBarManager\"/> <!-- (", "chunk_char_count": 1237, "chunk_word_count": 127, "chunk_token_count": 309.25}, {"page_number": 688, "sentence_chunk": "doesn't end in 'Service') --> \u00a0  <tx:advice id=\"txAdvice\"> \u00a0    <tx:attributes> \u00a0      <tx:method name=\"get*\" read-only=\"true\"/> \u00a0      <tx:method name=\"*\"/> \u00a0    </tx:attributes> \u00a0  </tx:advice> \u00a0  <!--other transaction infrastructure beans such as a TransactionManager omitted... --> </beans> The following example shows how to configure two distinct beans with totally different transactional settings: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" 688", "chunk_char_count": 507, "chunk_word_count": 73, "chunk_token_count": 126.75}, {"page_number": 689, "sentence_chunk": "xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:aop=\"http://www.springframework.org/schema/aop\" \u00a0  xmlns:tx=\"http://www.springframework.org/schema/tx\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/tx \u00a0    https://www.springframework.org/schema/tx/spring-tx.xsd \u00a0    http://www.springframework.org/schema/aop \u00a0    https://www.springframework.org/schema/aop/spring-aop.xsd\"> \u00a0  <aop:config> \u00a0    <aop:pointcut id=\"defaultServiceOperation\" \u00a0        expression=\"execution(* x.y.service.*Service.*(..))\"/> \u00a0    <aop:pointcut id=\"noTxServiceOperation\" \u00a0        expression=\"execution(* x.y.service.ddl. DefaultDdlManager.*(..))\"/> \u00a0    <aop:advisor pointcut-ref=\"defaultServiceOperation\" advice- ref=\"defaultTxAdvice\"/> \u00a0    <aop:advisor pointcut-ref=\"noTxServiceOperation\" advice-ref=\"noTxAdvice\"/> \u00a0  </aop:config> \u00a0  <!--this bean will be transactional (see the 'defaultServiceOperation' pointcut) --> \u00a0  <bean id=\"fooService\" class=\"x.y.service. DefaultFooService\"/> \u00a0  <!--this bean will also be transactional, but with totally different transactional settings --> \u00a0  <bean id=\"anotherFooService\" class=\"x.y.service.ddl. DefaultDdlManager\"/> \u00a0  <tx:advice id=\"defaultTxAdvice\"> \u00a0    <tx:attributes> \u00a0      <tx:method name=\"get*\" read-only=\"true\"/> \u00a0      <tx:method name=\"*\"/> \u00a0    </tx:attributes> \u00a0  </tx:advice> \u00a0  <tx:advice id=\"noTxAdvice\"> \u00a0    <tx:attributes> \u00a0      <tx:method name=\"*\" propagation=\"NEVER\"/> \u00a0    </tx:attributes> \u00a0  </tx:advice> \u00a0  <!--other transaction infrastructure beans such as a TransactionManager omitted... --> </beans> 689", "chunk_char_count": 1706, "chunk_word_count": 207, "chunk_token_count": 426.5}, {"page_number": 690, "sentence_chunk": "<tx:advice/> Settings This section summarizes the various transactional settings that you can specify by using the <tx:advice/> tag. The default <tx:advice/> settings are: \u2022 The propagation setting is REQUIRED. \u2022The isolation level is DEFAULT. \u2022The transaction is read-write. \u2022The transaction timeout defaults to the default timeout of the underlying transaction system or none if timeouts are not supported. \u2022Any RuntimeException triggers rollback, and any checked Exception does not. You can change these default settings. The following table summarizes the various attributes of the <tx:method/> tags that are nested within <tx:advice/> and <tx:attributes/> tags: Table 17.<tx:method/> settings Attribute Required?Default Description name Yes Method names with which the transaction attributes are to be associated.", "chunk_char_count": 818, "chunk_word_count": 112, "chunk_token_count": 204.5}, {"page_number": 690, "sentence_chunk": "The wildcard (*) character can be used to associate the same transaction attribute settings with a number of methods (for example, get*, handle*, on*Event, and so forth).propagation No REQUIRED Transaction propagation behavior.isolation No DEFAULT Transaction isolation level. Only applicable to propagation settings of REQUIRED or REQUIRES_NEW.timeout No -1 Transaction timeout (seconds). Only applicable to propagation REQUIRED or REQUIRES_NEW.read-only No false Read-write versus read- only transaction. Applies only to REQUIRED or REQUIRES_NEW.690", "chunk_char_count": 551, "chunk_word_count": 71, "chunk_token_count": 137.75}, {"page_number": 691, "sentence_chunk": "Attribute Required?Default Description rollback-for No Comma-delimited list of Exception instances that trigger rollback. For example, com.foo. MyBusinessExce ption,ServletException.no-rollback-for No Comma-delimited list of Exception instances that do not trigger rollback. For example, com.foo. MyBusinessExce ption,ServletException. Using @Transactional In addition to the XML-based declarative approach to transaction configuration, you can use an annotation-based approach. Declaring transaction semantics directly in the Java source code puts the declarations much closer to the affected code. There is not much danger of undue coupling, because code that is meant to be used transactionally is almost always deployed that way anyway.", "chunk_char_count": 740, "chunk_word_count": 94, "chunk_token_count": 185.0}, {"page_number": 691, "sentence_chunk": "\uf05a The standard jakarta.transaction. Transactional annotation is also supported as a drop-in replacement to Spring\u2019s own annotation. Please refer to the JTA documentation for more details. The ease-of-use afforded by the use of the @Transactional annotation is best illustrated with an example, which is explained in the text that follows. Consider the following class definition: 691", "chunk_char_count": 383, "chunk_word_count": 56, "chunk_token_count": 95.75}, {"page_number": 692, "sentence_chunk": "Java // the service class that we want to make transactional @Transactional public class DefaultFooService implements FooService { \u00a0  @Override \u00a0  public Foo getFoo(String fooName) { \u00a0    // ... \u00a0  } \u00a0  @Override \u00a0  public Foo getFoo(String fooName, String barName) { \u00a0    // ... \u00a0  } \u00a0  @Override \u00a0  public void insertFoo(Foo foo) { \u00a0    // ... \u00a0  } \u00a0  @Override \u00a0  public void updateFoo(Foo foo) { \u00a0    // ... \u00a0  } } Kotlin // the service class that we want to make transactional @Transactional class DefaultFooService : FooService { \u00a0  override fun getFoo(fooName: String): Foo { \u00a0    // ... \u00a0  } \u00a0  override fun getFoo(fooName: String, barName: String): Foo { \u00a0    // ... \u00a0  } \u00a0  override fun insertFoo(foo: Foo) { \u00a0    // ... \u00a0  } \u00a0  override fun updateFoo(foo: Foo) { \u00a0    // ... \u00a0  } } 692", "chunk_char_count": 796, "chunk_word_count": 184, "chunk_token_count": 199.0}, {"page_number": 693, "sentence_chunk": "Used at the class level as above, the annotation indicates a default for all methods of the declaring class (as well as its subclasses). Alternatively, each method can be annotated individually. See Method visibility and @Transactional for further details on which methods Spring considers transactional. Note that a class-level annotation does not apply to ancestor classes up the class hierarchy; in such a scenario, inherited methods need to be locally redeclared in order to participate in a subclass-level annotation. When a POJO class such as the one above is defined as a bean in a Spring context, you can make the bean instance transactional through an @EnableTransactionManagement annotation in a @Configuration class. See the javadoc for full details. In XML configuration, the <tx:annotation-driven/> tag provides similar convenience: <!--from the file 'context.xml' --> <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:aop=\"http://www.springframework.org/schema/aop\" \u00a0  xmlns:tx=\"http://www.springframework.org/schema/tx\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/tx \u00a0    https://www.springframework.org/schema/tx/spring-tx.xsd \u00a0    http://www.springframework.org/schema/aop \u00a0    https://www.springframework.org/schema/aop/spring-aop.xsd\"> \u00a0  <!--", "chunk_char_count": 1515, "chunk_word_count": 182, "chunk_token_count": 378.75}, {"page_number": 693, "sentence_chunk": "this is the service object that we want to make transactional --> \u00a0  <bean id=\"fooService\" class=\"x.y.service. DefaultFooService\"/> \u00a0  <!--enable the configuration of transactional behavior based on annotations --> \u00a0  <!--a TransactionManager is still required --> \u00a0  <tx:annotation-driven transaction-manager=\"txManager\"/> \u2460 \u00a0  <bean id=\"txManager\" class=\"org.springframework.jdbc.datasource. DataSourceTransactionManager\"> \u00a0    <!-- (this dependency is defined somewhere else) --> \u00a0    <property name=\"dataSource\" ref=\"dataSource\"/> \u00a0  </bean> \u00a0  <!--other <bean/> definitions here --> </beans> \u2460 The line that makes the bean instance transactional.693", "chunk_char_count": 654, "chunk_word_count": 88, "chunk_token_count": 163.5}, {"page_number": 694, "sentence_chunk": "\uf0eb You can omit the transaction-manager attribute in the <tx:annotation-driven/> tag if the bean name of the TransactionManager that you want to wire in has the name transactionManager. If the TransactionManager bean that you want to dependency- inject has any other name, you have to use the transaction-manager attribute, as in the preceding example. Reactive transactional methods use reactive return types in contrast to imperative programming arrangements as the following listing shows: Java // the reactive service class that we want to make transactional @Transactional public class DefaultFooService implements FooService { \u00a0  @Override \u00a0  public Publisher<Foo> getFoo(String fooName) { \u00a0    // ... \u00a0  } \u00a0  @Override \u00a0  public Mono<Foo> getFoo(String fooName, String barName) { \u00a0    // ... \u00a0  } \u00a0  @Override \u00a0  public Mono<Void> insertFoo(Foo foo) { \u00a0    // ... \u00a0  } \u00a0  @Override \u00a0  public Mono<Void> updateFoo(Foo foo) { \u00a0    // ... \u00a0  } } 694", "chunk_char_count": 952, "chunk_word_count": 171, "chunk_token_count": 238.0}, {"page_number": 695, "sentence_chunk": "Kotlin // the reactive service class that we want to make transactional @Transactional class DefaultFooService : FooService { \u00a0  override fun getFoo(fooName: String): Flow<Foo> { \u00a0    // ... \u00a0  } \u00a0  override fun getFoo(fooName: String, barName: String): Mono<Foo> { \u00a0    // ... \u00a0  } \u00a0  override fun insertFoo(foo: Foo): Mono<Void> { \u00a0    // ... \u00a0  } \u00a0  override fun updateFoo(foo: Foo): Mono<Void> { \u00a0    // ... \u00a0  } } Note that there are special considerations for the returned Publisher with regards to Reactive Streams cancellation signals. See the Cancel Signals section under \"Using the TransactionalOperator\" for more details.695", "chunk_char_count": 635, "chunk_word_count": 118, "chunk_token_count": 158.75}, {"page_number": 696, "sentence_chunk": "\uf05a Method visibility and @Transactional When you use transactional proxies with Spring\u2019s standard configuration, you should apply the @Transactional annotation only to methods with public visibility. If you do annotate protected, private, or package-visible methods with the @Transactional annotation, no error is raised, but the annotated method does not exhibit the configured transactional settings. If you need to annotate non-public methods, consider the tip in the following paragraph for class-based proxies or consider using AspectJ compile-time or load-time weaving (described later). When using @EnableTransactionManagement in a @Configuration class, protected or package-visible methods can also be made transactional for class-based proxies by registering a custom transactionAttributeSource bean like in the following example. Note, however, that transactional methods in interface-based proxies must always be public and defined in the proxied interface. /**\u00a0* Register a custom AnnotationTransactionAttributeSource with the \u00a0* publicMethodsOnly flag set to false to enable support for \u00a0* protected and package-private @Transactional methods in \u00a0* class-based proxies.\u00a0* \u00a0* @see ProxyTransactionManagementConfiguration#transactionAttributeSource() \u00a0*/ @Bean TransactionAttributeSource transactionAttributeSource() { \u00a0  return new AnnotationTransactionAttributeSource(false); } The Spring TestContext Framework supports non-private @Transactional test methods by default. See Transaction Management in the testing chapter for examples. You can apply the @Transactional annotation to an interface definition, a method on an interface, a class definition, or a method on a class. However, the mere presence of the @Transactional annotation is not enough to activate the transactional behavior.", "chunk_char_count": 1803, "chunk_word_count": 230, "chunk_token_count": 450.75}, {"page_number": 696, "sentence_chunk": "The @Transactional annotation is merely metadata that can be consumed by some runtime infrastructure that is @Transactional -aware and that can use the metadata to configure the appropriate beans with transactional behavior. In the preceding example, the <tx:annotation-driven/> element switches on the transactional behavior.696", "chunk_char_count": 329, "chunk_word_count": 44, "chunk_token_count": 82.25}, {"page_number": 697, "sentence_chunk": "\uf0eb The Spring team recommends that you annotate only concrete classes (and methods of concrete classes) with the @Transactional annotation, as opposed to annotating interfaces. You certainly can place the @Transactional annotation on an interface (or an interface method), but this works only as you would expect it to if you use interface-based proxies. The fact that Java annotations are not inherited from interfaces means that, if you use class-based proxies (proxy-target- class=\"true\") or the weaving-based aspect (mode=\"aspectj\"), the transaction settings are not recognized by the proxying and weaving infrastructure, and the object is not wrapped in a transactional proxy.\uf05a In proxy mode (which is the default), only external method calls coming in through the proxy are intercepted. This means that self-invocation (in effect, a method within the target object calling another method of the target object) does not lead to an actual transaction at runtime even if the invoked method is marked with @Transactional. Also, the proxy must be fully initialized to provide the expected behavior, so you should not rely on this feature in your initialization code\u2009\u2014\u2009for example, in a @PostConstruct method. Consider using AspectJ mode (see the mode attribute in the following table) if you expect self- invocations to be wrapped with transactions as well. In this case, there is no proxy in the first place. Instead, the target class is woven (that is, its byte code is modified) to support @Transactional runtime behavior on any kind of method. Table 18.", "chunk_char_count": 1557, "chunk_word_count": 244, "chunk_token_count": 389.25}, {"page_number": 697, "sentence_chunk": "Annotation driven transaction settings XML Attribute Annotation Attribute Default Description transaction-manager N/A (see TransactionManagementC onfigurer javadoc) transactionManager Name of the transaction manager to use. Required only if the name of the transaction manager is not transactionManager, as in the preceding example.697", "chunk_char_count": 335, "chunk_word_count": 41, "chunk_token_count": 83.75}, {"page_number": 698, "sentence_chunk": "XML Attribute Annotation Attribute Default Description mode mode proxy The default mode (proxy) processes annotated beans to be proxied by using Spring\u2019s AOP framework (following proxy semantics, as discussed earlier, applying to method calls coming in through the proxy only). The alternative mode (aspectj) instead weaves the affected classes with Spring\u2019s AspectJ transaction aspect, modifying the target class byte code to apply to any kind of method call. AspectJ weaving requires spring-aspects.jar in the classpath as well as having load-time weaving (or compile- time weaving) enabled. (See Spring configuration for details on how to set up load-time weaving.)698", "chunk_char_count": 671, "chunk_word_count": 98, "chunk_token_count": 167.75}, {"page_number": 699, "sentence_chunk": "XML Attribute Annotation Attribute Default Description proxy-target-class proxyTargetClass false Applies to proxy mode only. Controls what type of transactional proxies are created for classes annotated with the @Transactional annotation. If the proxy-target-class attribute is set to true, class-based proxies are created. If proxy- target-class is false or if the attribute is omitted, then standard JDK interface-based proxies are created. (See Proxying Mechanisms for a detailed examination of the different proxy types.)order order Ordered. LOWEST_PRECEDE NCE Defines the order of the transaction advice that is applied to beans annotated with @Transactional. (For more information about the rules related to ordering of AOP advice, see Advice Ordering.)No specified ordering means that the AOP subsystem determines the order of the advice.\uf05a The default advice mode for processing @Transactional annotations is proxy, which allows for interception of calls through the proxy only.", "chunk_char_count": 985, "chunk_word_count": 138, "chunk_token_count": 246.25}, {"page_number": 699, "sentence_chunk": "Local calls within the same class cannot get intercepted that way. For a more advanced mode of interception, consider switching to aspectj mode in combination with compile-time or load-time weaving.699", "chunk_char_count": 201, "chunk_word_count": 30, "chunk_token_count": 50.25}, {"page_number": 700, "sentence_chunk": "\uf05a The proxy-target-class attribute controls what type of transactional proxies are created for classes annotated with the @Transactional annotation. If proxy-target- class is set to true, class-based proxies are created. If proxy-target-class is false or if the attribute is omitted, standard JDK interface-based proxies are created. (See Proxying Mechanisms for a discussion of the different proxy types.)\uf05a @EnableTransactionManagement and <tx:annotation-driven/> look for @Transactional only on beans in the same application context in which they are defined. This means that, if you put annotation-driven configuration in a WebApplicationContext for a DispatcherServlet, it checks for @Transactional beans only in your controllers and not in your services. See MVC for more information. The most derived location takes precedence when evaluating the transactional settings for a method. In the case of the following example, the DefaultFooService class is annotated at the class level with the settings for a read-only transaction, but the @Transactional annotation on the updateFoo(Foo) method in the same class takes precedence over the transactional settings defined at the class level. Java @Transactional(readOnly = true) public class DefaultFooService implements FooService { \u00a0  public Foo getFoo(String fooName) { \u00a0    // ... \u00a0  } \u00a0  // these settings have precedence for this method \u00a0  @Transactional(readOnly = false, propagation = Propagation.", "chunk_char_count": 1456, "chunk_word_count": 213, "chunk_token_count": 364.0}, {"page_number": 701, "sentence_chunk": "Kotlin @Transactional(readOnly = true) class DefaultFooService : FooService { \u00a0  override fun getFoo(fooName: String): Foo { \u00a0    // ... \u00a0  } \u00a0  // these settings have precedence for this method \u00a0  @Transactional(readOnly = false, propagation = Propagation. REQUIRES_NEW) \u00a0  override fun updateFoo(foo: Foo) { \u00a0    // ... \u00a0  } } @Transactional Settings The @Transactional annotation is metadata that specifies that an interface, class, or method must have transactional semantics (for example, \"start a brand new read-only transaction when this method is invoked, suspending any existing transaction\"). The default @Transactional settings are as follows: \u2022 The propagation setting is PROPAGATION_REQUIRED. \u2022The isolation level is ISOLATION_DEFAULT. \u2022The transaction is read-write. \u2022The transaction timeout defaults to the default timeout of the underlying transaction system, or to none if timeouts are not supported. \u2022Any RuntimeException or Error triggers rollback, and any checked Exception does not. You can change these default settings. The following table summarizes the various properties of the @Transactional annotation: Table 19.@Transactional Settings Property Type Description value String Optional qualifier that specifies the transaction manager to be used.", "chunk_char_count": 1272, "chunk_word_count": 188, "chunk_token_count": 318.0}, {"page_number": 701, "sentence_chunk": "transactionManager String Alias for value.label Array of String labels to add an expressive description to the transaction. Labels may be evaluated by transaction managers to associate implementation- specific behavior with the actual transaction.propagation enum: Propagation Optional propagation setting.701", "chunk_char_count": 309, "chunk_word_count": 38, "chunk_token_count": 77.25}, {"page_number": 702, "sentence_chunk": "Property Type Description isolation enum: Isolation Optional isolation level. Applies only to propagation values of REQUIRED or REQUIRES_NEW.timeout int (in seconds of granularity) Optional transaction timeout. Applies only to propagation values of REQUIRED or REQUIRES_NEW.timeoutString String (in seconds of granularity) Alternative for specifying the timeout in seconds as a String value\u2009\u2014\u2009for example, as a placeholder.readOnly boolean Read-write versus read-only transaction. Only applicable to values of REQUIRED or REQUIRES_NEW.rollbackFor Array of Class objects, which must be derived from Throwable. Optional array of exception types that must cause rollback.rollbackForClassName Array of exception name patterns.", "chunk_char_count": 722, "chunk_word_count": 92, "chunk_token_count": 180.5}, {"page_number": 702, "sentence_chunk": "Optional array of exception name patterns that must cause rollback.noRollbackFor Array of Class objects, which must be derived from Throwable. Optional array of exception types that must not cause rollback.noRollbackForClassName Array of exception name patterns. Optional array of exception name patterns that must not cause rollback.\uf0eb See Rollback rules for further details on rollback rule semantics, patterns, and warnings regarding possible unintentional matches for pattern-based rollback rules. Currently, you cannot have explicit control over the name of a transaction, where 'name' means the transaction name that appears in a transaction monitor, if applicable (for example, WebLogic\u2019s transaction monitor), and in logging output. For declarative transactions, the transaction name is always the fully-qualified class name + .+ the method name of the transactionally advised class. For example, if the handlePayment(..) method of the BusinessService class started a transaction, the name of the transaction would be: com.example.", "chunk_char_count": 1038, "chunk_word_count": 145, "chunk_token_count": 259.5}, {"page_number": 702, "sentence_chunk": "BusinessService.handlePayment. Multiple Transaction Managers with @Transactional Most Spring applications need only a single transaction manager, but there may be situations where you want multiple independent transaction managers in a single application. You can use the value or transactionManager attribute of the @Transactional annotation to optionally specify the 702", "chunk_char_count": 372, "chunk_word_count": 48, "chunk_token_count": 93.0}, {"page_number": 703, "sentence_chunk": "identity of the TransactionManager to be used. This can either be the bean name or the qualifier value of the transaction manager bean. For example, using the qualifier notation, you can combine the following Java code with the following transaction manager bean declarations in the application context: Java public class TransactionalService { \u00a0  @Transactional(\"order\") \u00a0  public void setSomething(String name) { ... } \u00a0  @Transactional(\"account\") \u00a0  public void doSomething() { ... } \u00a0  @Transactional(\"reactive-account\") \u00a0  public Mono<Void> doSomethingReactive() { ... } } Kotlin class TransactionalService { \u00a0  @Transactional(\"order\") \u00a0  fun setSomething(name: String) { \u00a0    // ... \u00a0  } \u00a0  @Transactional(\"account\") \u00a0  fun doSomething() { \u00a0    // ... \u00a0  } \u00a0  @Transactional(\"reactive-account\") \u00a0  fun doSomethingReactive(): Mono<Void> { \u00a0    // ... \u00a0  } } The following listing shows the bean declarations: 703", "chunk_char_count": 917, "chunk_word_count": 153, "chunk_token_count": 229.25}, {"page_number": 704, "sentence_chunk": "<tx:annotation-driven/> \u00a0  <bean id=\"transactionManager1\" class=\"org.springframework.jdbc.datasource. DataSourceTransactionManager\"> \u00a0    ... \u00a0    <qualifier value=\"order\"/> \u00a0  </bean> \u00a0  <bean id=\"transactionManager2\" class=\"org.springframework.jdbc.datasource. DataSourceTransactionManager\"> \u00a0    ... \u00a0    <qualifier value=\"account\"/> \u00a0  </bean> \u00a0  <bean id=\"transactionManager3\" class=\"org.springframework.data.r2dbc.connectionfactory. R2dbcTransactionManager\"> \u00a0    ... \u00a0    <qualifier value=\"reactive-account\"/> \u00a0  </bean> In this case, the individual methods on TransactionalService run under separate transaction managers, differentiated by the order, account, and reactive-account qualifiers. The default <tx:annotation-driven> target bean name, transactionManager, is still used if no specifically qualified TransactionManager bean is found. Custom Composed Annotations If you find you repeatedly use the same attributes with @Transactional on many different methods, Spring\u2019s meta-annotation support lets you define custom composed annotations for your specific use cases. For example, consider the following annotation definitions: Java @Target({ElementType. METHOD, ElementType. TYPE}) @Retention(RetentionPolicy. RUNTIME) @Transactional(transactionManager = \"order\", label = \"causal-consistency\") public @interface OrderTx { } @Target({ElementType.", "chunk_char_count": 1361, "chunk_word_count": 158, "chunk_token_count": 340.25}, {"page_number": 704, "sentence_chunk": "METHOD, ElementType. TYPE}) @Retention(RetentionPolicy. RUNTIME) @Transactional(transactionManager = \"account\", label = \"retryable\") public @interface AccountTx { } 704", "chunk_char_count": 168, "chunk_word_count": 17, "chunk_token_count": 42.0}, {"page_number": 705, "sentence_chunk": "Kotlin @Target(AnnotationTarget. FUNCTION, AnnotationTarget. TYPE) @Retention(AnnotationRetention. RUNTIME) @Transactional(transactionManager = \"order\", label = [\"causal-consistency\"]) annotation class OrderTx @Target(AnnotationTarget. FUNCTION, AnnotationTarget. TYPE) @Retention(AnnotationRetention. RUNTIME) @Transactional(transactionManager = \"account\", label = [\"retryable\"]) annotation class AccountTx The preceding annotations let us write the example from the previous section as follows: Java public class TransactionalService { \u00a0  @OrderTx \u00a0  public void setSomething(String name) { \u00a0    // ... \u00a0  } \u00a0  @AccountTx \u00a0  public void doSomething() { \u00a0    // ... \u00a0  } } Kotlin class TransactionalService { \u00a0  @OrderTx \u00a0  fun setSomething(name: String) { \u00a0    // ... \u00a0  } \u00a0  @AccountTx \u00a0  fun doSomething() { \u00a0    // ... \u00a0  } } In the preceding example, we used the syntax to define the transaction manager qualifier and transactional labels, but we could also have included propagation behavior, rollback rules, timeouts, and other features.705", "chunk_char_count": 1048, "chunk_word_count": 159, "chunk_token_count": 262.0}, {"page_number": 706, "sentence_chunk": "Transaction Propagation This section describes some semantics of transaction propagation in Spring. Note that this section is not a proper introduction to transaction propagation. Rather, it details some of the semantics regarding transaction propagation in Spring. In Spring-managed transactions, be aware of the difference between physical and logical transactions, and how the propagation setting applies to this difference. Understanding PROPAGATION_REQUIRED PROPAGATION_REQUIRED enforces a physical transaction, either locally for the current scope if no transaction exists yet or participating in an existing 'outer' transaction defined for a larger scope. This is a fine default in common call stack arrangements within the same thread (for example, a service facade that delegates to several repository methods where all the underlying resources have to participate in the service-level transaction).\uf05a By default, a participating transaction joins the characteristics of the outer scope, silently ignoring the local isolation level, timeout value, or read-only flag (if any). Consider switching the validateExistingTransactions flag to true on your transaction manager if you want isolation level declarations to be rejected when participating in an existing transaction with a different isolation level. This non- lenient mode also rejects read-only mismatches (that is, an inner read-write transaction that tries to participate in a read-only outer scope). When the propagation setting is PROPAGATION_REQUIRED, a logical transaction scope is created for each method upon which the setting is applied.", "chunk_char_count": 1610, "chunk_word_count": 225, "chunk_token_count": 402.5}, {"page_number": 706, "sentence_chunk": "Each such logical transaction scope can determine rollback-only status individually, with an outer transaction scope being logically independent from the inner transaction scope. In the case of standard PROPAGATION_REQUIRED behavior, all these scopes are mapped to the same physical transaction. So a rollback-only marker set in the inner transaction scope does affect the outer transaction\u2019s chance to actually commit. However, in the case where an inner transaction scope sets the rollback-only marker, the outer transaction has not decided on the rollback itself, so the rollback (silently triggered by the inner transaction scope) is unexpected. A corresponding UnexpectedRollbackException is thrown at that 706", "chunk_char_count": 715, "chunk_word_count": 102, "chunk_token_count": 178.75}, {"page_number": 707, "sentence_chunk": "point. This is expected behavior so that the caller of a transaction can never be misled to assume that a commit was performed when it really was not. So, if an inner transaction (of which the outer caller is not aware) silently marks a transaction as rollback-only, the outer caller still calls commit. The outer caller needs to receive an UnexpectedRollbackException to indicate clearly that a rollback was performed instead. Understanding PROPAGATION_REQUIRES_NEW PROPAGATION_REQUIRES_NEW, in contrast to PROPAGATION_REQUIRED, always uses an independent physical transaction for each affected transaction scope, never participating in an existing transaction for an outer scope. In such an arrangement, the underlying resource transactions are different and, hence, can commit or roll back independently, with an outer transaction not affected by an inner transaction\u2019s rollback status and with an inner transaction\u2019s locks released immediately after its completion. Such an independent inner transaction can also declare its own isolation level, timeout, and read-only settings and not inherit an outer transaction\u2019s characteristics. Understanding PROPAGATION_NESTED PROPAGATION_NESTED uses a single physical transaction with multiple savepoints that it can roll back to. Such partial rollbacks let an inner transaction scope trigger a rollback for its scope, with the outer transaction being able to continue the physical transaction despite some operations having been rolled back. This setting is typically mapped onto JDBC savepoints, so it works only with JDBC resource transactions.", "chunk_char_count": 1592, "chunk_word_count": 227, "chunk_token_count": 398.0}, {"page_number": 707, "sentence_chunk": "See Spring\u2019s DataSourceTransactionManager. Advising Transactional Operations Suppose you want to run both transactional operations and some basic profiling advice. How do you effect this in the context of <tx:annotation-driven/>?When you invoke the updateFoo(Foo) method, you want to see the following actions: \u2022 The configured profiling aspect starts. \u2022The transactional advice runs. \u2022The method on the advised object runs. \u2022The transaction commits. \u2022The profiling aspect reports the exact duration of the whole transactional method invocation.707", "chunk_char_count": 548, "chunk_word_count": 74, "chunk_token_count": 137.0}, {"page_number": 708, "sentence_chunk": "\uf05a This chapter is not concerned with explaining AOP in any great detail (except as it applies to transactions). See AOP for detailed coverage of the AOP configuration and AOP in general. The following code shows the simple profiling aspect discussed earlier: Java package x.y; import org.aspectj.lang. ProceedingJoinPoint; import org.springframework.util. StopWatch; import org.springframework.core. Ordered; public class SimpleProfiler implements Ordered { \u00a0  private int order; \u00a0  // allows us to control the ordering of advice \u00a0  public int getOrder() { \u00a0    return this.order; \u00a0  } \u00a0  public void setOrder(int order) { \u00a0    this.order = order; \u00a0  } \u00a0  // this method is the around advice \u00a0  public Object profile(ProceedingJoinPoint call) throws Throwable { \u00a0    Object returnValue; \u00a0    StopWatch clock = new StopWatch(getClass().getName()); \u00a0    try { \u00a0      clock.start(call.toShortString()); \u00a0      returnValue = call.proceed(); \u00a0    } finally { \u00a0      clock.stop(); \u00a0      System.out.println(clock.prettyPrint()); \u00a0    } \u00a0    return returnValue; \u00a0  } } 708", "chunk_char_count": 1065, "chunk_word_count": 200, "chunk_token_count": 266.25}, {"page_number": 709, "sentence_chunk": "Kotlin class SimpleProfiler : Ordered { \u00a0  private var order: Int = 0 \u00a0  // allows us to control the ordering of advice \u00a0  override fun getOrder(): Int { \u00a0    return this.order \u00a0  } \u00a0  fun setOrder(order: Int) { \u00a0    this.order = order \u00a0  } \u00a0  // this method is the around advice \u00a0  fun profile(call: ProceedingJoinPoint): Any { \u00a0    var returnValue: Any \u00a0    val clock = StopWatch(javaClass.name) \u00a0    try { \u00a0      clock.start(call.toShortString()) \u00a0      returnValue = call.proceed() \u00a0    } finally { \u00a0      clock.stop() \u00a0      println(clock.prettyPrint()) \u00a0    } \u00a0    return returnValue \u00a0  } } The ordering of advice is controlled through the Ordered interface. For full details on advice ordering, see Advice ordering. The following configuration creates a fooService bean that has profiling and transactional aspects applied to it in the desired order: 709", "chunk_char_count": 861, "chunk_word_count": 186, "chunk_token_count": 215.25}, {"page_number": 710, "sentence_chunk": "<?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:aop=\"http://www.springframework.org/schema/aop\" \u00a0  xmlns:tx=\"http://www.springframework.org/schema/tx\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/tx \u00a0    https://www.springframework.org/schema/tx/spring-tx.xsd \u00a0    http://www.springframework.org/schema/aop \u00a0    https://www.springframework.org/schema/aop/spring-aop.xsd\"> \u00a0  <bean id=\"fooService\" class=\"x.y.service. DefaultFooService\"/> \u00a0  <!--this is the aspect --> \u00a0  <bean id=\"profiler\" class=\"x.y. SimpleProfiler\"> \u00a0    <!--run before the transactional advice (hence the lower order number) --> \u00a0    <property name=\"order\" value=\"1\"/> \u00a0  </bean> \u00a0  <tx:annotation-driven transaction-manager=\"txManager\" order=\"200\"/> \u00a0  <aop:config> \u00a0      <!--this advice runs around the transactional advice --> \u00a0      <aop:aspect id=\"profilingAspect\" ref=\"profiler\"> \u00a0        <aop:pointcut id=\"serviceMethodWithReturnValue\" \u00a0            expression=\"execution(!void x.y..*Service.*(..))\"/> \u00a0        <aop:around method=\"profile\" pointcut- ref=\"serviceMethodWithReturnValue\"/> \u00a0      </aop:aspect> \u00a0  </aop:config> \u00a0  <bean id=\"dataSource\" class=\"org.apache.commons.dbcp. BasicDataSource\" destroy- method=\"close\"> \u00a0    <property name=\"driverClassName\" value=\"oracle.jdbc.driver. OracleDriver\"/> \u00a0    <property name=\"url\" value=\"jdbc:oracle:thin:@rj-t42:1521:elvis\"/> \u00a0    <property name=\"username\" value=\"scott\"/> \u00a0    <property name=\"password\" value=\"tiger\"/> \u00a0  </bean> \u00a0  <bean id=\"txManager\" class=\"org.springframework.jdbc.datasource.", "chunk_char_count": 1781, "chunk_word_count": 213, "chunk_token_count": 445.25}, {"page_number": 710, "sentence_chunk": "DataSourceTransactionManager\"> \u00a0    <property name=\"dataSource\" ref=\"dataSource\"/> \u00a0  </bean> </beans> You can configure any number of additional aspects in similar fashion.710", "chunk_char_count": 176, "chunk_word_count": 23, "chunk_token_count": 44.0}, {"page_number": 711, "sentence_chunk": "The following example creates the same setup as the previous two examples but uses the purely XML declarative approach: 711", "chunk_char_count": 123, "chunk_word_count": 20, "chunk_token_count": 30.75}, {"page_number": 712, "sentence_chunk": "<?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:aop=\"http://www.springframework.org/schema/aop\" \u00a0  xmlns:tx=\"http://www.springframework.org/schema/tx\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/tx \u00a0    https://www.springframework.org/schema/tx/spring-tx.xsd \u00a0    http://www.springframework.org/schema/aop \u00a0    https://www.springframework.org/schema/aop/spring-aop.xsd\"> \u00a0  <bean id=\"fooService\" class=\"x.y.service. DefaultFooService\"/> \u00a0  <!--the profiling advice --> \u00a0  <bean id=\"profiler\" class=\"x.y. SimpleProfiler\"> \u00a0    <!--run before the transactional advice (hence the lower order number) --> \u00a0    <property name=\"order\" value=\"1\"/> \u00a0  </bean> \u00a0  <aop:config> \u00a0    <aop:pointcut id=\"entryPointMethod\" expression=\"execution(* x.y..*Service.*(..))\"/> \u00a0    <!--runs after the profiling advice (cf.the order attribute) --> \u00a0    <aop:advisor advice-ref=\"txAdvice\" pointcut-ref=\"entryPointMethod\" order=\"2\"/> \u00a0    <!--order value is higher than the profiling aspect --> \u00a0    <aop:aspect id=\"profilingAspect\" ref=\"profiler\"> \u00a0      <aop:pointcut id=\"serviceMethodWithReturnValue\" \u00a0          expression=\"execution(!void x.y..*Service.*(..))\"/> \u00a0      <aop:around method=\"profile\" pointcut-ref=\"serviceMethodWithReturnValue\"/> \u00a0    </aop:aspect> \u00a0  </aop:config> \u00a0  <tx:advice id=\"txAdvice\" transaction-manager=\"txManager\"> \u00a0    <tx:attributes> \u00a0      <tx:method name=\"get*\" read-only=\"true\"/> \u00a0      <tx:method name=\"*\"/> \u00a0    </tx:attributes> \u00a0  </tx:advice> \u00a0  <!--", "chunk_char_count": 1722, "chunk_word_count": 217, "chunk_token_count": 430.5}, {"page_number": 712, "sentence_chunk": "other <bean/> definitions such as a DataSource and a TransactionManager here --> </beans> The result of the preceding configuration is a fooService bean that has profiling and transactional 712", "chunk_char_count": 193, "chunk_word_count": 29, "chunk_token_count": 48.25}, {"page_number": 713, "sentence_chunk": "aspects applied to it in that order. If you want the profiling advice to run after the transactional advice on the way in and before the transactional advice on the way out, you can swap the value of the profiling aspect bean\u2019s order property so that it is higher than the transactional advice\u2019s order value. You can configure additional aspects in similar fashion. Using @Transactional with AspectJ You can also use the Spring Framework\u2019s @Transactional support outside of a Spring container by means of an AspectJ aspect. To do so, first annotate your classes (and optionally your classes' methods) with the @Transactional annotation, and then link (weave) your application with the org.springframework.transaction.aspectj. AnnotationTransactionAspect defined in the spring- aspects.jar file. You must also configure the aspect with a transaction manager. You can use the Spring Framework\u2019s IoC container to take care of dependency-injecting the aspect. The simplest way to configure the transaction management aspect is to use the <tx:annotation-driven/> element and specify the mode attribute to aspectj as described in Using @Transactional. Because we focus here on applications that run outside of a Spring container, we show you how to do it programmatically.", "chunk_char_count": 1266, "chunk_word_count": 192, "chunk_token_count": 316.5}, {"page_number": 713, "sentence_chunk": "\uf05a Prior to continuing, you may want to read Using @Transactional and AOP respectively. The following example shows how to create a transaction manager and configure the AnnotationTransactionAspect to use it: Java // construct an appropriate transaction manager DataSourceTransactionManager txManager = new DataSourceTransactionManager(getDataSource()); // configure the AnnotationTransactionAspect to use it; this must be done before executing any transactional methods AnnotationTransactionAspect.aspectOf().setTransactionManager(txManager); Kotlin // construct an appropriate transaction manager val txManager = DataSourceTransactionManager(getDataSource()) // configure the AnnotationTransactionAspect to use it; this must be done before executing any transactional methods AnnotationTransactionAspect.aspectOf().transactionManager = txManager 713", "chunk_char_count": 850, "chunk_word_count": 91, "chunk_token_count": 212.5}, {"page_number": 714, "sentence_chunk": "\uf05a When you use this aspect, you must annotate the implementation class (or the methods within that class or both), not the interface (if any) that the class implements. AspectJ follows Java\u2019s rule that annotations on interfaces are not inherited. The @Transactional annotation on a class specifies the default transaction semantics for the execution of any public method in the class. The @Transactional annotation on a method within the class overrides the default transaction semantics given by the class annotation (if present). You can annotate any method, regardless of visibility. To weave your applications with the AnnotationTransactionAspect, you must either build your application with AspectJ (see the AspectJ Development Guide) or use load-time weaving. See Load- time weaving with AspectJ in the Spring Framework for a discussion of load-time weaving with AspectJ. 4.1.5. Programmatic Transaction Management The Spring Framework provides two means of programmatic transaction management, by using: \u2022 The TransactionTemplate or TransactionalOperator. \u2022A TransactionManager implementation directly. The Spring team generally recommends the TransactionTemplate for programmatic transaction management in imperative flows and TransactionalOperator for reactive code.", "chunk_char_count": 1275, "chunk_word_count": 176, "chunk_token_count": 318.75}, {"page_number": 714, "sentence_chunk": "The second approach is similar to using the JTA UserTransaction API, although exception handling is less cumbersome. Using the TransactionTemplate The TransactionTemplate adopts the same approach as other Spring templates, such as the JdbcTemplate. It uses a callback approach (to free application code from having to do the boilerplate acquisition and release transactional resources) and results in code that is intention driven, in that your code focuses solely on what you want to do.\uf05a As the examples that follow show, using the TransactionTemplate absolutely couples you to Spring\u2019s transaction infrastructure and APIs. Whether or not programmatic transaction management is suitable for your development needs is a decision that you have to make yourself. Application code that must run in a transactional context and that explicitly uses the TransactionTemplate resembles the next example. You, as an application developer, can write a TransactionCallback implementation (typically expressed as an anonymous inner class) that contains the code that you need to run in the context of a transaction. You can then pass an instance of your custom TransactionCallback to the execute(..) method exposed on the TransactionTemplate. The following example shows how to do so: 714", "chunk_char_count": 1277, "chunk_word_count": 191, "chunk_token_count": 319.25}, {"page_number": 715, "sentence_chunk": "Java public class SimpleService implements Service { \u00a0  // single TransactionTemplate shared amongst all methods in this instance \u00a0  private final TransactionTemplate transactionTemplate; \u00a0  // use constructor-injection to supply the PlatformTransactionManager \u00a0  public SimpleService(PlatformTransactionManager transactionManager) { \u00a0    this.transactionTemplate = new TransactionTemplate(transactionManager); \u00a0  } \u00a0  public Object someServiceMethod() { \u00a0    return transactionTemplate.execute(new TransactionCallback() { \u00a0      // the code in this method runs in a transactional context \u00a0      public Object doInTransaction(TransactionStatus status) { \u00a0        updateOperation1(); \u00a0        return resultOfUpdateOperation2(); \u00a0      } \u00a0    }); \u00a0  } } Kotlin // use constructor-injection to supply the PlatformTransactionManager class SimpleService(transactionManager: PlatformTransactionManager) : Service { \u00a0  // single TransactionTemplate shared amongst all methods in this instance \u00a0  private val transactionTemplate = TransactionTemplate(transactionManager) \u00a0  fun someServiceMethod() = transactionTemplate.execute<Any?> { \u00a0    updateOperation1() \u00a0    resultOfUpdateOperation2() \u00a0  } } If there is no return value, you can use the convenient TransactionCallbackWithoutResult class with an anonymous class, as follows: Java transactionTemplate.execute(new TransactionCallbackWithoutResult() { \u00a0  protected void doInTransactionWithoutResult(TransactionStatus status) { \u00a0    updateOperation1(); \u00a0    updateOperation2(); \u00a0  } }); 715", "chunk_char_count": 1534, "chunk_word_count": 227, "chunk_token_count": 383.5}, {"page_number": 716, "sentence_chunk": "Kotlin transactionTemplate.execute(object : TransactionCallbackWithoutResult() { \u00a0  override fun doInTransactionWithoutResult(status: TransactionStatus) { \u00a0    updateOperation1() \u00a0    updateOperation2() \u00a0  } }) Code within the callback can roll the transaction back by calling the setRollbackOnly() method on the supplied TransactionStatus object, as follows: Java transactionTemplate.execute(new TransactionCallbackWithoutResult() { \u00a0  protected void doInTransactionWithoutResult(TransactionStatus status) { \u00a0    try { \u00a0      updateOperation1(); \u00a0      updateOperation2(); \u00a0    } catch (SomeBusinessException ex) { \u00a0      status.setRollbackOnly(); \u00a0    } \u00a0  } }); Kotlin transactionTemplate.execute(object : TransactionCallbackWithoutResult() { \u00a0  override fun doInTransactionWithoutResult(status: TransactionStatus) { \u00a0    try { \u00a0      updateOperation1() \u00a0      updateOperation2() \u00a0    } catch (ex: SomeBusinessException) { \u00a0      status.setRollbackOnly() \u00a0    } \u00a0  } }) Specifying Transaction Settings You can specify transaction settings (such as the propagation mode, the isolation level, the timeout, and so forth) on the TransactionTemplate either programmatically or in configuration. By default, TransactionTemplate instances have the default transactional settings. The following example shows the programmatic customization of the transactional settings for a specific TransactionTemplate: 716", "chunk_char_count": 1404, "chunk_word_count": 214, "chunk_token_count": 351.0}, {"page_number": 717, "sentence_chunk": "Java public class SimpleService implements Service { \u00a0  private final TransactionTemplate transactionTemplate; \u00a0  public SimpleService(PlatformTransactionManager transactionManager) { \u00a0    this.transactionTemplate = new TransactionTemplate(transactionManager); \u00a0    // the transaction settings can be set here explicitly if so desired \u00a0 this.transactionTemplate.setIsolationLevel(TransactionDefinition. ISOLATION_READ_UNCOMM ITTED); \u00a0    this.transactionTemplate.setTimeout(30); // 30 seconds \u00a0    // and so forth... \u00a0  } } Kotlin class SimpleService(transactionManager: PlatformTransactionManager) : Service { \u00a0  private val transactionTemplate = TransactionTemplate(transactionManager).apply { \u00a0    // the transaction settings can be set here explicitly if so desired \u00a0    isolationLevel = TransactionDefinition. ISOLATION_READ_UNCOMMITTED \u00a0    timeout = 30 // 30 seconds \u00a0    // and so forth... \u00a0  } } The following example defines a TransactionTemplate with some custom transactional settings by using Spring XML configuration: <bean id=\"sharedTransactionTemplate\" \u00a0    class=\"org.springframework.transaction.support. TransactionTemplate\"> \u00a0  <property name=\"isolationLevelName\" value=\"ISOLATION_READ_UNCOMMITTED\"/> \u00a0  <property name=\"timeout\" value=\"30\"/> </bean> You can then inject the sharedTransactionTemplate into as many services as are required. Finally, instances of the TransactionTemplate class are thread-safe, in that instances do not maintain any conversational state. TransactionTemplate instances do, however, maintain configuration state. So, while a number of classes may share a single instance of a TransactionTemplate, if a class needs to use a TransactionTemplate with different settings (for example, a different isolation level), you need to create two distinct TransactionTemplate instances.717", "chunk_char_count": 1823, "chunk_word_count": 239, "chunk_token_count": 455.75}, {"page_number": 718, "sentence_chunk": "Using the TransactionalOperator The TransactionalOperator follows an operator design that is similar to other reactive operators. It uses a callback approach (to free application code from having to do the boilerplate acquisition and release transactional resources) and results in code that is intention driven, in that your code focuses solely on what you want to do.\uf05a As the examples that follow show, using the TransactionalOperator absolutely couples you to Spring\u2019s transaction infrastructure and APIs. Whether or not programmatic transaction management is suitable for your development needs is a decision that you have to make yourself. Application code that must run in a transactional context and that explicitly uses the TransactionalOperator resembles the next example: Java public class SimpleService implements Service { \u00a0  // single TransactionalOperator shared amongst all methods in this instance \u00a0  private final TransactionalOperator transactionalOperator; \u00a0  // use constructor-injection to supply the ReactiveTransactionManager \u00a0  public SimpleService(ReactiveTransactionManager transactionManager) { \u00a0    this.transactionalOperator = TransactionalOperator.create(transactionManager); \u00a0  } \u00a0  public Mono<Object> someServiceMethod() { \u00a0    // the code in this method runs in a transactional context \u00a0    Mono<Object> update = updateOperation1(); \u00a0    return update.then(resultOfUpdateOperation2).as(transactionalOperator::transactional); \u00a0  } } 718", "chunk_char_count": 1469, "chunk_word_count": 204, "chunk_token_count": 367.25}, {"page_number": 719, "sentence_chunk": "Kotlin // use constructor-injection to supply the ReactiveTransactionManager class SimpleService(transactionManager: ReactiveTransactionManager) : Service { \u00a0  // single TransactionalOperator shared amongst all methods in this instance \u00a0  private val transactionalOperator = TransactionalOperator.create(transactionManager) \u00a0  suspend fun someServiceMethod() = transactionalOperator.executeAndAwait<Any?> { \u00a0    updateOperation1() \u00a0    resultOfUpdateOperation2() \u00a0  } } TransactionalOperator can be used in two ways: \u2022 Operator-style using Project Reactor types (mono.as(transactionalOperator::transactional)) \u2022 Callback-style for every other case (transactionalOperator.execute(TransactionCallback<T>)) Code within the callback can roll the transaction back by calling the setRollbackOnly() method on the supplied ReactiveTransaction object, as follows: Java transactionalOperator.execute(new TransactionCallback<>() { \u00a0  public Mono<Object> doInTransaction(ReactiveTransaction status) { \u00a0    return updateOperation1().then(updateOperation2) \u00a0          .doOnError(SomeBusinessException.class, e -> status.setRollbackOnly()); \u00a0    } \u00a0  } }); Kotlin transactionalOperator.execute(object : TransactionCallback() { \u00a0  override fun doInTransactionWithoutResult(status: ReactiveTransaction) { \u00a0    updateOperation1().then(updateOperation2) \u00a0          .doOnError(SomeBusinessException.class, e -> status.setRollbackOnly()) \u00a0  } }) Cancel Signals In Reactive Streams, a Subscriber can cancel its Subscription and stop its Publisher. Operators in 719", "chunk_char_count": 1542, "chunk_word_count": 190, "chunk_token_count": 385.5}, {"page_number": 720, "sentence_chunk": "Project Reactor, as well as in other libraries, such as next(), take(long), timeout(Duration), and others can issue cancellations. There is no way to know the reason for the cancellation, whether it is due to an error or a simply lack of interest to consume further. Since version 5.3 cancel signals lead to a roll back. As a result it is important to consider the operators used downstream from a transaction Publisher. In particular in the case of a Flux or other multi-value Publisher, the full output must be consumed to allow the transaction to complete. Specifying Transaction Settings You can specify transaction settings (such as the propagation mode, the isolation level, the timeout, and so forth) for the TransactionalOperator. By default, TransactionalOperator instances have default transactional settings. The following example shows customization of the transactional settings for a specific TransactionalOperator: Java public class SimpleService implements Service { \u00a0  private final TransactionalOperator transactionalOperator; \u00a0  public SimpleService(ReactiveTransactionManager transactionManager) { \u00a0    DefaultTransactionDefinition definition = new DefaultTransactionDefinition(); \u00a0    // the transaction settings can be set here explicitly if so desired \u00a0 definition.setIsolationLevel(TransactionDefinition. ISOLATION_READ_UNCOMMITTED); \u00a0    definition.setTimeout(30); // 30 seconds \u00a0    // and so forth... \u00a0    this.transactionalOperator = TransactionalOperator.create(transactionManager, definition); \u00a0  } } Kotlin class SimpleService(transactionManager: ReactiveTransactionManager) : Service { \u00a0  private val definition = DefaultTransactionDefinition().apply { \u00a0    // the transaction settings can be set here explicitly if so desired \u00a0    isolationLevel = TransactionDefinition. ISOLATION_READ_UNCOMMITTED \u00a0    timeout = 30 // 30 seconds \u00a0    // and so forth... \u00a0  } \u00a0  private val transactionalOperator = TransactionalOperator(transactionManager, definition) } 720", "chunk_char_count": 1990, "chunk_word_count": 285, "chunk_token_count": 497.5}, {"page_number": 721, "sentence_chunk": "Using the TransactionManager The following sections explain programmatic usage of imperative and reactive transaction managers. Using the PlatformTransactionManager For imperative transactions, you can use a org.springframework.transaction. PlatformTransactionManager directly to manage your transaction. To do so, pass the implementation of the PlatformTransactionManager you use to your bean through a bean reference. Then, by using the TransactionDefinition and TransactionStatus objects, you can initiate transactions, roll back, and commit. The following example shows how to do so: Java DefaultTransactionDefinition def = new DefaultTransactionDefinition(); // explicitly setting the transaction name is something that can be done only programmatically def.setName(\"SomeTxName\"); def.setPropagationBehavior(TransactionDefinition. PROPAGATION_REQUIRED); TransactionStatus status = txManager.getTransaction(def); try { \u00a0  // put your business logic here } catch (MyException ex) { \u00a0  txManager.rollback(status); \u00a0  throw ex; } txManager.commit(status); Kotlin val def = DefaultTransactionDefinition() // explicitly setting the transaction name is something that can be done only programmatically def.setName(\"SomeTxName\") def.propagationBehavior = TransactionDefinition. PROPAGATION_REQUIRED val status = txManager.getTransaction(def) try { \u00a0  // put your business logic here } catch (ex: MyException) { \u00a0  txManager.rollback(status) \u00a0  throw ex } txManager.commit(status) 721", "chunk_char_count": 1480, "chunk_word_count": 178, "chunk_token_count": 370.0}, {"page_number": 722, "sentence_chunk": "Using the ReactiveTransactionManager When working with reactive transactions, you can use a org.springframework.transaction. ReactiveTransactionManager directly to manage your transaction. To do so, pass the implementation of the ReactiveTransactionManager you use to your bean through a bean reference. Then, by using the TransactionDefinition and ReactiveTransaction objects, you can initiate transactions, roll back, and commit. The following example shows how to do so: Java DefaultTransactionDefinition def = new DefaultTransactionDefinition(); // explicitly setting the transaction name is something that can be done only programmatically def.setName(\"SomeTxName\"); def.setPropagationBehavior(TransactionDefinition. PROPAGATION_REQUIRED); Mono<ReactiveTransaction> reactiveTx = txManager.getReactiveTransaction(def); reactiveTx.flatMap(status -> { \u00a0  Mono<Object> tx = ...; // put your business logic here \u00a0  return tx.then(txManager.commit(status)) \u00a0      .onErrorResume(ex -> txManager.rollback(status).then(Mono.error(ex))); }); Kotlin val def = DefaultTransactionDefinition() // explicitly setting the transaction name is something that can be done only programmatically def.setName(\"SomeTxName\") def.propagationBehavior = TransactionDefinition. PROPAGATION_REQUIRED val reactiveTx = txManager.getReactiveTransaction(def) reactiveTx.flatMap { status -> \u00a0  val tx = ... // put your business logic here \u00a0  tx.then(txManager.commit(status)) \u00a0      .onErrorResume { ex -> txManager.rollback(status).then(Mono.error(ex)) } } 4.1.6. Choosing Between Programmatic and Declarative Transaction Management Programmatic transaction management is usually a good idea only if you have a small number of transactional operations. For example, if you have a web application that requires transactions only for certain update operations, you may not want to set up transactional proxies by using Spring or 722", "chunk_char_count": 1903, "chunk_word_count": 233, "chunk_token_count": 475.75}, {"page_number": 723, "sentence_chunk": "any other technology. In this case, using the TransactionTemplate may be a good approach. Being able to set the transaction name explicitly is also something that can be done only by using the programmatic approach to transaction management. On the other hand, if your application has numerous transactional operations, declarative transaction management is usually worthwhile. It keeps transaction management out of business logic and is not difficult to configure. When using the Spring Framework, rather than EJB CMT, the configuration cost of declarative transaction management is greatly reduced.4.1.7. Transaction-bound Events As of Spring 4.2, the listener of an event can be bound to a phase of the transaction. The typical example is to handle the event when the transaction has completed successfully. Doing so lets events be used with more flexibility when the outcome of the current transaction actually matters to the listener.", "chunk_char_count": 940, "chunk_word_count": 143, "chunk_token_count": 235.0}, {"page_number": 723, "sentence_chunk": "You can register a regular event listener by using the @EventListener annotation. If you need to bind it to the transaction, use @TransactionalEventListener. When you do so, the listener is bound to the commit phase of the transaction by default. The next example shows this concept. Assume that a component publishes an order-created event and that we want to define a listener that should only handle that event once the transaction in which it has been published has committed successfully. The following example sets up such an event listener: Java @Component public class MyComponent { \u00a0  @TransactionalEventListener \u00a0  public void handleOrderCreatedEvent(CreationEvent<Order> creationEvent) { \u00a0    // ... \u00a0  } } Kotlin @Component class MyComponent { \u00a0  @TransactionalEventListener \u00a0  fun handleOrderCreatedEvent(creationEvent: CreationEvent<Order>) { \u00a0    // ... \u00a0  } } The @TransactionalEventListener annotation exposes a phase attribute that lets you customize the phase of the transaction to which the listener should be bound. The valid phases are BEFORE_COMMIT, 723", "chunk_char_count": 1076, "chunk_word_count": 168, "chunk_token_count": 269.0}, {"page_number": 724, "sentence_chunk": "AFTER_COMMIT (default), AFTER_ROLLBACK, as well as AFTER_COMPLETION which aggregates the transaction completion (be it a commit or a rollback). If no transaction is running, the listener is not invoked at all, since we cannot honor the required semantics. You can, however, override that behavior by setting the fallbackExecution attribute of the annotation to true.\uf05a @TransactionalEventListener only works with thread-bound transactions managed by PlatformTransactionManager. A reactive transaction managed by ReactiveTransactionManager uses the Reactor context instead of thread-local attributes, so from the perspective of an event listener, there is no compatible active transaction that it can participate in.4.1.8. Application server-specific integration Spring\u2019s transaction abstraction is generally application server-agnostic. Additionally, Spring\u2019s JtaTransactionManager class (which can optionally perform a JNDI lookup for the JTA UserTransaction and TransactionManager objects) autodetects the location for the latter object, which varies by application server. Having access to the JTA TransactionManager allows for enhanced transaction semantics\u2009\u2014\u2009in particular, supporting transaction suspension. See the JtaTransactionManager javadoc for details.", "chunk_char_count": 1263, "chunk_word_count": 157, "chunk_token_count": 315.75}, {"page_number": 724, "sentence_chunk": "Spring\u2019s JtaTransactionManager is the standard choice to run on Jakarta EE application servers and is known to work on all common servers. Advanced functionality, such as transaction suspension, works on many servers as well (including GlassFish, JBoss and Geronimo) without any special configuration required. However, for fully supported transaction suspension and further advanced integration, Spring includes special adapters for WebLogic Server and WebSphere. These adapters are discussed in the following sections. For standard scenarios, including WebLogic Server and WebSphere, consider using the convenient <tx:jta-transaction-manager/> configuration element. When configured, this element automatically detects the underlying server and chooses the best transaction manager available for the platform. This means that you need not explicitly configure server-specific adapter classes (as discussed in the following sections). Rather, they are chosen automatically, with the standard JtaTransactionManager as the default fallback. IBM WebSphere On WebSphere 6.1.0.9 and above, the recommended Spring JTA transaction manager to use is WebSphereUowTransactionManager. This special adapter uses IBM\u2019s UOWManager API, which is available in WebSphere Application Server 6.1.0.9 and later.", "chunk_char_count": 1292, "chunk_word_count": 169, "chunk_token_count": 323.0}, {"page_number": 724, "sentence_chunk": "With this adapter, Spring-driven transaction suspension (suspend and resume as initiated by PROPAGATION_REQUIRES_NEW) is officially supported by IBM. Oracle WebLogic Server On WebLogic Server 9.0 or above, you would typically use the WebLogicJtaTransactionManager instead of the stock JtaTransactionManager class. This special WebLogic-specific subclass of the normal JtaTransactionManager supports the full power of Spring\u2019s transaction definitions in a 724", "chunk_char_count": 458, "chunk_word_count": 58, "chunk_token_count": 114.5}, {"page_number": 725, "sentence_chunk": "WebLogic-managed transaction environment, beyond standard JTA semantics. Features include transaction names, per-transaction isolation levels, and proper resuming of transactions in all cases.4.1.9. Solutions to Common Problems This section describes solutions to some common problems. Using the Wrong Transaction Manager for a Specific DataSource Use the correct PlatformTransactionManager implementation based on your choice of transactional technologies and requirements. Used properly, the Spring Framework merely provides a straightforward and portable abstraction. If you use global transactions, you must use the org.springframework.transaction.jta. JtaTransactionManager class (or an application server-specific subclass of it) for all your transactional operations. Otherwise, the transaction infrastructure tries to perform local transactions on such resources as container DataSource instances. Such local transactions do not make sense, and a good application server treats them as errors.", "chunk_char_count": 1001, "chunk_word_count": 125, "chunk_token_count": 250.25}, {"page_number": 725, "sentence_chunk": "4.1.10. Further Resources For more information about the Spring Framework\u2019s transaction support, see: \u2022 Distributed transactions in Spring, with and without XA is a JavaWorld presentation in which Spring\u2019s David Syer guides you through seven patterns for distributed transactions in Spring applications, three of them with XA and four without. \u2022Java Transaction Design Strategies is a book available from InfoQ that provides a well-paced introduction to transactions in Java. It also includes side-by-side examples of how to configure and use transactions with both the Spring Framework and EJB3.4.2. DAO Support The Data Access Object (DAO) support in Spring is aimed at making it easy to work with data access technologies (such as JDBC, Hibernate, or JPA) in a consistent way. This lets you switch between the aforementioned persistence technologies fairly easily, and it also lets you code without worrying about catching exceptions that are specific to each technology.4.2.1. Consistent Exception Hierarchy Spring provides a convenient translation from technology-specific exceptions, such as SQLException to its own exception class hierarchy, which has DataAccessException as the root exception. These exceptions wrap the original exception so that there is never any risk that you might lose any information about what might have gone wrong.", "chunk_char_count": 1348, "chunk_word_count": 200, "chunk_token_count": 337.0}, {"page_number": 725, "sentence_chunk": "In addition to JDBC exceptions, Spring can also wrap JPA- and Hibernate-specific exceptions, converting them to a set of focused runtime exceptions. This lets you handle most non-recoverable persistence exceptions in only the appropriate layers, without having annoying boilerplate catch- and-throw blocks and exception declarations in your DAOs. (You can still trap and handle exceptions anywhere you need to though.)As mentioned above, JDBC exceptions (including 725", "chunk_char_count": 468, "chunk_word_count": 66, "chunk_token_count": 117.0}, {"page_number": 726, "sentence_chunk": "database-specific dialects) are also converted to the same hierarchy, meaning that you can perform some operations with JDBC within a consistent programming model. The preceding discussion holds true for the various template classes in Spring\u2019s support for various ORM frameworks. If you use the interceptor-based classes, the application must care about handling HibernateExceptions and PersistenceExceptions itself, preferably by delegating to the convertHibernateAccessException(..) or convertJpaAccessException(..) methods, respectively, of SessionFactoryUtils. These methods convert the exceptions to exceptions that are compatible with the exceptions in the org.springframework.dao exception hierarchy. As PersistenceExceptions are unchecked, they can get thrown, too (sacrificing generic DAO abstraction in terms of exceptions, though). The following image shows the exception hierarchy that Spring provides. (Note that the class hierarchy detailed in the image shows only a subset of the entire DataAccessException hierarchy.)4.2.2. Annotations Used to Configure DAO or Repository Classes The best way to guarantee that your Data Access Objects (DAOs) or repositories provide exception translation is to use the @Repository annotation. This annotation also lets the component scanning support find and configure your DAOs and repositories without having to provide XML configuration entries for them.", "chunk_char_count": 1408, "chunk_word_count": 186, "chunk_token_count": 352.0}, {"page_number": 726, "sentence_chunk": "The following example shows how to use the @Repository annotation: Java @Repository \u2460 public class SomeMovieFinder implements MovieFinder { \u00a0  // ... } \u2460 The @Repository annotation.726", "chunk_char_count": 184, "chunk_word_count": 28, "chunk_token_count": 46.0}, {"page_number": 727, "sentence_chunk": "Kotlin @Repository \u2460 class SomeMovieFinder : MovieFinder { \u00a0  // ... } \u2460 The @Repository annotation. Any DAO or repository implementation needs access to a persistence resource, depending on the persistence technology used. For example, a JDBC-based repository needs access to a JDBC DataSource, and a JPA-based repository needs access to an EntityManager. The easiest way to accomplish this is to have this resource dependency injected by using one of the @Autowired, @Inject, @Resource or @PersistenceContext annotations. The following example works for a JPA repository: Java @Repository public class JpaMovieFinder implements MovieFinder { \u00a0  @PersistenceContext \u00a0  private EntityManager entityManager; \u00a0  // ... } Kotlin @Repository class JpaMovieFinder : MovieFinder { \u00a0  @PersistenceContext \u00a0  private lateinit var entityManager: EntityManager \u00a0  // ... } If you use the classic Hibernate APIs, you can inject SessionFactory, as the following example shows: 727", "chunk_char_count": 968, "chunk_word_count": 146, "chunk_token_count": 242.0}, {"page_number": 728, "sentence_chunk": "Java @Repository public class HibernateMovieFinder implements MovieFinder { \u00a0  private SessionFactory sessionFactory; \u00a0  @Autowired \u00a0  public void setSessionFactory(SessionFactory sessionFactory) { \u00a0    this.sessionFactory = sessionFactory; \u00a0  } \u00a0  // ... } Kotlin @Repository class HibernateMovieFinder(private val sessionFactory: SessionFactory) : MovieFinder { \u00a0  // ... } The last example we show here is for typical JDBC support. You could have the DataSource injected into an initialization method or a constructor, where you would create a JdbcTemplate and other data access support classes (such as SimpleJdbcCall and others) by using this DataSource. The following example autowires a DataSource: Java @Repository public class JdbcMovieFinder implements MovieFinder { \u00a0  private JdbcTemplate jdbcTemplate; \u00a0  @Autowired \u00a0  public void init(DataSource dataSource) { \u00a0    this.jdbcTemplate = new JdbcTemplate(dataSource); \u00a0  } \u00a0  // ... } 728", "chunk_char_count": 949, "chunk_word_count": 144, "chunk_token_count": 237.25}, {"page_number": 729, "sentence_chunk": "Kotlin @Repository class JdbcMovieFinder(dataSource: DataSource) : MovieFinder { \u00a0  private val jdbcTemplate = JdbcTemplate(dataSource) \u00a0  // ... } \uf05a See the specific coverage of each persistence technology for details on how to configure the application context to take advantage of these annotations.4.3. Data Access with JDBC The value provided by the Spring Framework JDBC abstraction is perhaps best shown by the sequence of actions outlined in the following table below. The table shows which actions Spring takes care of and which actions are your responsibility. Table 20. Spring JDBC - who does what?Action Spring You Define connection parameters. X Open the connection. X Specify the SQL statement. X Declare parameters and provide parameter values X Prepare and run the statement.", "chunk_char_count": 791, "chunk_word_count": 122, "chunk_token_count": 197.75}, {"page_number": 729, "sentence_chunk": "X Set up the loop to iterate through the results (if any). X Do the work for each iteration. X Process any exception. X Handle transactions. X Close the connection, the statement, and the resultset. X The Spring Framework takes care of all the low-level details that can make JDBC such a tedious API.4.3.1. Choosing an Approach for JDBC Database Access You can choose among several approaches to form the basis for your JDBC database access. In addition to three flavors of JdbcTemplate, a new SimpleJdbcInsert and SimpleJdbcCall approach optimizes database metadata, and the RDBMS Object style takes a more object-oriented approach similar to that of JDO Query design. Once you start using one of these approaches, you can still mix 729", "chunk_char_count": 737, "chunk_word_count": 122, "chunk_token_count": 184.25}, {"page_number": 730, "sentence_chunk": "and match to include a feature from a different approach. All approaches require a JDBC 2.0- compliant driver, and some advanced features require a JDBC 3.0 driver. \u2022JdbcTemplate is the classic and most popular Spring JDBC approach. This \u201clowest-level\u201d approach and all others use a JdbcTemplate under the covers. \u2022NamedParameterJdbcTemplate wraps a JdbcTemplate to provide named parameters instead of the traditional JDBC ?placeholders. This approach provides better documentation and ease of use when you have multiple parameters for an SQL statement. \u2022SimpleJdbcInsert and SimpleJdbcCall optimize database metadata to limit the amount of necessary configuration. This approach simplifies coding so that you need to provide only the name of the table or procedure and provide a map of parameters matching the column names. This works only if the database provides adequate metadata.", "chunk_char_count": 884, "chunk_word_count": 131, "chunk_token_count": 221.0}, {"page_number": 730, "sentence_chunk": "If the database does not provide this metadata, you have to provide explicit configuration of the parameters. \u2022RDBMS objects \u2014 including MappingSqlQuery, SqlUpdate, and StoredProcedure \u2014 require you to create reusable and thread-safe objects during initialization of your data-access layer. This approach is modeled after JDO Query, wherein you define your query string, declare parameters, and compile the query. Once you do that, execute(\u2026), update(\u2026), and findObject(\u2026) methods can be called multiple times with various parameter values.4.3.2. Package Hierarchy The Spring Framework\u2019s JDBC abstraction framework consists of four different packages: \u2022 core: The org.springframework.jdbc.core package contains the JdbcTemplate class and its various callback interfaces, plus a variety of related classes. A subpackage named org.springframework.jdbc.core.simple contains the SimpleJdbcInsert and SimpleJdbcCall classes. Another subpackage named org.springframework.jdbc.core.namedparam contains the NamedParameterJdbcTemplate class and the related support classes. See Using the JDBC Core Classes to Control Basic JDBC Processing and Error Handling, JDBC Batch Operations, and Simplifying JDBC Operations with the SimpleJdbc Classes. \u2022datasource: The org.springframework.jdbc.datasource package contains a utility class for easy DataSource access and various simple DataSource implementations that you can use for testing and running unmodified JDBC code outside of a Jakarta EE container.", "chunk_char_count": 1489, "chunk_word_count": 192, "chunk_token_count": 372.25}, {"page_number": 730, "sentence_chunk": "A subpackage named org.springfamework.jdbc.datasource.embedded provides support for creating embedded databases by using Java database engines, such as HSQL, H2, and Derby. See Controlling Database Connections and Embedded Database Support. \u2022object: The org.springframework.jdbc.object package contains classes that represent RDBMS queries, updates, and stored procedures as thread-safe, reusable objects. See Modeling JDBC Operations as Java Objects. This approach is modeled by JDO, although objects returned by queries are naturally disconnected from the database. This higher-level of JDBC abstraction depends on the lower-level abstraction in the org.springframework.jdbc.core package. \u2022support: The org.springframework.jdbc.support package provides SQLException translation functionality and some utility classes. Exceptions thrown during JDBC processing are translated to exceptions defined in the org.springframework.dao package. This means that code using the Spring JDBC abstraction layer does not need to implement JDBC or RDBMS-specific error handling. All translated exceptions are unchecked, which gives you the option of catching the 730", "chunk_char_count": 1152, "chunk_word_count": 145, "chunk_token_count": 288.0}, {"page_number": 731, "sentence_chunk": "exceptions from which you can recover while letting other exceptions be propagated to the caller. See Using SQLExceptionTranslator.4.3.3. Using the JDBC Core Classes to Control Basic JDBC Processing and Error Handling This section covers how to use the JDBC core classes to control basic JDBC processing, including error handling. It includes the following topics: \u2022 Using JdbcTemplate \u2022 Using NamedParameterJdbcTemplate \u2022 Using SQLExceptionTranslator \u2022 Running Statements \u2022 Running Queries \u2022 Updating the Database \u2022 Retrieving Auto-generated Keys Using JdbcTemplate JdbcTemplate is the central class in the JDBC core package. It handles the creation and release of resources, which helps you avoid common errors, such as forgetting to close the connection. It performs the basic tasks of the core JDBC workflow (such as statement creation and execution), leaving application code to provide SQL and extract results. The JdbcTemplate class: \u2022 Runs SQL queries \u2022 Updates statements and stored procedure calls \u2022 Performs iteration over ResultSet instances and extraction of returned parameter values. \u2022Catches JDBC exceptions and translates them to the generic, more informative, exception hierarchy defined in the org.springframework.dao package. (See Consistent Exception Hierarchy.)", "chunk_char_count": 1283, "chunk_word_count": 183, "chunk_token_count": 320.75}, {"page_number": 731, "sentence_chunk": "When you use the JdbcTemplate for your code, you need only to implement callback interfaces, giving them a clearly defined contract. Given a Connection provided by the JdbcTemplate class, the PreparedStatementCreator callback interface creates a prepared statement, providing SQL and any necessary parameters. The same is true for the CallableStatementCreator interface, which creates callable statements. The RowCallbackHandler interface extracts values from each row of a ResultSet. You can use JdbcTemplate within a DAO implementation through direct instantiation with a DataSource reference, or you can configure it in a Spring IoC container and give it to DAOs as a bean reference.\uf05a The DataSource should always be configured as a bean in the Spring IoC container. In the first case the bean is given to the service directly; in the second case it is given to the prepared template. All SQL issued by this class is logged at the DEBUG level under the category corresponding to the fully 731", "chunk_char_count": 995, "chunk_word_count": 157, "chunk_token_count": 248.75}, {"page_number": 732, "sentence_chunk": "qualified class name of the template instance (typically JdbcTemplate, but it may be different if you use a custom subclass of the JdbcTemplate class). The following sections provide some examples of JdbcTemplate usage. These examples are not an exhaustive list of all of the functionality exposed by the JdbcTemplate. See the attendant javadoc for that. Querying (SELECT) The following query gets the number of rows in a relation: Java int rowCount = this.jdbcTemplate.queryForObject(\"select count(*) from t_actor\", Integer.class); Kotlin val rowCount = jdbcTemplate.queryForObject<Int>(\"select count(*) from t_actor\")!!The following query uses a bind variable: Java int countOfActorsNamedJoe = this.jdbcTemplate.queryForObject( \u00a0    \"select count(*) from t_actor where first_name = ?\",Integer.class, \"Joe\"); Kotlin val countOfActorsNamedJoe = jdbcTemplate.queryForObject<Int>( \u00a0    \"select count(*) from t_actor where first_name = ?\",arrayOf(\"Joe\"))!!The following query looks for a String: Java String lastName = this.jdbcTemplate.queryForObject( \u00a0    \"select last_name from t_actor where id = ?\",\u00a0    String.class, 1212L); Kotlin val lastName = this.jdbcTemplate.queryForObject<String>( \u00a0    \"select last_name from t_actor where id = ?\",", "chunk_char_count": 1241, "chunk_word_count": 171, "chunk_token_count": 310.25}, {"page_number": 733, "sentence_chunk": "Java Actor actor = jdbcTemplate.queryForObject( \u00a0    \"select first_name, last_name from t_actor where id = ?\",\u00a0    (resultSet, rowNum) -> { \u00a0      Actor newActor = new Actor(); \u00a0      newActor.setFirstName(resultSet.getString(\"first_name\")); \u00a0      newActor.setLastName(resultSet.getString(\"last_name\")); \u00a0      return newActor; \u00a0    }, \u00a0    1212L); Kotlin val actor = jdbcTemplate.queryForObject( \u00a0      \"select first_name, last_name from t_actor where id = ?\",\u00a0      arrayOf(1212L)) { rs, _ -> \u00a0    Actor(rs.getString(\"first_name\"), rs.getString(\"last_name\")) \u00a0  } The following query finds and populates a list of domain objects: Java List<Actor> actors = this.jdbcTemplate.query( \u00a0    \"select first_name, last_name from t_actor\", \u00a0    (resultSet, rowNum) -> { \u00a0      Actor actor = new Actor(); \u00a0      actor.setFirstName(resultSet.getString(\"first_name\")); \u00a0      actor.setLastName(resultSet.getString(\"last_name\")); \u00a0      return actor; \u00a0    }); Kotlin val actors = jdbcTemplate.query(\"select first_name, last_name from t_actor\") { rs, _ -> \u00a0    Actor(rs.getString(\"first_name\"), rs.getString(\"last_name\")) If the last two snippets of code actually existed in the same application, it would make sense to remove the duplication present in the two RowMapper lambda expressions and extract them out into a single field that could then be referenced by DAO methods as needed. For example, it may be better to write the preceding code snippet as follows: 733", "chunk_char_count": 1458, "chunk_word_count": 258, "chunk_token_count": 364.5}, {"page_number": 734, "sentence_chunk": "Java private final RowMapper<Actor> actorRowMapper = (resultSet, rowNum) -> { \u00a0  Actor actor = new Actor(); \u00a0  actor.setFirstName(resultSet.getString(\"first_name\")); \u00a0  actor.setLastName(resultSet.getString(\"last_name\")); \u00a0  return actor; }; public List<Actor> findAllActors() { \u00a0  return this.jdbcTemplate.query(\"select first_name, last_name from t_actor\", actorRowMapper); } Kotlin val actorMapper = RowMapper<Actor> { rs: ResultSet, rowNum: Int -> \u00a0  Actor(rs.getString(\"first_name\"), rs.getString(\"last_name\")) } fun findAllActors(): List<Actor> { \u00a0  return jdbcTemplate.query(\"select first_name, last_name from t_actor\", actorMapper) } Updating (INSERT, UPDATE, and DELETE) with JdbcTemplate You can use the update(..) method to perform insert, update, and delete operations. Parameter values are usually provided as variable arguments or, alternatively, as an object array. The following example inserts a new entry: Java this.jdbcTemplate.update( \u00a0    \"insert into t_actor (first_name, last_name) values (?, ?)\",\u00a0    \"Leonor\", \"Watling\"); Kotlin jdbcTemplate.update( \u00a0    \"insert into t_actor (first_name, last_name) values (?, ?)\",\u00a0    \"Leonor\", \"Watling\") The following example updates an existing entry: 734", "chunk_char_count": 1217, "chunk_word_count": 159, "chunk_token_count": 304.25}, {"page_number": 735, "sentence_chunk": "Java this.jdbcTemplate.update( \u00a0    \"update t_actor set last_name = ?where id = ?\",\u00a0    \"Banjo\", 5276L); Kotlin jdbcTemplate.update( \u00a0    \"update t_actor set last_name = ?where id = ?\",\u00a0    \"Banjo\", 5276L) The following example deletes an entry: Java this.jdbcTemplate.update( \u00a0    \"delete from t_actor where id = ?\",\u00a0    Long.valueOf(actorId)); Kotlin jdbcTemplate.update(\"delete from t_actor where id = ?\",actorId.toLong()) Other JdbcTemplate Operations You can use the execute(..) method to run any arbitrary SQL. Consequently, the method is often used for DDL statements. It is heavily overloaded with variants that take callback interfaces, binding variable arrays, and so on. The following example creates a table: Java this.jdbcTemplate.execute(\"create table mytable (id integer, name varchar(100))\"); Kotlin jdbcTemplate.execute(\"create table mytable (id integer, name varchar(100))\") The following example invokes a stored procedure: Java this.jdbcTemplate.update( \u00a0    \"call SUPPORT. REFRESH_ACTORS_SUMMARY(?)\",", "chunk_char_count": 1021, "chunk_word_count": 148, "chunk_token_count": 255.25}, {"page_number": 736, "sentence_chunk": "Kotlin jdbcTemplate.update( \u00a0    \"call SUPPORT. REFRESH_ACTORS_SUMMARY(?)\",\u00a0    unionId.toLong()) More sophisticated stored procedure support is covered later. JdbcTemplate Best Practices Instances of the JdbcTemplate class are thread-safe, once configured. This is important because it means that you can configure a single instance of a JdbcTemplate and then safely inject this shared reference into multiple DAOs (or repositories). The JdbcTemplate is stateful, in that it maintains a reference to a DataSource, but this state is not conversational state. A common practice when using the JdbcTemplate class (and the associated NamedParameterJdbcTemplate class) is to configure a DataSource in your Spring configuration file and then dependency-inject that shared DataSource bean into your DAO classes. The JdbcTemplate is created in the setter for the DataSource. This leads to DAOs that resemble the following: Java public class JdbcCorporateEventDao implements CorporateEventDao { \u00a0  private JdbcTemplate jdbcTemplate; \u00a0  public void setDataSource(DataSource dataSource) { \u00a0    this.jdbcTemplate = new JdbcTemplate(dataSource); \u00a0  } \u00a0  // JDBC-backed implementations of the methods on the CorporateEventDao follow... } Kotlin class JdbcCorporateEventDao(dataSource: DataSource) : CorporateEventDao { \u00a0  private val jdbcTemplate = JdbcTemplate(dataSource) \u00a0  // JDBC-backed implementations of the methods on the CorporateEventDao follow... } The following example shows the corresponding XML configuration: 736", "chunk_char_count": 1515, "chunk_word_count": 212, "chunk_token_count": 378.75}, {"page_number": 737, "sentence_chunk": "<?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:context=\"http://www.springframework.org/schema/context\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/context \u00a0    https://www.springframework.org/schema/context/spring-context.xsd\"> \u00a0  <bean id=\"corporateEventDao\" class=\"com.example. JdbcCorporateEventDao\"> \u00a0    <property name=\"dataSource\" ref=\"dataSource\"/> \u00a0  </bean> \u00a0  <bean id=\"dataSource\" class=\"org.apache.commons.dbcp. BasicDataSource\" destroy- method=\"close\"> \u00a0    <property name=\"driverClassName\" value=\"${jdbc.driverClassName}\"/> \u00a0    <property name=\"url\" value=\"${jdbc.url}\"/> \u00a0    <property name=\"username\" value=\"${jdbc.username}\"/> \u00a0    <property name=\"password\" value=\"${jdbc.password}\"/> \u00a0  </bean> \u00a0  <context:property-placeholder location=\"jdbc.properties\"/> </beans> An alternative to explicit configuration is to use component-scanning and annotation support for dependency injection. In this case, you can annotate the class with @Repository (which makes it a candidate for component-scanning) and annotate the DataSource setter method with @Autowired. The following example shows how to do so: Java @Repository \u2460 public class JdbcCorporateEventDao implements CorporateEventDao { \u00a0  private JdbcTemplate jdbcTemplate; \u00a0  @Autowired \u2461 \u00a0  public void setDataSource(DataSource dataSource) { \u00a0    this.jdbcTemplate = new JdbcTemplate(dataSource); \u2462 \u00a0  } \u00a0  // JDBC-backed implementations of the methods on the CorporateEventDao follow... } \u2460 Annotate the class with @Repository.\u2461 Annotate the DataSource setter method with @Autowired.737", "chunk_char_count": 1808, "chunk_word_count": 205, "chunk_token_count": 452.0}, {"page_number": 738, "sentence_chunk": "\u2462 Create a new JdbcTemplate with the DataSource. Kotlin @Repository \u2460 class JdbcCorporateEventDao(dataSource: DataSource) : CorporateEventDao { \u2461 \u00a0  private val jdbcTemplate = JdbcTemplate(dataSource) \u2462 \u00a0  // JDBC-backed implementations of the methods on the CorporateEventDao follow... } \u2460 Annotate the class with @Repository.\u2461 Constructor injection of the DataSource.\u2462 Create a new JdbcTemplate with the DataSource. The following example shows the corresponding XML configuration: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:context=\"http://www.springframework.org/schema/context\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/context \u00a0    https://www.springframework.org/schema/context/spring-context.xsd\"> \u00a0  <!--Scans within the base package of the application for @Component classes to configure as beans --> \u00a0  <context:component-scan base-package=\"org.springframework.docs.test\" /> \u00a0  <bean id=\"dataSource\" class=\"org.apache.commons.dbcp. BasicDataSource\" destroy- method=\"close\"> \u00a0    <property name=\"driverClassName\" value=\"${jdbc.driverClassName}\"/> \u00a0    <property name=\"url\" value=\"${jdbc.url}\"/> \u00a0    <property name=\"username\" value=\"${jdbc.username}\"/> \u00a0    <property name=\"password\" value=\"${jdbc.password}\"/> \u00a0  </bean> \u00a0  <context:property-placeholder location=\"jdbc.properties\"/> </beans> If you use Spring\u2019s JdbcDaoSupport class and your various JDBC-backed DAO classes extend from it, your sub-class inherits a setDataSource(..) method from the JdbcDaoSupport class. You can choose whether to inherit from this class.", "chunk_char_count": 1794, "chunk_word_count": 200, "chunk_token_count": 448.5}, {"page_number": 738, "sentence_chunk": "The JdbcDaoSupport class is provided as a convenience only. Regardless of which of the above template initialization styles you choose to use (or not), it is 738", "chunk_char_count": 161, "chunk_word_count": 27, "chunk_token_count": 40.25}, {"page_number": 739, "sentence_chunk": "seldom necessary to create a new instance of a JdbcTemplate class each time you want to run SQL. Once configured, a JdbcTemplate instance is thread-safe. If your application accesses multiple databases, you may want multiple JdbcTemplate instances, which requires multiple DataSources and, subsequently, multiple differently configured JdbcTemplate instances. Using NamedParameterJdbcTemplate The NamedParameterJdbcTemplate class adds support for programming JDBC statements by using named parameters, as opposed to programming JDBC statements using only classic placeholder ( '?')arguments. The NamedParameterJdbcTemplate class wraps a JdbcTemplate and delegates to the wrapped JdbcTemplate to do much of its work. This section describes only those areas of the NamedParameterJdbcTemplate class that differ from the JdbcTemplate itself\u2009\u2014\u2009namely, programming JDBC statements by using named parameters. The following example shows how to use NamedParameterJdbcTemplate: Java // some JDBC-backed DAO class... private NamedParameterJdbcTemplate namedParameterJdbcTemplate; public void setDataSource(DataSource dataSource) { \u00a0  this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource); } public int countOfActorsByFirstName(String firstName) { \u00a0  String sql = \"select count(*) from T_ACTOR where first_name = :first_name\"; \u00a0  SqlParameterSource namedParameters = new MapSqlParameterSource(\"first_name\", firstName); \u00a0  return this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Integer.class); } Kotlin private val namedParameterJdbcTemplate = NamedParameterJdbcTemplate(dataSource) fun countOfActorsByFirstName(firstName: String): Int { \u00a0  val sql = \"select count(*) from T_ACTOR where first_name = :first_name\" \u00a0  val namedParameters = MapSqlParameterSource(\"first_name\", firstName) \u00a0  return namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Int::class.java)!! }Notice the use of the named parameter notation in the value assigned to the sql variable and the corresponding value that is plugged into the namedParameters variable (of type MapSqlParameterSource).739", "chunk_char_count": 2113, "chunk_word_count": 245, "chunk_token_count": 528.25}, {"page_number": 740, "sentence_chunk": "Alternatively, you can pass along named parameters and their corresponding values to a NamedParameterJdbcTemplate instance by using the Map-based style. The remaining methods exposed by the NamedParameterJdbcOperations and implemented by the NamedParameterJdbcTemplate class follow a similar pattern and are not covered here. The following example shows the use of the Map-based style: Java // some JDBC-backed DAO class... private NamedParameterJdbcTemplate namedParameterJdbcTemplate; public void setDataSource(DataSource dataSource) { \u00a0  this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource); } public int countOfActorsByFirstName(String firstName) { \u00a0  String sql = \"select count(*) from T_ACTOR where first_name = :first_name\"; \u00a0  Map<String, String> namedParameters = Collections.singletonMap(\"first_name\", firstName); \u00a0  return this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Integer.class); } Kotlin // some JDBC-backed DAO class... private val namedParameterJdbcTemplate = NamedParameterJdbcTemplate(dataSource) fun countOfActorsByFirstName(firstName: String): Int { \u00a0  val sql = \"select count(*) from T_ACTOR where first_name = :first_name\" \u00a0  val namedParameters = mapOf(\"first_name\" to firstName) \u00a0  return namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Int::class.java)!! }One nice feature related to the NamedParameterJdbcTemplate (and existing in the same Java package) is the SqlParameterSource interface. You have already seen an example of an implementation of this interface in one of the previous code snippets (the MapSqlParameterSource class). An SqlParameterSource is a source of named parameter values to a NamedParameterJdbcTemplate. The MapSqlParameterSource class is a simple implementation that is an adapter around a java.util. Map, where the keys are the parameter names and the values are the parameter values. Another SqlParameterSource implementation is the BeanPropertySqlParameterSource class. This class wraps an arbitrary JavaBean (that is, an instance of a class that adheres to the JavaBean conventions) and uses the properties of the wrapped JavaBean as the source of named parameter 740", "chunk_char_count": 2188, "chunk_word_count": 271, "chunk_token_count": 547.0}, {"page_number": 741, "sentence_chunk": "values. The following example shows a typical JavaBean: Java public class Actor { \u00a0  private Long id; \u00a0  private String firstName; \u00a0  private String lastName; \u00a0  public String getFirstName() { \u00a0    return this.firstName; \u00a0  } \u00a0  public String getLastName() { \u00a0    return this.lastName; \u00a0  } \u00a0  public Long getId() { \u00a0    return this.id; \u00a0  } \u00a0  // setters omitted... } Kotlin data class Actor(val id: Long, val firstName: String, val lastName: String) The following example uses a NamedParameterJdbcTemplate to return the count of the members of the class shown in the preceding example: 741", "chunk_char_count": 591, "chunk_word_count": 113, "chunk_token_count": 147.75}, {"page_number": 742, "sentence_chunk": "Java // some JDBC-backed DAO class... private NamedParameterJdbcTemplate namedParameterJdbcTemplate; public void setDataSource(DataSource dataSource) { \u00a0  this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource); } public int countOfActors(Actor exampleActor) { \u00a0  // notice how the named parameters match the properties of the above 'Actor' class \u00a0  String sql = \"select count(*) from T_ACTOR where first_name = :firstName and last_name = :lastName\"; \u00a0  SqlParameterSource namedParameters = new BeanPropertySqlParameterSource(exampleActor); \u00a0  return this.namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Integer.class); } Kotlin // some JDBC-backed DAO class... private val namedParameterJdbcTemplate = NamedParameterJdbcTemplate(dataSource) private val namedParameterJdbcTemplate = NamedParameterJdbcTemplate(dataSource) fun countOfActors(exampleActor: Actor): Int { \u00a0  // notice how the named parameters match the properties of the above 'Actor' class \u00a0  val sql = \"select count(*) from T_ACTOR where first_name = :firstName and last_name = :lastName\" \u00a0  val namedParameters = BeanPropertySqlParameterSource(exampleActor) \u00a0  return namedParameterJdbcTemplate.queryForObject(sql, namedParameters, Int::class.java)!! }Remember that the NamedParameterJdbcTemplate class wraps a classic JdbcTemplate template. If you need access to the wrapped JdbcTemplate instance to access functionality that is present only in the JdbcTemplate class, you can use the getJdbcOperations() method to access the wrapped JdbcTemplate through the JdbcOperations interface. See also JdbcTemplate Best Practices for guidelines on using the NamedParameterJdbcTemplate class in the context of an application. Using SQLExceptionTranslator SQLExceptionTranslator is an interface to be implemented by classes that can translate between SQLExceptions and Spring\u2019s own org.springframework.dao. DataAccessException, which is agnostic in 742", "chunk_char_count": 1946, "chunk_word_count": 228, "chunk_token_count": 486.5}, {"page_number": 743, "sentence_chunk": "regard to data access strategy. Implementations can be generic (for example, using SQLState codes for JDBC) or proprietary (for example, using Oracle error codes) for greater precision. SQLErrorCodeSQLExceptionTranslator is the implementation of SQLExceptionTranslator that is used by default. This implementation uses specific vendor codes. It is more precise than the SQLState implementation. The error code translations are based on codes held in a JavaBean type class called SQLErrorCodes. This class is created and populated by an SQLErrorCodesFactory, which (as the name suggests) is a factory for creating SQLErrorCodes based on the contents of a configuration file named sql-error-codes.xml. This file is populated with vendor codes and based on the DatabaseProductName taken from DatabaseMetaData. The codes for the actual database you are using are used. The SQLErrorCodeSQLExceptionTranslator applies matching rules in the following sequence: 1.", "chunk_char_count": 956, "chunk_word_count": 134, "chunk_token_count": 239.0}, {"page_number": 743, "sentence_chunk": "Any custom translation implemented by a subclass. Normally, the provided concrete SQLErrorCodeSQLExceptionTranslator is used, so this rule does not apply. It applies only if you have actually provided a subclass implementation.2. Any custom implementation of the SQLExceptionTranslator interface that is provided as the customSqlExceptionTranslator property of the SQLErrorCodes class.3. The list of instances of the CustomSQLErrorCodesTranslation class (provided for the customTranslations property of the SQLErrorCodes class) are searched for a match.4. Error code matching is applied.5.", "chunk_char_count": 589, "chunk_word_count": 76, "chunk_token_count": 147.25}, {"page_number": 743, "sentence_chunk": "Use the fallback translator. SQLExceptionSubclassTranslator is the default fallback translator. If this translation is not available, the next fallback translator is the SQLStateSQLExceptionTranslator.\uf05a The SQLErrorCodesFactory is used by default to define Error codes and custom exception translations. They are looked up in a file named sql-error-codes.xml from the classpath, and the matching SQLErrorCodes instance is located based on the database name from the database metadata of the database in use. You can extend SQLErrorCodeSQLExceptionTranslator, as the following example shows: Java public class CustomSQLErrorCodesTranslator extends SQLErrorCodeSQLExceptionTranslator { \u00a0  protected DataAccessException customTranslate(String task, String sql, SQLException sqlEx) { \u00a0    if (sqlEx.getErrorCode() == -12345) { \u00a0      return new DeadlockLoserDataAccessException(task, sqlEx); \u00a0    } \u00a0    return null; \u00a0  } } 743", "chunk_char_count": 923, "chunk_word_count": 132, "chunk_token_count": 230.75}, {"page_number": 744, "sentence_chunk": "Kotlin class CustomSQLErrorCodesTranslator : SQLErrorCodeSQLExceptionTranslator() { \u00a0  override fun customTranslate(task: String, sql: String?,sqlEx: SQLException): DataAccessException? {\u00a0    if (sqlEx.errorCode == -12345) { \u00a0      return DeadlockLoserDataAccessException(task, sqlEx) \u00a0    } \u00a0    return null \u00a0  } } In the preceding example, the specific error code (-12345) is translated, while other errors are left to be translated by the default translator implementation. To use this custom translator, you must pass it to the JdbcTemplate through the method setExceptionTranslator, and you must use this JdbcTemplate for all of the data access processing where this translator is needed. The following example shows how you can use this custom translator: Java private JdbcTemplate jdbcTemplate; public void setDataSource(DataSource dataSource) { \u00a0  // create a JdbcTemplate and set data source \u00a0  this.jdbcTemplate = new JdbcTemplate(); \u00a0  this.jdbcTemplate.setDataSource(dataSource); \u00a0  // create a custom translator and set the DataSource for the default translation lookup \u00a0  CustomSQLErrorCodesTranslator tr = new CustomSQLErrorCodesTranslator(); \u00a0  tr.setDataSource(dataSource); \u00a0  this.jdbcTemplate.setExceptionTranslator(tr); } public void updateShippingCharge(long orderId, long pct) { \u00a0  // use the prepared JdbcTemplate for this update \u00a0  this.jdbcTemplate.update(\"update orders\" + \u00a0    \" set shipping_charge = shipping_charge * ? /100\" + \u00a0    \" where id = ?\",pct, orderId); } 744", "chunk_char_count": 1497, "chunk_word_count": 223, "chunk_token_count": 374.25}, {"page_number": 745, "sentence_chunk": "Kotlin // create a JdbcTemplate and set data source private val jdbcTemplate = JdbcTemplate(dataSource).apply { \u00a0  // create a custom translator and set the DataSource for the default translation lookup \u00a0  exceptionTranslator = CustomSQLErrorCodesTranslator().apply { \u00a0    this.dataSource = dataSource \u00a0  } } fun updateShippingCharge(orderId: Long, pct: Long) { \u00a0  // use the prepared JdbcTemplate for this update \u00a0  this.jdbcTemplate!!.update(\"update orders\" + \u00a0      \" set shipping_charge = shipping_charge * ? /100\" + \u00a0      \" where id = ?\",pct, orderId) } The custom translator is passed a data source in order to look up the error codes in sql-error- codes.xml. Running Statements Running an SQL statement requires very little code. You need a DataSource and a JdbcTemplate, including the convenience methods that are provided with the JdbcTemplate. The following example shows what you need to include for a minimal but fully functional class that creates a new table: Java import javax.sql. DataSource; import org.springframework.jdbc.core. JdbcTemplate; public class ExecuteAStatement { \u00a0  private JdbcTemplate jdbcTemplate; \u00a0  public void setDataSource(DataSource dataSource) { \u00a0    this.jdbcTemplate = new JdbcTemplate(dataSource); \u00a0  } \u00a0  public void doExecute() { \u00a0    this.jdbcTemplate.execute(\"create table mytable (id integer, name varchar(100))\"); \u00a0  } } 745", "chunk_char_count": 1374, "chunk_word_count": 220, "chunk_token_count": 343.5}, {"page_number": 746, "sentence_chunk": "Kotlin import javax.sql. DataSource import org.springframework.jdbc.core. JdbcTemplate class ExecuteAStatement(dataSource: DataSource) { \u00a0  private val jdbcTemplate = JdbcTemplate(dataSource) \u00a0  fun doExecute() { \u00a0    jdbcTemplate.execute(\"create table mytable (id integer, name varchar(100))\") \u00a0  } } Running Queries Some query methods return a single value. To retrieve a count or a specific value from one row, use queryForObject(..). The latter converts the returned JDBC Type to the Java class that is passed in as an argument. If the type conversion is invalid, an InvalidDataAccessApiUsageException is thrown. The following example contains two query methods, one for an int and one that queries for a String: Java import javax.sql. DataSource; import org.springframework.jdbc.core. JdbcTemplate; public class RunAQuery { \u00a0  private JdbcTemplate jdbcTemplate; \u00a0  public void setDataSource(DataSource dataSource) { \u00a0    this.jdbcTemplate = new JdbcTemplate(dataSource); \u00a0  } \u00a0  public int getCount() { \u00a0    return this.jdbcTemplate.queryForObject(\"select count(*) from mytable\", Integer.class); \u00a0  } \u00a0  public String getName() { \u00a0    return this.jdbcTemplate.queryForObject(\"select name from mytable\", String.class); \u00a0  } } 746", "chunk_char_count": 1233, "chunk_word_count": 180, "chunk_token_count": 308.25}, {"page_number": 747, "sentence_chunk": "Kotlin import javax.sql. DataSource import org.springframework.jdbc.core. JdbcTemplate class RunAQuery(dataSource: DataSource) { \u00a0  private val jdbcTemplate = JdbcTemplate(dataSource) \u00a0  val count: Int \u00a0    get() = jdbcTemplate.queryForObject(\"select count(*) from mytable\")!!\u00a0  val name: String?\u00a0    get() = jdbcTemplate.queryForObject(\"select name from mytable\") } In addition to the single result query methods, several methods return a list with an entry for each row that the query returned. The most generic method is queryForList(..), which returns a List where each element is a Map containing one entry for each column, using the column name as the key. If you add a method to the preceding example to retrieve a list of all the rows, it might be as follows: Java private JdbcTemplate jdbcTemplate; public void setDataSource(DataSource dataSource) { \u00a0  this.jdbcTemplate = new JdbcTemplate(dataSource); } public List<Map<String, Object>> getList() { \u00a0  return this.jdbcTemplate.queryForList(\"select * from mytable\"); } Kotlin private val jdbcTemplate = JdbcTemplate(dataSource) fun getList(): List<Map<String, Any>> { \u00a0  return jdbcTemplate.queryForList(\"select * from mytable\") } The returned list would resemble the following: [{name=Bob, id=1}, {name=Mary, id=2}] 747", "chunk_char_count": 1279, "chunk_word_count": 181, "chunk_token_count": 319.75}, {"page_number": 748, "sentence_chunk": "Updating the Database The following example updates a column for a certain primary key: Java import javax.sql. DataSource; import org.springframework.jdbc.core. JdbcTemplate; public class ExecuteAnUpdate { \u00a0  private JdbcTemplate jdbcTemplate; \u00a0  public void setDataSource(DataSource dataSource) { \u00a0    this.jdbcTemplate = new JdbcTemplate(dataSource); \u00a0  } \u00a0  public void setName(int id, String name) { \u00a0    this.jdbcTemplate.update(\"update mytable set name = ?where id = ?\",name, id); \u00a0  } } Kotlin import javax.sql. DataSource import org.springframework.jdbc.core. JdbcTemplate class ExecuteAnUpdate(dataSource: DataSource) { \u00a0  private val jdbcTemplate = JdbcTemplate(dataSource) \u00a0  fun setName(id: Int, name: String) { \u00a0    jdbcTemplate.update(\"update mytable set name = ?where id = ?\",name, id) \u00a0  } } In the preceding example, an SQL statement has placeholders for row parameters. You can pass the parameter values in as varargs or, alternatively, as an array of objects.", "chunk_char_count": 978, "chunk_word_count": 147, "chunk_token_count": 244.5}, {"page_number": 748, "sentence_chunk": "Thus, you should explicitly wrap primitives in the primitive wrapper classes, or you should use auto-boxing. Retrieving Auto-generated Keys An update() convenience method supports the retrieval of primary keys generated by the database. This support is part of the JDBC 3.0 standard. See Chapter 13.6 of the specification for details. The method takes a PreparedStatementCreator as its first argument, and this is the way the required insert statement is specified. The other argument is a KeyHolder, which contains the generated key on successful return from the update. There is no standard single way to create an appropriate PreparedStatement (which explains why the method signature is the way it is). The following example works on Oracle but may not work on other platforms: 748", "chunk_char_count": 785, "chunk_word_count": 123, "chunk_token_count": 196.25}, {"page_number": 749, "sentence_chunk": "Java final String INSERT_SQL = \"insert into my_test (name) values(?)\";final String name = \"Rob\"; KeyHolder keyHolder = new GeneratedKeyHolder(); jdbcTemplate.update(connection -> { \u00a0  PreparedStatement ps = connection.prepareStatement(INSERT_SQL, new String[] { \"id\" }); \u00a0  ps.setString(1, name); \u00a0  return ps; }, keyHolder); // keyHolder.getKey() now contains the generated key Kotlin val INSERT_SQL = \"insert into my_test (name) values(?)\"val name = \"Rob\" val keyHolder = GeneratedKeyHolder() jdbcTemplate.update({ \u00a0  it.prepareStatement (INSERT_SQL, arrayOf(\"id\")).apply { setString(1, name) } }, keyHolder) // keyHolder.getKey() now contains the generated key 4.3.4. Controlling Database Connections This section covers: \u2022 Using DataSource \u2022 Using DataSourceUtils \u2022 Implementing SmartDataSource \u2022 Extending AbstractDataSource \u2022 Using SingleConnectionDataSource \u2022 Using DriverManagerDataSource \u2022 Using TransactionAwareDataSourceProxy \u2022 Using DataSourceTransactionManager Using DataSource Spring obtains a connection to the database through a DataSource. A DataSource is part of the JDBC specification and is a generalized connection factory. It lets a container or a framework hide connection pooling and transaction management issues from the application code. As a developer, you need not know details about how to connect to the database. That is the responsibility of the 749", "chunk_char_count": 1382, "chunk_word_count": 182, "chunk_token_count": 345.5}, {"page_number": 750, "sentence_chunk": "administrator who sets up the datasource. You most likely fill both roles as you develop and test code, but you do not necessarily have to know how the production data source is configured. When you use Spring\u2019s JDBC layer, you can obtain a data source from JNDI, or you can configure your own with a connection pool implementation provided by a third party. Traditional choices are Apache Commons DBCP and C3P0 with bean-style DataSource classes; for a modern JDBC connection pool, consider HikariCP with its builder-style API instead.\uf05a You should use the DriverManagerDataSource and SimpleDriverDataSource classes (as included in the Spring distribution) only for testing purposes!Those variants do not provide pooling and perform poorly when multiple requests for a connection are made. The following section uses Spring\u2019s DriverManagerDataSource implementation. Several other DataSource variants are covered later. To configure a DriverManagerDataSource: 1. Obtain a connection with DriverManagerDataSource as you typically obtain a JDBC connection.", "chunk_char_count": 1053, "chunk_word_count": 153, "chunk_token_count": 263.25}, {"page_number": 750, "sentence_chunk": "2. Specify the fully qualified classname of the JDBC driver so that the DriverManager can load the driver class.3. Provide a URL that varies between JDBC drivers. (See the documentation for your driver for the correct value.)4. Provide a username and a password to connect to the database. The following example shows how to configure a DriverManagerDataSource in Java: Java DriverManagerDataSource dataSource = new DriverManagerDataSource(); dataSource.setDriverClassName(\"org.hsqldb.jdbcDriver\"); dataSource.setUrl(\"jdbc:hsqldb:hsql://localhost:\"); dataSource.setUsername(\"sa\"); dataSource.setPassword(\"\"); Kotlin val dataSource = DriverManagerDataSource().apply { \u00a0  setDriverClassName(\"org.hsqldb.jdbcDriver\") \u00a0  url = \"jdbc:hsqldb:hsql://localhost:\" \u00a0  username = \"sa\" \u00a0  password = \"\" } The following example shows the corresponding XML configuration: 750", "chunk_char_count": 861, "chunk_word_count": 103, "chunk_token_count": 215.25}, {"page_number": 751, "sentence_chunk": "<bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource. DriverManagerDataSource\"> \u00a0  <property name=\"driverClassName\" value=\"${jdbc.driverClassName}\"/> \u00a0  <property name=\"url\" value=\"${jdbc.url}\"/> \u00a0  <property name=\"username\" value=\"${jdbc.username}\"/> \u00a0  <property name=\"password\" value=\"${jdbc.password}\"/> </bean> <context:property-placeholder location=\"jdbc.properties\"/> The next two examples show the basic connectivity and configuration for DBCP and C3P0. To learn about more options that help control the pooling features, see the product documentation for the respective connection pooling implementations. The following example shows DBCP configuration: <bean id=\"dataSource\" class=\"org.apache.commons.dbcp. BasicDataSource\" destroy- method=\"close\"> \u00a0  <property name=\"driverClassName\" value=\"${jdbc.driverClassName}\"/> \u00a0  <property name=\"url\" value=\"${jdbc.url}\"/> \u00a0  <property name=\"username\" value=\"${jdbc.username}\"/> \u00a0  <property name=\"password\" value=\"${jdbc.password}\"/> </bean> <context:property-placeholder location=\"jdbc.properties\"/> The following example shows C3P0 configuration: <bean id=\"dataSource\" class=\"com.mchange.v2.c3p0. ComboPooledDataSource\" destroy- method=\"close\"> \u00a0  <property name=\"driverClass\" value=\"${jdbc.driverClassName}\"/> \u00a0  <property name=\"jdbcUrl\" value=\"${jdbc.url}\"/> \u00a0  <property name=\"user\" value=\"${jdbc.username}\"/> \u00a0  <property name=\"password\" value=\"${jdbc.password}\"/> </bean> <context:property-placeholder location=\"jdbc.properties\"/> Using DataSourceUtils The DataSourceUtils class is a convenient and powerful helper class that provides static methods to obtain connections from JNDI and close connections if necessary. It supports thread-bound connections with, for example, DataSourceTransactionManager. Implementing SmartDataSource The SmartDataSource interface should be implemented by classes that can provide a connection to a 751", "chunk_char_count": 1906, "chunk_word_count": 184, "chunk_token_count": 476.5}, {"page_number": 752, "sentence_chunk": "relational database. It extends the DataSource interface to let classes that use it query whether the connection should be closed after a given operation. This usage is efficient when you know that you need to reuse a connection. Extending AbstractDataSource AbstractDataSource is an abstract base class for Spring\u2019s DataSource implementations. It implements code that is common to all DataSource implementations. You should extend the AbstractDataSource class if you write your own DataSource implementation. Using SingleConnectionDataSource The SingleConnectionDataSource class is an implementation of the SmartDataSource interface that wraps a single Connection that is not closed after each use. This is not multi-threading capable. If any client code calls close on the assumption of a pooled connection (as when using persistence tools), you should set the suppressClose property to true. This setting returns a close-suppressing proxy that wraps the physical connection.", "chunk_char_count": 977, "chunk_word_count": 139, "chunk_token_count": 244.25}, {"page_number": 752, "sentence_chunk": "Note that you can no longer cast this to a native Oracle Connection or a similar object. SingleConnectionDataSource is primarily a test class. It typically enables easy testing of code outside an application server, in conjunction with a simple JNDI environment. In contrast to DriverManagerDataSource, it reuses the same connection all the time, avoiding excessive creation of physical connections. Using DriverManagerDataSource The DriverManagerDataSource class is an implementation of the standard DataSource interface that configures a plain JDBC driver through bean properties and returns a new Connection every time. This implementation is useful for test and stand-alone environments outside of a Jakarta EE container, either as a DataSource bean in a Spring IoC container or in conjunction with a simple JNDI environment. Pool-assuming Connection.close() calls close the connection, so any DataSource -aware persistence code should work. However, using JavaBean-style connection pools (such as commons-dbcp) is so easy, even in a test environment, that it is almost always preferable to use such a connection pool over DriverManagerDataSource. Using TransactionAwareDataSourceProxy TransactionAwareDataSourceProxy is a proxy for a target DataSource. The proxy wraps that target DataSource to add awareness of Spring-managed transactions.", "chunk_char_count": 1345, "chunk_word_count": 187, "chunk_token_count": 336.25}, {"page_number": 752, "sentence_chunk": "In this respect, it is similar to a transactional JNDI DataSource, as provided by a Jakarta EE server.\uf05a It is rarely desirable to use this class, except when already existing code must be called and passed a standard JDBC DataSource interface implementation. In this case, you can still have this code be usable and, at the same time, have this code participating in Spring managed transactions. It is generally preferable to write your own new code by using the higher level abstractions for resource management, such as JdbcTemplate or DataSourceUtils.752", "chunk_char_count": 557, "chunk_word_count": 90, "chunk_token_count": 139.25}, {"page_number": 753, "sentence_chunk": "See the TransactionAwareDataSourceProxy javadoc for more details. Using DataSourceTransactionManager The DataSourceTransactionManager class is a PlatformTransactionManager implementation for single JDBC datasources. It binds a JDBC connection from the specified data source to the currently executing thread, potentially allowing for one thread connection per data source. Application code is required to retrieve the JDBC connection through DataSourceUtils.getConnection(DataSource) instead of Jakarta EE\u2019s standard DataSource.getConnection. It throws unchecked org.springframework.dao exceptions instead of checked SQLExceptions. All framework classes (such as JdbcTemplate) use this strategy implicitly. If not used with this transaction manager, the lookup strategy behaves exactly like the common one. Thus, it can be used in any case. The DataSourceTransactionManager class supports custom isolation levels and timeouts that get applied as appropriate JDBC statement query timeouts. To support the latter, application code must either use JdbcTemplate or call the DataSourceUtils.applyTransactionTimeout(..) method for each created statement.", "chunk_char_count": 1148, "chunk_word_count": 141, "chunk_token_count": 287.0}, {"page_number": 753, "sentence_chunk": "You can use this implementation instead of JtaTransactionManager in the single-resource case, as it does not require the container to support JTA. Switching between both is just a matter of configuration, provided you stick to the required connection lookup pattern. JTA does not support custom isolation levels.4.3.5. JDBC Batch Operations Most JDBC drivers provide improved performance if you batch multiple calls to the same prepared statement. By grouping updates into batches, you limit the number of round trips to the database. Basic Batch Operations with JdbcTemplate You accomplish JdbcTemplate batch processing by implementing two methods of a special interface, BatchPreparedStatementSetter, and passing that implementation in as the second parameter in your batchUpdate method call. You can use the getBatchSize method to provide the size of the current batch. You can use the setValues method to set the values for the parameters of the prepared statement. This method is called the number of times that you specified in the getBatchSize call.", "chunk_char_count": 1056, "chunk_word_count": 160, "chunk_token_count": 264.0}, {"page_number": 753, "sentence_chunk": "The following example updates the t_actor table based on entries in a list, and the entire list is used as the batch: 753", "chunk_char_count": 121, "chunk_word_count": 23, "chunk_token_count": 30.25}, {"page_number": 754, "sentence_chunk": "Java public class JdbcActorDao implements ActorDao { \u00a0  private JdbcTemplate jdbcTemplate; \u00a0  public void setDataSource(DataSource dataSource) { \u00a0    this.jdbcTemplate = new JdbcTemplate(dataSource); \u00a0  } \u00a0  public int[] batchUpdate(final List<Actor> actors) { \u00a0    return this.jdbcTemplate.batchUpdate( \u00a0        \"update t_actor set first_name = ?,last_name = ?where id = ?\",\u00a0        new BatchPreparedStatementSetter() { \u00a0          public void setValues(PreparedStatement ps, int i) throws SQLException { \u00a0            Actor actor = actors.get(i); \u00a0            ps.setString(1, actor.getFirstName()); \u00a0            ps.setString(2, actor.getLastName()); \u00a0            ps.setLong(3, actor.getId().longValue()); \u00a0          } \u00a0          public int getBatchSize() { \u00a0            return actors.size(); \u00a0          } \u00a0        }); \u00a0  } \u00a0  // ... additional methods } 754", "chunk_char_count": 857, "chunk_word_count": 220, "chunk_token_count": 214.25}, {"page_number": 755, "sentence_chunk": "Kotlin class JdbcActorDao(dataSource: DataSource) : ActorDao { \u00a0  private val jdbcTemplate = JdbcTemplate(dataSource) \u00a0  fun batchUpdate(actors: List<Actor>): IntArray { \u00a0    return jdbcTemplate.batchUpdate( \u00a0        \"update t_actor set first_name = ?,last_name = ?where id = ?\",\u00a0        object: BatchPreparedStatementSetter { \u00a0          override fun setValues(ps: PreparedStatement, i: Int) { \u00a0            ps.setString(1, actors[i].firstName) \u00a0            ps.setString(2, actors[i].lastName) \u00a0            ps.setLong(3, actors[i].id) \u00a0          } \u00a0          override fun getBatchSize() = actors.size \u00a0        }) \u00a0  } \u00a0  // ... additional methods } If you process a stream of updates or reading from a file, you might have a preferred batch size, but the last batch might not have that number of entries. In this case, you can use the InterruptibleBatchPreparedStatementSetter interface, which lets you interrupt a batch once the input source is exhausted. The isBatchExhausted method lets you signal the end of the batch. Batch Operations with a List of Objects Both the JdbcTemplate and the NamedParameterJdbcTemplate provides an alternate way of providing the batch update. Instead of implementing a special batch interface, you provide all parameter values in the call as a list. The framework loops over these values and uses an internal prepared statement setter. The API varies, depending on whether you use named parameters.", "chunk_char_count": 1431, "chunk_word_count": 285, "chunk_token_count": 357.75}, {"page_number": 755, "sentence_chunk": "For the named parameters, you provide an array of SqlParameterSource, one entry for each member of the batch. You can use the SqlParameterSourceUtils.createBatch convenience methods to create this array, passing in an array of bean-style objects (with getter methods corresponding to parameters), String -keyed Map instances (containing the corresponding parameters as values), or a mix of both. The following example shows a batch update using named parameters: 755", "chunk_char_count": 466, "chunk_word_count": 68, "chunk_token_count": 116.5}, {"page_number": 756, "sentence_chunk": "Java public class JdbcActorDao implements ActorDao { \u00a0  private NamedParameterTemplate namedParameterJdbcTemplate; \u00a0  public void setDataSource(DataSource dataSource) { \u00a0    this.namedParameterJdbcTemplate = new NamedParameterJdbcTemplate(dataSource); \u00a0  } \u00a0  public int[] batchUpdate(List<Actor> actors) { \u00a0    return this.namedParameterJdbcTemplate.batchUpdate( \u00a0        \"update t_actor set first_name = :firstName, last_name = :lastName where id = :id\", \u00a0        SqlParameterSourceUtils.createBatch(actors)); \u00a0  } \u00a0  // ... additional methods } Kotlin class JdbcActorDao(dataSource: DataSource) : ActorDao { \u00a0  private val namedParameterJdbcTemplate = NamedParameterJdbcTemplate(dataSource) \u00a0  fun batchUpdate(actors: List<Actor>): IntArray { \u00a0    return this.namedParameterJdbcTemplate.batchUpdate( \u00a0        \"update t_actor set first_name = :firstName, last_name = :lastName where id = :id\", \u00a0        SqlParameterSourceUtils.createBatch(actors)); \u00a0  } \u00a0    // ... additional methods } For an SQL statement that uses the classic ?placeholders, you pass in a list containing an object array with the update values. This object array must have one entry for each placeholder in the SQL statement, and they must be in the same order as they are defined in the SQL statement. The following example is the same as the preceding example, except that it uses classic JDBC ?placeholders: 756", "chunk_char_count": 1386, "chunk_word_count": 222, "chunk_token_count": 346.5}, {"page_number": 757, "sentence_chunk": "Java public class JdbcActorDao implements ActorDao { \u00a0  private JdbcTemplate jdbcTemplate; \u00a0  public void setDataSource(DataSource dataSource) { \u00a0    this.jdbcTemplate = new JdbcTemplate(dataSource); \u00a0  } \u00a0  public int[] batchUpdate(final List<Actor> actors) { \u00a0    List<Object[]> batch = new ArrayList<Object[]>(); \u00a0    for (Actor actor : actors) { \u00a0      Object[] values = new Object[] { \u00a0          actor.getFirstName(), actor.getLastName(), actor.getId()}; \u00a0      batch.add(values); \u00a0    } \u00a0    return this.jdbcTemplate.batchUpdate( \u00a0        \"update t_actor set first_name = ?,last_name = ?where id = ?\",\u00a0        batch); \u00a0  } \u00a0  // ... additional methods } Kotlin class JdbcActorDao(dataSource: DataSource) : ActorDao { \u00a0  private val jdbcTemplate = JdbcTemplate(dataSource) \u00a0  fun batchUpdate(actors: List<Actor>): IntArray { \u00a0    val batch = mutableListOf<Array<Any>>() \u00a0    for (actor in actors) { \u00a0      batch.add(arrayOf(actor.firstName, actor.lastName, actor.id)) \u00a0    } \u00a0    return jdbcTemplate.batchUpdate( \u00a0        \"update t_actor set first_name = ?,last_name = ?where id = ?\",batch) \u00a0  } \u00a0  // ... additional methods } All of the batch update methods that we described earlier return an int array containing the number of affected rows for each batch entry. This count is reported by the JDBC driver. If the count is not available, the JDBC driver returns a value of -2.757", "chunk_char_count": 1386, "chunk_word_count": 270, "chunk_token_count": 346.5}, {"page_number": 758, "sentence_chunk": "\uf05a In such a scenario, with automatic setting of values on an underlying PreparedStatement, the corresponding JDBC type for each value needs to be derived from the given Java type. While this usually works well, there is a potential for issues (for example, with Map-contained null values). Spring, by default, calls ParameterMetaData.getParameterType in such a case, which can be expensive with your JDBC driver. You should use a recent driver version and consider setting the spring.jdbc.getParameterType.ignore property to true (as a JVM system property or via the SpringProperties mechanism) if you encounter a performance issue (as reported on Oracle 12c, JBoss, and PostgreSQL). Alternatively, you might consider specifying the corresponding JDBC types explicitly, either through a BatchPreparedStatementSetter (as shown earlier), through an explicit type array given to a List<Object[]> based call, through registerSqlType calls on a custom MapSqlParameterSource instance, or through a BeanPropertySqlParameterSource that derives the SQL type from the Java-declared property type even for a null value. Batch Operations with Multiple Batches The preceding example of a batch update deals with batches that are so large that you want to break them up into several smaller batches. You can do this with the methods mentioned earlier by making multiple calls to the batchUpdate method, but there is now a more convenient method. This method takes, in addition to the SQL statement, a Collection of objects that contain the parameters, the number of updates to make for each batch, and a ParameterizedPreparedStatementSetter to set the values for the parameters of the prepared statement. The framework loops over the provided values and breaks the update calls into batches of the size specified. The following example shows a batch update that uses a batch size of 100: 758", "chunk_char_count": 1877, "chunk_word_count": 286, "chunk_token_count": 469.25}, {"page_number": 759, "sentence_chunk": "Java public class JdbcActorDao implements ActorDao { \u00a0  private JdbcTemplate jdbcTemplate; \u00a0  public void setDataSource(DataSource dataSource) { \u00a0    this.jdbcTemplate = new JdbcTemplate(dataSource); \u00a0  } \u00a0  public int[][] batchUpdate(final Collection<Actor> actors) { \u00a0    int[][] updateCounts = jdbcTemplate.batchUpdate( \u00a0        \"update t_actor set first_name = ?,last_name = ?where id = ?\",\u00a0        actors, \u00a0        100, \u00a0        (PreparedStatement ps, Actor actor) -> { \u00a0          ps.setString(1, actor.getFirstName()); \u00a0          ps.setString(2, actor.getLastName()); \u00a0          ps.setLong(3, actor.getId().longValue()); \u00a0        }); \u00a0    return updateCounts; \u00a0  } \u00a0  // ... additional methods } Kotlin class JdbcActorDao(dataSource: DataSource) : ActorDao { \u00a0  private val jdbcTemplate = JdbcTemplate(dataSource) \u00a0  fun batchUpdate(actors: List<Actor>): Array<IntArray> { \u00a0    return jdbcTemplate.batchUpdate( \u00a0          \"update t_actor set first_name = ?,last_name = ?where id = ?\",\u00a0          actors, 100) { ps, argument -> \u00a0      ps.setString(1, argument.firstName) \u00a0      ps.setString(2, argument.lastName) \u00a0      ps.setLong(3, argument.id) \u00a0    } \u00a0  } \u00a0  // ... additional methods } The batch update method for this call returns an array of int arrays that contains an array entry for each batch with an array of the number of affected rows for each update. The top-level array\u2019s length indicates the number of batches run, and the second level array\u2019s length indicates the number of updates in that batch. The number of updates in each batch should be the batch size 759", "chunk_char_count": 1582, "chunk_word_count": 329, "chunk_token_count": 395.5}, {"page_number": 760, "sentence_chunk": "provided for all batches (except that the last one that might be less), depending on the total number of update objects provided. The update count for each update statement is the one reported by the JDBC driver. If the count is not available, the JDBC driver returns a value of -2.4.3.6. Simplifying JDBC Operations with the SimpleJdbc Classes The SimpleJdbcInsert and SimpleJdbcCall classes provide a simplified configuration by taking advantage of database metadata that can be retrieved through the JDBC driver. This means that you have less to configure up front, although you can override or turn off the metadata processing if you prefer to provide all the details in your code. Inserting Data by Using SimpleJdbcInsert We start by looking at the SimpleJdbcInsert class with the minimal amount of configuration options. You should instantiate the SimpleJdbcInsert in the data access layer\u2019s initialization method. For this example, the initializing method is the setDataSource method. You do not need to subclass the SimpleJdbcInsert class.", "chunk_char_count": 1047, "chunk_word_count": 163, "chunk_token_count": 261.75}, {"page_number": 760, "sentence_chunk": "Instead, you can create a new instance and set the table name by using the withTableName method. Configuration methods for this class follow the fluid style that returns the instance of the SimpleJdbcInsert, which lets you chain all configuration methods. The following example uses only one configuration method (we show examples of multiple methods later): Java public class JdbcActorDao implements ActorDao { \u00a0  private SimpleJdbcInsert insertActor; \u00a0  public void setDataSource(DataSource dataSource) { \u00a0    this.insertActor = new SimpleJdbcInsert(dataSource).withTableName(\"t_actor\"); \u00a0  } \u00a0  public void add(Actor actor) { \u00a0    Map<String, Object> parameters = new HashMap<String, Object>(3); \u00a0    parameters.put(\"id\", actor.getId()); \u00a0    parameters.put(\"first_name\", actor.getFirstName()); \u00a0    parameters.put(\"last_name\", actor.getLastName()); \u00a0    insertActor.execute(parameters); \u00a0  } \u00a0  // ... additional methods } 760", "chunk_char_count": 930, "chunk_word_count": 137, "chunk_token_count": 232.5}, {"page_number": 761, "sentence_chunk": "Kotlin class JdbcActorDao(dataSource: DataSource) : ActorDao { \u00a0  private val insertActor = SimpleJdbcInsert(dataSource).withTableName(\"t_actor\") \u00a0  fun add(actor: Actor) { \u00a0    val parameters = mutableMapOf<String, Any>() \u00a0    parameters[\"id\"] = actor.id \u00a0    parameters[\"first_name\"] = actor.firstName \u00a0    parameters[\"last_name\"] = actor.lastName \u00a0    insertActor.execute(parameters) \u00a0  } \u00a0  // ... additional methods } The execute method used here takes a plain java.util. Map as its only parameter. The important thing to note here is that the keys used for the Map must match the column names of the table, as defined in the database. This is because we read the metadata to construct the actual insert statement. Retrieving Auto-generated Keys by Using SimpleJdbcInsert The next example uses the same insert as the preceding example, but, instead of passing in the id, it retrieves the auto-generated key and sets it on the new Actor object. When it creates the SimpleJdbcInsert, in addition to specifying the table name, it specifies the name of the generated key column with the usingGeneratedKeyColumns method. The following listing shows how it works: 761", "chunk_char_count": 1166, "chunk_word_count": 189, "chunk_token_count": 291.5}, {"page_number": 762, "sentence_chunk": "Java public class JdbcActorDao implements ActorDao { \u00a0  private SimpleJdbcInsert insertActor; \u00a0  public void setDataSource(DataSource dataSource) { \u00a0    this.insertActor = new SimpleJdbcInsert(dataSource) \u00a0        .withTableName(\"t_actor\") \u00a0        .usingGeneratedKeyColumns(\"id\"); \u00a0  } \u00a0  public void add(Actor actor) { \u00a0    Map<String, Object> parameters = new HashMap<String, Object>(2); \u00a0    parameters.put(\"first_name\", actor.getFirstName()); \u00a0    parameters.put(\"last_name\", actor.getLastName()); \u00a0    Number newId = insertActor.executeAndReturnKey(parameters); \u00a0    actor.setId(newId.longValue()); \u00a0  } \u00a0  // ... additional methods } Kotlin class JdbcActorDao(dataSource: DataSource) : ActorDao { \u00a0  private val insertActor = SimpleJdbcInsert(dataSource) \u00a0      .withTableName(\"t_actor\").usingGeneratedKeyColumns(\"id\") \u00a0  fun add(actor: Actor): Actor { \u00a0    val parameters = mapOf( \u00a0        \"first_name\" to actor.firstName, \u00a0        \"last_name\" to actor.lastName) \u00a0    val newId = insertActor.executeAndReturnKey(parameters); \u00a0    return actor.copy(id = newId.toLong()) \u00a0  } \u00a0  // ... additional methods } The main difference when you run the insert by using this second approach is that you do not add the id to the Map, and you call the executeAndReturnKey method. This returns a java.lang. Number object with which you can create an instance of the numerical type that is used in your domain class. You cannot rely on all databases to return a specific Java class here.java.lang. Number is the base class that you can rely on. If you have multiple auto-generated columns or the generated values are non-numeric, you can use a KeyHolder that is returned from the executeAndReturnKeyHolder method.762", "chunk_char_count": 1708, "chunk_word_count": 286, "chunk_token_count": 427.0}, {"page_number": 763, "sentence_chunk": "Specifying Columns for a SimpleJdbcInsert You can limit the columns for an insert by specifying a list of column names with the usingColumns method, as the following example shows: Java public class JdbcActorDao implements ActorDao { \u00a0  private SimpleJdbcInsert insertActor; \u00a0  public void setDataSource(DataSource dataSource) { \u00a0    this.insertActor = new SimpleJdbcInsert(dataSource) \u00a0        .withTableName(\"t_actor\") \u00a0        .usingColumns(\"first_name\", \"last_name\") \u00a0        .usingGeneratedKeyColumns(\"id\"); \u00a0  } \u00a0  public void add(Actor actor) { \u00a0    Map<String, Object> parameters = new HashMap<String, Object>(2); \u00a0    parameters.put(\"first_name\", actor.getFirstName()); \u00a0    parameters.put(\"last_name\", actor.getLastName()); \u00a0    Number newId = insertActor.executeAndReturnKey(parameters); \u00a0    actor.setId(newId.longValue()); \u00a0  } \u00a0  // ... additional methods } Kotlin class JdbcActorDao(dataSource: DataSource) : ActorDao { \u00a0  private val insertActor = SimpleJdbcInsert(dataSource) \u00a0      .withTableName(\"t_actor\") \u00a0      .usingColumns(\"first_name\", \"last_name\") \u00a0      .usingGeneratedKeyColumns(\"id\") \u00a0  fun add(actor: Actor): Actor { \u00a0    val parameters = mapOf( \u00a0        \"first_name\" to actor.firstName, \u00a0        \"last_name\" to actor.lastName) \u00a0    val newId = insertActor.executeAndReturnKey(parameters); \u00a0    return actor.copy(id = newId.toLong()) \u00a0  } \u00a0  // ... additional methods } The execution of the insert is the same as if you had relied on the metadata to determine which 763", "chunk_char_count": 1499, "chunk_word_count": 259, "chunk_token_count": 374.75}, {"page_number": 764, "sentence_chunk": "columns to use. Using SqlParameterSource to Provide Parameter Values Using a Map to provide parameter values works fine, but it is not the most convenient class to use. Spring provides a couple of implementations of the SqlParameterSource interface that you can use instead. The first one is BeanPropertySqlParameterSource, which is a very convenient class if you have a JavaBean-compliant class that contains your values. It uses the corresponding getter method to extract the parameter values. The following example shows how to use BeanPropertySqlParameterSource: Java public class JdbcActorDao implements ActorDao { \u00a0  private SimpleJdbcInsert insertActor; \u00a0  public void setDataSource(DataSource dataSource) { \u00a0    this.insertActor = new SimpleJdbcInsert(dataSource) \u00a0        .withTableName(\"t_actor\") \u00a0        .usingGeneratedKeyColumns(\"id\"); \u00a0  } \u00a0  public void add(Actor actor) { \u00a0    SqlParameterSource parameters = new BeanPropertySqlParameterSource(actor); \u00a0    Number newId = insertActor.executeAndReturnKey(parameters); \u00a0    actor.setId(newId.longValue()); \u00a0  } \u00a0  // ... additional methods } Kotlin class JdbcActorDao(dataSource: DataSource) : ActorDao { \u00a0  private val insertActor = SimpleJdbcInsert(dataSource) \u00a0      .withTableName(\"t_actor\") \u00a0      .usingGeneratedKeyColumns(\"id\") \u00a0  fun add(actor: Actor): Actor { \u00a0    val parameters = BeanPropertySqlParameterSource(actor) \u00a0    val newId = insertActor.executeAndReturnKey(parameters) \u00a0    return actor.copy(id = newId.toLong()) \u00a0  } \u00a0  // ... additional methods } Another option is the MapSqlParameterSource that resembles a Map but provides a more convenient 764", "chunk_char_count": 1633, "chunk_word_count": 254, "chunk_token_count": 408.25}, {"page_number": 765, "sentence_chunk": "addValue method that can be chained. The following example shows how to use it: Java public class JdbcActorDao implements ActorDao { \u00a0  private SimpleJdbcInsert insertActor; \u00a0  public void setDataSource(DataSource dataSource) { \u00a0    this.insertActor = new SimpleJdbcInsert(dataSource) \u00a0        .withTableName(\"t_actor\") \u00a0        .usingGeneratedKeyColumns(\"id\"); \u00a0  } \u00a0  public void add(Actor actor) { \u00a0    SqlParameterSource parameters = new MapSqlParameterSource() \u00a0        .addValue(\"first_name\", actor.getFirstName()) \u00a0        .addValue(\"last_name\", actor.getLastName()); \u00a0    Number newId = insertActor.executeAndReturnKey(parameters); \u00a0    actor.setId(newId.longValue()); \u00a0  } \u00a0  // ... additional methods } Kotlin class JdbcActorDao(dataSource: DataSource) : ActorDao { \u00a0  private val insertActor = SimpleJdbcInsert(dataSource) \u00a0      .withTableName(\"t_actor\") \u00a0      .usingGeneratedKeyColumns(\"id\") \u00a0  fun add(actor: Actor): Actor { \u00a0    val parameters = MapSqlParameterSource() \u00a0          .addValue(\"first_name\", actor.firstName) \u00a0          .addValue(\"last_name\", actor.lastName) \u00a0    val newId = insertActor.executeAndReturnKey(parameters) \u00a0    return actor.copy(id = newId.toLong()) \u00a0  } \u00a0  // ... additional methods } As you can see, the configuration is the same. Only the executing code has to change to use these alternative input classes. Calling a Stored Procedure with SimpleJdbcCall The SimpleJdbcCall class uses metadata in the database to look up names of in and out parameters 765", "chunk_char_count": 1501, "chunk_word_count": 260, "chunk_token_count": 375.25}, {"page_number": 766, "sentence_chunk": "so that you do not have to explicitly declare them. You can declare parameters if you prefer to do that or if you have parameters (such as ARRAY or STRUCT) that do not have an automatic mapping to a Java class. The first example shows a simple procedure that returns only scalar values in VARCHAR and DATE format from a MySQL database. The example procedure reads a specified actor entry and returns first_name, last_name, and birth_date columns in the form of out parameters. The following listing shows the first example: CREATE PROCEDURE read_actor ( \u00a0  IN in_id INTEGER, \u00a0  OUT out_first_name VARCHAR(100), \u00a0  OUT out_last_name VARCHAR(100), \u00a0  OUT out_birth_date DATE) BEGIN \u00a0  SELECT first_name, last_name, birth_date \u00a0  INTO out_first_name, out_last_name, out_birth_date \u00a0  FROM t_actor where id = in_id; END; The in_id parameter contains the id of the actor that you are looking up. The out parameters return the data read from the table. You can declare SimpleJdbcCall in a manner similar to declaring SimpleJdbcInsert. You should instantiate and configure the class in the initialization method of your data-access layer. Compared to the StoredProcedure class, you need not create a subclass and you need not to declare parameters that can be looked up in the database metadata. The following example of a SimpleJdbcCall configuration uses the preceding stored procedure (the only configuration option, in addition to the DataSource, is the name of the stored procedure): 766", "chunk_char_count": 1485, "chunk_word_count": 242, "chunk_token_count": 371.25}, {"page_number": 767, "sentence_chunk": "Java public class JdbcActorDao implements ActorDao { \u00a0  private SimpleJdbcCall procReadActor; \u00a0  public void setDataSource(DataSource dataSource) { \u00a0    this.procReadActor = new SimpleJdbcCall(dataSource) \u00a0        .withProcedureName(\"read_actor\"); \u00a0  } \u00a0  public Actor readActor(Long id) { \u00a0    SqlParameterSource in = new MapSqlParameterSource() \u00a0        .addValue(\"in_id\", id); \u00a0    Map out = procReadActor.execute(in); \u00a0    Actor actor = new Actor(); \u00a0    actor.setId(id); \u00a0    actor.setFirstName((String) out.get(\"out_first_name\")); \u00a0    actor.setLastName((String) out.get(\"out_last_name\")); \u00a0    actor.setBirthDate((Date) out.get(\"out_birth_date\")); \u00a0    return actor; \u00a0  } \u00a0  // ... additional methods } Kotlin class JdbcActorDao(dataSource: DataSource) : ActorDao { \u00a0  private val procReadActor = SimpleJdbcCall(dataSource) \u00a0      .withProcedureName(\"read_actor\") \u00a0  fun readActor(id: Long): Actor { \u00a0    val source = MapSqlParameterSource().addValue(\"in_id\", id) \u00a0    val output = procReadActor.execute(source) \u00a0    return Actor( \u00a0        id, \u00a0        output[\"out_first_name\"] as String, \u00a0        output[\"out_last_name\"] as String, \u00a0        output[\"out_birth_date\"] as Date) \u00a0  } \u00a0    // ... additional methods } The code you write for the execution of the call involves creating an SqlParameterSource containing the IN parameter. You must match the name provided for the input value with that of the parameter name declared in the stored procedure. The case does not have to match because you 767", "chunk_char_count": 1505, "chunk_word_count": 275, "chunk_token_count": 376.25}, {"page_number": 768, "sentence_chunk": "use metadata to determine how database objects should be referred to in a stored procedure. What is specified in the source for the stored procedure is not necessarily the way it is stored in the database. Some databases transform names to all upper case, while others use lower case or use the case as specified. The execute method takes the IN parameters and returns a Map that contains any out parameters keyed by the name, as specified in the stored procedure. In this case, they are out_first_name, out_last_name, and out_birth_date. The last part of the execute method creates an Actor instance to use to return the data retrieved. Again, it is important to use the names of the out parameters as they are declared in the stored procedure. Also, the case in the names of the out parameters stored in the results map matches that of the out parameter names in the database, which could vary between databases. To make your code more portable, you should do a case-insensitive lookup or instruct Spring to use a LinkedCaseInsensitiveMap. To do the latter, you can create your own JdbcTemplate and set the setResultsMapCaseInsensitive property to true.", "chunk_char_count": 1155, "chunk_word_count": 194, "chunk_token_count": 288.75}, {"page_number": 768, "sentence_chunk": "Then you can pass this customized JdbcTemplate instance into the constructor of your SimpleJdbcCall. The following example shows this configuration: Java public class JdbcActorDao implements ActorDao { \u00a0  private SimpleJdbcCall procReadActor; \u00a0  public void setDataSource(DataSource dataSource) { \u00a0    JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); \u00a0    jdbcTemplate.setResultsMapCaseInsensitive(true); \u00a0    this.procReadActor = new SimpleJdbcCall(jdbcTemplate) \u00a0        .withProcedureName(\"read_actor\"); \u00a0  } \u00a0  // ... additional methods } Kotlin class JdbcActorDao(dataSource: DataSource) : ActorDao { \u00a0  private var procReadActor = SimpleJdbcCall(JdbcTemplate(dataSource).apply { \u00a0    isResultsMapCaseInsensitive = true \u00a0  }).withProcedureName(\"read_actor\") \u00a0  // ... additional methods } By taking this action, you avoid conflicts in the case used for the names of your returned out parameters.768", "chunk_char_count": 912, "chunk_word_count": 131, "chunk_token_count": 228.0}, {"page_number": 769, "sentence_chunk": "Explicitly Declaring Parameters to Use for a SimpleJdbcCall Earlier in this chapter, we described how parameters are deduced from metadata, but you can declare them explicitly if you wish. You can do so by creating and configuring SimpleJdbcCall with the declareParameters method, which takes a variable number of SqlParameter objects as input. See the next section for details on how to define an SqlParameter.\uf05a Explicit declarations are necessary if the database you use is not a Spring- supported database. Currently, Spring supports metadata lookup of stored procedure calls for the following databases: Apache Derby, DB2, MySQL, Microsoft SQL Server, Oracle, and Sybase. We also support metadata lookup of stored functions for MySQL, Microsoft SQL Server, and Oracle. You can opt to explicitly declare one, some, or all of the parameters. The parameter metadata is still used where you do not explicitly declare parameters. To bypass all processing of metadata lookups for potential parameters and use only the declared parameters, you can call the method withoutProcedureColumnMetaDataAccess as part of the declaration. Suppose that you have two or more different call signatures declared for a database function.", "chunk_char_count": 1219, "chunk_word_count": 185, "chunk_token_count": 304.75}, {"page_number": 769, "sentence_chunk": "In this case, you call useInParameterNames to specify the list of IN parameter names to include for a given signature. The following example shows a fully declared procedure call and uses the information from the preceding example: Java public class JdbcActorDao implements ActorDao { \u00a0  private SimpleJdbcCall procReadActor; \u00a0  public void setDataSource(DataSource dataSource) { \u00a0    JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); \u00a0    jdbcTemplate.setResultsMapCaseInsensitive(true); \u00a0    this.procReadActor = new SimpleJdbcCall(jdbcTemplate) \u00a0        .withProcedureName(\"read_actor\") \u00a0        .withoutProcedureColumnMetaDataAccess() \u00a0        .useInParameterNames(\"in_id\") \u00a0        .declareParameters( \u00a0            new SqlParameter(\"in_id\", Types. NUMERIC), \u00a0            new SqlOutParameter(\"out_first_name\", Types. VARCHAR), \u00a0            new SqlOutParameter(\"out_last_name\", Types. VARCHAR), \u00a0            new SqlOutParameter(\"out_birth_date\", Types. DATE) \u00a0        ); \u00a0  } \u00a0  // ... additional methods } 769", "chunk_char_count": 1021, "chunk_word_count": 198, "chunk_token_count": 255.25}, {"page_number": 770, "sentence_chunk": "Kotlin class JdbcActorDao(dataSource: DataSource) : ActorDao { \u00a0    private val procReadActor = SimpleJdbcCall(JdbcTemplate(dataSource).apply { \u00a0      isResultsMapCaseInsensitive = true \u00a0    }).withProcedureName(\"read_actor\") \u00a0        .withoutProcedureColumnMetaDataAccess() \u00a0        .useInParameterNames(\"in_id\") \u00a0        .declareParameters( \u00a0            SqlParameter(\"in_id\", Types. NUMERIC), \u00a0            SqlOutParameter(\"out_first_name\", Types. VARCHAR), \u00a0            SqlOutParameter(\"out_last_name\", Types. VARCHAR), \u00a0            SqlOutParameter(\"out_birth_date\", Types. DATE) \u00a0  ) \u00a0    // ... additional methods } The execution and end results of the two examples are the same. The second example specifies all details explicitly rather than relying on metadata. How to Define SqlParameters To define a parameter for the SimpleJdbc classes and also for the RDBMS operations classes (covered in Modeling JDBC Operations as Java Objects) you can use SqlParameter or one of its subclasses. To do so, you typically specify the parameter name and SQL type in the constructor. The SQL type is specified by using the java.sql. Types constants.", "chunk_char_count": 1142, "chunk_word_count": 216, "chunk_token_count": 285.5}, {"page_number": 770, "sentence_chunk": "Earlier in this chapter, we saw declarations similar to the following: Java new SqlParameter(\"in_id\", Types. NUMERIC), new SqlOutParameter(\"out_first_name\", Types. VARCHAR), Kotlin SqlParameter(\"in_id\", Types. NUMERIC), SqlOutParameter(\"out_first_name\", Types. VARCHAR), The first line with the SqlParameter declares an IN parameter. You can use IN parameters for both stored procedure calls and for queries by using the SqlQuery and its subclasses (covered in Understanding SqlQuery). The second line (with the SqlOutParameter) declares an out parameter to be used in a stored procedure call. There is also an SqlInOutParameter for InOut parameters (parameters that provide an IN value to the procedure and that also return a value).770", "chunk_char_count": 737, "chunk_word_count": 102, "chunk_token_count": 184.25}, {"page_number": 771, "sentence_chunk": "\uf05a Only parameters declared as SqlParameter and SqlInOutParameter are used to provide input values. This is different from the StoredProcedure class, which (for backwards compatibility reasons) lets input values be provided for parameters declared as SqlOutParameter. For IN parameters, in addition to the name and the SQL type, you can specify a scale for numeric data or a type name for custom database types. For out parameters, you can provide a RowMapper to handle mapping of rows returned from a REF cursor. Another option is to specify an SqlReturnType that provides an opportunity to define customized handling of the return values. Calling a Stored Function by Using SimpleJdbcCall You can call a stored function in almost the same way as you call a stored procedure, except that you provide a function name rather than a procedure name. You use the withFunctionName method as part of the configuration to indicate that you want to make a call to a function, and the corresponding string for a function call is generated. A specialized call (executeFunction) is used to run the function, and it returns the function return value as an object of a specified type, which means you do not have to retrieve the return value from the results map. A similar convenience method (named executeObject) is also available for stored procedures that have only one out parameter. The following example (for MySQL) is based on a stored function named get_actor_name that returns an actor\u2019s full name: CREATE FUNCTION get_actor_name (in_id INTEGER) RETURNS VARCHAR(200) READS SQL DATA BEGIN \u00a0  DECLARE out_name VARCHAR(200); \u00a0  SELECT concat(first_name, ' ', last_name) \u00a0    INTO out_name \u00a0    FROM t_actor where id = in_id; \u00a0  RETURN out_name; END; To call this function, we again create a SimpleJdbcCall in the initialization method, as the following example shows: 771", "chunk_char_count": 1864, "chunk_word_count": 308, "chunk_token_count": 466.0}, {"page_number": 772, "sentence_chunk": "Java public class JdbcActorDao implements ActorDao { \u00a0  private SimpleJdbcCall funcGetActorName; \u00a0  public void setDataSource(DataSource dataSource) { \u00a0    JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); \u00a0    jdbcTemplate.setResultsMapCaseInsensitive(true); \u00a0    this.funcGetActorName = new SimpleJdbcCall(jdbcTemplate) \u00a0        .withFunctionName(\"get_actor_name\"); \u00a0  } \u00a0  public String getActorName(Long id) { \u00a0    SqlParameterSource in = new MapSqlParameterSource() \u00a0        .addValue(\"in_id\", id); \u00a0    String name = funcGetActorName.executeFunction(String.class, in); \u00a0    return name; \u00a0  } \u00a0  // ... additional methods } Kotlin class JdbcActorDao(dataSource: DataSource) : ActorDao { \u00a0  private val jdbcTemplate = JdbcTemplate(dataSource).apply { \u00a0    isResultsMapCaseInsensitive = true \u00a0  } \u00a0  private val funcGetActorName = SimpleJdbcCall(jdbcTemplate) \u00a0      .withFunctionName(\"get_actor_name\") \u00a0  fun getActorName(id: Long): String { \u00a0    val source = MapSqlParameterSource().addValue(\"in_id\", id) \u00a0    return funcGetActorName.executeFunction(String::class.java, source) \u00a0  } \u00a0  // ... additional methods } The executeFunction method used returns a String that contains the return value from the function call. Returning a ResultSet or REF Cursor from a SimpleJdbcCall Calling a stored procedure or function that returns a result set is a bit tricky. Some databases return result sets during the JDBC results processing, while others require an explicitly registered out parameter of a specific type. Both approaches need additional processing to loop over the result set 772", "chunk_char_count": 1595, "chunk_word_count": 250, "chunk_token_count": 398.75}, {"page_number": 773, "sentence_chunk": "and process the returned rows. With the SimpleJdbcCall, you can use the returningResultSet method and declare a RowMapper implementation to be used for a specific parameter. If the result set is returned during the results processing, there are no names defined, so the returned results must match the order in which you declare the RowMapper implementations. The name specified is still used to store the processed list of results in the results map that is returned from the execute statement. The next example (for MySQL) uses a stored procedure that takes no IN parameters and returns all rows from the t_actor table: CREATE PROCEDURE read_all_actors() BEGIN \u00a0SELECT a.id, a.first_name, a.last_name, a.birth_date FROM t_actor a; END; To call this procedure, you can declare the RowMapper. Because the class to which you want to map follows the JavaBean rules, you can use a BeanPropertyRowMapper that is created by passing in the required class to map to in the newInstance method. The following example shows how to do so: Java public class JdbcActorDao implements ActorDao { \u00a0  private SimpleJdbcCall procReadAllActors; \u00a0  public void setDataSource(DataSource dataSource) { \u00a0    JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); \u00a0    jdbcTemplate.setResultsMapCaseInsensitive(true); \u00a0    this.procReadAllActors = new SimpleJdbcCall(jdbcTemplate) \u00a0        .withProcedureName(\"read_all_actors\") \u00a0        .returningResultSet(\"actors\", \u00a0        BeanPropertyRowMapper.newInstance(Actor.class)); \u00a0  } \u00a0  public List getActorsList() { \u00a0    Map m = procReadAllActors.execute(new HashMap<String, Object>(0)); \u00a0    return (List) m.get(\"actors\"); \u00a0  } \u00a0  // ... additional methods } 773", "chunk_char_count": 1689, "chunk_word_count": 271, "chunk_token_count": 422.25}, {"page_number": 774, "sentence_chunk": "Kotlin class JdbcActorDao(dataSource: DataSource) : ActorDao { \u00a0    private val procReadAllActors = SimpleJdbcCall(JdbcTemplate(dataSource).apply { \u00a0      isResultsMapCaseInsensitive = true \u00a0    }).withProcedureName(\"read_all_actors\") \u00a0        .returningResultSet(\"actors\", \u00a0            BeanPropertyRowMapper.newInstance(Actor::class.java)) \u00a0  fun getActorsList(): List<Actor> { \u00a0    val m = procReadAllActors.execute(mapOf<String, Any>()) \u00a0    return m[\"actors\"] as List<Actor> \u00a0  } \u00a0  // ... additional methods } The execute call passes in an empty Map, because this call does not take any parameters. The list of actors is then retrieved from the results map and returned to the caller.4.3.7. Modeling JDBC Operations as Java Objects The org.springframework.jdbc.object package contains classes that let you access the database in a more object-oriented manner. As an example, you can run queries and get the results back as a list that contains business objects with the relational column data mapped to the properties of the business object. You can also run stored procedures and run update, delete, and insert statements.\uf05a Many Spring developers believe that the various RDBMS operation classes described below (with the exception of the StoredProcedure class) can often be replaced with straight JdbcTemplate calls. Often, it is simpler to write a DAO method that calls a method on a JdbcTemplate directly (as opposed to encapsulating a query as a full-blown class). However, if you are getting measurable value from using the RDBMS operation classes, you should continue to use these classes. Understanding SqlQuery SqlQuery is a reusable, thread-safe class that encapsulates an SQL query.", "chunk_char_count": 1698, "chunk_word_count": 272, "chunk_token_count": 424.5}, {"page_number": 774, "sentence_chunk": "Subclasses must implement the newRowMapper(..) method to provide a RowMapper instance that can create one object per row obtained from iterating over the ResultSet that is created during the execution of the query. The SqlQuery class is rarely used directly, because the MappingSqlQuery subclass provides a much more convenient implementation for mapping rows to Java classes. Other implementations that extend SqlQuery are MappingSqlQueryWithParameters and UpdatableSqlQuery.774", "chunk_char_count": 479, "chunk_word_count": 65, "chunk_token_count": 119.75}, {"page_number": 775, "sentence_chunk": "Using MappingSqlQuery MappingSqlQuery is a reusable query in which concrete subclasses must implement the abstract mapRow(..) method to convert each row of the supplied ResultSet into an object of the type specified. The following example shows a custom query that maps the data from the t_actor relation to an instance of the Actor class: Java public class ActorMappingQuery extends MappingSqlQuery<Actor> { \u00a0  public ActorMappingQuery(DataSource ds) { \u00a0    super(ds, \"select id, first_name, last_name from t_actor where id = ?\");\u00a0    declareParameter(new SqlParameter(\"id\", Types. INTEGER)); \u00a0    compile(); \u00a0  } \u00a0  @Override \u00a0  protected Actor mapRow(ResultSet rs, int rowNumber) throws SQLException { \u00a0    Actor actor = new Actor(); \u00a0    actor.setId(rs.getLong(\"id\")); \u00a0    actor.setFirstName(rs.getString(\"first_name\")); \u00a0    actor.setLastName(rs.getString(\"last_name\")); \u00a0    return actor; \u00a0  } } Kotlin class ActorMappingQuery(ds: DataSource) : MappingSqlQuery<Actor>(ds, \"select id, first_name, last_name from t_actor where id = ?\") {\u00a0  init { \u00a0    declareParameter(SqlParameter(\"id\", Types. INTEGER)) \u00a0    compile() \u00a0  } \u00a0  override fun mapRow(rs: ResultSet, rowNumber: Int) = Actor( \u00a0      rs.getLong(\"id\"), \u00a0      rs.getString(\"first_name\"), \u00a0      rs.getString(\"last_name\") \u00a0  ) } The class extends MappingSqlQuery parameterized with the Actor type. The constructor for this customer query takes a DataSource as the only parameter. In this constructor, you can call the constructor on the superclass with the DataSource and the SQL that should be run to retrieve the rows for this query. This SQL is used to create a PreparedStatement, so it may contain placeholders for any parameters to be passed in during execution. You must declare each parameter by using the declareParameter method passing in an SqlParameter.", "chunk_char_count": 1828, "chunk_word_count": 301, "chunk_token_count": 457.0}, {"page_number": 776, "sentence_chunk": "type as defined in java.sql. Types. After you define all parameters, you can call the compile() method so that the statement can be prepared and later run. This class is thread-safe after it is compiled, so, as long as these instances are created when the DAO is initialized, they can be kept as instance variables and be reused. The following example shows how to define such a class: Java private ActorMappingQuery actorMappingQuery; @Autowired public void setDataSource(DataSource dataSource) { \u00a0  this.actorMappingQuery = new ActorMappingQuery(dataSource); } public Customer getCustomer(Long id) { \u00a0  return actorMappingQuery.findObject(id); } Kotlin private val actorMappingQuery = ActorMappingQuery(dataSource) fun getCustomer(id: Long) = actorMappingQuery.findObject(id) The method in the preceding example retrieves the customer with the id that is passed in as the only parameter. Since we want only one object to be returned, we call the findObject convenience method with the id as the parameter. If we had instead a query that returned a list of objects and took additional parameters, we would use one of the execute methods that takes an array of parameter values passed in as varargs. The following example shows such a method: Java public List<Actor> searchForActors(int age, String namePattern) { \u00a0  List<Actor> actors = actorSearchMappingQuery.execute(age, namePattern); \u00a0  return actors; } Kotlin fun searchForActors(age: Int, namePattern: String) = \u00a0      actorSearchMappingQuery.execute(age, namePattern) Using SqlUpdate The SqlUpdate class encapsulates an SQL update. As with a query, an update object is reusable, and, as with all RdbmsOperation classes, an update can have parameters and is defined in SQL. This class provides a number of update(..) methods analogous to the execute(..) methods of query objects.", "chunk_char_count": 1836, "chunk_word_count": 274, "chunk_token_count": 459.0}, {"page_number": 777, "sentence_chunk": "However, you do not have to subclass the SqlUpdate class, since it can easily be parameterized by setting SQL and declaring parameters. The following example creates a custom update method named execute: Java import java.sql. Types; import javax.sql. DataSource; import org.springframework.jdbc.core. SqlParameter; import org.springframework.jdbc.object. SqlUpdate; public class UpdateCreditRating extends SqlUpdate { \u00a0  public UpdateCreditRating(DataSource ds) { \u00a0    setDataSource(ds); \u00a0    setSql(\"update customer set credit_rating = ?where id = ?\");\u00a0    declareParameter(new SqlParameter(\"creditRating\", Types. NUMERIC)); \u00a0    declareParameter(new SqlParameter(\"id\", Types. NUMERIC)); \u00a0    compile(); \u00a0  } \u00a0  /** \u00a0  * @param id for the Customer to be updated \u00a0  * @param rating the new value for credit rating \u00a0  * @return number of rows updated \u00a0  */ \u00a0  public int execute(int id, int rating) { \u00a0    return update(rating, id); \u00a0  } } 777", "chunk_char_count": 942, "chunk_word_count": 155, "chunk_token_count": 235.5}, {"page_number": 778, "sentence_chunk": "Kotlin import java.sql. Types import javax.sql. DataSource import org.springframework.jdbc.core. SqlParameter import org.springframework.jdbc.object. SqlUpdate class UpdateCreditRating(ds: DataSource) : SqlUpdate() { \u00a0  init { \u00a0    setDataSource(ds) \u00a0    sql = \"update customer set credit_rating = ?where id = ?\"\u00a0    declareParameter(SqlParameter(\"creditRating\", Types. NUMERIC)) \u00a0    declareParameter(SqlParameter(\"id\", Types. NUMERIC)) \u00a0    compile() \u00a0  } \u00a0  /** \u00a0  * @param id for the Customer to be updated \u00a0  * @param rating the new value for credit rating \u00a0  * @return number of rows updated \u00a0  */ \u00a0  fun execute(id: Int, rating: Int): Int { \u00a0    return update(rating, id) \u00a0  } } Using StoredProcedure The StoredProcedure class is an abstract superclass for object abstractions of RDBMS stored procedures. The inherited sql property is the name of the stored procedure in the RDBMS.", "chunk_char_count": 888, "chunk_word_count": 150, "chunk_token_count": 222.0}, {"page_number": 778, "sentence_chunk": "To define a parameter for the StoredProcedure class, you can use an SqlParameter or one of its subclasses. You must specify the parameter name and SQL type in the constructor, as the following code snippet shows: Java new SqlParameter(\"in_id\", Types. NUMERIC), new SqlOutParameter(\"out_first_name\", Types. VARCHAR), Kotlin SqlParameter(\"in_id\", Types. NUMERIC), SqlOutParameter(\"out_first_name\", Types. VARCHAR), The SQL type is specified using the java.sql. Types constants.778", "chunk_char_count": 478, "chunk_word_count": 62, "chunk_token_count": 119.5}, {"page_number": 779, "sentence_chunk": "The first line (with the SqlParameter) declares an IN parameter. You can use IN parameters both for stored procedure calls and for queries using the SqlQuery and its subclasses (covered in Understanding SqlQuery). The second line (with the SqlOutParameter) declares an out parameter to be used in the stored procedure call. There is also an SqlInOutParameter for InOut parameters (parameters that provide an in value to the procedure and that also return a value). For in parameters, in addition to the name and the SQL type, you can specify a scale for numeric data or a type name for custom database types. For out parameters, you can provide a RowMapper to handle mapping of rows returned from a REF cursor. Another option is to specify an SqlReturnType that lets you define customized handling of the return values. The next example of a simple DAO uses a StoredProcedure to call a function (sysdate()), which comes with any Oracle database. To use the stored procedure functionality, you have to create a class that extends StoredProcedure. In this example, the StoredProcedure class is an inner class.", "chunk_char_count": 1107, "chunk_word_count": 183, "chunk_token_count": 276.75}, {"page_number": 779, "sentence_chunk": "However, if you need to reuse the StoredProcedure, you can declare it as a top-level class. This example has no input parameters, but an output parameter is declared as a date type by using the SqlOutParameter class. The execute() method runs the procedure and extracts the returned date from the results Map. The results Map has an entry for each declared output parameter (in this case, only one) by using the parameter name as the key. The following listing shows our custom StoredProcedure class: 779", "chunk_char_count": 504, "chunk_word_count": 85, "chunk_token_count": 126.0}, {"page_number": 780, "sentence_chunk": "Java import java.sql. Types; import java.util. Date; import java.util. HashMap; import java.util. Map; import javax.sql. DataSource; import org.springframework.beans.factory.annotation. Autowired; import org.springframework.jdbc.core. SqlOutParameter; import org.springframework.jdbc.object. StoredProcedure; public class StoredProcedureDao { \u00a0  private GetSysdateProcedure getSysdate; \u00a0  @Autowired \u00a0  public void init(DataSource dataSource) { \u00a0    this.getSysdate = new GetSysdateProcedure(dataSource); \u00a0  } \u00a0  public Date getSysdate() { \u00a0    return getSysdate.execute(); \u00a0  } \u00a0  private class GetSysdateProcedure extends StoredProcedure { \u00a0    private static final String SQL = \"sysdate\"; \u00a0    public GetSysdateProcedure(DataSource dataSource) { \u00a0      setDataSource(dataSource); \u00a0      setFunction(true); \u00a0      setSql(SQL); \u00a0      declareParameter(new SqlOutParameter(\"date\", Types. DATE)); \u00a0      compile(); \u00a0    } \u00a0    public Date execute() { \u00a0      // the 'sysdate' sproc has no input parameters, so an empty Map is supplied... \u00a0      Map<String, Object> results = execute(new HashMap<String, Object>()); \u00a0      Date sysdate = (Date) results.get(\"date\"); \u00a0      return sysdate; \u00a0    } \u00a0  } } 780", "chunk_char_count": 1203, "chunk_word_count": 210, "chunk_token_count": 300.75}, {"page_number": 781, "sentence_chunk": "Kotlin import java.sql. Types import java.util. Date import java.util. Map import javax.sql. DataSource import org.springframework.jdbc.core. SqlOutParameter import org.springframework.jdbc.object. StoredProcedure class StoredProcedureDao(dataSource: DataSource) { \u00a0  private val SQL = \"sysdate\" \u00a0  private val getSysdate = GetSysdateProcedure(dataSource) \u00a0  val sysdate: Date \u00a0    get() = getSysdate.execute() \u00a0  private inner class GetSysdateProcedure(dataSource: DataSource) : StoredProcedure() { \u00a0    init { \u00a0      setDataSource(dataSource) \u00a0      isFunction = true \u00a0      sql = SQL \u00a0      declareParameter(SqlOutParameter(\"date\", Types. DATE)) \u00a0      compile() \u00a0    } \u00a0    fun execute(): Date { \u00a0      // the 'sysdate' sproc has no input parameters, so an empty Map is supplied... \u00a0      val results = execute(mutableMapOf<String, Any>()) \u00a0      return results[\"date\"] as Date \u00a0    } \u00a0  } } The following example of a StoredProcedure has two output parameters (in this case, Oracle REF cursors): 781", "chunk_char_count": 1004, "chunk_word_count": 186, "chunk_token_count": 251.0}, {"page_number": 782, "sentence_chunk": "Java import java.util. HashMap; import java.util. Map; import javax.sql. DataSource; import oracle.jdbc. OracleTypes; import org.springframework.jdbc.core. SqlOutParameter; import org.springframework.jdbc.object. StoredProcedure; public class TitlesAndGenresStoredProcedure extends StoredProcedure { \u00a0  private static final String SPROC_NAME = \"AllTitlesAndGenres\"; \u00a0  public TitlesAndGenresStoredProcedure(DataSource dataSource) { \u00a0    super(dataSource, SPROC_NAME); \u00a0    declareParameter(new SqlOutParameter(\"titles\", OracleTypes. CURSOR, new TitleMapper())); \u00a0    declareParameter(new SqlOutParameter(\"genres\", OracleTypes. CURSOR, new GenreMapper())); \u00a0    compile(); \u00a0  } \u00a0  public Map<String, Object> execute() { \u00a0    // again, this sproc has no input parameters, so an empty Map is supplied \u00a0    return super.execute(new HashMap<String, Object>()); \u00a0  } } 782", "chunk_char_count": 866, "chunk_word_count": 112, "chunk_token_count": 216.5}, {"page_number": 783, "sentence_chunk": "Kotlin import java.util. HashMap import javax.sql. DataSource import oracle.jdbc. OracleTypes import org.springframework.jdbc.core. SqlOutParameter import org.springframework.jdbc.object. StoredProcedure class TitlesAndGenresStoredProcedure(dataSource: DataSource) : StoredProcedure(dataSource, SPROC_NAME) { \u00a0  companion object { \u00a0    private const val SPROC_NAME = \"AllTitlesAndGenres\" \u00a0  } \u00a0  init { \u00a0    declareParameter(SqlOutParameter(\"titles\", OracleTypes. CURSOR, TitleMapper())) \u00a0    declareParameter(SqlOutParameter(\"genres\", OracleTypes. CURSOR, GenreMapper())) \u00a0    compile() \u00a0  } \u00a0  fun execute(): Map<String, Any> { \u00a0    // again, this sproc has no input parameters, so an empty Map is supplied \u00a0    return super.execute(HashMap<String, Any>()) \u00a0  } } Notice how the overloaded variants of the declareParameter(..) method that have been used in the TitlesAndGenresStoredProcedure constructor are passed RowMapper implementation instances. This is a very convenient and powerful way to reuse existing functionality. The next two examples provide code for the two RowMapper implementations.", "chunk_char_count": 1102, "chunk_word_count": 150, "chunk_token_count": 275.5}, {"page_number": 784, "sentence_chunk": "Java import java.sql. ResultSet; import java.sql. SQLException; import com.foo.domain. Title; import org.springframework.jdbc.core. RowMapper; public final class TitleMapper implements RowMapper<Title> { \u00a0  public Title mapRow(ResultSet rs, int rowNum) throws SQLException { \u00a0    Title title = new Title(); \u00a0    title.setId(rs.getLong(\"id\")); \u00a0    title.setName(rs.getString(\"name\")); \u00a0    return title; \u00a0  } } Kotlin import java.sql. ResultSet import com.foo.domain. Title import org.springframework.jdbc.core. RowMapper class TitleMapper : RowMapper<Title> { \u00a0  override fun mapRow(rs: ResultSet, rowNum: Int) = \u00a0      Title(rs.getLong(\"id\"), rs.getString(\"name\")) } The GenreMapper class maps a ResultSet to a Genre domain object for each row in the supplied ResultSet, as follows: Java import java.sql. ResultSet; import java.sql. SQLException; import com.foo.domain.", "chunk_char_count": 871, "chunk_word_count": 122, "chunk_token_count": 217.75}, {"page_number": 784, "sentence_chunk": "Genre; import org.springframework.jdbc.core. RowMapper; public final class GenreMapper implements RowMapper<Genre> { \u00a0  public Genre mapRow(ResultSet rs, int rowNum) throws SQLException { \u00a0    return new Genre(rs.getString(\"name\")); \u00a0  } } 784", "chunk_char_count": 243, "chunk_word_count": 34, "chunk_token_count": 60.75}, {"page_number": 785, "sentence_chunk": "Kotlin import java.sql. ResultSet import com.foo.domain. Genre import org.springframework.jdbc.core. RowMapper class GenreMapper : RowMapper<Genre> { \u00a0  override fun mapRow(rs: ResultSet, rowNum: Int): Genre { \u00a0    return Genre(rs.getString(\"name\")) \u00a0  } } To pass parameters to a stored procedure that has one or more input parameters in its definition in the RDBMS, you can code a strongly typed execute(..) method that would delegate to the untyped execute(Map) method in the superclass, as the following example shows: Java import java.sql. Types; import java.util. Date; import java.util. HashMap; import java.util. Map; import javax.sql. DataSource; import oracle.jdbc. OracleTypes; import org.springframework.jdbc.core.", "chunk_char_count": 726, "chunk_word_count": 100, "chunk_token_count": 181.5}, {"page_number": 785, "sentence_chunk": "SqlOutParameter; import org.springframework.jdbc.core. SqlParameter; import org.springframework.jdbc.object. StoredProcedure; public class TitlesAfterDateStoredProcedure extends StoredProcedure { \u00a0  private static final String SPROC_NAME = \"TitlesAfterDate\"; \u00a0  private static final String CUTOFF_DATE_PARAM = \"cutoffDate\"; \u00a0  public TitlesAfterDateStoredProcedure(DataSource dataSource) { \u00a0    super(dataSource, SPROC_NAME); \u00a0    declareParameter(new SqlParameter(CUTOFF_DATE_PARAM, Types. DATE); \u00a0    declareParameter(new SqlOutParameter(\"titles\", OracleTypes. CURSOR, new TitleMapper())); \u00a0    compile(); \u00a0  } \u00a0  public Map<String, Object> execute(Date cutoffDate) { \u00a0    Map<String, Object> inputs = new HashMap<String, Object>(); \u00a0    inputs.put(CUTOFF_DATE_PARAM, cutoffDate); \u00a0    return super.execute(inputs); \u00a0  } } 785", "chunk_char_count": 828, "chunk_word_count": 105, "chunk_token_count": 207.0}, {"page_number": 786, "sentence_chunk": "Kotlin import java.sql. Types import java.util. Date import javax.sql. DataSource import oracle.jdbc. OracleTypes import org.springframework.jdbc.core. SqlOutParameter import org.springframework.jdbc.core. SqlParameter import org.springframework.jdbc.object. StoredProcedure class TitlesAfterDateStoredProcedure(dataSource: DataSource) : StoredProcedure(dataSource, SPROC_NAME) { \u00a0  companion object { \u00a0    private const val SPROC_NAME = \"TitlesAfterDate\" \u00a0    private const val CUTOFF_DATE_PARAM = \"cutoffDate\" \u00a0  } \u00a0  init { \u00a0    declareParameter(SqlParameter(CUTOFF_DATE_PARAM, Types. DATE)) \u00a0    declareParameter(SqlOutParameter(\"titles\", OracleTypes. CURSOR, TitleMapper())) \u00a0    compile() \u00a0  } \u00a0  fun execute(cutoffDate: Date) = super.execute( \u00a0      mapOf<String, Any>(CUTOFF_DATE_PARAM to cutoffDate)) } 4.3.8.", "chunk_char_count": 818, "chunk_word_count": 103, "chunk_token_count": 204.5}, {"page_number": 786, "sentence_chunk": "Common Problems with Parameter and Data Value Handling Common problems with parameters and data values exist in the different approaches provided by Spring Framework\u2019s JDBC support. This section covers how to address them. Providing SQL Type Information for Parameters Usually, Spring determines the SQL type of the parameters based on the type of parameter passed in. It is possible to explicitly provide the SQL type to be used when setting parameter values. This is sometimes necessary to correctly set NULL values. You can provide SQL type information in several ways: \u2022 Many update and query methods of the JdbcTemplate take an additional parameter in the form of an int array. This array is used to indicate the SQL type of the corresponding parameter by using constant values from the java.sql. Types class. Provide one entry for each parameter. \u2022You can use the SqlParameterValue class to wrap the parameter value that needs this additional information.", "chunk_char_count": 961, "chunk_word_count": 154, "chunk_token_count": 240.25}, {"page_number": 786, "sentence_chunk": "To do so, create a new instance for each value and pass in the SQL type and the parameter value in the constructor. You can also provide an optional scale parameter for numeric values. \u2022For methods that work with named parameters, you can use the SqlParameterSource classes, 786", "chunk_char_count": 278, "chunk_word_count": 48, "chunk_token_count": 69.5}, {"page_number": 787, "sentence_chunk": "BeanPropertySqlParameterSource or MapSqlParameterSource. They both have methods for registering the SQL type for any of the named parameter values. Handling BLOB and CLOB objects You can store images, other binary data, and large chunks of text in the database. These large objects are called BLOBs (Binary Large OBject) for binary data and CLOBs (Character Large OBject) for character data. In Spring, you can handle these large objects by using the JdbcTemplate directly and also when using the higher abstractions provided by RDBMS Objects and the SimpleJdbc classes. All of these approaches use an implementation of the LobHandler interface for the actual management of the LOB (Large OBject) data. LobHandler provides access to a LobCreator class, through the getLobCreator method, that is used for creating new LOB objects to be inserted. LobCreator and LobHandler provide the following support for LOB input and output: \u2022 BLOB \u25e6 byte[]: getBlobAsBytes and setBlobAsBytes \u25e6 InputStream: getBlobAsBinaryStream and setBlobAsBinaryStream \u2022 CLOB \u25e6 String: getClobAsString and setClobAsString \u25e6 InputStream: getClobAsAsciiStream and setClobAsAsciiStream \u25e6 Reader: getClobAsCharacterStream and setClobAsCharacterStream The next example shows how to create and insert a BLOB. Later we show how to read it back from the database. This example uses a JdbcTemplate and an implementation of the AbstractLobCreatingPreparedStatementCallback.", "chunk_char_count": 1435, "chunk_word_count": 204, "chunk_token_count": 358.75}, {"page_number": 787, "sentence_chunk": "It implements one method, setValues. This method provides a LobCreator that we use to set the values for the LOB columns in your SQL insert statement. For this example, we assume that there is a variable, lobHandler, that is already set to an instance of a DefaultLobHandler. You typically set this value through dependency injection. The following example shows how to create and insert a BLOB: 787", "chunk_char_count": 399, "chunk_word_count": 67, "chunk_token_count": 99.75}, {"page_number": 788, "sentence_chunk": "Java final File blobIn = new File(\"spring2004.jpg\"); final InputStream blobIs = new FileInputStream(blobIn); final File clobIn = new File(\"large.txt\"); final InputStream clobIs = new FileInputStream(clobIn); final InputStreamReader clobReader = new InputStreamReader(clobIs); jdbcTemplate.execute( \u00a0  \"INSERT INTO lob_table (id, a_clob, a_blob) VALUES (?, ?, ?)\",\u00a0  new AbstractLobCreatingPreparedStatementCallback(lobHandler) { \u2460 \u00a0    protected void setValues(PreparedStatement ps, LobCreator lobCreator) throws SQLException { \u00a0      ps.setLong(1, 1L); \u00a0      lobCreator.setClobAsCharacterStream(ps, 2, clobReader, (int)clobIn.length()); \u2461 \u00a0      lobCreator.setBlobAsBinaryStream(ps, 3, blobIs, (int)blobIn.length()); \u2462 \u00a0    } \u00a0  } ); blobIs.close(); clobReader.close(); \u2460 Pass in the lobHandler that (in this example) is a plain DefaultLobHandler.\u2461 Using the method setClobAsCharacterStream to pass in the contents of the CLOB.\u2462 Using the method setBlobAsBinaryStream to pass in the contents of the BLOB.788", "chunk_char_count": 1009, "chunk_word_count": 140, "chunk_token_count": 252.25}, {"page_number": 789, "sentence_chunk": "Kotlin val blobIn = File(\"spring2004.jpg\") val blobIs = FileInputStream(blobIn) val clobIn = File(\"large.txt\") val clobIs = FileInputStream(clobIn) val clobReader = InputStreamReader(clobIs) jdbcTemplate.execute( \u00a0    \"INSERT INTO lob_table (id, a_clob, a_blob) VALUES (?, ?, ?)\",\u00a0    object: AbstractLobCreatingPreparedStatementCallback(lobHandler) { \u2460 \u00a0      override fun setValues(ps: PreparedStatement, lobCreator: LobCreator) { \u00a0        ps.setLong(1, 1L) \u00a0        lobCreator.setClobAsCharacterStream(ps, 2, clobReader, clobIn.length().toInt()) \u2461 \u00a0        lobCreator.setBlobAsBinaryStream(ps, 3, blobIs, blobIn.length().toInt()) \u2462 \u00a0      } \u00a0    } ) blobIs.close() clobReader.close() \u2460 Pass in the lobHandler that (in this example) is a plain DefaultLobHandler.\u2461 Using the method setClobAsCharacterStream to pass in the contents of the CLOB.\u2462 Using the method setBlobAsBinaryStream to pass in the contents of the BLOB.\uf05a If you invoke the setBlobAsBinaryStream, setClobAsAsciiStream, or setClobAsCharacterStream method on the LobCreator returned from DefaultLobHandler.getLobCreator(), you can optionally specify a negative value for the contentLength argument. If the specified content length is negative, the DefaultLobHandler uses the JDBC 4.0 variants of the set-stream methods without a length parameter. Otherwise, it passes the specified length on to the driver. See the documentation for the JDBC driver you use to verify that it supports streaming a LOB without providing the content length. Now it is time to read the LOB data from the database. Again, you use a JdbcTemplate with the same instance variable lobHandler and a reference to a DefaultLobHandler.", "chunk_char_count": 1670, "chunk_word_count": 253, "chunk_token_count": 417.5}, {"page_number": 790, "sentence_chunk": "Java List<Map<String, Object>> l = jdbcTemplate.query(\"select id, a_clob, a_blob from lob_table\", \u00a0  new RowMapper<Map<String, Object>>() { \u00a0    public Map<String, Object> mapRow(ResultSet rs, int i) throws SQLException { \u00a0      Map<String, Object> results = new HashMap<String, Object>(); \u00a0      String clobText = lobHandler.getClobAsString(rs, \"a_clob\"); \u2460 \u00a0      results.put(\"CLOB\", clobText); \u00a0      byte[] blobBytes = lobHandler.getBlobAsBytes(rs, \"a_blob\"); \u2461 \u00a0      results.put(\"BLOB\", blobBytes); \u00a0      return results; \u00a0    } \u00a0  }); \u2460 Using the method getClobAsString to retrieve the contents of the CLOB.\u2461 Using the method getBlobAsBytes to retrieve the contents of the BLOB. Kotlin val l = jdbcTemplate.query(\"select id, a_clob, a_blob from lob_table\") { rs, _ -> \u00a0  val clobText = lobHandler.getClobAsString(rs, \"a_clob\") \u2460 \u00a0  val blobBytes = lobHandler.getBlobAsBytes(rs, \"a_blob\") \u2461 \u00a0  mapOf(\"CLOB\" to clobText, \"BLOB\" to blobBytes) } \u2460 Using the method getClobAsString to retrieve the contents of the CLOB.\u2461 Using the method getBlobAsBytes to retrieve the contents of the BLOB. Passing in Lists of Values for IN Clause The SQL standard allows for selecting rows based on an expression that includes a variable list of values. A typical example would be select * from T_ACTOR where id in (1, 2, 3). This variable list is not directly supported for prepared statements by the JDBC standard. You cannot declare a variable number of placeholders. You need a number of variations with the desired number of placeholders prepared, or you need to generate the SQL string dynamically once you know how many placeholders are required. The named parameter support provided in the NamedParameterJdbcTemplate and JdbcTemplate takes the latter approach.", "chunk_char_count": 1755, "chunk_word_count": 292, "chunk_token_count": 438.75}, {"page_number": 790, "sentence_chunk": "You can pass in the values as a java.util. List of primitive objects. This list is used to insert the required placeholders and pass in the values during statement execution.\uf05a Be careful when passing in many values. The JDBC standard does not guarantee that you can use more than 100 values for an in expression list. Various databases exceed this number, but they usually have a hard limit for how many values are allowed. For example, Oracle\u2019s limit is 1000. In addition to the primitive values in the value list, you can create a java.util. List of object arrays. This list can support multiple expressions being defined for the in clause, such as select * from T_ACTOR where (id, last_name) in ((1, 'Johnson'), (2, 'Harrop')).", "chunk_char_count": 730, "chunk_word_count": 125, "chunk_token_count": 182.5}, {"page_number": 791, "sentence_chunk": "your database supports this syntax. Handling Complex Types for Stored Procedure Calls When you call stored procedures, you can sometimes use complex types specific to the database. To accommodate these types, Spring provides a SqlReturnType for handling them when they are returned from the stored procedure call and SqlTypeValue when they are passed in as a parameter to the stored procedure. The SqlReturnType interface has a single method (named getTypeValue) that must be implemented. This interface is used as part of the declaration of an SqlOutParameter. The following example shows returning the value of an Oracle STRUCT object of the user declared type ITEM_TYPE: Java public class TestItemStoredProcedure extends StoredProcedure { \u00a0  public TestItemStoredProcedure(DataSource dataSource) { \u00a0    // ... \u00a0    declareParameter(new SqlOutParameter(\"item\", OracleTypes. STRUCT, \"ITEM_TYPE\", \u00a0      (CallableStatement cs, int colIndx, int sqlType, String typeName) -> { \u00a0        STRUCT struct = (STRUCT) cs.getObject(colIndx); \u00a0        Object[] attr = struct.getAttributes(); \u00a0        TestItem item = new TestItem(); \u00a0        item.setId(((Number) attr[0]).longValue()); \u00a0        item.setDescription((String) attr[1]); \u00a0        item.setExpirationDate((java.util. Date) attr[2]); \u00a0        return item; \u00a0      })); \u00a0    // ... \u00a0  } Kotlin class TestItemStoredProcedure(dataSource: DataSource) : StoredProcedure() { \u00a0  init { \u00a0    // ... \u00a0    declareParameter(SqlOutParameter(\"item\", OracleTypes. STRUCT, \"ITEM_TYPE\") { cs, colIndx, sqlType, typeName -> \u00a0      val struct = cs.getObject(colIndx) as STRUCT \u00a0      val attr = struct.getAttributes() \u00a0      TestItem((attr[0] as Long, attr[1] as String, attr[2] as Date) \u00a0    }) \u00a0    // ... \u00a0  } } You can use SqlTypeValue to pass the value of a Java object (such as TestItem) to a stored procedure. The SqlTypeValue interface has a single method (named createTypeValue) that you must implement.", "chunk_char_count": 1942, "chunk_word_count": 358, "chunk_token_count": 485.5}, {"page_number": 792, "sentence_chunk": "The active connection is passed in, and you can use it to create database-specific objects, such as StructDescriptor instances or ArrayDescriptor instances. The following example creates a StructDescriptor instance: Java final TestItem testItem = new TestItem(123L, \"A test item\", \u00a0    new SimpleDateFormat(\"yyyy-M-d\").parse(\"2010-12-31\")); SqlTypeValue value = new AbstractSqlTypeValue() { \u00a0  protected Object createTypeValue(Connection conn, int sqlType, String typeName) throws SQLException { \u00a0    StructDescriptor itemDescriptor = new StructDescriptor(typeName, conn); \u00a0    Struct item = new STRUCT(itemDescriptor, conn, \u00a0    new Object[] { \u00a0      testItem.getId(), \u00a0      testItem.getDescription(), \u00a0      new java.sql. Date(testItem.getExpirationDate().getTime()) \u00a0    }); \u00a0    return item; \u00a0  } }; Kotlin val (id, description, expirationDate) = TestItem(123L, \"A test item\", \u00a0    SimpleDateFormat(\"yyyy-M-d\").parse(\"2010-12-31\")) val value = object : AbstractSqlTypeValue() { \u00a0  override fun createTypeValue(conn: Connection, sqlType: Int, typeName: String?):Any { \u00a0    val itemDescriptor = StructDescriptor(typeName, conn) \u00a0    return STRUCT(itemDescriptor, conn, \u00a0        arrayOf(id, description, java.sql. Date(expirationDate.time))) \u00a0  } } You can now add this SqlTypeValue to the Map that contains the input parameters for the execute call of the stored procedure. Another use for the SqlTypeValue is passing in an array of values to an Oracle stored procedure. Oracle has its own internal ARRAY class that must be used in this case, and you can use the SqlTypeValue to create an instance of the Oracle ARRAY and populate it with values from the Java ARRAY, as the following example shows: 792", "chunk_char_count": 1705, "chunk_word_count": 276, "chunk_token_count": 426.25}, {"page_number": 793, "sentence_chunk": "Java final Long[] ids = new Long[] {1L, 2L}; SqlTypeValue value = new AbstractSqlTypeValue() { \u00a0  protected Object createTypeValue(Connection conn, int sqlType, String typeName) throws SQLException { \u00a0    ArrayDescriptor arrayDescriptor = new ArrayDescriptor(typeName, conn); \u00a0    ARRAY idArray = new ARRAY(arrayDescriptor, conn, ids); \u00a0    return idArray; \u00a0  } }; Kotlin class TestItemStoredProcedure(dataSource: DataSource) : StoredProcedure() { \u00a0  init { \u00a0    val ids = arrayOf(1L, 2L) \u00a0    val value = object : AbstractSqlTypeValue() { \u00a0      override fun createTypeValue(conn: Connection, sqlType: Int, typeName: String?):Any { \u00a0        val arrayDescriptor = ArrayDescriptor(typeName, conn) \u00a0        return ARRAY(arrayDescriptor, conn, ids) \u00a0      } \u00a0    } \u00a0  } } 4.3.9. Embedded Database Support The org.springframework.jdbc.datasource.embedded package provides support for embedded Java database engines. Support for HSQL, H2, and Derby is provided natively. You can also use an extensible API to plug in new embedded database types and DataSource implementations. Why Use an Embedded Database?An embedded database can be useful during the development phase of a project because of its lightweight nature. Benefits include ease of configuration, quick startup time, testability, and the ability to rapidly evolve your SQL during development. Creating an Embedded Database by Using Spring XML If you want to expose an embedded database instance as a bean in a Spring ApplicationContext, you can use the embedded-database tag in the spring-jdbc namespace: 793", "chunk_char_count": 1564, "chunk_word_count": 262, "chunk_token_count": 391.0}, {"page_number": 794, "sentence_chunk": "<jdbc:embedded-database id=\"dataSource\" generate-name=\"true\"> \u00a0  <jdbc:script location=\"classpath:schema.sql\"/> \u00a0  <jdbc:script location=\"classpath:test-data.sql\"/> </jdbc:embedded-database> The preceding configuration creates an embedded HSQL database that is populated with SQL from the schema.sql and test-data.sql resources in the root of the classpath. In addition, as a best practice, the embedded database is assigned a uniquely generated name. The embedded database is made available to the Spring container as a bean of type javax.sql. DataSource that can then be injected into data access objects as needed. Creating an Embedded Database Programmatically The EmbeddedDatabaseBuilder class provides a fluent API for constructing an embedded database programmatically. You can use this when you need to create an embedded database in a stand- alone environment or in a stand-alone integration test, as in the following example: Java EmbeddedDatabase db = new EmbeddedDatabaseBuilder() \u00a0    .generateUniqueName(true) \u00a0    .setType(H2) \u00a0    .setScriptEncoding(\"UTF-8\") \u00a0    .ignoreFailedDrops(true) \u00a0    .addScript(\"schema.sql\") \u00a0    .addScripts(\"user_data.sql\", \"country_data.sql\") \u00a0    .build(); // perform actions against the db (EmbeddedDatabase extends javax.sql. DataSource) db.shutdown() Kotlin val db = EmbeddedDatabaseBuilder() \u00a0    .generateUniqueName(true) \u00a0    .setType(H2) \u00a0    .setScriptEncoding(\"UTF-8\") \u00a0    .ignoreFailedDrops(true) \u00a0    .addScript(\"schema.sql\") \u00a0    .addScripts(\"user_data.sql\", \"country_data.sql\") \u00a0    .build() // perform actions against the db (EmbeddedDatabase extends javax.sql. DataSource) db.shutdown() See the javadoc for EmbeddedDatabaseBuilder for further details on all supported options.794", "chunk_char_count": 1742, "chunk_word_count": 243, "chunk_token_count": 435.5}, {"page_number": 795, "sentence_chunk": "You can also use the EmbeddedDatabaseBuilder to create an embedded database by using Java configuration, as the following example shows: Java @Configuration public class DataSourceConfig { \u00a0  @Bean \u00a0  public DataSource dataSource() { \u00a0    return new EmbeddedDatabaseBuilder() \u00a0        .generateUniqueName(true) \u00a0        .setType(H2) \u00a0        .setScriptEncoding(\"UTF-8\") \u00a0        .ignoreFailedDrops(true) \u00a0        .addScript(\"schema.sql\") \u00a0        .addScripts(\"user_data.sql\", \"country_data.sql\") \u00a0        .build(); \u00a0  } } Kotlin @Configuration class DataSourceConfig { \u00a0  @Bean \u00a0  fun dataSource(): DataSource { \u00a0    return EmbeddedDatabaseBuilder() \u00a0        .generateUniqueName(true) \u00a0        .setType(H2) \u00a0        .setScriptEncoding(\"UTF-8\") \u00a0        .ignoreFailedDrops(true) \u00a0        .addScript(\"schema.sql\") \u00a0        .addScripts(\"user_data.sql\", \"country_data.sql\") \u00a0        .build() \u00a0  } } Selecting the Embedded Database Type This section covers how to select one of the three embedded databases that Spring supports. It includes the following topics: \u2022 Using HSQL \u2022 Using H2 \u2022 Using Derby 795", "chunk_char_count": 1099, "chunk_word_count": 233, "chunk_token_count": 274.75}, {"page_number": 796, "sentence_chunk": "Using HSQL Spring supports HSQL 1.8.0 and above. HSQL is the default embedded database if no type is explicitly specified. To specify HSQL explicitly, set the type attribute of the embedded-database tag to HSQL. If you use the builder API, call the setType(EmbeddedDatabaseType) method with EmbeddedDatabaseType. HSQL. Using H2 Spring supports the H2 database. To enable H2, set the type attribute of the embedded-database tag to H2. If you use the builder API, call the setType(EmbeddedDatabaseType) method with EmbeddedDatabaseType. H2. Using Derby Spring supports Apache Derby 10.5 and above.", "chunk_char_count": 595, "chunk_word_count": 89, "chunk_token_count": 148.75}, {"page_number": 796, "sentence_chunk": "To enable Derby, set the type attribute of the embedded-database tag to DERBY. If you use the builder API, call the setType(EmbeddedDatabaseType) method with EmbeddedDatabaseType. DERBY. Testing Data Access Logic with an Embedded Database Embedded databases provide a lightweight way to test data access code. The next example is a data access integration test template that uses an embedded database. Using such a template can be useful for one-offs when the embedded database does not need to be reused across test classes. However, if you wish to create an embedded database that is shared within a test suite, consider using the Spring TestContext Framework and configuring the embedded database as a bean in the Spring ApplicationContext as described in Creating an Embedded Database by Using Spring XML and Creating an Embedded Database Programmatically. The following listing shows the test template: 796", "chunk_char_count": 911, "chunk_word_count": 141, "chunk_token_count": 227.75}, {"page_number": 797, "sentence_chunk": "Java public class DataAccessIntegrationTestTemplate { \u00a0  private EmbeddedDatabase db; \u00a0  @BeforeEach \u00a0  public void setUp() { \u00a0    // creates an HSQL in-memory database populated from default scripts \u00a0    // classpath:schema.sql and classpath:data.sql \u00a0    db = new EmbeddedDatabaseBuilder() \u00a0        .generateUniqueName(true) \u00a0        .addDefaultScripts() \u00a0        .build(); \u00a0  } \u00a0  @Test \u00a0  public void testDataAccess() { \u00a0    JdbcTemplate template = new JdbcTemplate(db); \u00a0    template.query( /* ... */ ); \u00a0  } \u00a0  @AfterEach \u00a0  public void tearDown() { \u00a0    db.shutdown(); \u00a0  } } 797", "chunk_char_count": 586, "chunk_word_count": 128, "chunk_token_count": 146.5}, {"page_number": 798, "sentence_chunk": "Kotlin class DataAccessIntegrationTestTemplate { \u00a0  private lateinit var db: EmbeddedDatabase \u00a0  @BeforeEach \u00a0  fun setUp() { \u00a0    // creates an HSQL in-memory database populated from default scripts \u00a0    // classpath:schema.sql and classpath:data.sql \u00a0    db = EmbeddedDatabaseBuilder() \u00a0        .generateUniqueName(true) \u00a0        .addDefaultScripts() \u00a0        .build() \u00a0  } \u00a0  @Test \u00a0  fun testDataAccess() { \u00a0    val template = JdbcTemplate(db) \u00a0    template.query( /* ... */) \u00a0  } \u00a0  @AfterEach \u00a0  fun tearDown() { \u00a0    db.shutdown() \u00a0  } } Generating Unique Names for Embedded Databases Development teams often encounter errors with embedded databases if their test suite inadvertently attempts to recreate additional instances of the same database. This can happen quite easily if an XML configuration file or @Configuration class is responsible for creating an embedded database and the corresponding configuration is then reused across multiple testing scenarios within the same test suite (that is, within the same JVM process)\u2009\u2014\u2009for example, integration tests against embedded databases whose ApplicationContext configuration differs only with regard to which bean definition profiles are active. The root cause of such errors is the fact that Spring\u2019s EmbeddedDatabaseFactory (used internally by both the <jdbc:embedded-database> XML namespace element and the EmbeddedDatabaseBuilder for Java configuration) sets the name of the embedded database to testdb if not otherwise specified. For the case of <jdbc:embedded-database>, the embedded database is typically assigned a name equal to the bean\u2019s id (often, something like dataSource). Thus, subsequent attempts to create an embedded database do not result in a new database. Instead, the same JDBC connection URL is reused, and attempts to create a new embedded database actually point to an existing embedded database created from the same configuration. To address this common issue, Spring Framework 4.2 provides support for generating unique names for embedded databases. To enable the use of generated names, use one of the following 798", "chunk_char_count": 2105, "chunk_word_count": 348, "chunk_token_count": 526.25}, {"page_number": 799, "sentence_chunk": "options. \u2022EmbeddedDatabaseFactory.setGenerateUniqueDatabaseName() \u2022 EmbeddedDatabaseBuilder.generateUniqueName() \u2022 <jdbc:embedded-database generate-name=\"true\" \u2026 > Extending the Embedded Database Support You can extend Spring JDBC embedded database support in two ways: \u2022 Implement EmbeddedDatabaseConfigurer to support a new embedded database type. \u2022Implement DataSourceFactory to support a new DataSource implementation, such as a connection pool to manage embedded database connections. We encourage you to contribute extensions to the Spring community at GitHub Issues.4.3.10. Initializing a DataSource The org.springframework.jdbc.datasource.init package provides support for initializing an existing DataSource. The embedded database support provides one option for creating and initializing a DataSource for an application. However, you may sometimes need to initialize an instance that runs on a server somewhere. Initializing a Database by Using Spring XML If you want to initialize a database and you can provide a reference to a DataSource bean, you can use the initialize-database tag in the spring-jdbc namespace: <jdbc:initialize-database data-source=\"dataSource\"> \u00a0  <jdbc:script location=\"classpath:com/foo/sql/db-schema.sql\"/> \u00a0  <jdbc:script location=\"classpath:com/foo/sql/db-test-data.sql\"/> </jdbc:initialize-database> The preceding example runs the two specified scripts against the database. The first script creates a schema, and the second populates tables with a test data set.", "chunk_char_count": 1503, "chunk_word_count": 182, "chunk_token_count": 375.75}, {"page_number": 799, "sentence_chunk": "The script locations can also be patterns with wildcards in the usual Ant style used for resources in Spring (for example, classpath*:/com/foo/**/sql/*-data.sql). If you use a pattern, the scripts are run in the lexical order of their URL or filename. The default behavior of the database initializer is to unconditionally run the provided scripts. This may not always be what you want\u2009\u2014\u2009for instance, if you run the scripts against a database that already has test data in it. The likelihood of accidentally deleting data is reduced by following the common pattern (shown earlier) of creating the tables first and then inserting the data. The first step fails if the tables already exist. However, to gain more control over the creation and deletion of existing data, the XML namespace provides a few additional options. The first is a flag to switch the initialization on and off. You can set this according to the environment (such as pulling a boolean value from system properties or 799", "chunk_char_count": 991, "chunk_word_count": 164, "chunk_token_count": 247.75}, {"page_number": 800, "sentence_chunk": "from an environment bean). The following example gets a value from a system property: <jdbc:initialize-database data-source=\"dataSource\" \u00a0  enabled=\"#{systemProperties. INITIALIZE_DATABASE}\"> \u2460 \u00a0  <jdbc:script location=\"...\"/> </jdbc:initialize-database> \u2460 Get the value for enabled from a system property called INITIALIZE_DATABASE. The second option to control what happens with existing data is to be more tolerant of failures. To this end, you can control the ability of the initializer to ignore certain errors in the SQL it runs from the scripts, as the following example shows: <jdbc:initialize-database data-source=\"dataSource\" ignore-failures=\"DROPS\"> \u00a0  <jdbc:script location=\"...\"/> </jdbc:initialize-database> In the preceding example, we are saying that we expect that, sometimes, the scripts are run against an empty database, and there are some DROP statements in the scripts that would, therefore, fail. So failed SQL DROP statements will be ignored, but other failures will cause an exception. This is useful if your SQL dialect doesn\u2019t support DROP \u2026 IF EXISTS (or similar) but you want to unconditionally remove all test data before re-creating it. In that case the first script is usually a set of DROP statements, followed by a set of CREATE statements. The ignore-failures option can be set to NONE (the default), DROPS (ignore failed drops), or ALL (ignore all failures). Each statement should be separated by ; or a new line if the ; character is not present at all in the script.", "chunk_char_count": 1504, "chunk_word_count": 228, "chunk_token_count": 376.0}, {"page_number": 800, "sentence_chunk": "You can control that globally or script by script, as the following example shows: <jdbc:initialize-database data-source=\"dataSource\" separator=\"@@\"> \u2460 \u00a0  <jdbc:script location=\"classpath:com/myapp/sql/db-schema.sql\" separator=\";\"/> \u2461 \u00a0  <jdbc:script location=\"classpath:com/myapp/sql/db-test-data-1.sql\"/> \u00a0  <jdbc:script location=\"classpath:com/myapp/sql/db-test-data-2.sql\"/> </jdbc:initialize-database> \u2460 Set the separator scripts to @@. \u2461 Set the separator for db-schema.sql to ;. In this example, the two test-data scripts use @@ as statement separator and only the db-schema.sql uses ;. This configuration specifies that the default separator is @@ and overrides that default for the db-schema script. If you need more control than you get from the XML namespace, you can use the DataSourceInitializer directly and define it as a component in your application.800", "chunk_char_count": 870, "chunk_word_count": 110, "chunk_token_count": 217.5}, {"page_number": 801, "sentence_chunk": "Initialization of Other Components that Depend on the Database A large class of applications (those that do not use the database until after the Spring context has started) can use the database initializer with no further complications. If your application is not one of those, you might need to read the rest of this section. The database initializer depends on a DataSource instance and runs the scripts provided in its initialization callback (analogous to an init-method in an XML bean definition, a @PostConstruct method in a component, or the afterPropertiesSet() method in a component that implements InitializingBean). If other beans depend on the same data source and use the data source in an initialization callback, there might be a problem because the data has not yet been initialized. A common example of this is a cache that initializes eagerly and loads data from the database on application startup. To get around this issue, you have two options: change your cache initialization strategy to a later phase or ensure that the database initializer is initialized first. Changing your cache initialization strategy might be easy if the application is in your control and not otherwise. Some suggestions for how to implement this include: \u2022 Make the cache initialize lazily on first usage, which improves application startup time. \u2022Have your cache or a separate component that initializes the cache implement Lifecycle or SmartLifecycle. When the application context starts, you can automatically start a SmartLifecycle by setting its autoStartup flag, and you can manually start a Lifecycle by calling ConfigurableApplicationContext.start() on the enclosing context. \u2022", "chunk_char_count": 1684, "chunk_word_count": 261, "chunk_token_count": 421.0}, {"page_number": 801, "sentence_chunk": "Use a Spring ApplicationEvent or similar custom observer mechanism to trigger the cache initialization. ContextRefreshedEvent is always published by the context when it is ready for use (after all beans have been initialized), so that is often a useful hook (this is how the SmartLifecycle works by default). Ensuring that the database initializer is initialized first can also be easy. Some suggestions on how to implement this include: \u2022 Rely on the default behavior of the Spring BeanFactory, which is that beans are initialized in registration order. You can easily arrange that by adopting the common practice of a set of <import/> elements in XML configuration that order your application modules and ensuring that the database and database initialization are listed first. \u2022Separate the DataSource and the business components that use it and control their startup order by putting them in separate ApplicationContext instances (for example, the parent context contains the DataSource, and the child context contains the business components). This structure is common in Spring web applications but can be more generally applied.4.4. Data Access with R2DBC R2DBC (\"Reactive Relational Database Connectivity\") is a community-driven specification effort to standardize access to SQL databases using reactive patterns.801", "chunk_char_count": 1324, "chunk_word_count": 197, "chunk_token_count": 331.0}, {"page_number": 802, "sentence_chunk": "4.4.1. Package Hierarchy The Spring Framework\u2019s R2DBC abstraction framework consists of two different packages: \u2022 core: The org.springframework.r2dbc.core package contains the DatabaseClient class plus a variety of related classes. See Using the R2DBC Core Classes to Control Basic R2DBC Processing and Error Handling. \u2022connection: The org.springframework.r2dbc.connection package contains a utility class for easy ConnectionFactory access and various simple ConnectionFactory implementations that you can use for testing and running unmodified R2DBC. See Controlling Database Connections.4.4.2. Using the R2DBC Core Classes to Control Basic R2DBC Processing and Error Handling This section covers how to use the R2DBC core classes to control basic R2DBC processing, including error handling. It includes the following topics: \u2022 Using DatabaseClient \u2022 Executing Statements \u2022 Querying (SELECT) \u2022 Updating (INSERT, UPDATE, and DELETE) with DatabaseClient \u2022 Statement Filters \u2022 Retrieving Auto-generated Keys Using DatabaseClient DatabaseClient is the central class in the R2DBC core package. It handles the creation and release of resources, which helps to avoid common errors, such as forgetting to close the connection. It performs the basic tasks of the core R2DBC workflow (such as statement creation and execution), leaving application code to provide SQL and extract results.", "chunk_char_count": 1379, "chunk_word_count": 192, "chunk_token_count": 344.75}, {"page_number": 802, "sentence_chunk": "The DatabaseClient class: \u2022 Runs SQL queries \u2022 Update statements and stored procedure calls \u2022 Performs iteration over Result instances \u2022 Catches R2DBC exceptions and translates them to the generic, more informative, exception hierarchy defined in the org.springframework.dao package. (See Consistent Exception Hierarchy.)The client has a functional, fluent API using reactive types for declarative composition. When you use the DatabaseClient for your code, you need only to implement java.util.function interfaces, giving them a clearly defined contract. Given a Connection provided by the DatabaseClient class, a Function callback creates a Publisher. The same is true for mapping functions that extract a Row result. You can use DatabaseClient within a DAO implementation through direct instantiation with a ConnectionFactory reference, or you can configure it in a Spring IoC container and give it to DAOs as 802", "chunk_char_count": 916, "chunk_word_count": 134, "chunk_token_count": 229.0}, {"page_number": 803, "sentence_chunk": "a bean reference. The simplest way to create a DatabaseClient object is through a static factory method, as follows: Java DatabaseClient client = DatabaseClient.create(connectionFactory); Kotlin val client = DatabaseClient.create(connectionFactory) \uf05a The ConnectionFactory should always be configured as a bean in the Spring IoC container. The preceding method creates a DatabaseClient with default settings. You can also obtain a Builder instance from DatabaseClient.builder(). You can customize the client by calling the following methods: \u2022 \u2026.bindMarkers(\u2026): Supply a specific BindMarkersFactory to configure named parameter to database bind marker translation. \u2022 \u2026.executeFunction(\u2026): Set the ExecuteFunction how Statement objects get run. \u2022 \u2026.namedParameters(false): Disable named parameter expansion. Enabled by default.\uf0eb Dialects are resolved by BindMarkersFactoryResolver from a ConnectionFactory, typically by inspecting ConnectionFactoryMetadata. You can let Spring auto-discover your BindMarkersFactory by registering a class that implements org.springframework.r2dbc.core.binding.", "chunk_char_count": 1092, "chunk_word_count": 132, "chunk_token_count": 273.0}, {"page_number": 803, "sentence_chunk": "BindMarkersFactoryResolver$BindMarkerFac toryProvider through META-INF/spring.factories. BindMarkersFactoryResolver discovers bind marker provider implementations from the class path using Spring\u2019s SpringFactoriesLoader. Currently supported databases are: \u2022 H2 \u2022 MariaDB \u2022 Microsoft SQL Server \u2022 MySQL \u2022 Postgres All SQL issued by this class is logged at the DEBUG level under the category corresponding to the fully qualified class name of the client instance (typically DefaultDatabaseClient). Additionally, each execution registers a checkpoint in the reactive sequence to aid debugging.803", "chunk_char_count": 593, "chunk_word_count": 74, "chunk_token_count": 148.25}, {"page_number": 804, "sentence_chunk": "The following sections provide some examples of DatabaseClient usage. These examples are not an exhaustive list of all of the functionality exposed by the DatabaseClient. See the attendant javadoc for that. Executing Statements DatabaseClient provides the basic functionality of running a statement. The following example shows what you need to include for minimal but fully functional code that creates a new table: Java Mono<Void> completion = client.sql(\"CREATE TABLE person (id VARCHAR(255) PRIMARY KEY, name VARCHAR(255), age INTEGER);\") \u00a0    .then(); Kotlin client.sql(\"CREATE TABLE person (id VARCHAR(255) PRIMARY KEY, name VARCHAR(255), age INTEGER);\") \u00a0    .await() DatabaseClient is designed for convenient, fluent usage. It exposes intermediate, continuation, and terminal methods at each stage of the execution specification. The preceding example above uses then() to return a completion Publisher that completes as soon as the query (or queries, if the SQL query contains multiple statements) completes.\uf05a execute(\u2026) accepts either the SQL query string or a query Supplier<String> to defer the actual query creation until execution. Querying (SELECT) SQL queries can return values through Row objects or the number of affected rows. DatabaseClient can return the number of updated rows or the rows themselves, depending on the issued query.", "chunk_char_count": 1353, "chunk_word_count": 200, "chunk_token_count": 338.25}, {"page_number": 804, "sentence_chunk": "The following query gets the id and name columns from a table: Java Mono<Map<String, Object>> first = client.sql(\"SELECT id, name FROM person\") \u00a0    .fetch().first(); Kotlin val first = client.sql(\"SELECT id, name FROM person\") \u00a0    .fetch().awaitSingle() The following query uses a bind variable: 804", "chunk_char_count": 301, "chunk_word_count": 49, "chunk_token_count": 75.25}, {"page_number": 805, "sentence_chunk": "Java Mono<Map<String, Object>> first = client.sql(\"SELECT id, name FROM person WHERE first_name = :fn\") \u00a0    .bind(\"fn\", \"Joe\") \u00a0    .fetch().first(); Kotlin val first = client.sql(\"SELECT id, name FROM person WHERE WHERE first_name = :fn\") \u00a0    .bind(\"fn\", \"Joe\") \u00a0    .fetch().awaitSingle() You might have noticed the use of fetch() in the example above.fetch() is a continuation operator that lets you specify how much data you want to consume. Calling first() returns the first row from the result and discards remaining rows. You can consume data with the following operators: \u2022 first() return the first row of the entire result. Its Kotlin Coroutine variant is named awaitSingle() for non-nullable return values and awaitSingleOrNull() if the value is optional. \u2022one() returns exactly one result and fails if the result contains more rows. Using Kotlin Coroutines, awaitOne() for exactly one value or awaitOneOrNull() if the value may be null. \u2022all() returns all rows of the result. When using Kotlin Coroutines, use flow(). \u2022rowsUpdated() returns the number of affected rows (INSERT/UPDATE/DELETE count).", "chunk_char_count": 1111, "chunk_word_count": 177, "chunk_token_count": 277.75}, {"page_number": 805, "sentence_chunk": "Its Kotlin Coroutine variant is named awaitRowsUpdated(). Without specifying further mapping details, queries return tabular results as Map whose keys are case-insensitive column names that map to their column value. You can take control over result mapping by supplying a Function<Row, T> that gets called for each Row so it can can return arbitrary values (singular values, collections and maps, and objects). The following example extracts the name column and emits its value: Java Flux<String> names = client.sql(\"SELECT name FROM person\") \u00a0    .map(row -> row.get(\"name\", String.class)) \u00a0    .all(); Kotlin val names = client.sql(\"SELECT name FROM person\") \u00a0    .map{ row: Row -> row.get(\"name\", String.class) } \u00a0    .flow() 805", "chunk_char_count": 733, "chunk_word_count": 119, "chunk_token_count": 183.25}, {"page_number": 806, "sentence_chunk": "What about null?Relational database results can contain null values. The Reactive Streams specification forbids the emission of null values. That requirement mandates proper null handling in the extractor function. While you can obtain null values from a Row, you must not emit a null value. You must wrap any null values in an object (for example, Optional for singular values) to make sure a null value is never returned directly by your extractor function. Updating (INSERT, UPDATE, and DELETE) with DatabaseClient The only difference of modifying statements is that these statements typically do not return tabular data so you use rowsUpdated() to consume results. The following example shows an UPDATE statement that returns the number of updated rows: Java Mono<Integer> affectedRows = client.sql(\"UPDATE person SET first_name = :fn\") \u00a0    .bind(\"fn\", \"Joe\") \u00a0    .fetch().rowsUpdated(); Kotlin val affectedRows = client.sql(\"UPDATE person SET first_name = :fn\") \u00a0    .bind(\"fn\", \"Joe\") \u00a0    .fetch().awaitRowsUpdated() Binding Values to Queries A typical application requires parameterized SQL statements to select or update rows according to some input. These are typically SELECT statements constrained by a WHERE clause or INSERT and UPDATE statements that accept input parameters. Parameterized statements bear the risk of SQL injection if parameters are not escaped properly.", "chunk_char_count": 1387, "chunk_word_count": 213, "chunk_token_count": 346.75}, {"page_number": 806, "sentence_chunk": "DatabaseClient leverages R2DBC\u2019s bind API to eliminate the risk of SQL injection for query parameters. You can provide a parameterized SQL statement with the execute(\u2026) operator and bind parameters to the actual Statement. Your R2DBC driver then runs the statement by using prepared statements and parameter substitution. Parameter binding supports two binding strategies: \u2022 By Index, using zero-based parameter indexes. \u2022By Name, using the placeholder name. The following example shows parameter binding for a query: 806", "chunk_char_count": 521, "chunk_word_count": 76, "chunk_token_count": 130.25}, {"page_number": 807, "sentence_chunk": "db.sql(\"INSERT INTO person (id, name, age) VALUES(:id, :name, :age)\") \u00a0  .bind(\"id\", \"joe\") \u00a0  .bind(\"name\", \"Joe\") \u00a0  .bind(\"age\", 34); R2DBC Native Bind Markers R2DBC uses database-native bind markers that depend on the actual database vendor. As an example, Postgres uses indexed markers, such as $1, $2, $n. Another example is SQL Server, which uses named bind markers prefixed with @. This is different from JDBC, which requires ?as bind markers. In JDBC, the actual drivers translate ?bind markers to database-native markers as part of their statement execution. Spring Framework\u2019s R2DBC support lets you use native bind markers or named bind markers with the :name syntax. Named parameter support leverages a BindMarkersFactory instance to expand named parameters to native bind markers at the time of query execution, which gives you a certain degree of query portability across various database vendors. The query-preprocessor unrolls named Collection parameters into a series of bind markers to remove the need of dynamic query creation based on the number of arguments. Nested object arrays are expanded to allow usage of (for example) select lists. Consider the following query: SELECT id, name, state FROM table WHERE (name, age) IN (('John', 35), ('Ann', 50)) The preceding query can be parametrized and run as follows: Java List<Object[]> tuples = new ArrayList<>(); tuples.add(new Object[] {\"John\", 35}); tuples.add(new Object[] {\"Ann\", 50}); client.sql(\"SELECT id, name, state FROM table WHERE (name, age) IN (:tuples)\") \u00a0  .bind(\"tuples\", tuples); 807", "chunk_char_count": 1569, "chunk_word_count": 238, "chunk_token_count": 392.25}, {"page_number": 808, "sentence_chunk": "Kotlin val tuples: MutableList<Array<Any>> = ArrayList() tuples.add(arrayOf(\"John\", 35)) tuples.add(arrayOf(\"Ann\", 50)) client.sql(\"SELECT id, name, state FROM table WHERE (name, age) IN (:tuples)\") \u00a0  .bind(\"tuples\", tuples) \uf05a Usage of select lists is vendor-dependent. The following example shows a simpler variant using IN predicates: Java client.sql(\"SELECT id, name, state FROM table WHERE age IN (:ages)\") \u00a0  .bind(\"ages\", Arrays.asList(35, 50)); Kotlin val tuples: MutableList<Array<Any>> = ArrayList() tuples.add(arrayOf(\"John\", 35)) tuples.add(arrayOf(\"Ann\", 50)) client.sql(\"SELECT id, name, state FROM table WHERE age IN (:ages)\") \u00a0  .bind(\"tuples\", arrayOf(35, 50)) \uf05a R2DBC itself does not support Collection-like values. Nevertheless, expanding a given List in the example above works for named parameters in Spring\u2019s R2DBC support, e.g. for use in IN clauses as shown above. However, inserting or updating array-typed columns (e.g. in Postgres) requires an array type that is supported by the underlying R2DBC driver: typically a Java array, e.g. String[] to update a text[] column. Do not pass Collection<String> or the like as an array parameter. Statement Filters Sometimes it you need to fine-tune options on the actual Statement before it gets run. Register a Statement filter (StatementFilterFunction) through DatabaseClient to intercept and modify statements in their execution, as the following example shows: Java client.sql(\"INSERT INTO table (name, state) VALUES(:name, :state)\") \u00a0  .filter((s, next) -> next.execute(s.returnGeneratedValues(\"id\"))) \u00a0  .bind(\"name\", \u2026) \u00a0  .bind(\"state\", \u2026); 808", "chunk_char_count": 1619, "chunk_word_count": 220, "chunk_token_count": 404.75}, {"page_number": 809, "sentence_chunk": "Kotlin client.sql(\"INSERT INTO table (name, state) VALUES(:name, :state)\") \u00a0      .filter { s: Statement, next: ExecuteFunction -> next.execute(s.returnGeneratedValues(\"id\")) } \u00a0      .bind(\"name\", \u2026) \u00a0      .bind(\"state\", \u2026) DatabaseClient exposes also simplified filter(\u2026) overload accepting Function<Statement, Statement>: Java client.sql(\"INSERT INTO table (name, state) VALUES(:name, :state)\") \u00a0  .filter(statement -> s.returnGeneratedValues(\"id\")); client.sql(\"SELECT id, name, state FROM table\") \u00a0  .filter(statement -> s.fetchSize(25)); Kotlin client.sql(\"INSERT INTO table (name, state) VALUES(:name, :state)\") \u00a0  .filter { statement -> s.returnGeneratedValues(\"id\") } client.sql(\"SELECT id, name, state FROM table\") \u00a0  .filter { statement -> s.fetchSize(25) } StatementFilterFunction implementations allow filtering of the Statement and filtering of Result objects. DatabaseClient Best Practices Instances of the DatabaseClient class are thread-safe, once configured. This is important because it means that you can configure a single instance of a DatabaseClient and then safely inject this shared reference into multiple DAOs (or repositories). The DatabaseClient is stateful, in that it maintains a reference to a ConnectionFactory, but this state is not conversational state. A common practice when using the DatabaseClient class is to configure a ConnectionFactory in your Spring configuration file and then dependency-inject that shared ConnectionFactory bean into your DAO classes. The DatabaseClient is created in the setter for the ConnectionFactory. This leads to DAOs that resemble the following: 809", "chunk_char_count": 1621, "chunk_word_count": 222, "chunk_token_count": 405.25}, {"page_number": 810, "sentence_chunk": "Java public class R2dbcCorporateEventDao implements CorporateEventDao { \u00a0  private DatabaseClient databaseClient; \u00a0  public void setConnectionFactory(ConnectionFactory connectionFactory) { \u00a0    this.databaseClient = DatabaseClient.create(connectionFactory); \u00a0  } \u00a0  // R2DBC-backed implementations of the methods on the CorporateEventDao follow... } Kotlin class R2dbcCorporateEventDao(connectionFactory: ConnectionFactory) : CorporateEventDao { \u00a0  private val databaseClient = DatabaseClient.create(connectionFactory) \u00a0  // R2DBC-backed implementations of the methods on the CorporateEventDao follow... } An alternative to explicit configuration is to use component-scanning and annotation support for dependency injection. In this case, you can annotate the class with @Component (which makes it a candidate for component-scanning) and annotate the ConnectionFactory setter method with @Autowired. The following example shows how to do so: Java @Component \u2460 public class R2dbcCorporateEventDao implements CorporateEventDao { \u00a0  private DatabaseClient databaseClient; \u00a0  @Autowired \u2461 \u00a0  public void setConnectionFactory(ConnectionFactory connectionFactory) { \u00a0    this.databaseClient = DatabaseClient.create(connectionFactory); \u2462 \u00a0  } \u00a0  // R2DBC-backed implementations of the methods on the CorporateEventDao follow... } \u2460 Annotate the class with @Component.\u2461 Annotate the ConnectionFactory setter method with @Autowired.\u2462 Create a new DatabaseClient with the ConnectionFactory.810", "chunk_char_count": 1483, "chunk_word_count": 186, "chunk_token_count": 370.75}, {"page_number": 811, "sentence_chunk": "Kotlin @Component \u2460 class R2dbcCorporateEventDao(connectionFactory: ConnectionFactory) : CorporateEventDao { \u2461 \u00a0  private val databaseClient = DatabaseClient(connectionFactory) \u2462 \u00a0  // R2DBC-backed implementations of the methods on the CorporateEventDao follow... } \u2460 Annotate the class with @Component.\u2461 Constructor injection of the ConnectionFactory.\u2462 Create a new DatabaseClient with the ConnectionFactory. Regardless of which of the above template initialization styles you choose to use (or not), it is seldom necessary to create a new instance of a DatabaseClient class each time you want to run SQL. Once configured, a DatabaseClient instance is thread-safe. If your application accesses multiple databases, you may want multiple DatabaseClient instances, which requires multiple ConnectionFactory and, subsequently, multiple differently configured DatabaseClient instances.4.4.3. Retrieving Auto-generated Keys INSERT statements may generate keys when inserting rows into a table that defines an auto- increment or identity column. To get full control over the column name to generate, simply register a StatementFilterFunction that requests the generated key for the desired column. Java Mono<Integer> generatedId = client.sql(\"INSERT INTO table (name, state) VALUES(:name, :state)\") \u00a0  .filter(statement -> s.returnGeneratedValues(\"id\")) \u00a0    .map(row -> row.get(\"id\", Integer.class)) \u00a0    .first(); // generatedId emits the generated key once the INSERT statement has finished Kotlin val generatedId = client.sql(\"INSERT INTO table (name, state) VALUES(:name, :state)\") \u00a0  .filter { statement -> s.returnGeneratedValues(\"id\") } \u00a0    .map { row -> row.get(\"id\", Integer.class) } \u00a0    .awaitOne() // generatedId emits the generated key once the INSERT statement has finished 811", "chunk_char_count": 1787, "chunk_word_count": 248, "chunk_token_count": 446.75}, {"page_number": 812, "sentence_chunk": "4.4.4. Controlling Database Connections This section covers: \u2022 Using ConnectionFactory \u2022 Using ConnectionFactoryUtils \u2022 Using SingleConnectionFactory \u2022 Using TransactionAwareConnectionFactoryProxy \u2022 Using R2dbcTransactionManager Using ConnectionFactory Spring obtains an R2DBC connection to the database through a ConnectionFactory. A ConnectionFactory is part of the R2DBC specification and is a common entry-point for drivers. It lets a container or a framework hide connection pooling and transaction management issues from the application code. As a developer, you need not know details about how to connect to the database. That is the responsibility of the administrator who sets up the ConnectionFactory. You most likely fill both roles as you develop and test code, but you do not necessarily have to know how the production data source is configured. When you use Spring\u2019s R2DBC layer, you can can configure your own with a connection pool implementation provided by a third party. A popular implementation is R2DBC Pool (r2dbc-pool). Implementations in the Spring distribution are meant only for testing purposes and do not provide pooling.", "chunk_char_count": 1150, "chunk_word_count": 167, "chunk_token_count": 287.5}, {"page_number": 812, "sentence_chunk": "To configure a ConnectionFactory: 1. Obtain a connection with ConnectionFactory as you typically obtain an R2DBC ConnectionFactory.2. Provide an R2DBC URL (See the documentation for your driver for the correct value). The following example shows how to configure a ConnectionFactory: Java ConnectionFactory factory = ConnectionFactories.get(\"r2dbc:h2:mem:///test?options=DB_CLOSE_DELAY=- 1;DB_CLOSE_ON_EXIT=FALSE\"); Kotlin val factory = ConnectionFactories.get(\"r2dbc:h2:mem:///test?options=DB_CLOSE_DELAY=- 1;DB_CLOSE_ON_EXIT=FALSE\"); Using ConnectionFactoryUtils The ConnectionFactoryUtils class is a convenient and powerful helper class that provides static methods to obtain connections from ConnectionFactory and close connections (if necessary).812", "chunk_char_count": 754, "chunk_word_count": 78, "chunk_token_count": 188.5}, {"page_number": 813, "sentence_chunk": "It supports subscriber Context-bound connections with, for example R2dbcTransactionManager. Using SingleConnectionFactory The SingleConnectionFactory class is an implementation of DelegatingConnectionFactory interface that wraps a single Connection that is not closed after each use. If any client code calls close on the assumption of a pooled connection (as when using persistence tools), you should set the suppressClose property to true. This setting returns a close-suppressing proxy that wraps the physical connection. Note that you can no longer cast this to a native Connection or a similar object. SingleConnectionFactory is primarily a test class and may be used for specific requirements such as pipelining if your R2DBC driver permits for such use. In contrast to a pooled ConnectionFactory, it reuses the same connection all the time, avoiding excessive creation of physical connections. Using TransactionAwareConnectionFactoryProxy TransactionAwareConnectionFactoryProxy is a proxy for a target ConnectionFactory. The proxy wraps that target ConnectionFactory to add awareness of Spring-managed transactions.\uf05a Using this class is required if you use a R2DBC client that is not integrated otherwise with Spring\u2019s R2DBC support.", "chunk_char_count": 1240, "chunk_word_count": 171, "chunk_token_count": 310.0}, {"page_number": 813, "sentence_chunk": "In this case, you can still use this client and, at the same time, have this client participating in Spring managed transactions. It is generally preferable to integrate a R2DBC client with proper access to ConnectionFactoryUtils for resource management. See the TransactionAwareConnectionFactoryProxy javadoc for more details. Using R2dbcTransactionManager The R2dbcTransactionManager class is a ReactiveTransactionManager implementation for single R2DBC datasources. It binds an R2DBC connection from the specified connection factory to the subscriber Context, potentially allowing for one subscriber connection for each connection factory. Application code is required to retrieve the R2DBC connection through ConnectionFactoryUtils.getConnection(ConnectionFactory), instead of R2DBC\u2019s standard ConnectionFactory.create(). All framework classes (such as DatabaseClient) use this strategy implicitly. If not used with this transaction manager, the lookup strategy behaves exactly like the common one. Thus, it can be used in any case. The R2dbcTransactionManager class supports custom isolation levels that get applied to the connection.", "chunk_char_count": 1139, "chunk_word_count": 146, "chunk_token_count": 284.75}, {"page_number": 813, "sentence_chunk": "4.5. Object Relational Mapping (ORM) Data Access This section covers data access when you use Object Relational Mapping (ORM).813", "chunk_char_count": 129, "chunk_word_count": 19, "chunk_token_count": 32.25}, {"page_number": 814, "sentence_chunk": "4.5.1. Introduction to ORM with Spring The Spring Framework supports integration with the Java Persistence API (JPA) and supports native Hibernate for resource management, data access object (DAO) implementations, and transaction strategies. For example, for Hibernate, there is first-class support with several convenient IoC features that address many typical Hibernate integration issues. You can configure all of the supported features for OR (object relational) mapping tools through Dependency Injection. They can participate in Spring\u2019s resource and transaction management, and they comply with Spring\u2019s generic transaction and DAO exception hierarchies. The recommended integration style is to code DAOs against plain Hibernate or JPA APIs. Spring adds significant enhancements to the ORM layer of your choice when you create data access applications. You can leverage as much of the integration support as you wish, and you should compare this integration effort with the cost and risk of building a similar infrastructure in-house. You can use much of the ORM support as you would a library, regardless of technology, because everything is designed as a set of reusable JavaBeans. ORM in a Spring IoC container facilitates configuration and deployment.", "chunk_char_count": 1262, "chunk_word_count": 186, "chunk_token_count": 315.5}, {"page_number": 814, "sentence_chunk": "Thus, most examples in this section show configuration inside a Spring container. The benefits of using the Spring Framework to create your ORM DAOs include: \u2022 Easier testing. Spring\u2019s IoC approach makes it easy to swap the implementations and configuration locations of Hibernate SessionFactory instances, JDBC DataSource instances, transaction managers, and mapped object implementations (if needed). This in turn makes it much easier to test each piece of persistence-related code in isolation. \u2022Common data access exceptions. Spring can wrap exceptions from your ORM tool, converting them from proprietary (potentially checked) exceptions to a common runtime DataAccessException hierarchy. This feature lets you handle most persistence exceptions, which are non-recoverable, only in the appropriate layers, without annoying boilerplate catches, throws, and exception declarations. You can still trap and handle exceptions as necessary. Remember that JDBC exceptions (including DB-specific dialects) are also converted to the same hierarchy, meaning that you can perform some operations with JDBC within a consistent programming model. \u2022General resource management.", "chunk_char_count": 1168, "chunk_word_count": 161, "chunk_token_count": 292.0}, {"page_number": 814, "sentence_chunk": "Spring application contexts can handle the location and configuration of Hibernate SessionFactory instances, JPA EntityManagerFactory instances, JDBC DataSource instances, and other related resources. This makes these values easy to manage and change. Spring offers efficient, easy, and safe handling of persistence resources. For example, related code that uses Hibernate generally needs to use the same Hibernate Session to ensure efficiency and proper transaction handling. Spring makes it easy to create and bind a Session to the current thread transparently, by exposing a current Session through the Hibernate SessionFactory. Thus, Spring solves many chronic problems of typical Hibernate usage, for any local or JTA transaction environment. \u2022Integrated transaction management. You can wrap your ORM code with a declarative, aspect- oriented programming (AOP) style method interceptor either through the @Transactional annotation or by explicitly configuring the transaction AOP advice in an XML configuration file. In both cases, transaction semantics and exception handling (rollback and so on) are handled for you. As discussed in Resource and Transaction Management, you can also swap various 814", "chunk_char_count": 1206, "chunk_word_count": 171, "chunk_token_count": 301.5}, {"page_number": 815, "sentence_chunk": "transaction managers, without affecting your ORM-related code. For example, you can swap between local transactions and JTA, with the same full services (such as declarative transactions) available in both scenarios. Additionally, JDBC-related code can fully integrate transactionally with the code you use to do ORM. This is useful for data access that is not suitable for ORM (such as batch processing and BLOB streaming) but that still needs to share common transactions with ORM operations.\uf0eb For more comprehensive ORM support, including support for alternative database technologies such as MongoDB, you might want to check out the Spring Data suite of projects. If you are a JPA user, the Getting Started Accessing Data with JPA guide from https://spring.io provides a great introduction.4.5.2. General ORM Integration Considerations This section highlights considerations that apply to all ORM technologies. The Hibernate section provides more details and also show these features and configurations in a concrete context. The major goal of Spring\u2019s ORM integration is clear application layering (with any data access and transaction technology) and for loose coupling of application objects\u2009\u2014\u2009no more business service dependencies on the data access or transaction strategy, no more hard-coded resource lookups, no more hard-to-replace singletons, no more custom service registries.", "chunk_char_count": 1390, "chunk_word_count": 202, "chunk_token_count": 347.5}, {"page_number": 815, "sentence_chunk": "The goal is to have one simple and consistent approach to wiring up application objects, keeping them as reusable and free from container dependencies as possible. All the individual data access features are usable on their own but integrate nicely with Spring\u2019s application context concept, providing XML-based configuration and cross-referencing of plain JavaBean instances that need not be Spring-aware. In a typical Spring application, many important objects are JavaBeans: data access templates, data access objects, transaction managers, business services that use the data access objects and transaction managers, web view resolvers, web controllers that use the business services, and so on. Resource and Transaction Management Typical business applications are cluttered with repetitive resource management code. Many projects try to invent their own solutions, sometimes sacrificing proper handling of failures for programming convenience. Spring advocates simple solutions for proper resource handling, namely IoC through templating in the case of JDBC and applying AOP interceptors for the ORM technologies. The infrastructure provides proper resource handling and appropriate conversion of specific API exceptions to an unchecked infrastructure exception hierarchy. Spring introduces a DAO exception hierarchy, applicable to any data access strategy. For direct JDBC, the JdbcTemplate class mentioned in a previous section provides connection handling and proper conversion of SQLException to the DataAccessException hierarchy, including translation of database-specific SQL error codes to meaningful exception classes. For ORM technologies, see the next section for how to get the same exception translation benefits.", "chunk_char_count": 1731, "chunk_word_count": 238, "chunk_token_count": 432.75}, {"page_number": 815, "sentence_chunk": "When it comes to transaction management, the JdbcTemplate class hooks in to the Spring transaction support and supports both JTA and JDBC transactions, through respective Spring transaction managers. For the supported ORM technologies, Spring offers Hibernate and JPA support through the Hibernate and JPA transaction managers as well as JTA support. For details on 815", "chunk_char_count": 369, "chunk_word_count": 55, "chunk_token_count": 92.25}, {"page_number": 816, "sentence_chunk": "transaction support, see the Transaction Management chapter. Exception Translation When you use Hibernate or JPA in a DAO, you must decide how to handle the persistence technology\u2019s native exception classes. The DAO throws a subclass of a HibernateException or PersistenceException, depending on the technology. These exceptions are all runtime exceptions and do not have to be declared or caught. You may also have to deal with IllegalArgumentException and IllegalStateException. This means that callers can only treat exceptions as being generally fatal, unless they want to depend on the persistence technology\u2019s own exception structure. Catching specific causes (such as an optimistic locking failure) is not possible without tying the caller to the implementation strategy. This trade-off might be acceptable to applications that are strongly ORM- based or do not need any special exception treatment (or both). However, Spring lets exception translation be applied transparently through the @Repository annotation. The following examples (one for Java configuration and one for XML configuration) show how to do so: Java @Repository public class ProductDaoImpl implements ProductDao { \u00a0  // class body here... } Kotlin @Repository class ProductDaoImpl : ProductDao { \u00a0  // class body here... } <beans> \u00a0  <!--", "chunk_char_count": 1315, "chunk_word_count": 197, "chunk_token_count": 328.75}, {"page_number": 816, "sentence_chunk": "Exception translation bean post processor --> \u00a0  <bean class=\"org.springframework.dao.annotation. PersistenceExceptionTranslationPostProcessor \"/> \u00a0  <bean id=\"myProductDao\" class=\"product. ProductDaoImpl\"/> </beans> The postprocessor automatically looks for all exception translators (implementations of the PersistenceExceptionTranslator interface) and advises all beans marked with the @Repository annotation so that the discovered translators can intercept and apply the appropriate translation 816", "chunk_char_count": 502, "chunk_word_count": 54, "chunk_token_count": 125.5}, {"page_number": 817, "sentence_chunk": "on the thrown exceptions. In summary, you can implement DAOs based on the plain persistence technology\u2019s API and annotations while still benefiting from Spring-managed transactions, dependency injection, and transparent exception conversion (if desired) to Spring\u2019s custom exception hierarchies.4.5.3. Hibernate We start with a coverage of Hibernate 5 in a Spring environment, using it to demonstrate the approach that Spring takes towards integrating OR mappers. This section covers many issues in detail and shows different variations of DAO implementations and transaction demarcation. Most of these patterns can be directly translated to all other supported ORM tools. The later sections in this chapter then cover the other ORM technologies and show brief examples.\uf05a As of Spring Framework 5.3, Spring requires Hibernate ORM 5.2+ for Spring\u2019s HibernateJpaVendorAdapter as well as for a native Hibernate SessionFactory setup. It is strongly recommended to go with Hibernate ORM 5.4 for a newly started application. For use with HibernateJpaVendorAdapter, Hibernate Search needs to be upgraded to 5.11.6.", "chunk_char_count": 1107, "chunk_word_count": 160, "chunk_token_count": 276.75}, {"page_number": 817, "sentence_chunk": "SessionFactory Setup in a Spring Container To avoid tying application objects to hard-coded resource lookups, you can define resources (such as a JDBC DataSource or a Hibernate SessionFactory) as beans in the Spring container. Application objects that need to access resources receive references to such predefined instances through bean references, as illustrated in the DAO definition in the next section. The following excerpt from an XML application context definition shows how to set up a JDBC DataSource and a Hibernate SessionFactory on top of it: 817", "chunk_char_count": 559, "chunk_word_count": 86, "chunk_token_count": 139.75}, {"page_number": 818, "sentence_chunk": "<beans> \u00a0  <bean id=\"myDataSource\" class=\"org.apache.commons.dbcp. BasicDataSource\" destroy- method=\"close\"> \u00a0    <property name=\"driverClassName\" value=\"org.hsqldb.jdbcDriver\"/> \u00a0    <property name=\"url\" value=\"jdbc:hsqldb:hsql://localhost:9001\"/> \u00a0    <property name=\"username\" value=\"sa\"/> \u00a0    <property name=\"password\" value=\"\"/> \u00a0  </bean> \u00a0  <bean id=\"mySessionFactory\" class=\"org.springframework.orm.hibernate5. LocalSessionFactoryBean\"> \u00a0    <property name=\"dataSource\" ref=\"myDataSource\"/> \u00a0    <property name=\"mappingResources\"> \u00a0      <list> \u00a0        <value>product.hbm.xml</value> \u00a0      </list> \u00a0    </property> \u00a0    <property name=\"hibernateProperties\"> \u00a0      <value> \u00a0        hibernate.dialect=org.hibernate.dialect. HSQLDialect \u00a0      </value> \u00a0    </property> \u00a0  </bean> </beans> Switching from a local Jakarta Commons DBCP BasicDataSource to a JNDI-located DataSource (usually managed by an application server) is only a matter of configuration, as the following example shows: <beans> \u00a0  <jee:jndi-lookup id=\"myDataSource\" jndi-name=\"java:comp/env/jdbc/myds\"/> </beans> You can also access a JNDI-located SessionFactory, using Spring\u2019s JndiObjectFactoryBean / <jee:jndi- lookup> to retrieve and expose it. However, that is typically not common outside of an EJB context.818", "chunk_char_count": 1294, "chunk_word_count": 191, "chunk_token_count": 323.5}, {"page_number": 819, "sentence_chunk": "\uf05a Spring also provides a LocalSessionFactoryBuilder variant, seamlessly integrating with @Bean style configuration and programmatic setup (no FactoryBean involved). Both LocalSessionFactoryBean and LocalSessionFactoryBuilder support background bootstrapping, with Hibernate initialization running in parallel to the application bootstrap thread on a given bootstrap executor (such as a SimpleAsyncTaskExecutor). On LocalSessionFactoryBean, this is available through the bootstrapExecutor property. On the programmatic LocalSessionFactoryBuilder, there is an overloaded buildSessionFactory method that takes a bootstrap executor argument. As of Spring Framework 5.1, such a native Hibernate setup can also expose a JPA EntityManagerFactory for standard JPA interaction next to native Hibernate access. See Native Hibernate Setup for JPA for details. Implementing DAOs Based on the Plain Hibernate API Hibernate has a feature called contextual sessions, wherein Hibernate itself manages one current Session per transaction. This is roughly equivalent to Spring\u2019s synchronization of one Hibernate Session per transaction. A corresponding DAO implementation resembles the following example, based on the plain Hibernate API: Java public class ProductDaoImpl implements ProductDao { \u00a0  private SessionFactory sessionFactory; \u00a0  public void setSessionFactory(SessionFactory sessionFactory) { \u00a0    this.sessionFactory = sessionFactory; \u00a0  } \u00a0  public Collection loadProductsByCategory(String category) { \u00a0    return this.sessionFactory.getCurrentSession() \u00a0        .createQuery(\"from test. Product product where product.category=?\")", "chunk_char_count": 1625, "chunk_word_count": 211, "chunk_token_count": 406.25}, {"page_number": 820, "sentence_chunk": "Kotlin class ProductDaoImpl(private val sessionFactory: SessionFactory) : ProductDao { \u00a0  fun loadProductsByCategory(category: String): Collection<*> { \u00a0    return sessionFactory.currentSession \u00a0        .createQuery(\"from test. Product product where product.category=?\")\u00a0        .setParameter(0, category) \u00a0        .list() \u00a0  } } This style is similar to that of the Hibernate reference documentation and examples, except for holding the SessionFactory in an instance variable. We strongly recommend such an instance-based setup over the old-school static HibernateUtil class from Hibernate\u2019s CaveatEmptor sample application. (In general, do not keep any resources in static variables unless absolutely necessary.)The preceding DAO example follows the dependency injection pattern. It fits nicely into a Spring IoC container, as it would if coded against Spring\u2019s HibernateTemplate. You can also set up such a DAO in plain Java (for example, in unit tests). To do so, instantiate it and call setSessionFactory(..) with the desired factory reference. As a Spring bean definition, the DAO would resemble the following: <beans> \u00a0  <bean id=\"myProductDao\" class=\"product.", "chunk_char_count": 1167, "chunk_word_count": 181, "chunk_token_count": 291.75}, {"page_number": 820, "sentence_chunk": "ProductDaoImpl\"> \u00a0    <property name=\"sessionFactory\" ref=\"mySessionFactory\"/> \u00a0  </bean> </beans> The main advantage of this DAO style is that it depends on Hibernate API only. No import of any Spring class is required. This is appealing from a non-invasiveness perspective and may feel more natural to Hibernate developers. However, the DAO throws plain HibernateException (which is unchecked, so it does not have to be declared or caught), which means that callers can treat exceptions only as being generally fatal\u2009\u2014\u2009unless they want to depend on Hibernate\u2019s own exception hierarchy. Catching specific causes (such as an optimistic locking failure) is not possible without tying the caller to the implementation strategy. This trade off might be acceptable to applications that are strongly Hibernate-based, do not need any special exception treatment, or both. Fortunately, Spring\u2019s LocalSessionFactoryBean supports Hibernate\u2019s SessionFactory.getCurrentSession() method for any Spring transaction strategy, returning the current Spring-managed transactional Session, even with HibernateTransactionManager. The standard behavior of that method remains to return the current Session associated with the ongoing JTA transaction, if any. This behavior applies regardless of whether you use Spring\u2019s JtaTransactionManager, EJB container managed transactions (CMTs), or JTA.820", "chunk_char_count": 1376, "chunk_word_count": 189, "chunk_token_count": 344.0}, {"page_number": 821, "sentence_chunk": "In summary, you can implement DAOs based on the plain Hibernate API, while still being able to participate in Spring-managed transactions. Declarative Transaction Demarcation We recommend that you use Spring\u2019s declarative transaction support, which lets you replace explicit transaction demarcation API calls in your Java code with an AOP transaction interceptor. You can configure this transaction interceptor in a Spring container by using either Java annotations or XML. This declarative transaction capability lets you keep business services free of repetitive transaction demarcation code and focus on adding business logic, which is the real value of your application.\uf05a Before you continue, we are strongly encourage you to read Declarative Transaction Management if you have not already done so. You can annotate the service layer with @Transactional annotations and instruct the Spring container to find these annotations and provide transactional semantics for these annotated methods. The following example shows how to do so: Java public class ProductServiceImpl implements ProductService { \u00a0  private ProductDao productDao; \u00a0  public void setProductDao(ProductDao productDao) { \u00a0    this.productDao = productDao; \u00a0  } \u00a0  @Transactional \u00a0  public void increasePriceOfAllProductsInCategory(final String category) { \u00a0    List productsToChange = this.productDao.loadProductsByCategory(category); \u00a0    // ... \u00a0  } \u00a0  @Transactional(readOnly = true) \u00a0  public List<Product> findAllProducts() { \u00a0    return this.productDao.findAllProducts(); \u00a0  } } 821", "chunk_char_count": 1557, "chunk_word_count": 230, "chunk_token_count": 389.25}, {"page_number": 822, "sentence_chunk": "Kotlin class ProductServiceImpl(private val productDao: ProductDao) : ProductService { \u00a0  @Transactional \u00a0  fun increasePriceOfAllProductsInCategory(category: String) { \u00a0    val productsToChange = productDao.loadProductsByCategory(category) \u00a0    // ... \u00a0  } \u00a0  @Transactional(readOnly = true) \u00a0  fun findAllProducts() = productDao.findAllProducts() } In the container, you need to set up the PlatformTransactionManager implementation (as a bean) and a <tx:annotation-driven/> entry, opting into @Transactional processing at runtime. The following example shows how to do so: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:aop=\"http://www.springframework.org/schema/aop\" \u00a0  xmlns:tx=\"http://www.springframework.org/schema/tx\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/tx \u00a0    https://www.springframework.org/schema/tx/spring-tx.xsd \u00a0    http://www.springframework.org/schema/aop \u00a0    https://www.springframework.org/schema/aop/spring-aop.xsd\"> \u00a0  <!--SessionFactory, DataSource, etc.omitted --> \u00a0  <bean id=\"transactionManager\" \u00a0      class=\"org.springframework.orm.hibernate5. HibernateTransactionManager\"> \u00a0    <property name=\"sessionFactory\" ref=\"sessionFactory\"/> \u00a0  </bean> \u00a0  <tx:annotation-driven/> \u00a0  <bean id=\"myProductService\" class=\"product. SimpleProductService\"> \u00a0    <property name=\"productDao\" ref=\"myProductDao\"/> \u00a0  </bean> </beans> Programmatic Transaction Demarcation You can demarcate transactions in a higher level of the application, on top of lower-level data 822", "chunk_char_count": 1743, "chunk_word_count": 194, "chunk_token_count": 435.75}, {"page_number": 823, "sentence_chunk": "access services that span any number of operations. Nor do restrictions exist on the implementation of the surrounding business service. It needs only a Spring PlatformTransactionManager. Again, the latter can come from anywhere, but preferably as a bean reference through a setTransactionManager(..) method. Also, the productDAO should be set by a setProductDao(..) method. The following pair of snippets show a transaction manager and a business service definition in a Spring application context and an example for a business method implementation: <beans> \u00a0  <bean id=\"myTxManager\" class=\"org.springframework.orm.hibernate5. HibernateTransactionManager\"> \u00a0    <property name=\"sessionFactory\" ref=\"mySessionFactory\"/> \u00a0  </bean> \u00a0  <bean id=\"myProductService\" class=\"product. ProductServiceImpl\"> \u00a0    <property name=\"transactionManager\" ref=\"myTxManager\"/> \u00a0    <property name=\"productDao\" ref=\"myProductDao\"/> \u00a0  </bean> </beans> Java public class ProductServiceImpl implements ProductService { \u00a0  private TransactionTemplate transactionTemplate; \u00a0  private ProductDao productDao; \u00a0  public void setTransactionManager(PlatformTransactionManager transactionManager) { \u00a0    this.transactionTemplate = new TransactionTemplate(transactionManager); \u00a0  } \u00a0  public void setProductDao(ProductDao productDao) { \u00a0    this.productDao = productDao; \u00a0  } \u00a0  public void increasePriceOfAllProductsInCategory(final String category) { \u00a0    this.transactionTemplate.execute(new TransactionCallbackWithoutResult() { \u00a0      public void doInTransactionWithoutResult(TransactionStatus status) { \u00a0        List productsToChange = this.productDao.loadProductsByCategory(category); \u00a0        // do the price increase... \u00a0      } \u00a0    }); \u00a0  } } 823", "chunk_char_count": 1728, "chunk_word_count": 241, "chunk_token_count": 432.0}, {"page_number": 824, "sentence_chunk": "Kotlin class ProductServiceImpl(transactionManager: PlatformTransactionManager, \u00a0            private val productDao: ProductDao) : ProductService { \u00a0  private val transactionTemplate = TransactionTemplate(transactionManager) \u00a0  fun increasePriceOfAllProductsInCategory(category: String) { \u00a0    transactionTemplate.execute { \u00a0      val productsToChange = productDao.loadProductsByCategory(category) \u00a0      // do the price increase... \u00a0    } \u00a0  } } Spring\u2019s TransactionInterceptor lets any checked application exception be thrown with the callback code, while TransactionTemplate is restricted to unchecked exceptions within the callback. TransactionTemplate triggers a rollback in case of an unchecked application exception or if the transaction is marked rollback-only by the application (by setting TransactionStatus). By default, TransactionInterceptor behaves the same way but allows configurable rollback policies per method. Transaction Management Strategies Both TransactionTemplate and TransactionInterceptor delegate the actual transaction handling to a PlatformTransactionManager instance (which can be a HibernateTransactionManager (for a single Hibernate SessionFactory) by using a ThreadLocal Session under the hood) or a JtaTransactionManager (delegating to the JTA subsystem of the container) for Hibernate applications. You can even use a custom PlatformTransactionManager implementation. Switching from native Hibernate transaction management to JTA (such as when facing distributed transaction requirements for certain deployments of your application) is only a matter of configuration. You can replace the Hibernate transaction manager with Spring\u2019s JTA transaction implementation. Both transaction demarcation and data access code work without changes, because they use the generic transaction management APIs. For distributed transactions across multiple Hibernate session factories, you can combine JtaTransactionManager as a transaction strategy with multiple LocalSessionFactoryBean definitions. Each DAO then gets one specific SessionFactory reference passed into its corresponding bean property.", "chunk_char_count": 2120, "chunk_word_count": 280, "chunk_token_count": 530.0}, {"page_number": 824, "sentence_chunk": "If all underlying JDBC data sources are transactional container ones, a business service can demarcate transactions across any number of DAOs and any number of session factories without special regard, as long as it uses JtaTransactionManager as the strategy. Both HibernateTransactionManager and JtaTransactionManager allow for proper JVM-level cache handling with Hibernate, without container-specific transaction manager lookup or a JCA connector (if you do not use EJB to initiate transactions). HibernateTransactionManager can export the Hibernate JDBC Connection to plain JDBC access code for a specific DataSource. This ability allows for high-level transaction demarcation with mixed Hibernate and JDBC data access completely without JTA, provided you access only one database.824", "chunk_char_count": 788, "chunk_word_count": 108, "chunk_token_count": 197.0}, {"page_number": 825, "sentence_chunk": "HibernateTransactionManager automatically exposes the Hibernate transaction as a JDBC transaction if you have set up the passed-in SessionFactory with a DataSource through the dataSource property of the LocalSessionFactoryBean class. Alternatively, you can specify explicitly the DataSource for which the transactions are supposed to be exposed through the dataSource property of the HibernateTransactionManager class. Comparing Container-managed and Locally Defined Resources You can switch between a container-managed JNDI SessionFactory and a locally defined one without having to change a single line of application code. Whether to keep resource definitions in the container or locally within the application is mainly a matter of the transaction strategy that you use. Compared to a Spring-defined local SessionFactory, a manually registered JNDI SessionFactory does not provide any benefits. Deploying a SessionFactory through Hibernate\u2019s JCA connector provides the added value of participating in the Jakarta EE server\u2019s management infrastructure, but does not add actual value beyond that. Spring\u2019s transaction support is not bound to a container. When configured with any strategy other than JTA, transaction support also works in a stand-alone or test environment. Especially in the typical case of single-database transactions, Spring\u2019s single-resource local transaction support is a lightweight and powerful alternative to JTA. When you use local EJB stateless session beans to drive transactions, you depend both on an EJB container and on JTA, even if you access only a single database and use only stateless session beans to provide declarative transactions through container-managed transactions.", "chunk_char_count": 1713, "chunk_word_count": 240, "chunk_token_count": 428.25}, {"page_number": 825, "sentence_chunk": "Direct use of JTA programmatically also requires a Jakarta EE environment. Spring-driven transactions can work as well with a locally defined Hibernate SessionFactory as they do with a local JDBC DataSource, provided they access a single database. Thus, you need only use Spring\u2019s JTA transaction strategy when you have distributed transaction requirements. A JCA connector requires container-specific deployment steps, and (obviously) JCA support in the first place. This configuration requires more work than deploying a simple web application with local resource definitions and Spring-driven transactions. All things considered, if you do not use EJBs, stick with local SessionFactory setup and Spring\u2019s HibernateTransactionManager or JtaTransactionManager. You get all of the benefits, including proper transactional JVM-level caching and distributed transactions, without the inconvenience of container deployment. JNDI registration of a Hibernate SessionFactory through the JCA connector adds value only when used in conjunction with EJBs. Spurious Application Server Warnings with Hibernate In some JTA environments with very strict XADataSource implementations (currently some WebLogic Server and WebSphere versions), when Hibernate is configured without regard to the JTA transaction manager for that environment, spurious warnings or exceptions can show up in the application server log. These warnings or exceptions indicate that the connection being accessed is no longer valid or JDBC access is no longer valid, possibly because the transaction is no longer active.", "chunk_char_count": 1579, "chunk_word_count": 220, "chunk_token_count": 394.75}, {"page_number": 826, "sentence_chunk": "java.sql. SQLException: The transaction is no longer active - status: 'Committed'. No further JDBC access is allowed within this transaction. Another common problem is a connection leak after JTA transactions, with Hibernate sessions (and potentially underlying JDBC connections) not getting closed properly. You can resolve such issues by making Hibernate aware of the JTA transaction manager, to which it synchronizes (along with Spring). You have two options for doing this: \u2022 Pass your Spring JtaTransactionManager bean to your Hibernate setup. The easiest way is a bean reference into the jtaTransactionManager property for your LocalSessionFactoryBean bean (see Hibernate Transaction Setup). Spring then makes the corresponding JTA strategies available to Hibernate. \u2022You may also configure Hibernate\u2019s JTA-related properties explicitly, in particular \"hibernate.transaction.coordinator_class\", \"hibernate.connection.handling_mode\" and potentially \"hibernate.transaction.jta.platform\" in your \"hibernateProperties\" on LocalSessionFactoryBean (see Hibernate\u2019s manual for details on those properties). The remainder of this section describes the sequence of events that occur with and without Hibernate\u2019s awareness of the JTA PlatformTransactionManager.", "chunk_char_count": 1257, "chunk_word_count": 158, "chunk_token_count": 314.25}, {"page_number": 826, "sentence_chunk": "When Hibernate is not configured with any awareness of the JTA transaction manager, the following events occur when a JTA transaction commits: \u2022 The JTA transaction commits. \u2022Spring\u2019s JtaTransactionManager is synchronized to the JTA transaction, so it is called back through an afterCompletion callback by the JTA transaction manager. \u2022Among other activities, this synchronization can trigger a callback by Spring to Hibernate, through Hibernate\u2019s afterTransactionCompletion callback (used to clear the Hibernate cache), followed by an explicit close() call on the Hibernate session, which causes Hibernate to attempt to close() the JDBC Connection. \u2022In some environments, this Connection.close() call then triggers the warning or error, as the application server no longer considers the Connection to be usable, because the transaction has already been committed. When Hibernate is configured with awareness of the JTA transaction manager, the following events occur when a JTA transaction commits: \u2022 The JTA transaction is ready to commit. \u2022Spring\u2019s JtaTransactionManager is synchronized to the JTA transaction, so the transaction is called back through a beforeCompletion callback by the JTA transaction manager. \u2022Spring is aware that Hibernate itself is synchronized to the JTA transaction and behaves differently than in the previous scenario. In particular, it aligns with Hibernate\u2019s transactional resource management. \u2022The JTA transaction commits.826", "chunk_char_count": 1458, "chunk_word_count": 207, "chunk_token_count": 364.5}, {"page_number": 827, "sentence_chunk": "\u2022 Hibernate is synchronized to the JTA transaction, so the transaction is called back through an afterCompletion callback by the JTA transaction manager and can properly clear its cache.4.5.4. JPA The Spring JPA, available under the org.springframework.orm.jpa package, offers comprehensive support for the Java Persistence API in a manner similar to the integration with Hibernate while being aware of the underlying implementation in order to provide additional features. Three Options for JPA Setup in a Spring Environment The Spring JPA support offers three ways of setting up the JPA EntityManagerFactory that is used by the application to obtain an entity manager. \u2022Using LocalEntityManagerFactoryBean \u2022 Obtaining an EntityManagerFactory from JNDI \u2022 Using LocalContainerEntityManagerFactoryBean Using LocalEntityManagerFactoryBean You can use this option only in simple deployment environments such as stand-alone applications and integration tests. The LocalEntityManagerFactoryBean creates an EntityManagerFactory suitable for simple deployment environments where the application uses only JPA for data access. The factory bean uses the JPA PersistenceProvider auto-detection mechanism (according to JPA\u2019s Java SE bootstrapping) and, in most cases, requires you to specify only the persistence unit name. The following XML example configures such a bean: <beans> \u00a0  <bean id=\"myEmf\" class=\"org.springframework.orm.jpa. LocalEntityManagerFactoryBean\"> \u00a0    <property name=\"persistenceUnitName\" value=\"myPersistenceUnit\"/> \u00a0  </bean> </beans> This form of JPA deployment is the simplest and the most limited. You cannot refer to an existing JDBC DataSource bean definition, and no support for global transactions exists.", "chunk_char_count": 1726, "chunk_word_count": 233, "chunk_token_count": 431.5}, {"page_number": 827, "sentence_chunk": "Furthermore, weaving (byte-code transformation) of persistent classes is provider-specific, often requiring a specific JVM agent to be specified on startup. This option is sufficient only for stand-alone applications and test environments, for which the JPA specification is designed. Obtaining an EntityManagerFactory from JNDI You can use this option when deploying to a Jakarta EE server. Check your server\u2019s documentation on how to deploy a custom JPA provider into your server, allowing for a different provider than the server\u2019s default.827", "chunk_char_count": 546, "chunk_word_count": 79, "chunk_token_count": 136.5}, {"page_number": 828, "sentence_chunk": "Obtaining an EntityManagerFactory from JNDI (for example in a Jakarta EE environment), is a matter of changing the XML configuration, as the following example shows: <beans> \u00a0  <jee:jndi-lookup id=\"myEmf\" jndi-name=\"persistence/myPersistenceUnit\"/> </beans> This action assumes standard Jakarta EE bootstrapping. The Jakarta EE server auto-detects persistence units (in effect, META-INF/persistence.xml files in application jars) and persistence-unit- ref entries in the Jakarta EE deployment descriptor (for example, web.xml) and defines environment naming context locations for those persistence units. In such a scenario, the entire persistence unit deployment, including the weaving (byte-code transformation) of persistent classes, is up to the Jakarta EE server. The JDBC DataSource is defined through a JNDI location in the META-INF/persistence.xml file. EntityManager transactions are integrated with the server\u2019s JTA subsystem. Spring merely uses the obtained EntityManagerFactory, passing it on to application objects through dependency injection and managing transactions for the persistence unit (typically through JtaTransactionManager). If you use multiple persistence units in the same application, the bean names of such JNDI- retrieved persistence units should match the persistence unit names that the application uses to refer to them (for example, in @PersistenceUnit and @PersistenceContext annotations). Using LocalContainerEntityManagerFactoryBean You can use this option for full JPA capabilities in a Spring-based application environment. This includes web containers such as Tomcat, stand-alone applications, and integration tests with sophisticated persistence requirements.\uf05a If you want to specifically configure a Hibernate setup, an immediate alternative is to set up a native Hibernate LocalSessionFactoryBean instead of a plain JPA LocalContainerEntityManagerFactoryBean, letting it interact with JPA access code as well as native Hibernate access code.", "chunk_char_count": 1985, "chunk_word_count": 259, "chunk_token_count": 496.25}, {"page_number": 828, "sentence_chunk": "See Native Hibernate setup for JPA interaction for details. The LocalContainerEntityManagerFactoryBean gives full control over EntityManagerFactory configuration and is appropriate for environments where fine-grained customization is required. The LocalContainerEntityManagerFactoryBean creates a PersistenceUnitInfo instance based on the persistence.xml file, the supplied dataSourceLookup strategy, and the specified loadTimeWeaver. It is, thus, possible to work with custom data sources outside of JNDI and to control the weaving process. The following example shows a typical bean definition for a LocalContainerEntityManagerFactoryBean: 828", "chunk_char_count": 645, "chunk_word_count": 77, "chunk_token_count": 161.25}, {"page_number": 829, "sentence_chunk": "<beans> \u00a0  <bean id=\"myEmf\" class=\"org.springframework.orm.jpa. LocalContainerEntityManagerFactoryBean\"> \u00a0    <property name=\"dataSource\" ref=\"someDataSource\"/> \u00a0    <property name=\"loadTimeWeaver\"> \u00a0      <bean class=\"org.springframework.instrument.classloading. InstrumentationLoadTimeWeaver\"/> \u00a0    </property> \u00a0  </bean> </beans> The following example shows a typical persistence.xml file: <persistence xmlns=\"http://java.sun.com/xml/ns/persistence\" version=\"1.0\"> \u00a0  <persistence-unit name=\"myUnit\" transaction-type=\"RESOURCE_LOCAL\"> \u00a0    <mapping-file>META-INF/orm.xml</mapping-file> \u00a0    <exclude-unlisted-classes/> \u00a0  </persistence-unit> </persistence> \uf05a The <exclude-unlisted-classes/> shortcut indicates that no scanning for annotated entity classes is supposed to occur. An explicit 'true' value (<exclude-unlisted- classes>true</exclude-unlisted-classes/>) also means no scan.<exclude-unlisted- classes>false</exclude-unlisted-classes/> does trigger a scan. However, we recommend omitting the exclude-unlisted-classes element if you want entity class scanning to occur. Using the LocalContainerEntityManagerFactoryBean is the most powerful JPA setup option, allowing for flexible local configuration within the application. It supports links to an existing JDBC DataSource, supports both local and global transactions, and so on. However, it also imposes requirements on the runtime environment, such as the availability of a weaving-capable class loader if the persistence provider demands byte-code transformation. This option may conflict with the built-in JPA capabilities of a Jakarta EE server.", "chunk_char_count": 1612, "chunk_word_count": 188, "chunk_token_count": 403.0}, {"page_number": 829, "sentence_chunk": "In a full Jakarta EE environment, consider obtaining your EntityManagerFactory from JNDI. Alternatively, specify a custom persistenceXmlLocation on your LocalContainerEntityManagerFactoryBean definition (for example, META-INF/my-persistence.xml) and include only a descriptor with that name in your application jar files. Because the Jakarta EE server looks only for default META-INF/persistence.xml files, it ignores such custom persistence units and, hence, avoids conflicts with a Spring-driven JPA setup upfront. (This applies to Resin 3.1, for example.)829", "chunk_char_count": 561, "chunk_word_count": 71, "chunk_token_count": 140.25}, {"page_number": 830, "sentence_chunk": "When is load-time weaving required?Not all JPA providers require a JVM agent. Hibernate is an example of one that does not. If your provider does not require an agent or you have other alternatives, such as applying enhancements at build time through a custom compiler or an Ant task, you should not use the load-time weaver. The LoadTimeWeaver interface is a Spring-provided class that lets JPA ClassTransformer instances be plugged in a specific manner, depending on whether the environment is a web container or application server. Hooking ClassTransformers through an agent is typically not efficient. The agents work against the entire virtual machine and inspect every class that is loaded, which is usually undesirable in a production server environment. Spring provides a number of LoadTimeWeaver implementations for various environments, letting ClassTransformer instances be applied only for each class loader and not for each VM. See the Spring configuration in the AOP chapter for more insight regarding the LoadTimeWeaver implementations and their setup, either generic or customized to various platforms (such as Tomcat, JBoss and WebSphere). As described in Spring configuration, you can configure a context-wide LoadTimeWeaver by using the @EnableLoadTimeWeaving annotation or the context:load-time-weaver XML element.", "chunk_char_count": 1334, "chunk_word_count": 196, "chunk_token_count": 333.5}, {"page_number": 830, "sentence_chunk": "Such a global weaver is automatically picked up by all JPA LocalContainerEntityManagerFactoryBean instances. The following example shows the preferred way of setting up a load-time weaver, delivering auto- detection of the platform (e.g. Tomcat\u2019s weaving-capable class loader or Spring\u2019s JVM agent) and automatic propagation of the weaver to all weaver-aware beans: <context:load-time-weaver/> <bean id=\"emf\" class=\"org.springframework.orm.jpa. LocalContainerEntityManagerFactoryBean\"> \u00a0  ... </bean> However, you can, if needed, manually specify a dedicated weaver through the loadTimeWeaver property, as the following example shows: <bean id=\"emf\" class=\"org.springframework.orm.jpa. LocalContainerEntityManagerFactoryBean\"> \u00a0  <property name=\"loadTimeWeaver\"> \u00a0    <bean class=\"org.springframework.instrument.classloading. ReflectiveLoadTimeWeaver\"/> \u00a0  </property> </bean> No matter how the LTW is configured, by using this technique, JPA applications relying on instrumentation can run in the target platform (for example, Tomcat) without needing an agent.830", "chunk_char_count": 1064, "chunk_word_count": 127, "chunk_token_count": 266.0}, {"page_number": 831, "sentence_chunk": "This is especially important when the hosting applications rely on different JPA implementations, because the JPA transformers are applied only at the class-loader level and are, thus, isolated from each other. Dealing with Multiple Persistence Units For applications that rely on multiple persistence units locations (stored in various JARS in the classpath, for example), Spring offers the PersistenceUnitManager to act as a central repository and to avoid the persistence units discovery process, which can be expensive. The default implementation lets multiple locations be specified. These locations are parsed and later retrieved through the persistence unit name. (By default, the classpath is searched for META- INF/persistence.xml files.)The following example configures multiple locations: <bean id=\"pum\" class=\"org.springframework.orm.jpa.persistenceunit. DefaultPersistenceUnitManager\"> \u00a0  <property name=\"persistenceXmlLocations\"> \u00a0    <list> \u00a0      <value>org/springframework/orm/jpa/domain/persistence-multi.xml</value> \u00a0      <value>classpath:/my/package/**/custom-persistence.xml</value> \u00a0      <value>classpath*:META-INF/persistence.xml</value> \u00a0    </list> \u00a0  </property> \u00a0  <property name=\"dataSources\"> \u00a0    <map> \u00a0      <entry key=\"localDataSource\" value-ref=\"local-db\"/> \u00a0      <entry key=\"remoteDataSource\" value-ref=\"remote-db\"/> \u00a0    </map> \u00a0  </property> \u00a0  <!--if no datasource is specified, use this one --> \u00a0  <property name=\"defaultDataSource\" ref=\"remoteDataSource\"/> </bean> <bean id=\"emf\" class=\"org.springframework.orm.jpa. LocalContainerEntityManagerFactoryBean\"> \u00a0  <property name=\"persistenceUnitManager\" ref=\"pum\"/> \u00a0  <property name=\"persistenceUnitName\" value=\"myCustomUnit\"/> </bean> The default implementation allows customization of the PersistenceUnitInfo instances (before they are fed to the JPA provider) either declaratively (through its properties, which affect all hosted units) or programmatically (through the PersistenceUnitPostProcessor, which allows persistence unit selection). If no PersistenceUnitManager is specified, one is created and used internally by LocalContainerEntityManagerFactoryBean.", "chunk_char_count": 2155, "chunk_word_count": 270, "chunk_token_count": 538.75}, {"page_number": 831, "sentence_chunk": "Background Bootstrapping LocalContainerEntityManagerFactoryBean supports background bootstrapping through the bootstrapExecutor property, as the following example shows: 831", "chunk_char_count": 173, "chunk_word_count": 16, "chunk_token_count": 43.25}, {"page_number": 832, "sentence_chunk": "<bean id=\"emf\" class=\"org.springframework.orm.jpa. LocalContainerEntityManagerFactoryBean\"> \u00a0  <property name=\"bootstrapExecutor\"> \u00a0    <bean class=\"org.springframework.core.task. SimpleAsyncTaskExecutor\"/> \u00a0  </property> </bean> The actual JPA provider bootstrapping is handed off to the specified executor and then, running in parallel, to the application bootstrap thread. The exposed EntityManagerFactory proxy can be injected into other application components and is even able to respond to EntityManagerFactoryInfo configuration inspection. However, once the actual JPA provider is being accessed by other components (for example, calling createEntityManager), those calls block until the background bootstrapping has completed. In particular, when you use Spring Data JPA, make sure to set up deferred bootstrapping for its repositories as well. Implementing DAOs Based on JPA: EntityManagerFactory and EntityManager \uf05a Although EntityManagerFactory instances are thread-safe, EntityManager instances are not. The injected JPA EntityManager behaves like an EntityManager fetched from an application server\u2019s JNDI environment, as defined by the JPA specification. It delegates all calls to the current transactional EntityManager, if any. Otherwise, it falls back to a newly created EntityManager per operation, in effect making its usage thread-safe.", "chunk_char_count": 1356, "chunk_word_count": 174, "chunk_token_count": 339.0}, {"page_number": 832, "sentence_chunk": "It is possible to write code against the plain JPA without any Spring dependencies, by using an injected EntityManagerFactory or EntityManager. Spring can understand the @PersistenceUnit and @PersistenceContext annotations both at the field and the method level if a PersistenceAnnotationBeanPostProcessor is enabled. The following example shows a plain JPA DAO implementation that uses the @PersistenceUnit annotation: 832", "chunk_char_count": 423, "chunk_word_count": 57, "chunk_token_count": 105.75}, {"page_number": 833, "sentence_chunk": "Java public class ProductDaoImpl implements ProductDao { \u00a0  private EntityManagerFactory emf; \u00a0  @PersistenceUnit \u00a0  public void setEntityManagerFactory(EntityManagerFactory emf) { \u00a0    this.emf = emf; \u00a0  } \u00a0  public Collection loadProductsByCategory(String category) { \u00a0    EntityManager em = this.emf.createEntityManager(); \u00a0    try { \u00a0      Query query = em.createQuery(\"from Product as p where p.category = ?1\"); \u00a0      query.setParameter(1, category); \u00a0      return query.getResultList(); \u00a0    } \u00a0    finally { \u00a0      if (em != null) { \u00a0        em.close(); \u00a0      } \u00a0    } \u00a0  } } Kotlin class ProductDaoImpl : ProductDao { \u00a0  private lateinit var emf: EntityManagerFactory \u00a0  @PersistenceUnit \u00a0  fun setEntityManagerFactory(emf: EntityManagerFactory) { \u00a0    this.emf = emf \u00a0  } \u00a0  fun loadProductsByCategory(category: String): Collection<*> { \u00a0    val em = this.emf.createEntityManager() \u00a0    val query = em.createQuery(\"from Product as p where p.category = ?1\"); \u00a0    query.setParameter(1, category); \u00a0    return query.resultList; \u00a0  } } The preceding DAO has no dependency on Spring and still fits nicely into a Spring application context. Moreover, the DAO takes advantage of annotations to require the injection of the default EntityManagerFactory, as the following example bean definition shows: 833", "chunk_char_count": 1309, "chunk_word_count": 251, "chunk_token_count": 327.25}, {"page_number": 834, "sentence_chunk": "<beans> \u00a0  <!--bean post-processor for JPA annotations --> \u00a0  <bean class=\"org.springframework.orm.jpa.support. PersistenceAnnotationBeanPostProcessor\"/> \u00a0  <bean id=\"myProductDao\" class=\"product. ProductDaoImpl\"/> </beans> As an alternative to explicitly defining a PersistenceAnnotationBeanPostProcessor, consider using the Spring context:annotation-config XML element in your application context configuration. Doing so automatically registers all Spring standard post-processors for annotation-based configuration, including CommonAnnotationBeanPostProcessor and so on. Consider the following example: <beans> \u00a0  <!--post-processors for all standard config annotations --> \u00a0  <context:annotation-config/> \u00a0  <bean id=\"myProductDao\" class=\"product. ProductDaoImpl\"/> </beans> The main problem with such a DAO is that it always creates a new EntityManager through the factory. You can avoid this by requesting a transactional EntityManager (also called a \u201cshared EntityManager\u201d because it is a shared, thread-safe proxy for the actual transactional EntityManager) to be injected instead of the factory. The following example shows how to do so: Java public class ProductDaoImpl implements ProductDao { \u00a0  @PersistenceContext \u00a0  private EntityManager em; \u00a0  public Collection loadProductsByCategory(String category) { \u00a0    Query query = em.createQuery(\"from Product as p where p.category = :category\"); \u00a0    query.setParameter(\"category\", category); \u00a0    return query.getResultList(); \u00a0  } } 834", "chunk_char_count": 1496, "chunk_word_count": 194, "chunk_token_count": 374.0}, {"page_number": 835, "sentence_chunk": "Kotlin class ProductDaoImpl : ProductDao { \u00a0  @PersistenceContext \u00a0  private lateinit var em: EntityManager \u00a0  fun loadProductsByCategory(category: String): Collection<*> { \u00a0    val query = em.createQuery(\"from Product as p where p.category = :category\") \u00a0    query.setParameter(\"category\", category) \u00a0    return query.resultList \u00a0  } } The @PersistenceContext annotation has an optional attribute called type, which defaults to PersistenceContextType. TRANSACTION. You can use this default to receive a shared EntityManager proxy. The alternative, PersistenceContextType. EXTENDED, is a completely different affair. This results in a so-called extended EntityManager, which is not thread-safe and, hence, must not be used in a concurrently accessed component, such as a Spring-managed singleton bean. Extended EntityManager instances are only supposed to be used in stateful components that, for example, reside in a session, with the lifecycle of the EntityManager not tied to a current transaction but rather being completely up to the application. Method- and field-level Injection You can apply annotations that indicate dependency injections (such as @PersistenceUnit and @PersistenceContext) on field or methods inside a class\u2009\u2014\u2009hence the expressions \u201cmethod- level injection\u201d and \u201cfield-level injection\u201d. Field-level annotations are concise and easier to use while method-level annotations allow for further processing of the injected dependency. In both cases, the member visibility (public, protected, or private) does not matter.", "chunk_char_count": 1540, "chunk_word_count": 219, "chunk_token_count": 385.0}, {"page_number": 835, "sentence_chunk": "What about class-level annotations?On the Jakarta EE platform, they are used for dependency declaration and not for resource injection. The injected EntityManager is Spring-managed (aware of the ongoing transaction). Even though the new DAO implementation uses method-level injection of an EntityManager instead of an EntityManagerFactory, no change is required in the application context XML, due to annotation usage. The main advantage of this DAO style is that it depends only on the Java Persistence API. No import of any Spring class is required. Moreover, as the JPA annotations are understood, the injections are applied automatically by the Spring container. This is appealing from a non-invasiveness perspective and can feel more natural to JPA developers.835", "chunk_char_count": 768, "chunk_word_count": 114, "chunk_token_count": 192.0}, {"page_number": 836, "sentence_chunk": "Spring-driven JPA transactions \uf05a We strongly encourage you to read Declarative Transaction Management, if you have not already done so, to get more detailed coverage of Spring\u2019s declarative transaction support. The recommended strategy for JPA is local transactions through JPA\u2019s native transaction support. Spring\u2019s JpaTransactionManager provides many capabilities known from local JDBC transactions (such as transaction-specific isolation levels and resource-level read-only optimizations) against any regular JDBC connection pool (no XA requirement). Spring JPA also lets a configured JpaTransactionManager expose a JPA transaction to JDBC access code that accesses the same DataSource, provided that the registered JpaDialect supports retrieval of the underlying JDBC Connection. Spring provides dialects for the EclipseLink and Hibernate JPA implementations. See the next section for details on the JpaDialect mechanism.\uf05a As an immediate alternative, Spring\u2019s native HibernateTransactionManager is capable of interacting with JPA access code, adapting to several Hibernate specifics and providing JDBC interaction. This makes particular sense in combination with LocalSessionFactoryBean setup. See Native Hibernate Setup for JPA Interaction for details. Understanding JpaDialect and JpaVendorAdapter As an advanced feature, JpaTransactionManager and subclasses of AbstractEntityManagerFactoryBean allow a custom JpaDialect to be passed into the jpaDialect bean property.", "chunk_char_count": 1475, "chunk_word_count": 190, "chunk_token_count": 368.75}, {"page_number": 836, "sentence_chunk": "A JpaDialect implementation can enable the following advanced features supported by Spring, usually in a vendor-specific manner: \u2022 Applying specific transaction semantics (such as custom isolation level or transaction timeout) \u2022 Retrieving the transactional JDBC Connection (for exposure to JDBC-based DAOs) \u2022 Advanced translation of PersistenceExceptions to Spring DataAccessExceptions This is particularly valuable for special transaction semantics and for advanced translation of exception. The default implementation (DefaultJpaDialect) does not provide any special abilities and, if the features listed earlier are required, you have to specify the appropriate dialect.\uf0eb As an even broader provider adaptation facility primarily for Spring\u2019s full- featured LocalContainerEntityManagerFactoryBean setup, JpaVendorAdapter combines the capabilities of JpaDialect with other provider-specific defaults. Specifying a HibernateJpaVendorAdapter or EclipseLinkJpaVendorAdapter is the most convenient way of auto-configuring an EntityManagerFactory setup for Hibernate or EclipseLink, respectively. Note that those provider adapters are primarily designed for use with Spring-driven transaction management (that is, for use with JpaTransactionManager). See the JpaDialect and JpaVendorAdapter javadoc for more details of its operations and how they are used within Spring\u2019s JPA support.836", "chunk_char_count": 1385, "chunk_word_count": 173, "chunk_token_count": 346.25}, {"page_number": 837, "sentence_chunk": "Setting up JPA with JTA Transaction Management As an alternative to JpaTransactionManager, Spring also allows for multi-resource transaction coordination through JTA, either in a Jakarta EE environment or with a stand-alone transaction coordinator, such as Atomikos. Aside from choosing Spring\u2019s JtaTransactionManager instead of JpaTransactionManager, you need to take few further steps: \u2022 The underlying JDBC connection pools need to be XA-capable and be integrated with your transaction coordinator. This is usually straightforward in a Jakarta EE environment, exposing a different kind of DataSource through JNDI. See your application server documentation for details. Analogously, a standalone transaction coordinator usually comes with special XA- integrated DataSource variants. Again, check its documentation. \u2022The JPA EntityManagerFactory setup needs to be configured for JTA. This is provider-specific, typically through special properties to be specified as jpaProperties on LocalContainerEntityManagerFactoryBean. In the case of Hibernate, these properties are even version-specific. See your Hibernate documentation for details. \u2022", "chunk_char_count": 1142, "chunk_word_count": 150, "chunk_token_count": 285.5}, {"page_number": 837, "sentence_chunk": "Spring\u2019s HibernateJpaVendorAdapter enforces certain Spring-oriented defaults, such as the connection release mode, on-close, which matches Hibernate\u2019s own default in Hibernate 5.0 but not any more in Hibernate 5.1+. For a JTA setup, make sure to declare your persistence unit transaction type as \"JTA\". Alternatively, set Hibernate 5.2\u2019s hibernate.connection.handling_mode property to DELAYED_ACQUISITION_AND_RELEASE_AFTER_STATEMENT to restore Hibernate\u2019s own default. See Spurious Application Server Warnings with Hibernate for related notes. \u2022Alternatively, consider obtaining the EntityManagerFactory from your application server itself (that is, through a JNDI lookup instead of a locally declared LocalContainerEntityManagerFactoryBean). A server-provided EntityManagerFactory might require special definitions in your server configuration (making the deployment less portable) but is set up for the server\u2019s JTA environment. Native Hibernate Setup and Native Hibernate Transactions for JPA Interaction A native LocalSessionFactoryBean setup in combination with HibernateTransactionManager allows for interaction with @PersistenceContext and other JPA access code. A Hibernate SessionFactory natively implements JPA\u2019s EntityManagerFactory interface now and a Hibernate Session handle natively is a JPA EntityManager. Spring\u2019s JPA support facilities automatically detect native Hibernate sessions. Such native Hibernate setup can, therefore, serve as a replacement for a standard JPA LocalContainerEntityManagerFactoryBean and JpaTransactionManager combination in many scenarios, allowing for interaction with SessionFactory.getCurrentSession() (and also HibernateTemplate) next to @PersistenceContext EntityManager within the same local transaction.", "chunk_char_count": 1754, "chunk_word_count": 207, "chunk_token_count": 438.5}, {"page_number": 837, "sentence_chunk": "Such a setup also provides stronger Hibernate integration and more configuration flexibility, because it is not constrained by JPA bootstrap contracts. You do not need HibernateJpaVendorAdapter configuration in such a scenario, since Spring\u2019s native Hibernate setup provides even more features (for example, custom Hibernate Integrator setup, Hibernate 5.3 bean container integration, and stronger optimizations for read-only transactions). Last but not least, you can also express native Hibernate setup through LocalSessionFactoryBuilder, seamlessly integrating with @Bean style configuration (no FactoryBean involved).837", "chunk_char_count": 624, "chunk_word_count": 79, "chunk_token_count": 156.0}, {"page_number": 838, "sentence_chunk": "\uf05a LocalSessionFactoryBean and LocalSessionFactoryBuilder support background bootstrapping, just as the JPA LocalContainerEntityManagerFactoryBean does. See Background Bootstrapping for an introduction. On LocalSessionFactoryBean, this is available through the bootstrapExecutor property. On the programmatic LocalSessionFactoryBuilder, an overloaded buildSessionFactory method takes a bootstrap executor argument.4.6. Marshalling XML by Using Object-XML Mappers 4.6.1. Introduction This chapter, describes Spring\u2019s Object-XML Mapping support. Object-XML Mapping (O-X mapping for short) is the act of converting an XML document to and from an object. This conversion process is also known as XML Marshalling, or XML Serialization. This chapter uses these terms interchangeably.", "chunk_char_count": 776, "chunk_word_count": 93, "chunk_token_count": 194.0}, {"page_number": 838, "sentence_chunk": "Within the field of O-X mapping, a marshaller is responsible for serializing an object (graph) to XML. In similar fashion, an unmarshaller deserializes the XML to an object graph. This XML can take the form of a DOM document, an input or output stream, or a SAX handler. Some of the benefits of using Spring for your O/X mapping needs are: \u2022 Ease of configuration \u2022 Consistent Interfaces \u2022 Consistent Exception Hierarchy Ease of configuration Spring\u2019s bean factory makes it easy to configure marshallers, without needing to construct JAXB context, JiBX binding factories, and so on. You can configure the marshallers as you would any other bean in your application context. Additionally, XML namespace-based configuration is available for a number of marshallers, making the configuration even simpler. Consistent Interfaces Spring\u2019s O-X mapping operates through two global interfaces: Marshaller and Unmarshaller. These abstractions let you switch O-X mapping frameworks with relative ease, with little or no change required on the classes that do the marshalling. This approach has the additional benefit of making it possible to do XML marshalling with a mix-and-match approach (for example, some marshalling performed using JAXB and some by XStream) in a non-intrusive fashion, letting you use the strength of each technology. Consistent Exception Hierarchy Spring provides a conversion from exceptions from the underlying O-X mapping tool to its own exception hierarchy with the XmlMappingException as the root exception.", "chunk_char_count": 1526, "chunk_word_count": 232, "chunk_token_count": 381.5}, {"page_number": 839, "sentence_chunk": "4.6.2. Marshaller and Unmarshaller As stated in the introduction, a marshaller serializes an object to XML, and an unmarshaller deserializes XML stream to an object. This section describes the two Spring interfaces used for this purpose. Understanding Marshaller Spring abstracts all marshalling operations behind the org.springframework.oxm. Marshaller interface, the main method of which follows: public interface Marshaller { \u00a0  /** \u00a0  * Marshal the object graph with the given root into the provided Result.\u00a0  */ \u00a0  void marshal(Object graph, Result result) throws XmlMappingException, IOException; } The Marshaller interface has one main method, which marshals the given object to a given javax.xml.transform. Result. The result is a tagging interface that basically represents an XML output abstraction. Concrete implementations wrap various XML representations, as the following table indicates: Result implementation Wraps XML representation DOMResult org.w3c.dom. Node SAXResult org.xml.sax.", "chunk_char_count": 1000, "chunk_word_count": 140, "chunk_token_count": 250.0}, {"page_number": 839, "sentence_chunk": "ContentHandler StreamResult java.io. File, java.io. OutputStream, or java.io. Writer \uf05a Although the marshal() method accepts a plain object as its first parameter, most Marshaller implementations cannot handle arbitrary objects. Instead, an object class must be mapped in a mapping file, be marked with an annotation, be registered with the marshaller, or have a common base class. Refer to the later sections in this chapter to determine how your O-X technology manages this. Understanding Unmarshaller Similar to the Marshaller, we have the org.springframework.oxm. Unmarshaller interface, which the following listing shows: 839", "chunk_char_count": 630, "chunk_word_count": 90, "chunk_token_count": 157.5}, {"page_number": 840, "sentence_chunk": "public interface Unmarshaller { \u00a0  /** \u00a0  * Unmarshal the given provided Source into an object graph.\u00a0  */ \u00a0  Object unmarshal(Source source) throws XmlMappingException, IOException; } This interface also has one method, which reads from the given javax.xml.transform. Source (an XML input abstraction) and returns the object read. As with Result, Source is a tagging interface that has three concrete implementations. Each wraps a different XML representation, as the following table indicates: Source implementation Wraps XML representation DOMSource org.w3c.dom. Node SAXSource org.xml.sax. InputSource, and org.xml.sax. XMLReader StreamSource java.io. File, java.io. InputStream, or java.io.", "chunk_char_count": 695, "chunk_word_count": 97, "chunk_token_count": 173.75}, {"page_number": 840, "sentence_chunk": "Reader Even though there are two separate marshalling interfaces (Marshaller and Unmarshaller), all implementations in Spring-WS implement both in one class. This means that you can wire up one marshaller class and refer to it both as a marshaller and as an unmarshaller in your applicationContext.xml. Understanding XmlMappingException Spring converts exceptions from the underlying O-X mapping tool to its own exception hierarchy with the XmlMappingException as the root exception. These runtime exceptions wrap the original exception so that no information will be lost. Additionally, the MarshallingFailureException and UnmarshallingFailureException provide a distinction between marshalling and unmarshalling operations, even though the underlying O-X mapping tool does not do so. The O-X Mapping exception hierarchy is shown in the following figure: 840", "chunk_char_count": 859, "chunk_word_count": 119, "chunk_token_count": 214.75}, {"page_number": 841, "sentence_chunk": "4.6.3. Using Marshaller and Unmarshaller You can use Spring\u2019s OXM for a wide variety of situations. In the following example, we use it to marshal the settings of a Spring-managed application as an XML file. In the following example, we use a simple JavaBean to represent the settings: Java public class Settings { \u00a0  private boolean fooEnabled; \u00a0  public boolean isFooEnabled() { \u00a0    return fooEnabled; \u00a0  } \u00a0  public void setFooEnabled(boolean fooEnabled) { \u00a0    this.fooEnabled = fooEnabled; \u00a0  } } Kotlin class Settings { \u00a0  var isFooEnabled: Boolean = false } The application class uses this bean to store its settings. Besides a main method, the class has two methods: saveSettings() saves the settings bean to a file named settings.xml, and loadSettings() loads these settings again. The following main() method constructs a Spring application context and calls these two methods: 841", "chunk_char_count": 892, "chunk_word_count": 153, "chunk_token_count": 223.0}, {"page_number": 842, "sentence_chunk": "Java import java.io. FileInputStream; import java.io. FileOutputStream; import java.io. IOException; import javax.xml.transform.stream. StreamResult; import javax.xml.transform.stream. StreamSource; import org.springframework.context. ApplicationContext; import org.springframework.context.support. ClassPathXmlApplicationContext; import org.springframework.oxm. Marshaller; import org.springframework.oxm. Unmarshaller; public class Application { \u00a0  private static final String FILE_NAME = \"settings.xml\"; \u00a0  private Settings settings = new Settings(); \u00a0  private Marshaller marshaller; \u00a0  private Unmarshaller unmarshaller; \u00a0  public void setMarshaller(Marshaller marshaller) { \u00a0    this.marshaller = marshaller; \u00a0  } \u00a0  public void setUnmarshaller(Unmarshaller unmarshaller) { \u00a0    this.unmarshaller = unmarshaller; \u00a0  } \u00a0  public void saveSettings() throws IOException { \u00a0    try (FileOutputStream os = new FileOutputStream(FILE_NAME)) { \u00a0      this.marshaller.marshal(settings, new StreamResult(os)); \u00a0    } \u00a0  } \u00a0  public void loadSettings() throws IOException { \u00a0    try (FileInputStream is = new FileInputStream(FILE_NAME)) { \u00a0      this.settings = (Settings) this.unmarshaller.unmarshal(new StreamSource(is)); \u00a0    } \u00a0  } \u00a0  public static void main(String[] args) throws IOException { \u00a0    ApplicationContext appContext = \u00a0        new ClassPathXmlApplicationContext(\"applicationContext.xml\"); \u00a0    Application application = (Application) appContext.getBean(\"application\"); \u00a0    application.saveSettings(); \u00a0    application.loadSettings(); \u00a0  } } 842", "chunk_char_count": 1558, "chunk_word_count": 218, "chunk_token_count": 389.5}, {"page_number": 843, "sentence_chunk": "Kotlin class Application { \u00a0  lateinit var marshaller: Marshaller \u00a0  lateinit var unmarshaller: Unmarshaller \u00a0  fun saveSettings() { \u00a0    FileOutputStream(FILE_NAME).use { outputStream -> marshaller.marshal(settings, StreamResult(outputStream)) } \u00a0  } \u00a0  fun loadSettings() { \u00a0    FileInputStream(FILE_NAME).use { inputStream -> settings = unmarshaller.unmarshal(StreamSource(inputStream)) as Settings } \u00a0  } } private const val FILE_NAME = \"settings.xml\" fun main(args: Array<String>) { \u00a0  val appContext = ClassPathXmlApplicationContext(\"applicationContext.xml\") \u00a0  val application = appContext.getBean(\"application\") as Application \u00a0  application.saveSettings() \u00a0  application.loadSettings() } The Application requires both a marshaller and an unmarshaller property to be set. We can do so by using the following applicationContext.xml: <beans> \u00a0  <bean id=\"application\" class=\"Application\"> \u00a0    <property name=\"marshaller\" ref=\"xstreamMarshaller\" /> \u00a0    <property name=\"unmarshaller\" ref=\"xstreamMarshaller\" /> \u00a0  </bean> \u00a0  <bean id=\"xstreamMarshaller\" class=\"org.springframework.oxm.xstream. XStreamMarshaller\"/> </beans> This application context uses XStream, but we could have used any of the other marshaller instances described later in this chapter. Note that, by default, XStream does not require any further configuration, so the bean definition is rather simple. Also note that the XStreamMarshaller implements both Marshaller and Unmarshaller, so we can refer to the xstreamMarshaller bean in both the marshaller and unmarshaller property of the application. This sample application produces the following settings.xml file: 843", "chunk_char_count": 1645, "chunk_word_count": 219, "chunk_token_count": 411.25}, {"page_number": 844, "sentence_chunk": "<?xml version=\"1.0\" encoding=\"UTF-8\"?> <settings foo-enabled=\"false\"/> 4.6.4. XML Configuration Namespace You can configure marshallers more concisely by using tags from the OXM namespace. To make these tags available, you must first reference the appropriate schema in the preamble of the XML configuration file. The following example shows how to do so: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:oxm=\"http://www.springframework.org/schema/oxm\" \u2460 xsi:schemaLocation=\"http://www.springframework.org/schema/beans \u00a0 https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0 http://www.springframework.org/schema/oxm https://www.springframework.org/schema/oxm/spring-oxm.xsd\"> \u2461 \u2460 Reference the oxm schema.\u2461 Specify the oxm schema location. The schema makes the following elements available: \u2022 jaxb2-marshaller \u2022 jibx-marshaller Each tag is explained in its respective marshaller\u2019s section.", "chunk_char_count": 1015, "chunk_word_count": 99, "chunk_token_count": 253.75}, {"page_number": 844, "sentence_chunk": "As an example, though, the configuration of a JAXB2 marshaller might resemble the following: <oxm:jaxb2-marshaller id=\"marshaller\" contextPath=\"org.springframework.ws.samples.airline.schema\"/> 4.6.5. JAXB The JAXB binding compiler translates a W3C XML Schema into one or more Java classes, a jaxb.properties file, and possibly some resource files. JAXB also offers a way to generate a schema from annotated Java classes. Spring supports the JAXB 2.0 API as XML marshalling strategies, following the Marshaller and Unmarshaller interfaces described in Marshaller and Unmarshaller. The corresponding integration classes reside in the org.springframework.oxm.jaxb package. Using Jaxb2Marshaller The Jaxb2Marshaller class implements both of Spring\u2019s Marshaller and Unmarshaller interfaces. It requires a context path to operate. You can set the context path by setting the contextPath property.844", "chunk_char_count": 893, "chunk_word_count": 116, "chunk_token_count": 223.25}, {"page_number": 845, "sentence_chunk": "The context path is a list of colon-separated Java package names that contain schema derived classes. It also offers a classesToBeBound property, which allows you to set an array of classes to be supported by the marshaller. Schema validation is performed by specifying one or more schema resources to the bean, as the following example shows: <beans> \u00a0  <bean id=\"jaxb2Marshaller\" class=\"org.springframework.oxm.jaxb. Jaxb2Marshaller\"> \u00a0    <property name=\"classesToBeBound\"> \u00a0      <list> \u00a0        <value>org.springframework.oxm.jaxb. Flight</value> \u00a0        <value>org.springframework.oxm.jaxb. Flights</value> \u00a0      </list> \u00a0    </property> \u00a0    <property name=\"schema\" value=\"classpath:org/springframework/oxm/schema.xsd\"/> \u00a0  </bean> \u00a0  ... </beans> XML Configuration Namespace The jaxb2-marshaller element configures a org.springframework.oxm.jaxb. Jaxb2Marshaller, as the following example shows: <oxm:jaxb2-marshaller id=\"marshaller\" contextPath=\"org.springframework.ws.samples.airline.schema\"/> Alternatively, you can provide the list of classes to bind to the marshaller by using the class-to-be- bound child element: <oxm:jaxb2-marshaller id=\"marshaller\"> \u00a0  <oxm:class-to-be-bound name=\"org.springframework.ws.samples.airline.schema. Airport\"/> \u00a0  <oxm:class-to-be-bound name=\"org.springframework.ws.samples.airline.schema. Flight\"/> \u00a0  ... </oxm:jaxb2-marshaller> The following table describes the available attributes: Attribute Description Required id The ID of the marshaller No contextPath The JAXB Context path No 845", "chunk_char_count": 1537, "chunk_word_count": 200, "chunk_token_count": 384.25}, {"page_number": 846, "sentence_chunk": "4.6.6. JiBX The JiBX framework offers a solution similar to that which Hibernate provides for ORM: A binding definition defines the rules for how your Java objects are converted to or from XML. After preparing the binding and compiling the classes, a JiBX binding compiler enhances the class files and adds code to handle converting instances of the classes from or to XML. For more information on JiBX, see the JiBX web site. The Spring integration classes reside in the org.springframework.oxm.jibx package. Using JibxMarshaller The JibxMarshaller class implements both the Marshaller and Unmarshaller interface. To operate, it requires the name of the class to marshal in, which you can set using the targetClass property. Optionally, you can set the binding name by setting the bindingName property. In the following example, we bind the Flights class: <beans> \u00a0  <bean id=\"jibxFlightsMarshaller\" class=\"org.springframework.oxm.jibx. JibxMarshaller\"> \u00a0    <property name=\"targetClass\">org.springframework.oxm.jibx.", "chunk_char_count": 1018, "chunk_word_count": 148, "chunk_token_count": 254.5}, {"page_number": 846, "sentence_chunk": "Flights</property> \u00a0  </bean> \u00a0  ... </beans> A JibxMarshaller is configured for a single class. If you want to marshal multiple classes, you have to configure multiple JibxMarshaller instances with different targetClass property values. XML Configuration Namespace The jibx-marshaller tag configures a org.springframework.oxm.jibx. JibxMarshaller, as the following example shows: <oxm:jibx-marshaller id=\"marshaller\" target- class=\"org.springframework.ws.samples.airline.schema. Flight\"/> The following table describes the available attributes: Attribute Description Required id The ID of the marshaller No target-class The target class for this marshaller Yes bindingName The binding name used by this marshaller No 846", "chunk_char_count": 721, "chunk_word_count": 90, "chunk_token_count": 180.25}, {"page_number": 847, "sentence_chunk": "4.6.7. XStream XStream is a simple library to serialize objects to XML and back again. It does not require any mapping and generates clean XML. For more information on XStream, see the XStream web site. The Spring integration classes reside in the org.springframework.oxm.xstream package. Using XStreamMarshaller The XStreamMarshaller does not require any configuration and can be configured in an application context directly. To further customize the XML, you can set an alias map, which consists of string aliases mapped to classes, as the following example shows: <beans> \u00a0  <bean id=\"xstreamMarshaller\" class=\"org.springframework.oxm.xstream. XStreamMarshaller\"> \u00a0    <property name=\"aliases\"> \u00a0      <props> \u00a0        <prop key=\"Flight\">org.springframework.oxm.xstream. Flight</prop> \u00a0      </props> \u00a0    </property> \u00a0  </bean> \u00a0  ... </beans> 847", "chunk_char_count": 852, "chunk_word_count": 137, "chunk_token_count": 213.0}, {"page_number": 848, "sentence_chunk": "\uf071 By default, XStream lets arbitrary classes be unmarshalled, which can lead to unsafe Java serialization effects. As such, we do not recommend using the XStreamMarshaller to unmarshal XML from external sources (that is, the Web), as this can result in security vulnerabilities. If you choose to use the XStreamMarshaller to unmarshal XML from an external source, set the supportedClasses property on the XStreamMarshaller, as the following example shows: <bean id=\"xstreamMarshaller\" class=\"org.springframework.oxm.xstream. XStreamMarshaller\"> \u00a0  <property name=\"supportedClasses\" value=\"org.springframework.oxm.xstream. Flight\"/> \u00a0  ... </bean> Doing so ensures that only the registered classes are eligible for unmarshalling. Additionally, you can register custom converters to make sure that only your supported classes can be unmarshalled. You might want to add a CatchAllConverter as the last converter in the list, in addition to converters that explicitly support the domain classes that should be supported. As a result, default XStream converters with lower priorities and possible security vulnerabilities do not get invoked.\uf05a Note that XStream is an XML serialization library, not a data binding library. Therefore, it has limited namespace support.", "chunk_char_count": 1261, "chunk_word_count": 176, "chunk_token_count": 315.25}, {"page_number": 848, "sentence_chunk": "As a result, it is rather unsuitable for usage within Web Services.4.7. Appendix 4.7.1. XML Schemas This part of the appendix lists XML schemas for data access, including the following: \u2022 The tx Schema \u2022 The jdbc Schema The tx Schema The tx tags deal with configuring all of those beans in Spring\u2019s comprehensive support for transactions. These tags are covered in the chapter entitled Transaction Management.848", "chunk_char_count": 412, "chunk_word_count": 67, "chunk_token_count": 103.0}, {"page_number": 849, "sentence_chunk": "\uf0eb We strongly encourage you to look at the 'spring-tx.xsd' file that ships with the Spring distribution. This file contains the XML Schema for Spring\u2019s transaction configuration and covers all of the various elements in the tx namespace, including attribute defaults and similar information. This file is documented inline, and, thus, the information is not repeated here in the interests of adhering to the DRY (Don\u2019t Repeat Yourself) principle. In the interest of completeness, to use the elements in the tx schema, you need to have the following preamble at the top of your Spring XML configuration file. The text in the following snippet references the correct schema so that the tags in the tx namespace are available to you: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:aop=\"http://www.springframework.org/schema/aop\" \u00a0  xmlns:tx=\"http://www.springframework.org/schema/tx\" \u2460 \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd \u2461 \u00a0    http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"> \u00a0  <!--bean definitions here --> </beans> \u2460 Declare usage of the tx namespace.\u2461 Specify the location (with other schema locations).\uf05a Often, when you use the elements in the tx namespace, you are also using the elements from the aop namespace (since the declarative transaction support in Spring is implemented by using AOP).", "chunk_char_count": 1670, "chunk_word_count": 210, "chunk_token_count": 417.5}, {"page_number": 849, "sentence_chunk": "The preceding XML snippet contains the relevant lines needed to reference the aop schema so that the elements in the aop namespace are available to you. The jdbc Schema The jdbc elements let you quickly configure an embedded database or initialize an existing data source. These elements are documented in Embedded Database Support and Initializing a DataSource, respectively. To use the elements in the jdbc schema, you need to have the following preamble at the top of your Spring XML configuration file. The text in the following snippet references the correct schema so that the elements in the jdbc namespace are available to you: 849", "chunk_char_count": 639, "chunk_word_count": 105, "chunk_token_count": 159.75}, {"page_number": 850, "sentence_chunk": "<?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:jdbc=\"http://www.springframework.org/schema/jdbc\" \u2460 \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/jdbc https://www.springframework.org/schema/jdbc/spring-jdbc.xsd\"> \u2461 \u00a0  <!--bean definitions here --> </beans> \u2460 Declare usage of the jdbc namespace.\u2461 Specify the location (with other schema locations).850", "chunk_char_count": 599, "chunk_word_count": 49, "chunk_token_count": 149.75}, {"page_number": 851, "sentence_chunk": "Chapter 5. Web on Servlet Stack This part of the documentation covers support for Servlet-stack web applications built on the Servlet API and deployed to Servlet containers. Individual chapters include Spring MVC, View Technologies, CORS Support, and WebSocket Support. For reactive-stack web applications, see Web on Reactive Stack.5.1. Spring Web MVC Spring Web MVC is the original web framework built on the Servlet API and has been included in the Spring Framework from the very beginning. The formal name, \u201cSpring Web MVC,\u201d comes from the name of its source module (spring-webmvc), but it is more commonly known as \u201cSpring MVC\u201d. Parallel to Spring Web MVC, Spring Framework 5.0 introduced a reactive-stack web framework whose name, \u201cSpring WebFlux,\u201d is also based on its source module (spring-webflux). This section covers Spring Web MVC. The next section covers Spring WebFlux.", "chunk_char_count": 883, "chunk_word_count": 137, "chunk_token_count": 220.75}, {"page_number": 851, "sentence_chunk": "For baseline information and compatibility with Servlet container and Jakarta EE version ranges, see the Spring Framework Wiki.5.1.1. DispatcherServlet WebFlux Spring MVC, as many other web frameworks, is designed around the front controller pattern where a central Servlet, the DispatcherServlet, provides a shared algorithm for request processing, while actual work is performed by configurable delegate components. This model is flexible and supports diverse workflows. The DispatcherServlet, as any Servlet, needs to be declared and mapped according to the Servlet specification by using Java configuration or in web.xml. In turn, the DispatcherServlet uses Spring configuration to discover the delegate components it needs for request mapping, view resolution, exception handling, and more. The following example of the Java configuration registers and initializes the DispatcherServlet, which is auto-detected by the Servlet container (see Servlet Config): 851", "chunk_char_count": 966, "chunk_word_count": 133, "chunk_token_count": 241.5}, {"page_number": 852, "sentence_chunk": "Java public class MyWebApplicationInitializer implements WebApplicationInitializer { \u00a0  @Override \u00a0  public void onStartup(ServletContext servletContext) { \u00a0    // Load Spring web application configuration \u00a0    AnnotationConfigWebApplicationContext context = new AnnotationConfigWebApplicationContext(); \u00a0    context.register(AppConfig.class); \u00a0    // Create and register the DispatcherServlet \u00a0    DispatcherServlet servlet = new DispatcherServlet(context); \u00a0    ServletRegistration. Dynamic registration = servletContext.addServlet(\"app\", servlet); \u00a0    registration.setLoadOnStartup(1); \u00a0    registration.addMapping(\"/app/*\"); \u00a0  } } Kotlin class MyWebApplicationInitializer : WebApplicationInitializer { \u00a0  override fun onStartup(servletContext: ServletContext) { \u00a0    // Load Spring web application configuration \u00a0    val context = AnnotationConfigWebApplicationContext() \u00a0    context.register(AppConfig::class.java) \u00a0    // Create and register the DispatcherServlet \u00a0    val servlet = DispatcherServlet(context) \u00a0    val registration = servletContext.addServlet(\"app\", servlet) \u00a0    registration.setLoadOnStartup(1) \u00a0    registration.addMapping(\"/app/*\") \u00a0  } } \uf05a In addition to using the ServletContext API directly, you can also extend AbstractAnnotationConfigDispatcherServletInitializer and override specific methods (see the example under Context Hierarchy).\uf05a For programmatic use cases, a GenericWebApplicationContext can be used as an alternative to AnnotationConfigWebApplicationContext. See the GenericWebApplicationContext javadoc for details. The following example of web.xml configuration registers and initializes the DispatcherServlet: 852", "chunk_char_count": 1659, "chunk_word_count": 217, "chunk_token_count": 414.75}, {"page_number": 853, "sentence_chunk": "<web-app> \u00a0  <listener> \u00a0    <listener- class>org.springframework.web.context. ContextLoaderListener</listener-class> \u00a0  </listener> \u00a0  <context-param> \u00a0    <param-name>contextConfigLocation</param-name> \u00a0    <param-value>/WEB-INF/app-context.xml</param-value> \u00a0  </context-param> \u00a0  <servlet> \u00a0    <servlet-name>app</servlet-name> \u00a0    <servlet-class>org.springframework.web.servlet. DispatcherServlet</servlet- class> \u00a0    <init-param> \u00a0      <param-name>contextConfigLocation</param-name> \u00a0      <param-value></param-value> \u00a0    </init-param> \u00a0    <load-on-startup>1</load-on-startup> \u00a0  </servlet> \u00a0  <servlet-mapping> \u00a0    <servlet-name>app</servlet-name> \u00a0    <url-pattern>/app/*</url-pattern> \u00a0  </servlet-mapping> </web-app> \uf05a Spring Boot follows a different initialization sequence. Rather than hooking into the lifecycle of the Servlet container, Spring Boot uses Spring configuration to bootstrap itself and the embedded Servlet container. Filter and Servlet declarations are detected in Spring configuration and registered with the Servlet container. For more details, see the Spring Boot documentation. Context Hierarchy DispatcherServlet expects a WebApplicationContext (an extension of a plain ApplicationContext) for its own configuration. WebApplicationContext has a link to the ServletContext and the Servlet with which it is associated. It is also bound to the ServletContext such that applications can use static methods on RequestContextUtils to look up the WebApplicationContext if they need access to it. For many applications, having a single WebApplicationContext is simple and suffices.", "chunk_char_count": 1612, "chunk_word_count": 217, "chunk_token_count": 403.0}, {"page_number": 853, "sentence_chunk": "It is also possible to have a context hierarchy where one root WebApplicationContext is shared across multiple DispatcherServlet (or other Servlet) instances, each with its own child WebApplicationContext configuration. See Additional Capabilities of the ApplicationContext for more on the context hierarchy feature.853", "chunk_char_count": 319, "chunk_word_count": 42, "chunk_token_count": 79.75}, {"page_number": 854, "sentence_chunk": "The root WebApplicationContext typically contains infrastructure beans, such as data repositories and business services that need to be shared across multiple Servlet instances. Those beans are effectively inherited and can be overridden (that is, re-declared) in the Servlet-specific child WebApplicationContext, which typically contains beans local to the given Servlet. The following image shows this relationship: The following example configures a WebApplicationContext hierarchy: 854", "chunk_char_count": 489, "chunk_word_count": 63, "chunk_token_count": 122.25}, {"page_number": 855, "sentence_chunk": "Java public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer { \u00a0  @Override \u00a0  protected Class<?>[] getRootConfigClasses() { \u00a0    return new Class<?>[] { RootConfig.class }; \u00a0  } \u00a0  @Override \u00a0  protected Class<?>[] getServletConfigClasses() { \u00a0    return new Class<?>[] { App1Config.class }; \u00a0  } \u00a0  @Override \u00a0  protected String[] getServletMappings() { \u00a0    return new String[] { \"/app1/*\" }; \u00a0  } } Kotlin class MyWebAppInitializer : AbstractAnnotationConfigDispatcherServletInitializer() { \u00a0  override fun getRootConfigClasses(): Array<Class<*>> { \u00a0    return arrayOf(RootConfig::class.java) \u00a0  } \u00a0  override fun getServletConfigClasses(): Array<Class<*>> { \u00a0    return arrayOf(App1Config::class.java) \u00a0  } \u00a0  override fun getServletMappings(): Array<String> { \u00a0    return arrayOf(\"/app1/*\") \u00a0  } } \uf0eb If an application context hierarchy is not required, applications can return all configuration through getRootConfigClasses() and null from getServletConfigClasses(). The following example shows the web.xml equivalent: 855", "chunk_char_count": 1066, "chunk_word_count": 157, "chunk_token_count": 266.5}, {"page_number": 856, "sentence_chunk": "<web-app> \u00a0  <listener> \u00a0    <listener- class>org.springframework.web.context. ContextLoaderListener</listener-class> \u00a0  </listener> \u00a0  <context-param> \u00a0    <param-name>contextConfigLocation</param-name> \u00a0    <param-value>/WEB-INF/root-context.xml</param-value> \u00a0  </context-param> \u00a0  <servlet> \u00a0    <servlet-name>app1</servlet-name> \u00a0    <servlet-class>org.springframework.web.servlet. DispatcherServlet</servlet- class> \u00a0    <init-param> \u00a0      <param-name>contextConfigLocation</param-name> \u00a0      <param-value>/WEB-INF/app1-context.xml</param-value> \u00a0    </init-param> \u00a0    <load-on-startup>1</load-on-startup> \u00a0  </servlet> \u00a0  <servlet-mapping> \u00a0    <servlet-name>app1</servlet-name> \u00a0    <url-pattern>/app1/*</url-pattern> \u00a0  </servlet-mapping> </web-app> \uf0eb If an application context hierarchy is not required, applications may configure a \u201croot\u201d context only and leave the contextConfigLocation Servlet parameter empty. Special Bean Types WebFlux The DispatcherServlet delegates to special beans to process requests and render the appropriate responses. By \u201cspecial beans\u201d we mean Spring-managed Object instances that implement framework contracts. Those usually come with built-in contracts, but you can customize their properties and extend or replace them. The following table lists the special beans detected by the DispatcherServlet: 856", "chunk_char_count": 1349, "chunk_word_count": 176, "chunk_token_count": 337.25}, {"page_number": 857, "sentence_chunk": "Bean type Explanation HandlerMapping Map a request to a handler along with a list of interceptors for pre- and post-processing. The mapping is based on some criteria, the details of which vary by HandlerMapping implementation. The two main HandlerMapping implementations are RequestMappingHandlerMapping (which supports @RequestMapping annotated methods) and SimpleUrlHandlerMapping (which maintains explicit registrations of URI path patterns to handlers). HandlerAdapter Help the DispatcherServlet to invoke a handler mapped to a request, regardless of how the handler is actually invoked. For example, invoking an annotated controller requires resolving annotations. The main purpose of a HandlerAdapter is to shield the DispatcherServlet from such details. HandlerExceptionResolver Strategy to resolve exceptions, possibly mapping them to handlers, to HTML error views, or other targets. See Exceptions. ViewResolver Resolve logical String-based view names returned from a handler to an actual View with which to render to the response. See View Resolution and View Technologies.", "chunk_char_count": 1083, "chunk_word_count": 148, "chunk_token_count": 270.75}, {"page_number": 857, "sentence_chunk": "LocaleResolver, LocaleContextResolver Resolve the Locale a client is using and possibly their time zone, in order to be able to offer internationalized views. See Locale. ThemeResolver Resolve themes your web application can use\u2009\u2014\u2009for example, to offer personalized layouts. See Themes. MultipartResolver Abstraction for parsing a multi-part request (for example, browser form file upload) with the help of some multipart parsing library. See Multipart Resolver. FlashMapManager Store and retrieve the \u201cinput\u201d and the \u201coutput\u201d FlashMap that can be used to pass attributes from one request to another, usually across a redirect. See Flash Attributes. Web MVC Config WebFlux Applications can declare the infrastructure beans listed in Special Bean Types that are required to process requests. The DispatcherServlet checks the WebApplicationContext for each special bean.", "chunk_char_count": 868, "chunk_word_count": 123, "chunk_token_count": 217.0}, {"page_number": 857, "sentence_chunk": "If there are no matching bean types, it falls back on the default types listed in DispatcherServlet.properties. In most cases, the MVC Config is the best starting point. It declares the required beans in either Java or XML and provides a higher-level configuration callback API to customize it.\uf05a Spring Boot relies on the MVC Java configuration to configure Spring MVC and provides many extra convenient options.857", "chunk_char_count": 415, "chunk_word_count": 66, "chunk_token_count": 103.75}, {"page_number": 858, "sentence_chunk": "Servlet Config In a Servlet environment, you have the option of configuring the Servlet container programmatically as an alternative or in combination with a web.xml file. The following example registers a DispatcherServlet: Java import org.springframework.web. WebApplicationInitializer; public class MyWebApplicationInitializer implements WebApplicationInitializer { \u00a0  @Override \u00a0  public void onStartup(ServletContext container) { \u00a0    XmlWebApplicationContext appContext = new XmlWebApplicationContext(); \u00a0    appContext.setConfigLocation(\"/WEB-INF/spring/dispatcher-config.xml\"); \u00a0    ServletRegistration. Dynamic registration = container.addServlet(\"dispatcher\", new DispatcherServlet(appContext)); \u00a0    registration.setLoadOnStartup(1); \u00a0    registration.addMapping(\"/\"); \u00a0  } } Kotlin import org.springframework.web. WebApplicationInitializer class MyWebApplicationInitializer : WebApplicationInitializer { \u00a0  override fun onStartup(container: ServletContext) { \u00a0    val appContext = XmlWebApplicationContext() \u00a0    appContext.setConfigLocation(\"/WEB-INF/spring/dispatcher-config.xml\") \u00a0    val registration = container.addServlet(\"dispatcher\", DispatcherServlet(appContext)) \u00a0    registration.setLoadOnStartup(1) \u00a0    registration.addMapping(\"/\") \u00a0  } } WebApplicationInitializer is an interface provided by Spring MVC that ensures your implementation is detected and automatically used to initialize any Servlet 3 container. An abstract base class implementation of WebApplicationInitializer named AbstractDispatcherServletInitializer makes it even easier to register the DispatcherServlet by overriding methods to specify the servlet mapping and the location of the DispatcherServlet configuration. This is recommended for applications that use Java-based Spring configuration, as the following example shows: 858", "chunk_char_count": 1825, "chunk_word_count": 214, "chunk_token_count": 456.25}, {"page_number": 859, "sentence_chunk": "Java public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer { \u00a0  @Override \u00a0  protected Class<?>[] getRootConfigClasses() { \u00a0    return null; \u00a0  } \u00a0  @Override \u00a0  protected Class<?>[] getServletConfigClasses() { \u00a0    return new Class<?>[] { MyWebConfig.class }; \u00a0  } \u00a0  @Override \u00a0  protected String[] getServletMappings() { \u00a0    return new String[] { \"/\" }; \u00a0  } } Kotlin class MyWebAppInitializer : AbstractAnnotationConfigDispatcherServletInitializer() { \u00a0  override fun getRootConfigClasses(): Array<Class<*>>? {\u00a0    return null \u00a0  } \u00a0  override fun getServletConfigClasses(): Array<Class<*>>? {\u00a0    return arrayOf(MyWebConfig::class.java) \u00a0  } \u00a0  override fun getServletMappings(): Array<String> { \u00a0    return arrayOf(\"/\") \u00a0  } } If you use XML-based Spring configuration, you should extend directly from AbstractDispatcherServletInitializer, as the following example shows: 859", "chunk_char_count": 922, "chunk_word_count": 141, "chunk_token_count": 230.5}, {"page_number": 860, "sentence_chunk": "Java public class MyWebAppInitializer extends AbstractDispatcherServletInitializer { \u00a0  @Override \u00a0  protected WebApplicationContext createRootApplicationContext() { \u00a0    return null; \u00a0  } \u00a0  @Override \u00a0  protected WebApplicationContext createServletApplicationContext() { \u00a0    XmlWebApplicationContext cxt = new XmlWebApplicationContext(); \u00a0    cxt.setConfigLocation(\"/WEB-INF/spring/dispatcher-config.xml\"); \u00a0    return cxt; \u00a0  } \u00a0  @Override \u00a0  protected String[] getServletMappings() { \u00a0    return new String[] { \"/\" }; \u00a0  } } Kotlin class MyWebAppInitializer : AbstractDispatcherServletInitializer() { \u00a0  override fun createRootApplicationContext(): WebApplicationContext? {\u00a0    return null \u00a0  } \u00a0  override fun createServletApplicationContext(): WebApplicationContext { \u00a0    return XmlWebApplicationContext().apply { \u00a0      setConfigLocation(\"/WEB-INF/spring/dispatcher-config.xml\") \u00a0    } \u00a0  } \u00a0  override fun getServletMappings(): Array<String> { \u00a0    return arrayOf(\"/\") \u00a0  } } AbstractDispatcherServletInitializer also provides a convenient way to add Filter instances and have them be automatically mapped to the DispatcherServlet, as the following example shows: 860", "chunk_char_count": 1178, "chunk_word_count": 172, "chunk_token_count": 294.5}, {"page_number": 861, "sentence_chunk": "Java public class MyWebAppInitializer extends AbstractDispatcherServletInitializer { \u00a0  // ... \u00a0  @Override \u00a0  protected Filter[] getServletFilters() { \u00a0    return new Filter[] { \u00a0      new HiddenHttpMethodFilter(), new CharacterEncodingFilter() }; \u00a0  } } Kotlin class MyWebAppInitializer : AbstractDispatcherServletInitializer() { \u00a0  // ... \u00a0  override fun getServletFilters(): Array<Filter> { \u00a0    return arrayOf(HiddenHttpMethodFilter(), CharacterEncodingFilter()) \u00a0  } } Each filter is added with a default name based on its concrete type and automatically mapped to the DispatcherServlet. The isAsyncSupported protected method of AbstractDispatcherServletInitializer provides a single place to enable async support on the DispatcherServlet and all filters mapped to it. By default, this flag is set to true. Finally, if you need to further customize the DispatcherServlet itself, you can override the createDispatcherServlet method. Processing WebFlux The DispatcherServlet processes requests as follows: \u2022 The WebApplicationContext is searched for and bound in the request as an attribute that the controller and other elements in the process can use. It is bound by default under the DispatcherServlet. WEB_APPLICATION_CONTEXT_ATTRIBUTE key. \u2022The locale resolver is bound to the request to let elements in the process resolve the locale to use when processing the request (rendering the view, preparing data, and so on). If you do not need locale resolving, you do not need the locale resolver. \u2022The theme resolver is bound to the request to let elements such as views determine which theme to use.", "chunk_char_count": 1605, "chunk_word_count": 244, "chunk_token_count": 401.25}, {"page_number": 862, "sentence_chunk": "\u2022 If you specify a multipart file resolver, the request is inspected for multiparts. If multiparts are found, the request is wrapped in a MultipartHttpServletRequest for further processing by other elements in the process. See Multipart Resolver for further information about multipart handling. \u2022An appropriate handler is searched for. If a handler is found, the execution chain associated with the handler (preprocessors, postprocessors, and controllers) is run to prepare a model for rendering. Alternatively, for annotated controllers, the response can be rendered (within the HandlerAdapter) instead of returning a view. \u2022If a model is returned, the view is rendered. If no model is returned (maybe due to a preprocessor or postprocessor intercepting the request, perhaps for security reasons), no view is rendered, because the request could already have been fulfilled. The HandlerExceptionResolver beans declared in the WebApplicationContext are used to resolve exceptions thrown during request processing. Those exception resolvers allow customizing the logic to address exceptions.", "chunk_char_count": 1090, "chunk_word_count": 156, "chunk_token_count": 272.5}, {"page_number": 862, "sentence_chunk": "See Exceptions for more details. For HTTP caching support, handlers can use the checkNotModified methods of WebRequest, along with further options for annotated controllers as described in HTTP Caching for Controllers. You can customize individual DispatcherServlet instances by adding Servlet initialization parameters (init-param elements) to the Servlet declaration in the web.xml file. The following table lists the supported parameters: Table 21. DispatcherServlet initialization parameters Parameter Explanation contextClass Class that implements ConfigurableWebApplicationContext, to be instantiated and locally configured by this Servlet. By default, XmlWebApplicationContext is used.contextConfigLocation String that is passed to the context instance (specified by contextClass) to indicate where contexts can be found. The string consists potentially of multiple strings (using a comma as a delimiter) to support multiple contexts. In the case of multiple context locations with beans that are defined twice, the latest location takes precedence.namespace Namespace of the WebApplicationContext.", "chunk_char_count": 1105, "chunk_word_count": 142, "chunk_token_count": 276.25}, {"page_number": 863, "sentence_chunk": "Parameter Explanation throwExceptionIfNoHandlerFound Whether to throw a NoHandlerFoundException when no handler was found for a request. The exception can then be caught with a HandlerExceptionResolver (for example, by using an @ExceptionHandler controller method) and handled as any others. By default, this is set to false, in which case the DispatcherServlet sets the response status to 404 (NOT_FOUND) without raising an exception. Note that, if default servlet handling is also configured, unresolved requests are always forwarded to the default servlet and a 404 is never raised. Path Matching The Servlet API exposes the full request path as requestURI and further sub-divides it into contextPath, servletPath, and pathInfo whose values vary depending on how a Servlet is mapped. From these inputs, Spring MVC needs to determine the lookup path to use for mapping handlers, which should exclude the contextPath and any servletMapping prefix, if applicable. The servletPath and pathInfo are decoded and that makes them impossible to compare directly to the full requestURI in order to derive the lookupPath and that makes it necessary to decode the requestURI. However this introduces its own issues because the path may contain encoded reserved characters such as \"/\" or \";\" that can in turn alter the structure of the path after they are decoded which can also lead to security issues. In addition, Servlet containers may normalize the servletPath to varying degrees which makes it further impossible to perform startsWith comparisons against the requestURI. This is why it is best to avoid reliance on the servletPath which comes with the prefix-based servletPath mapping type.", "chunk_char_count": 1686, "chunk_word_count": 259, "chunk_token_count": 421.5}, {"page_number": 863, "sentence_chunk": "If the DispatcherServlet is mapped as the default Servlet with \"/\" or otherwise without a prefix with \"/*\" and the Servlet container is 4.0+ then Spring MVC is able to detect the Servlet mapping type and avoid use of the servletPath and pathInfo altogether. On a 3.1 Servlet container, assuming the same Servlet mapping types, the equivalent can be achieved by providing a UrlPathHelper with alwaysUseFullPath=true via Path Matching in the MVC config. Fortunately the default Servlet mapping \"/\" is a good choice. However, there is still an issue in that the requestURI needs to be decoded to make it possible to compare to controller mappings. This is again undesirable because of the potential to decode reserved characters that alter the path structure. If such characters are not expected, then you can reject them (like the Spring Security HTTP firewall), or you can configure UrlPathHelper with urlDecode=false but controller mappings will need to match to the encoded path which may not always work well. Furthermore, sometimes the DispatcherServlet needs to share the URL space with another Servlet and may need to be mapped by prefix.863", "chunk_char_count": 1146, "chunk_word_count": 185, "chunk_token_count": 286.5}, {"page_number": 864, "sentence_chunk": "The above issues are addressed when using PathPatternParser and parsed patterns, as an alternative to String path matching with AntPathMatcher. The PathPatternParser has been available for use in Spring MVC from version 5.3, and is enabled by default from version 6.0. Unlike AntPathMatcher which needs either the lookup path decoded or the controller mapping encoded, a parsed PathPattern matches to a parsed representation of the path called RequestPath, one path segment at a time. This allows decoding and sanitizing path segment values individually without the risk of altering the structure of the path. Parsed PathPattern also supports the use of servletPath prefix mapping as long as a Servlet path mapping is used and the prefix is kept simple, i.e. it has no encoded characters. For pattern syntax details and comparison, see Pattern Comparison. Interception All HandlerMapping implementations support handler interceptors that are useful when you want to apply specific functionality to certain requests\u2009\u2014\u2009for example, checking for a principal. Interceptors must implement HandlerInterceptor from the org.springframework.web.servlet package with three methods that should provide enough flexibility to do all kinds of pre-processing and post- processing: \u2022 preHandle(..): Before the actual handler is run \u2022 postHandle(..): After the handler is run \u2022 afterCompletion(..): After the complete request has finished The preHandle(..) method returns a boolean value. You can use this method to break or continue the processing of the execution chain. When this method returns true, the handler execution chain continues.", "chunk_char_count": 1625, "chunk_word_count": 238, "chunk_token_count": 406.25}, {"page_number": 864, "sentence_chunk": "When it returns false, the DispatcherServlet assumes the interceptor itself has taken care of requests (and, for example, rendered an appropriate view) and does not continue executing the other interceptors and the actual handler in the execution chain. See Interceptors in the section on MVC configuration for examples of how to configure interceptors. You can also register them directly by using setters on individual HandlerMapping implementations.postHandle method is less useful with @ResponseBody and ResponseEntity methods for which the response is written and committed within the HandlerAdapter and before postHandle. That means it is too late to make any changes to the response, such as adding an extra header. For such scenarios, you can implement ResponseBodyAdvice and either declare it as an Controller Advice bean or configure it directly on RequestMappingHandlerAdapter. Exceptions WebFlux If an exception occurs during request mapping or is thrown from a request handler (such as a @Controller), the DispatcherServlet delegates to a chain of HandlerExceptionResolver beans to resolve the exception and provide alternative handling, which is typically an error response. The following table lists the available HandlerExceptionResolver implementations: Table 22. HandlerExceptionResolver implementations 864", "chunk_char_count": 1325, "chunk_word_count": 186, "chunk_token_count": 331.25}, {"page_number": 865, "sentence_chunk": "HandlerExceptionResolver Description SimpleMappingExceptionResolver A mapping between exception class names and error view names. Useful for rendering error pages in a browser application. DefaultHandlerExceptionResolve r Resolves exceptions raised by Spring MVC and maps them to HTTP status codes. See also alternative ResponseEntityExceptionHandler and Error Responses. ResponseStatusExceptionResolve r Resolves exceptions with the @ResponseStatus annotation and maps them to HTTP status codes based on the value in the annotation. ExceptionHandlerExceptionResol ver Resolves exceptions by invoking an @ExceptionHandler method in a @Controller or a @ControllerAdvice class. See @ExceptionHandler methods. Chain of Resolvers You can form an exception resolver chain by declaring multiple HandlerExceptionResolver beans in your Spring configuration and setting their order properties as needed. The higher the order property, the later the exception resolver is positioned. The contract of HandlerExceptionResolver specifies that it can return: \u2022 a ModelAndView that points to an error view. \u2022", "chunk_char_count": 1093, "chunk_word_count": 142, "chunk_token_count": 273.25}, {"page_number": 865, "sentence_chunk": "An empty ModelAndView if the exception was handled within the resolver. \u2022null if the exception remains unresolved, for subsequent resolvers to try, and, if the exception remains at the end, it is allowed to bubble up to the Servlet container. The MVC Config automatically declares built-in resolvers for default Spring MVC exceptions, for @ResponseStatus annotated exceptions, and for support of @ExceptionHandler methods. You can customize that list or replace it. Container Error Page If an exception remains unresolved by any HandlerExceptionResolver and is, therefore, left to propagate or if the response status is set to an error status (that is, 4xx, 5xx), Servlet containers can render a default error page in HTML. To customize the default error page of the container, you can declare an error page mapping in web.xml. The following example shows how to do so: <error-page> \u00a0  <location>/error</location> </error-page> Given the preceding example, when an exception bubbles up or the response has an error status, the Servlet container makes an ERROR dispatch within the container to the configured URL (for example, /error). This is then processed by the DispatcherServlet, possibly mapping it to a @Controller, which could be implemented to return an error view name with a model or to render a 865", "chunk_char_count": 1309, "chunk_word_count": 207, "chunk_token_count": 327.25}, {"page_number": 866, "sentence_chunk": "JSON response, as the following example shows: Java @RestController public class ErrorController { \u00a0  @RequestMapping(path = \"/error\") \u00a0  public Map<String, Object> handle(HttpServletRequest request) { \u00a0    Map<String, Object> map = new HashMap<String, Object>(); \u00a0    map.put(\"status\", request.getAttribute(\"jakarta.servlet.error.status_code\")); \u00a0    map.put(\"reason\", request.getAttribute(\"jakarta.servlet.error.message\")); \u00a0    return map; \u00a0  } } Kotlin @RestController class ErrorController { \u00a0  @RequestMapping(path = [\"/error\"]) \u00a0  fun handle(request: HttpServletRequest): Map<String, Any> { \u00a0    val map = HashMap<String, Any>() \u00a0    map[\"status\"] = request.getAttribute(\"jakarta.servlet.error.status_code\") \u00a0    map[\"reason\"] = request.getAttribute(\"jakarta.servlet.error.message\") \u00a0    return map \u00a0  } } \uf0eb The Servlet API does not provide a way to create error page mappings in Java. You can, however, use both a WebApplicationInitializer and a minimal web.xml. View Resolution WebFlux Spring MVC defines the ViewResolver and View interfaces that let you render models in a browser without tying you to a specific view technology. ViewResolver provides a mapping between view names and actual views. View addresses the preparation of data before handing over to a specific view technology. The following table provides more details on the ViewResolver hierarchy: Table 23. ViewResolver implementations 866", "chunk_char_count": 1414, "chunk_word_count": 203, "chunk_token_count": 353.5}, {"page_number": 867, "sentence_chunk": "ViewResolver Description AbstractCachingViewResolver Subclasses of AbstractCachingViewResolver cache view instances that they resolve. Caching improves performance of certain view technologies. You can turn off the cache by setting the cache property to false. Furthermore, if you must refresh a certain view at runtime (for example, when a FreeMarker template is modified), you can use the removeFromCache(String viewName, Locale loc) method. UrlBasedViewResolver Simple implementation of the ViewResolver interface that effects the direct resolution of logical view names to URLs without an explicit mapping definition. This is appropriate if your logical names match the names of your view resources in a straightforward manner, without the need for arbitrary mappings. InternalResourceViewResolver Convenient subclass of UrlBasedViewResolver that supports InternalResourceView (in effect, Servlets and JSPs) and subclasses such as JstlView and TilesView. You can specify the view class for all views generated by this resolver by using setViewClass(..). See the UrlBasedViewResolver javadoc for details. FreeMarkerViewResolver Convenient subclass of UrlBasedViewResolver that supports FreeMarkerView and custom subclasses of them.", "chunk_char_count": 1234, "chunk_word_count": 161, "chunk_token_count": 308.5}, {"page_number": 867, "sentence_chunk": "ContentNegotiatingViewResolver Implementation of the ViewResolver interface that resolves a view based on the request file name or Accept header. See Content Negotiation. BeanNameViewResolver Implementation of the ViewResolver interface that interprets a view name as a bean name in the current application context. This is a very flexible variant which allows for mixing and matching different view types based on distinct view names. Each such View can be defined as a bean e.g. in XML or in configuration classes. Handling WebFlux You can chain view resolvers by declaring more than one resolver bean and, if necessary, by setting the order property to specify ordering. Remember, the higher the order property, the later the view resolver is positioned in the chain.867", "chunk_char_count": 773, "chunk_word_count": 119, "chunk_token_count": 193.25}, {"page_number": 868, "sentence_chunk": "The contract of a ViewResolver specifies that it can return null to indicate that the view could not be found. However, in the case of JSPs and InternalResourceViewResolver, the only way to figure out if a JSP exists is to perform a dispatch through RequestDispatcher. Therefore, you must always configure an InternalResourceViewResolver to be last in the overall order of view resolvers. Configuring view resolution is as simple as adding ViewResolver beans to your Spring configuration. The MVC Config provides a dedicated configuration API for View Resolvers and for adding logic-less View Controllers which are useful for HTML template rendering without controller logic. Redirecting WebFlux The special redirect: prefix in a view name lets you perform a redirect. The UrlBasedViewResolver (and its subclasses) recognize this as an instruction that a redirect is needed. The rest of the view name is the redirect URL. The net effect is the same as if the controller had returned a RedirectView, but now the controller itself can operate in terms of logical view names. A logical view name (such as redirect:/myapp/some/resource) redirects relative to the current Servlet context, while a name such as redirect:https://myhost.com/some/arbitrary/path redirects to an absolute URL.", "chunk_char_count": 1282, "chunk_word_count": 195, "chunk_token_count": 320.5}, {"page_number": 868, "sentence_chunk": "Note that, if a controller method is annotated with the @ResponseStatus, the annotation value takes precedence over the response status set by RedirectView. Forwarding You can also use a special forward: prefix for view names that are ultimately resolved by UrlBasedViewResolver and subclasses. This creates an InternalResourceView, which does a RequestDispatcher.forward(). Therefore, this prefix is not useful with InternalResourceViewResolver and InternalResourceView (for JSPs), but it can be helpful if you use another view technology but still want to force a forward of a resource to be handled by the Servlet/JSP engine. Note that you may also chain multiple view resolvers, instead. Content Negotiation WebFlux ContentNegotiatingViewResolver does not resolve views itself but rather delegates to other view resolvers and selects the view that resembles the representation requested by the client. The representation can be determined from the Accept header or from a query parameter (for example, \"/path?format=pdf\"). The ContentNegotiatingViewResolver selects an appropriate View to handle the request by comparing the request media types with the media type (also known as Content-Type) supported by the View associated with each of its ViewResolvers. The first View in the list that has a compatible Content-Type returns the representation to the client. If a compatible view cannot be supplied by the ViewResolver chain, the list of views specified through the DefaultViews property is consulted.", "chunk_char_count": 1509, "chunk_word_count": 219, "chunk_token_count": 377.25}, {"page_number": 868, "sentence_chunk": "This latter option is appropriate for singleton Views that can render an appropriate representation of the current resource regardless of the logical view name. The Accept header can include wildcards (for example text/*), in which case a View whose Content-Type is text/xml is a compatible match.868", "chunk_char_count": 300, "chunk_word_count": 46, "chunk_token_count": 75.0}, {"page_number": 869, "sentence_chunk": "See View Resolvers under MVC Config for configuration details. Locale Most parts of Spring\u2019s architecture support internationalization, as the Spring web MVC framework does. DispatcherServlet lets you automatically resolve messages by using the client\u2019s locale. This is done with LocaleResolver objects. When a request comes in, the DispatcherServlet looks for a locale resolver and, if it finds one, it tries to use it to set the locale. By using the RequestContext.getLocale() method, you can always retrieve the locale that was resolved by the locale resolver. In addition to automatic locale resolution, you can also attach an interceptor to the handler mapping (see Interception for more information on handler mapping interceptors) to change the locale under specific circumstances (for example, based on a parameter in the request). Locale resolvers and interceptors are defined in the org.springframework.web.servlet.i18n package and are configured in your application context in the normal way. The following selection of locale resolvers is included in Spring. \u2022Time Zone \u2022 Header Resolver \u2022 Cookie Resolver \u2022 Session Resolver \u2022 Locale Interceptor Time Zone In addition to obtaining the client\u2019s locale, it is often useful to know its time zone.", "chunk_char_count": 1255, "chunk_word_count": 189, "chunk_token_count": 313.75}, {"page_number": 869, "sentence_chunk": "The LocaleContextResolver interface offers an extension to LocaleResolver that lets resolvers provide a richer LocaleContext, which may include time zone information. When available, the user\u2019s TimeZone can be obtained by using the RequestContext.getTimeZone() method. Time zone information is automatically used by any Date/Time Converter and Formatter objects that are registered with Spring\u2019s ConversionService. Header Resolver This locale resolver inspects the accept-language header in the request that was sent by the client (for example, a web browser). Usually, this header field contains the locale of the client\u2019s operating system. Note that this resolver does not support time zone information. Cookie Resolver This locale resolver inspects a Cookie that might exist on the client to see if a Locale or TimeZone is specified. If so, it uses the specified details. By using the properties of this locale resolver, you can specify the name of the cookie as well as the maximum age. The following example defines a CookieLocaleResolver: 869", "chunk_char_count": 1048, "chunk_word_count": 157, "chunk_token_count": 262.0}, {"page_number": 870, "sentence_chunk": "<bean id=\"localeResolver\" class=\"org.springframework.web.servlet.i18n. CookieLocaleResolver\"> \u00a0  <property name=\"cookieName\" value=\"clientlanguage\"/> \u00a0  <!--in seconds. If set to -1, the cookie is not persisted (deleted when browser shuts down) --> \u00a0  <property name=\"cookieMaxAge\" value=\"100000\"/> </bean> The following table describes the properties CookieLocaleResolver: Table 24. CookieLocaleResolver properties Property Default Description cookieName classname + LOCALE The name of the cookie cookieMaxAge Servlet container default The maximum time a cookie persists on the client. If -1 is specified, the cookie will not be persisted. It is available only until the client shuts down the browser.cookiePath / Limits the visibility of the cookie to a certain part of your site. When cookiePath is specified, the cookie is visible only to that path and the paths below it. Session Resolver The SessionLocaleResolver lets you retrieve Locale and TimeZone from the session that might be associated with the user\u2019s request.", "chunk_char_count": 1024, "chunk_word_count": 143, "chunk_token_count": 256.0}, {"page_number": 870, "sentence_chunk": "In contrast to CookieLocaleResolver, this strategy stores locally chosen locale settings in the Servlet container\u2019s HttpSession. As a consequence, those settings are temporary for each session and are, therefore, lost when each session ends. Note that there is no direct relationship with external session management mechanisms, such as the Spring Session project. This SessionLocaleResolver evaluates and modifies the corresponding HttpSession attributes against the current HttpServletRequest. Locale Interceptor You can enable changing of locales by adding the LocaleChangeInterceptor to one of the HandlerMapping definitions. It detects a parameter in the request and changes the locale accordingly, calling the setLocale method on the LocaleResolver in the dispatcher\u2019s application context. The next example shows that calls to all *.view resources that contain a parameter named siteLanguage now changes the locale. So, for example, a request for the URL, https://www.sf.net/home.view?siteLanguage=nl, changes the site language to Dutch. The following example shows how to intercept the locale: 870", "chunk_char_count": 1104, "chunk_word_count": 152, "chunk_token_count": 276.0}, {"page_number": 871, "sentence_chunk": "<bean id=\"localeChangeInterceptor\" \u00a0    class=\"org.springframework.web.servlet.i18n. LocaleChangeInterceptor\"> \u00a0  <property name=\"paramName\" value=\"siteLanguage\"/> </bean> <bean id=\"localeResolver\" \u00a0    class=\"org.springframework.web.servlet.i18n. CookieLocaleResolver\"/> <bean id=\"urlMapping\" \u00a0    class=\"org.springframework.web.servlet.handler. SimpleUrlHandlerMapping\"> \u00a0  <property name=\"interceptors\"> \u00a0    <list> \u00a0      <ref bean=\"localeChangeInterceptor\"/> \u00a0    </list> \u00a0  </property> \u00a0  <property name=\"mappings\"> \u00a0    <value>/**/*.view=someController</value> \u00a0  </property> </bean> Themes You can apply Spring Web MVC framework themes to set the overall look-and-feel of your application, thereby enhancing user experience. A theme is a collection of static resources, typically style sheets and images, that affect the visual style of the application.\uf071 as of 6.0 support for themes has been deprecated theme in favor of using CSS, and without any special support on the server side. Defining a theme To use themes in your web application, you must set up an implementation of the org.springframework.ui.context. ThemeSource interface. The WebApplicationContext interface extends ThemeSource but delegates its responsibilities to a dedicated implementation. By default, the delegate is an org.springframework.ui.context.support.", "chunk_char_count": 1337, "chunk_word_count": 175, "chunk_token_count": 334.25}, {"page_number": 871, "sentence_chunk": "ResourceBundleThemeSource implementation that loads properties files from the root of the classpath. To use a custom ThemeSource implementation or to configure the base name prefix of the ResourceBundleThemeSource, you can register a bean in the application context with the reserved name, themeSource. The web application context automatically detects a bean with that name and uses it. When you use the ResourceBundleThemeSource, a theme is defined in a simple properties file. The properties file lists the resources that make up the theme, as the following example shows: styleSheet=/themes/cool/style.css background=/themes/cool/img/coolBg.jpg The keys of the properties are the names that refer to the themed elements from view code. For a 871", "chunk_char_count": 749, "chunk_word_count": 108, "chunk_token_count": 187.25}, {"page_number": 872, "sentence_chunk": "JSP, you typically do this using the spring:theme custom tag, which is very similar to the spring:message tag. The following JSP fragment uses the theme defined in the previous example to customize the look and feel: <%@ taglib prefix=\"spring\" uri=\"http://www.springframework.org/tags\"%> <html> \u00a0  <head> \u00a0    <link rel=\"stylesheet\" href=\"<spring:theme code='styleSheet'/>\" type=\"text/css\"/> \u00a0  </head> \u00a0  <body style=\"background=<spring:theme code='background'/>\"> \u00a0    ... \u00a0  </body> </html> By default, the ResourceBundleThemeSource uses an empty base name prefix. As a result, the properties files are loaded from the root of the classpath. Thus, you would put the cool.properties theme definition in a directory at the root of the classpath (for example, in /WEB-INF/classes). The ResourceBundleThemeSource uses the standard Java resource bundle loading mechanism, allowing for full internationalization of themes. For example, we could have a /WEB- INF/classes/cool_nl.properties that references a special background image with Dutch text on it. Resolving Themes After you define themes, as described in the preceding section, you decide which theme to use. The DispatcherServlet looks for a bean named themeResolver to find out which ThemeResolver implementation to use. A theme resolver works in much the same way as a LocaleResolver. It detects the theme to use for a particular request and can also alter the request\u2019s theme.", "chunk_char_count": 1435, "chunk_word_count": 213, "chunk_token_count": 358.75}, {"page_number": 872, "sentence_chunk": "The following table describes the theme resolvers provided by Spring: Table 25. ThemeResolver implementations Class Description FixedThemeResolver Selects a fixed theme, set by using the defaultThemeName property. SessionThemeResolv er The theme is maintained in the user\u2019s HTTP session. It needs to be set only once for each session but is not persisted between sessions. CookieThemeResolve r The selected theme is stored in a cookie on the client. Spring also provides a ThemeChangeInterceptor that lets theme changes on every request with a simple request parameter. Multipart Resolver WebFlux MultipartResolver from the org.springframework.web.multipart package is a strategy for parsing multipart requests including file uploads. There is one implementation based on Commons FileUpload and another based on Servlet multipart request parsing.872", "chunk_char_count": 849, "chunk_word_count": 118, "chunk_token_count": 212.25}, {"page_number": 873, "sentence_chunk": "To enable multipart handling, you need to declare a MultipartResolver bean in your DispatcherServlet Spring configuration with a name of multipartResolver. The DispatcherServlet detects it and applies it to the incoming request. When a POST with a content type of multipart/form-data is received, the resolver parses the content wraps the current HttpServletRequest as a MultipartHttpServletRequest to provide access to resolved files in addition to exposing parts as request parameters. Apache Commons FileUpload To use Apache Commons FileUpload, you can configure a bean of type CommonsMultipartResolver with a name of multipartResolver. You also need to have the commons-fileupload jar as a dependency on your classpath. This resolver variant delegates to a local library within the application, providing maximum portability across Servlet containers. As an alternative, consider standard Servlet multipart resolution through the container\u2019s own parser as discussed below.\uf05a Commons FileUpload traditionally applies to POST requests only but accepts any multipart/ content type. See the CommonsMultipartResolver javadoc for details and configuration options. Servlet Multipart Parsing Servlet multipart parsing needs to be enabled through Servlet container configuration.", "chunk_char_count": 1274, "chunk_word_count": 174, "chunk_token_count": 318.5}, {"page_number": 873, "sentence_chunk": "To do so: \u2022 In Java, set a MultipartConfigElement on the Servlet registration. \u2022In web.xml, add a \"<multipart-config>\" section to the servlet declaration. The following example shows how to set a MultipartConfigElement on the Servlet registration: Java public class AppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer { \u00a0  // ... \u00a0  @Override \u00a0  protected void customizeRegistration(ServletRegistration. Dynamic registration) { \u00a0    // Optionally also set maxFileSize, maxRequestSize, fileSizeThreshold \u00a0    registration.setMultipartConfig(new MultipartConfigElement(\"/tmp\")); \u00a0  } } 873", "chunk_char_count": 611, "chunk_word_count": 80, "chunk_token_count": 152.75}, {"page_number": 874, "sentence_chunk": "Kotlin class AppInitializer : AbstractAnnotationConfigDispatcherServletInitializer() { \u00a0  // ... \u00a0  override fun customizeRegistration(registration: ServletRegistration. Dynamic) { \u00a0    // Optionally also set maxFileSize, maxRequestSize, fileSizeThreshold \u00a0    registration.setMultipartConfig(MultipartConfigElement(\"/tmp\")) \u00a0  } } Once the Servlet multipart configuration is in place, you can add a bean of type StandardServletMultipartResolver with a name of multipartResolver.\uf05a This resolver variant uses your Servlet container\u2019s multipart parser as-is, potentially exposing the application to container implementation differences. By default, it will try to parse any multipart/ content type with any HTTP method but this may not be supported across all Servlet containers. See the StandardServletMultipartResolver javadoc for details and configuration options. Logging WebFlux DEBUG-level logging in Spring MVC is designed to be compact, minimal, and human-friendly. It focuses on high-value bits of information that are useful over and over again versus others that are useful only when debugging a specific issue. TRACE-level logging generally follows the same principles as DEBUG (and, for example, also should not be a fire hose) but can be used for debugging any issue. In addition, some log messages may show a different level of detail at TRACE versus DEBUG. Good logging comes from the experience of using the logs.", "chunk_char_count": 1428, "chunk_word_count": 204, "chunk_token_count": 357.0}, {"page_number": 874, "sentence_chunk": "If you spot anything that does not meet the stated goals, please let us know. Sensitive Data WebFlux DEBUG and TRACE logging may log sensitive information. This is why request parameters and headers are masked by default and their logging in full must be enabled explicitly through the enableLoggingRequestDetails property on DispatcherServlet. The following example shows how to do so by using Java configuration: 874", "chunk_char_count": 418, "chunk_word_count": 65, "chunk_token_count": 104.5}, {"page_number": 875, "sentence_chunk": "Java public class MyInitializer \u00a0    extends AbstractAnnotationConfigDispatcherServletInitializer { \u00a0  @Override \u00a0  protected Class<?>[] getRootConfigClasses() { \u00a0    return ... ; \u00a0  } \u00a0  @Override \u00a0  protected Class<?>[] getServletConfigClasses() { \u00a0    return ... ; \u00a0  } \u00a0  @Override \u00a0  protected String[] getServletMappings() { \u00a0    return ... ; \u00a0  } \u00a0  @Override \u00a0  protected void customizeRegistration(ServletRegistration. Dynamic registration) { \u00a0    registration.setInitParameter(\"enableLoggingRequestDetails\", \"true\"); \u00a0  } } Kotlin class MyInitializer : AbstractAnnotationConfigDispatcherServletInitializer() { \u00a0  override fun getRootConfigClasses(): Array<Class<*>>? {\u00a0    return ... \u00a0  } \u00a0  override fun getServletConfigClasses(): Array<Class<*>>? {\u00a0    return ... \u00a0  } \u00a0  override fun getServletMappings(): Array<String> { \u00a0    return ... \u00a0  } \u00a0  override fun customizeRegistration(registration: ServletRegistration. Dynamic) { \u00a0    registration.setInitParameter(\"enableLoggingRequestDetails\", \"true\") \u00a0  } } 875", "chunk_char_count": 1024, "chunk_word_count": 160, "chunk_token_count": 256.0}, {"page_number": 876, "sentence_chunk": "5.1.2. Filters WebFlux The spring-web module provides some useful filters: \u2022 Form Data \u2022 Forwarded Headers \u2022 Shallow ETag \u2022 CORS Form Data Browsers can submit form data only through HTTP GET or HTTP POST but non-browser clients can also use HTTP PUT, PATCH, and DELETE. The Servlet API requires ServletRequest.getParameter*() methods to support form field access only for HTTP POST. The spring-web module provides FormContentFilter to intercept HTTP PUT, PATCH, and DELETE requests with a content type of application/x-www-form-urlencoded, read the form data from the body of the request, and wrap the ServletRequest to make the form data available through the ServletRequest.getParameter*() family of methods. Forwarded Headers WebFlux As a request goes through proxies (such as load balancers) the host, port, and scheme may change, and that makes it a challenge to create links that point to the correct host, port, and scheme from a client perspective. RFC 7239 defines the Forwarded HTTP header that proxies can use to provide information about the original request. There are other non-standard headers, too, including X-Forwarded-Host, X- Forwarded-Port, X-Forwarded-Proto, X-Forwarded-Ssl, and X-Forwarded-Prefix. ForwardedHeaderFilter is a Servlet filter that modifies the request in order to a) change the host, port, and scheme based on Forwarded headers, and b) to remove those headers to eliminate further impact. The filter relies on wrapping the request, and therefore it must be ordered ahead of other filters, such as RequestContextFilter, that should work with the modified and not the original request. There are security considerations for forwarded headers since an application cannot know if the headers were added by a proxy, as intended, or by a malicious client.", "chunk_char_count": 1787, "chunk_word_count": 271, "chunk_token_count": 446.75}, {"page_number": 876, "sentence_chunk": "This is why a proxy at the boundary of trust should be configured to remove untrusted Forwarded headers that come from the outside. You can also configure the ForwardedHeaderFilter with removeOnly=true, in which case it removes but does not use the headers. In order to support asynchronous requests and error dispatches this filter should be mapped with DispatcherType. ASYNC and also DispatcherType. ERROR. If using Spring Framework\u2019s AbstractAnnotationConfigDispatcherServletInitializer (see Servlet Config) all filters are 876", "chunk_char_count": 530, "chunk_word_count": 75, "chunk_token_count": 132.5}, {"page_number": 877, "sentence_chunk": "automatically registered for all dispatch types. However if registering the filter via web.xml or in Spring Boot via a FilterRegistrationBean be sure to include DispatcherType. ASYNC and DispatcherType. ERROR in addition to DispatcherType. REQUEST. Shallow ETag The ShallowEtagHeaderFilter filter creates a \u201cshallow\u201d ETag by caching the content written to the response and computing an MD5 hash from it. The next time a client sends, it does the same, but it also compares the computed value against the If-None-Match request header and, if the two are equal, returns a 304 (NOT_MODIFIED). This strategy saves network bandwidth but not CPU, as the full response must be computed for each request. Other strategies at the controller level, described earlier, can avoid the computation. See HTTP Caching.", "chunk_char_count": 802, "chunk_word_count": 123, "chunk_token_count": 200.5}, {"page_number": 877, "sentence_chunk": "This filter has a writeWeakETag parameter that configures the filter to write weak ETags similar to the following: W/\"02a2d595e6ed9a0b24f027f2b63b134d6\" (as defined in RFC 7232 Section 2.3). In order to support asynchronous requests this filter must be mapped with DispatcherType. ASYNC so that the filter can delay and successfully generate an ETag to the end of the last async dispatch. If using Spring Framework\u2019s AbstractAnnotationConfigDispatcherServletInitializer (see Servlet Config) all filters are automatically registered for all dispatch types. However if registering the filter via web.xml or in Spring Boot via a FilterRegistrationBean be sure to include DispatcherType. ASYNC. CORS WebFlux Spring MVC provides fine-grained support for CORS configuration through annotations on controllers. However, when used with Spring Security, we advise relying on the built-in CorsFilter that must be ordered ahead of Spring Security\u2019s chain of filters. See the sections on CORS and the CORS Filter for more details.5.1.3.", "chunk_char_count": 1024, "chunk_word_count": 146, "chunk_token_count": 256.0}, {"page_number": 877, "sentence_chunk": "Annotated Controllers WebFlux Spring MVC provides an annotation-based programming model where @Controller and @RestController components use annotations to express request mappings, request input, exception handling, and more. Annotated controllers have flexible method signatures and do not have to extend base classes nor implement specific interfaces. The following example shows a controller defined by annotations: 877", "chunk_char_count": 423, "chunk_word_count": 55, "chunk_token_count": 105.75}, {"page_number": 878, "sentence_chunk": "Java @Controller public class HelloController { \u00a0  @GetMapping(\"/hello\") \u00a0  public String handle(Model model) { \u00a0    model.addAttribute(\"message\", \"Hello World!\");\u00a0    return \"index\"; \u00a0  } } Kotlin import org.springframework.ui.set @Controller class HelloController { \u00a0  @GetMapping(\"/hello\") \u00a0  fun handle(model: Model): String { \u00a0    model[\"message\"] = \"Hello World!\"\u00a0    return \"index\" \u00a0  } } In the preceding example, the method accepts a Model and returns a view name as a String, but many other options exist and are explained later in this chapter.\uf0eb Guides and tutorials on spring.io use the annotation-based programming model described in this section. Declaration WebFlux You can define controller beans by using a standard Spring bean definition in the Servlet\u2019s WebApplicationContext. The @Controller stereotype allows for auto-detection, aligned with Spring general support for detecting @Component classes in the classpath and auto-registering bean definitions for them. It also acts as a stereotype for the annotated class, indicating its role as a web component. To enable auto-detection of such @Controller beans, you can add component scanning to your Java configuration, as the following example shows: 878", "chunk_char_count": 1224, "chunk_word_count": 190, "chunk_token_count": 306.0}, {"page_number": 879, "sentence_chunk": "Java @Configuration @ComponentScan(\"org.example.web\") public class WebConfig { \u00a0  // ... } Kotlin @Configuration @ComponentScan(\"org.example.web\") class WebConfig { \u00a0  // ... } The following example shows the XML configuration equivalent of the preceding example: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:p=\"http://www.springframework.org/schema/p\" \u00a0  xmlns:context=\"http://www.springframework.org/schema/context\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/context \u00a0    https://www.springframework.org/schema/context/spring-context.xsd\"> \u00a0  <context:component-scan base-package=\"org.example.web\"/> \u00a0  <!-- ... --> </beans> @RestController is a composed annotation that is itself meta-annotated with @Controller and @ResponseBody to indicate a controller whose every method inherits the type-level @ResponseBody annotation and, therefore, writes directly to the response body versus view resolution and rendering with an HTML template. AOP Proxies WebFlux In some cases, you may need to decorate a controller with an AOP proxy at runtime. One example is if you choose to have @Transactional annotations directly on the controller. When this is the case, for controllers specifically, we recommend using class-based proxying. This is automatically the 879", "chunk_char_count": 1516, "chunk_word_count": 175, "chunk_token_count": 379.0}, {"page_number": 880, "sentence_chunk": "case with such annotations directly on the controller. If the controller implements an interface, and needs AOP proxying, you may need to explicitly configure class-based proxying. For example, with @EnableTransactionManagement you can change to @EnableTransactionManagement(proxyTargetClass = true), and with <tx:annotation-driven/> you can change to <tx:annotation-driven proxy-target-class=\"true\"/>.\uf05a Keep in mind that as of 6.0, with interface proxying, Spring MVC no longer detects controllers based solely on a type-level @RequestMapping annotation on the interface. Please, enable class based proxying, or otherwise the interface must also have an @Controller annotation. Request Mapping WebFlux You can use the @RequestMapping annotation to map requests to controllers methods. It has various attributes to match by URL, HTTP method, request parameters, headers, and media types. You can use it at the class level to express shared mappings or at the method level to narrow down to a specific endpoint mapping. There are also HTTP method specific shortcut variants of @RequestMapping: \u2022 @GetMapping \u2022 @PostMapping \u2022 @PutMapping \u2022 @DeleteMapping \u2022 @PatchMapping The shortcuts are Custom Annotations that are provided because, arguably, most controller methods should be mapped to a specific HTTP method versus using @RequestMapping, which, by default, matches to all HTTP methods. A @RequestMapping is still needed at the class level to express shared mappings.", "chunk_char_count": 1468, "chunk_word_count": 208, "chunk_token_count": 367.0}, {"page_number": 881, "sentence_chunk": "Java @RestController @RequestMapping(\"/persons\") class PersonController { \u00a0  @GetMapping(\"/{id}\") \u00a0  public Person getPerson(@PathVariable Long id) { \u00a0    // ... \u00a0  } \u00a0  @PostMapping \u00a0  @ResponseStatus(HttpStatus. CREATED) \u00a0  public void add(@RequestBody Person person) { \u00a0    // ... \u00a0  } } Kotlin @RestController @RequestMapping(\"/persons\") class PersonController { \u00a0  @GetMapping(\"/{id}\") \u00a0  fun getPerson(@PathVariable id: Long): Person { \u00a0    // ... \u00a0  } \u00a0  @PostMapping \u00a0  @ResponseStatus(HttpStatus. CREATED) \u00a0  fun add(@RequestBody person: Person) { \u00a0    // ... \u00a0  } } URI patterns WebFlux @RequestMapping methods can be mapped using URL patterns. There are two alternatives: \u2022 PathPattern\u2009\u2014\u2009a pre-parsed pattern matched against the URL path also pre-parsed as PathContainer. Designed for web use, this solution deals effectively with encoding and path parameters, and matches efficiently. \u2022AntPathMatcher\u2009\u2014\u2009match String patterns against a String path. This is the original solution also used in Spring configuration to select resources on the classpath, on the filesystem, and other locations. It is less efficient and the String path input is a challenge for dealing effectively with encoding and other issues with URLs.881", "chunk_char_count": 1232, "chunk_word_count": 196, "chunk_token_count": 308.0}, {"page_number": 882, "sentence_chunk": "PathPattern is the recommended solution for web applications and it is the only choice in Spring WebFlux. It was enabled for use in Spring MVC from version 5.3 and is enabled by default from version 6.0. See MVC config for customizations of path matching options. PathPattern supports the same pattern syntax as AntPathMatcher. In addition, it also supports the capturing pattern, e.g. {*spring}, for matching 0 or more path segments at the end of a path. PathPattern also restricts the use of ** for matching multiple path segments such that it\u2019s only allowed at the end of a pattern. This eliminates many cases of ambiguity when choosing the best matching pattern for a given request. For full pattern syntax please refer to PathPattern and AntPathMatcher. Some example patterns: \u2022 \"/resources/ima?e.png\" - match one character in a path segment \u2022 \"/resources/*.png\" - match zero or more characters in a path segment \u2022 \"/resources/**\" - match multiple path segments \u2022 \"/projects/{project}/versions\" - match a path segment and capture it as a variable \u2022 \"/projects/{project:[a-z]+}/versions\" - match and capture a variable with a regex Captured URI variables can be accessed with @PathVariable. For example: Java @GetMapping(\"/owners/{ownerId}/pets/{petId}\") public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) { \u00a0  // ... } Kotlin @GetMapping(\"/owners/{ownerId}/pets/{petId}\") fun findPet(@PathVariable ownerId: Long, @PathVariable petId: Long): Pet { \u00a0  // ... } You can declare URI variables at the class and method levels, as the following example shows: 882", "chunk_char_count": 1583, "chunk_word_count": 240, "chunk_token_count": 395.75}, {"page_number": 883, "sentence_chunk": "Java @Controller @RequestMapping(\"/owners/{ownerId}\") public class OwnerController { \u00a0  @GetMapping(\"/pets/{petId}\") \u00a0  public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) { \u00a0    // ... \u00a0  } } Kotlin @Controller @RequestMapping(\"/owners/{ownerId}\") class OwnerController { \u00a0  @GetMapping(\"/pets/{petId}\") \u00a0  fun findPet(@PathVariable ownerId: Long, @PathVariable petId: Long): Pet { \u00a0    // ... \u00a0  } } URI variables are automatically converted to the appropriate type, or TypeMismatchException is raised. Simple types (int, long, Date, and so on) are supported by default and you can register support for any other data type. See Type Conversion and DataBinder. You can explicitly name URI variables (for example, @PathVariable(\"customId\")), but you can leave that detail out if the names are the same and your code is compiled with debugging information or with the -parameters compiler flag on Java 8. The syntax {varName:regex} declares a URI variable with a regular expression that has syntax of {varName:regex}. For example, given URL \"/spring-web-3.0.5.jar\", the following method extracts the name, version, and file extension: Java @GetMapping(\"/{name:[a-z-]+}-{version:\\\\d\\\\.\\\\d\\\\.\\\\d}{ext:\\\\.[a-z]+}\") public void handle(@PathVariable String name, @PathVariable String version, @PathVariable String ext) { \u00a0  // ... } 883", "chunk_char_count": 1351, "chunk_word_count": 191, "chunk_token_count": 337.75}, {"page_number": 884, "sentence_chunk": "Kotlin @GetMapping(\"/{name:[a-z-]+}-{version:\\\\d\\\\.\\\\d\\\\.\\\\d}{ext:\\\\.[a-z]+}\") fun handle(@PathVariable name: String, @PathVariable version: String, @PathVariable ext: String) { \u00a0  // ... } URI path patterns can also have embedded ${\u2026} placeholders that are resolved on startup by using PropertySourcesPlaceholderConfigurer against local, system, environment, and other property sources. You can use this, for example, to parameterize a base URL based on some external configuration. Pattern Comparison WebFlux When multiple patterns match a URL, the best match must be selected. This is done with one of the following depending on whether use of parsed PathPattern is enabled for use or not: \u2022 PathPattern. SPECIFICITY_COMPARATOR \u2022 AntPathMatcher.getPatternComparator(String path) Both help to sort patterns with more specific ones on top. A pattern is less specific if it has a lower count of URI variables (counted as 1), single wildcards (counted as 1), and double wildcards (counted as 2). Given an equal score, the longer pattern is chosen. Given the same score and length, the pattern with more URI variables than wildcards is chosen. The default mapping pattern (/**) is excluded from scoring and always sorted last. Also, prefix patterns (such as /public/**) are considered less specific than other pattern that do not have double wildcards.", "chunk_char_count": 1350, "chunk_word_count": 197, "chunk_token_count": 337.5}, {"page_number": 884, "sentence_chunk": "For the full details, follow the above links to the pattern Comparators. Suffix Match Starting in 5.3, by default Spring MVC no longer performs .*suffix pattern matching where a controller mapped to /person is also implicitly mapped to /person.*. As a consequence path extensions are no longer used to interpret the requested content type for the response\u2009\u2014\u2009for example, /person.pdf, /person.xml, and so on. Using file extensions in this way was necessary when browsers used to send Accept headers that were hard to interpret consistently. At present, that is no longer a necessity and using the Accept header should be the preferred choice. Over time, the use of file name extensions has proven problematic in a variety of ways. It can cause ambiguity when overlain with the use of URI variables, path parameters, and URI encoding. Reasoning about URL-based authorization and security (see next section for more details) also becomes more difficult.884", "chunk_char_count": 953, "chunk_word_count": 151, "chunk_token_count": 238.25}, {"page_number": 885, "sentence_chunk": "To completely disable the use of path extensions in versions prior to 5.3, set the following: \u2022 useSuffixPatternMatching(false), see PathMatchConfigurer \u2022 favorPathExtension(false), see ContentNegotiationConfigurer Having a way to request content types other than through the \"Accept\" header can still be useful, e.g. when typing a URL in a browser. A safe alternative to path extensions is to use the query parameter strategy. If you must use file extensions, consider restricting them to a list of explicitly registered extensions through the mediaTypes property of ContentNegotiationConfigurer. Suffix Match and RFD A reflected file download (RFD) attack is similar to XSS in that it relies on request input (for example, a query parameter and a URI variable) being reflected in the response. However, instead of inserting JavaScript into HTML, an RFD attack relies on the browser switching to perform a download and treating the response as an executable script when double-clicked later. In Spring MVC, @ResponseBody and ResponseEntity methods are at risk, because they can render different content types, which clients can request through URL path extensions. Disabling suffix pattern matching and using path extensions for content negotiation lower the risk but are not sufficient to prevent RFD attacks. To prevent RFD attacks, prior to rendering the response body, Spring MVC adds a Content- Disposition:inline;filename=f.txt header to suggest a fixed and safe download file. This is done only if the URL path contains a file extension that is neither allowed as safe nor explicitly registered for content negotiation. However, it can potentially have side effects when URLs are typed directly into a browser.", "chunk_char_count": 1718, "chunk_word_count": 260, "chunk_token_count": 429.5}, {"page_number": 885, "sentence_chunk": "Many common path extensions are allowed as safe by default. Applications with custom HttpMessageConverter implementations can explicitly register file extensions for content negotiation to avoid having a Content-Disposition header added for those extensions. See Content Types. See CVE-2015-5211 for additional recommendations related to RFD. Consumable Media Types WebFlux You can narrow the request mapping based on the Content-Type of the request, as the following example shows: Java @PostMapping(path = \"/pets\", consumes = \"application/json\") \u2460 public void addPet(@RequestBody Pet pet) { \u00a0  // ... } \u2460 Using a consumes attribute to narrow the mapping by the content type.885", "chunk_char_count": 679, "chunk_word_count": 98, "chunk_token_count": 169.75}, {"page_number": 886, "sentence_chunk": "Kotlin @PostMapping(\"/pets\", consumes = [\"application/json\"]) \u2460 fun addPet(@RequestBody pet: Pet) { \u00a0  // ... } \u2460 Using a consumes attribute to narrow the mapping by the content type. The consumes attribute also supports negation expressions\u2009\u2014\u2009for example, !text/plain means any content type other than text/plain. You can declare a shared consumes attribute at the class level. Unlike most other request-mapping attributes, however, when used at the class level, a method-level consumes attribute overrides rather than extends the class-level declaration.\uf0eb MediaType provides constants for commonly used media types, such as APPLICATION_JSON_VALUE and APPLICATION_XML_VALUE. Producible Media Types WebFlux You can narrow the request mapping based on the Accept request header and the list of content types that a controller method produces, as the following example shows: Java @GetMapping(path = \"/pets/{petId}\", produces = \"application/json\") \u2460 @ResponseBody public Pet getPet(@PathVariable String petId) { \u00a0  // ... } \u2460 Using a produces attribute to narrow the mapping by the content type. Kotlin @GetMapping(\"/pets/{petId}\", produces = [\"application/json\"]) \u2460 @ResponseBody fun getPet(@PathVariable petId: String): Pet { \u00a0  // ... } \u2460 Using a produces attribute to narrow the mapping by the content type. The media type can specify a character set. Negated expressions are supported\u2009\u2014\u2009for example, !", "chunk_char_count": 1404, "chunk_word_count": 202, "chunk_token_count": 351.0}, {"page_number": 886, "sentence_chunk": "text/plain means any content type other than \"text/plain\". You can declare a shared produces attribute at the class level. Unlike most other request-mapping attributes, however, when used at the class level, a method-level produces attribute overrides rather 886", "chunk_char_count": 262, "chunk_word_count": 38, "chunk_token_count": 65.5}, {"page_number": 887, "sentence_chunk": "than extends the class-level declaration.\uf0eb MediaType provides constants for commonly used media types, such as APPLICATION_JSON_VALUE and APPLICATION_XML_VALUE. Parameters, headers WebFlux You can narrow request mappings based on request parameter conditions. You can test for the presence of a request parameter (myParam), for the absence of one (!myParam), or for a specific value (myParam=myValue). The following example shows how to test for a specific value: Java @GetMapping(path = \"/pets/{petId}\", params = \"myParam=myValue\") \u2460 public void findPet(@PathVariable String petId) { \u00a0  // ... } \u2460 Testing whether myParam equals myValue. Kotlin @GetMapping(\"/pets/{petId}\", params = [\"myParam=myValue\"]) \u2460 fun findPet(@PathVariable petId: String) { \u00a0  // ... } \u2460 Testing whether myParam equals myValue. You can also use the same with request header conditions, as the following example shows: Java @GetMapping(path = \"/pets\", headers = \"myHeader=myValue\") \u2460 public void findPet(@PathVariable String petId) { \u00a0  // ... } \u2460 Testing whether myHeader equals myValue. Kotlin @GetMapping(\"/pets\", headers = [\"myHeader=myValue\"]) \u2460 fun findPet(@PathVariable petId: String) { \u00a0  // ... } 887", "chunk_char_count": 1184, "chunk_word_count": 169, "chunk_token_count": 296.0}, {"page_number": 888, "sentence_chunk": "\uf0eb You can match Content-Type and Accept with the headers condition, but it is better to use consumes and produces instead. HTTP HEAD, OPTIONS WebFlux @GetMapping (and @RequestMapping(method=HttpMethod. GET)) support HTTP HEAD transparently for request mapping. Controller methods do not need to change. A response wrapper, applied in jakarta.servlet.http. HttpServlet, ensures a Content-Length header is set to the number of bytes written (without actually writing to the response).@GetMapping (and @RequestMapping(method=HttpMethod. GET)) are implicitly mapped to and support HTTP HEAD. An HTTP HEAD request is processed as if it were HTTP GET except that, instead of writing the body, the number of bytes are counted and the Content-Length header is set. By default, HTTP OPTIONS is handled by setting the Allow response header to the list of HTTP methods listed in all @RequestMapping methods that have matching URL patterns.", "chunk_char_count": 928, "chunk_word_count": 138, "chunk_token_count": 232.0}, {"page_number": 888, "sentence_chunk": "For a @RequestMapping without HTTP method declarations, the Allow header is set to GET,HEAD,POST,PUT,PATCH,DELETE,OPTIONS. Controller methods should always declare the supported HTTP methods (for example, by using the HTTP method specific variants: @GetMapping, @PostMapping, and others). You can explicitly map the @RequestMapping method to HTTP HEAD and HTTP OPTIONS, but that is not necessary in the common case. Custom Annotations WebFlux Spring MVC supports the use of composed annotations for request mapping. Those are annotations that are themselves meta-annotated with @RequestMapping and composed to redeclare a subset (or all) of the @RequestMapping attributes with a narrower, more specific purpose.@GetMapping, @PostMapping, @PutMapping, @DeleteMapping, and @PatchMapping are examples of composed annotations. They are provided because, arguably, most controller methods should be mapped to a specific HTTP method versus using @RequestMapping, which, by default, matches to all HTTP methods. If you need an example of composed annotations, look at how those are declared. Spring MVC also supports custom request-mapping attributes with custom request-matching logic. This is a more advanced option that requires subclassing RequestMappingHandlerMapping and overriding the getCustomMethodCondition method, where you can check the custom attribute and return your own RequestCondition.", "chunk_char_count": 1396, "chunk_word_count": 188, "chunk_token_count": 349.0}, {"page_number": 888, "sentence_chunk": "Explicit Registrations WebFlux You can programmatically register handler methods, which you can use for dynamic registrations or for advanced cases, such as different instances of the same handler under different URLs. The 888", "chunk_char_count": 226, "chunk_word_count": 33, "chunk_token_count": 56.5}, {"page_number": 889, "sentence_chunk": "following example registers a handler method: Java @Configuration public class MyConfig { \u00a0  @Autowired \u00a0  public void setHandlerMapping(RequestMappingHandlerMapping mapping, UserHandler handler) \u2460 \u00a0      throws NoSuchMethodException { \u00a0    RequestMappingInfo info = RequestMappingInfo \u00a0        .paths(\"/user/{id}\").methods(RequestMethod. GET).build(); \u2461 \u00a0    Method method = UserHandler.class.getMethod(\"getUser\", Long.class); \u2462 \u00a0    mapping.registerMapping(info, handler, method); \u2463 \u00a0  } } \u2460 Inject the target handler and the handler mapping for controllers.\u2461 Prepare the request mapping meta data.\u2462 Get the handler method.\u2463 Add the registration. Kotlin @Configuration class MyConfig { \u00a0  @Autowired \u00a0  fun setHandlerMapping(mapping: RequestMappingHandlerMapping, handler: UserHandler) { \u2460 \u00a0    val info = RequestMappingInfo.paths(\"/user/{id}\").methods(RequestMethod. GET).build() \u2461 \u00a0    val method = UserHandler::class.java.getMethod(\"getUser\", Long::class.java) \u2462 \u00a0    mapping.registerMapping(info, handler, method) \u2463 \u00a0  } } \u2460 Inject the target handler and the handler mapping for controllers.\u2461 Prepare the request mapping meta data.\u2462 Get the handler method.\u2463 Add the registration.", "chunk_char_count": 1185, "chunk_word_count": 171, "chunk_token_count": 296.25}, {"page_number": 890, "sentence_chunk": "Handler Methods WebFlux @RequestMapping handler methods have a flexible signature and can choose from a range of supported controller method arguments and return values. Method Arguments WebFlux The next table describes the supported controller method arguments. Reactive types are not supported for any arguments. JDK 8\u2019s java.util. Optional is supported as a method argument in combination with annotations that have a required attribute (for example, @RequestParam, @RequestHeader, and others) and is equivalent to required=false. Controller method argument Description WebRequest, NativeWebRequest Generic access to request parameters and request and session attributes, without direct use of the Servlet API.jakarta.servlet. ServletRequest, jakarta.servlet. ServletRespons e Choose any specific request or response type\u2009\u2014\u2009for example, ServletRequest, HttpServletRequest, or Spring\u2019s MultipartRequest, MultipartHttpServletRequest.jakarta.servlet.http.", "chunk_char_count": 955, "chunk_word_count": 115, "chunk_token_count": 238.75}, {"page_number": 890, "sentence_chunk": "HttpSessi on Enforces the presence of a session. As a consequence, such an argument is never null. Note that session access is not thread- safe. Consider setting the RequestMappingHandlerAdapter instance\u2019s synchronizeOnSession flag to true if multiple requests are allowed to concurrently access a session.jakarta.servlet.http. PushBuild er Servlet 4.0 push builder API for programmatic HTTP/2 resource pushes. Note that, per the Servlet specification, the injected PushBuilder instance can be null if the client does not support that HTTP/2 feature.java.security. Principal Currently authenticated user\u2009\u2014\u2009possibly a specific Principal implementation class if known. Note that this argument is not resolved eagerly, if it is annotated in order to allow a custom resolver to resolve it before falling back on default resolution via HttpServletRequest#getUserPrincipal.", "chunk_char_count": 867, "chunk_word_count": 119, "chunk_token_count": 216.75}, {"page_number": 890, "sentence_chunk": "For example, the Spring Security Authentication implements Principal and would be injected as such via HttpServletRequest#getUserPrincipal, unless it is also annotated with @AuthenticationPrincipal in which case it is resolved by a custom Spring Security resolver through Authentication#getPrincipal. HttpMethod The HTTP method of the request.890", "chunk_char_count": 346, "chunk_word_count": 44, "chunk_token_count": 86.5}, {"page_number": 891, "sentence_chunk": "Controller method argument Description java.util. Locale The current request locale, determined by the most specific LocaleResolver available (in effect, the configured LocaleResolver or LocaleContextResolver).java.util. TimeZone + java.time. ZoneId The time zone associated with the current request, as determined by a LocaleContextResolver.java.io. InputStream, java.io. Reader For access to the raw request body as exposed by the Servlet API.java.io. OutputStream, java.io.", "chunk_char_count": 476, "chunk_word_count": 59, "chunk_token_count": 119.0}, {"page_number": 891, "sentence_chunk": "Writer For access to the raw response body as exposed by the Servlet API.@PathVariable For access to URI template variables. See URI patterns.@MatrixVariable For access to name-value pairs in URI path segments. See Matrix Variables.@RequestParam For access to the Servlet request parameters, including multipart files. Parameter values are converted to the declared method argument type. See @RequestParam as well as Multipart. Note that use of @RequestParam is optional for simple parameter values. See \u201cAny other argument\u201d, at the end of this table.", "chunk_char_count": 551, "chunk_word_count": 82, "chunk_token_count": 137.75}, {"page_number": 891, "sentence_chunk": "@RequestHeader For access to request headers. Header values are converted to the declared method argument type. See @RequestHeader.@CookieValue For access to cookies. Cookies values are converted to the declared method argument type. See @CookieValue.@RequestBody For access to the HTTP request body. Body content is converted to the declared method argument type by using HttpMessageConverter implementations. See @RequestBody. HttpEntity<B> For access to request headers and body.", "chunk_char_count": 482, "chunk_word_count": 65, "chunk_token_count": 120.5}, {"page_number": 891, "sentence_chunk": "The body is converted with an HttpMessageConverter. See HttpEntity.@RequestPart For access to a part in a multipart/form-data request, converting the part\u2019s body with an HttpMessageConverter. See Multipart.java.util. Map, org.springframework.ui. Model, org.springframework.ui. ModelMa p For access to the model that is used in HTML controllers and exposed to templates as part of view rendering. RedirectAttributes Specify attributes to use in case of a redirect (that is, to be appended to the query string) and flash attributes to be stored temporarily until the request after redirect. See Redirect Attributes and Flash Attributes.", "chunk_char_count": 634, "chunk_word_count": 90, "chunk_token_count": 158.5}, {"page_number": 892, "sentence_chunk": "Controller method argument Description @ModelAttribute For access to an existing attribute in the model (instantiated if not present) with data binding and validation applied. See @ModelAttribute as well as Model and DataBinder. Note that use of @ModelAttribute is optional (for example, to set its attributes). See \u201cAny other argument\u201d at the end of this table. Errors, BindingResult For access to errors from validation and data binding for a command object (that is, a @ModelAttribute argument) or errors from the validation of a @RequestBody or @RequestPart arguments. You must declare an Errors, or BindingResult argument immediately after the validated method argument. SessionStatus + class-level @SessionAttributes For marking form processing complete, which triggers cleanup of session attributes declared through a class-level @SessionAttributes annotation. See @SessionAttributes for more details. UriComponentsBuilder For preparing a URL relative to the current request\u2019s host, port, scheme, context path, and the literal part of the servlet mapping. See URI Links.", "chunk_char_count": 1077, "chunk_word_count": 152, "chunk_token_count": 269.25}, {"page_number": 892, "sentence_chunk": "@SessionAttribute For access to any session attribute, in contrast to model attributes stored in the session as a result of a class-level @SessionAttributes declaration. See @SessionAttribute for more details.@RequestAttribute For access to request attributes. See @RequestAttribute for more details. Any other argument If a method argument is not matched to any of the earlier values in this table and it is a simple type (as determined by BeanUtils#isSimpleProperty), it is resolved as a @RequestParam. Otherwise, it is resolved as a @ModelAttribute. Return Values WebFlux The next table describes the supported controller method return values. Reactive types are supported for all return values. Controller method return value Description @ResponseBody The return value is converted through HttpMessageConverter implementations and written to the response. See @ResponseBody.", "chunk_char_count": 878, "chunk_word_count": 123, "chunk_token_count": 219.5}, {"page_number": 892, "sentence_chunk": "HttpEntity<B>, ResponseEntity<B> The return value that specifies the full response (including HTTP headers and body) is to be converted through HttpMessageConverter implementations and written to the response. See ResponseEntity.892", "chunk_char_count": 232, "chunk_word_count": 29, "chunk_token_count": 58.0}, {"page_number": 893, "sentence_chunk": "Controller method return value Description HttpHeaders For returning a response with headers and no body. ErrorResponse To render an RFC 7807 error response with details in the body, see Error Responses ProblemDetail To render an RFC 7807 error response with details in the body, see Error Responses String A view name to be resolved with ViewResolver implementations and used together with the implicit model\u2009\u2014\u2009determined through command objects and @ModelAttribute methods. The handler method can also programmatically enrich the model by declaring a Model argument (see Explicit Registrations). View A View instance to use for rendering together with the implicit model\u2009\u2014\u2009determined through command objects and @ModelAttribute methods. The handler method can also programmatically enrich the model by declaring a Model argument (see Explicit Registrations).java.util. Map, org.springframework.ui. Model Attributes to be added to the implicit model, with the view name implicitly determined through a RequestToViewNameTranslator.@ModelAttribute An attribute to be added to the model, with the view name implicitly determined through a RequestToViewNameTranslator. Note that @ModelAttribute is optional.", "chunk_char_count": 1204, "chunk_word_count": 165, "chunk_token_count": 301.0}, {"page_number": 893, "sentence_chunk": "See \"Any other return value\" at the end of this table. ModelAndView object The view and model attributes to use and, optionally, a response status.void A method with a void return type (or null return value) is considered to have fully handled the response if it also has a ServletResponse, an OutputStream argument, or an @ResponseStatus annotation. The same is also true if the controller has made a positive ETag or lastModified timestamp check (see Controllers for details). If none of the above is true, a void return type can also indicate \u201cno response body\u201d for REST controllers or a default view name selection for HTML controllers. DeferredResult<V> Produce any of the preceding return values asynchronously from any thread\u2009\u2014\u2009for example, as a result of some event or callback. See Asynchronous Requests and DeferredResult. Callable<V> Produce any of the above return values asynchronously in a Spring MVC-managed thread. See Asynchronous Requests and Callable.893", "chunk_char_count": 973, "chunk_word_count": 152, "chunk_token_count": 243.25}, {"page_number": 894, "sentence_chunk": "Controller method return value Description ListenableFuture<V>, java.util.concurrent. Completio nStage<V>, java.util.concurrent. Completab leFuture<V> Alternative to DeferredResult, as a convenience (for example, when an underlying service returns one of those). ResponseBodyEmitter, SseEmitter Emit a stream of objects asynchronously to be written to the response with HttpMessageConverter implementations. Also supported as the body of a ResponseEntity. See Asynchronous Requests and HTTP Streaming. StreamingResponseBody Write to the response OutputStream asynchronously. Also supported as the body of a ResponseEntity. See Asynchronous Requests and HTTP Streaming. Reactor and other reactive types registered via ReactiveAdapterRegistry A single value type, e.g. Mono, is comparable to returning DeferredResult.", "chunk_char_count": 815, "chunk_word_count": 99, "chunk_token_count": 203.75}, {"page_number": 894, "sentence_chunk": "A multi-value type, e.g. Flux, may be treated as a stream depending on the requested media type, e.g. \"text/event- stream\", \"application/json+stream\", or otherwise is collected to a List and rendered as a single value. See Asynchronous Requests and Reactive Types. Other return values If a return value remains unresolved in any other way, it is treated as a model attribute, unless it is a simple type as determined by BeanUtils#isSimpleProperty, in which case it remains unresolved. Type Conversion WebFlux Some annotated controller method arguments that represent String-based request input (such as @RequestParam, @RequestHeader, @PathVariable, @MatrixVariable, and @CookieValue) can require type conversion if the argument is declared as something other than String. For such cases, type conversion is automatically applied based on the configured converters. By default, simple types (int, long, Date, and others) are supported. You can customize type conversion through a WebDataBinder (see DataBinder) or by registering Formatters with the FormattingConversionService. See Spring Field Formatting. A practical issue in type conversion is the treatment of an empty String source value. Such a value is treated as missing if it becomes null as a result of type conversion.", "chunk_char_count": 1278, "chunk_word_count": 188, "chunk_token_count": 319.5}, {"page_number": 894, "sentence_chunk": "This can be the case for Long, UUID, and other target types. If you want to allow null to be injected, either use the required flag on the argument annotation, or declare the argument as @Nullable.894", "chunk_char_count": 200, "chunk_word_count": 36, "chunk_token_count": 50.0}, {"page_number": 895, "sentence_chunk": "\uf05a As of 5.3, non-null arguments will be enforced even after type conversion. If your handler method intends to accept a null value as well, either declare your argument as @Nullable or mark it as required=false in the corresponding @RequestParam, etc.annotation. This is a best practice and the recommended solution for regressions encountered in a 5.3 upgrade. Alternatively, you may specifically handle e.g. the resulting MissingPathVariableException in the case of a required @PathVariable. A null value after conversion will be treated like an empty original value, so the corresponding Missing\u2026Exception variants will be thrown. Matrix Variables WebFlux RFC 3986 discusses name-value pairs in path segments. In Spring MVC, we refer to those as \u201cmatrix variables\u201d based on an \u201cold post\u201d by Tim Berners-Lee, but they can be also be referred to as URI path parameters. Matrix variables can appear in any path segment, with each variable separated by a semicolon and multiple values separated by comma (for example, /cars;color=red,green;year=2012). Multiple values can also be specified through repeated variable names (for example, color=red;color=green;color=blue).", "chunk_char_count": 1169, "chunk_word_count": 172, "chunk_token_count": 292.25}, {"page_number": 895, "sentence_chunk": "If a URL is expected to contain matrix variables, the request mapping for a controller method must use a URI variable to mask that variable content and ensure the request can be matched successfully independent of matrix variable order and presence. The following example uses a matrix variable: Java // GET /pets/42;q=11;r=22 @GetMapping(\"/pets/{petId}\") public void findPet(@PathVariable String petId, @MatrixVariable int q) { \u00a0  // petId == 42 \u00a0  // q == 11 } 895", "chunk_char_count": 466, "chunk_word_count": 76, "chunk_token_count": 116.5}, {"page_number": 896, "sentence_chunk": "Kotlin // GET /pets/42;q=11;r=22 @GetMapping(\"/pets/{petId}\") fun findPet(@PathVariable petId: String, @MatrixVariable q: Int) { \u00a0  // petId == 42 \u00a0  // q == 11 } Given that all path segments may contain matrix variables, you may sometimes need to disambiguate which path variable the matrix variable is expected to be in. The following example shows how to do so: Java // GET /owners/42;q=11/pets/21;q=22 @GetMapping(\"/owners/{ownerId}/pets/{petId}\") public void findPet( \u00a0    @MatrixVariable(name=\"q\", pathVar=\"ownerId\") int q1, \u00a0    @MatrixVariable(name=\"q\", pathVar=\"petId\") int q2) { \u00a0  // q1 == 11 \u00a0  // q2 == 22 } Kotlin // GET /owners/42;q=11/pets/21;q=22 @GetMapping(\"/owners/{ownerId}/pets/{petId}\") fun findPet( \u00a0    @MatrixVariable(name = \"q\", pathVar = \"ownerId\") q1: Int, \u00a0    @MatrixVariable(name = \"q\", pathVar = \"petId\") q2: Int) { \u00a0  // q1 == 11 \u00a0  // q2 == 22 } A matrix variable may be defined as optional and a default value specified, as the following example shows: 896", "chunk_char_count": 992, "chunk_word_count": 162, "chunk_token_count": 248.0}, {"page_number": 897, "sentence_chunk": "Java // GET /pets/42 @GetMapping(\"/pets/{petId}\") public void findPet(@MatrixVariable(required=false, defaultValue=\"1\") int q) { \u00a0  // q == 1 } Kotlin // GET /pets/42 @GetMapping(\"/pets/{petId}\") fun findPet(@MatrixVariable(required = false, defaultValue = \"1\") q: Int) { \u00a0  // q == 1 } To get all matrix variables, you can use a MultiValueMap, as the following example shows: Java // GET /owners/42;q=11;r=12/pets/21;q=22;s=23 @GetMapping(\"/owners/{ownerId}/pets/{petId}\") public void findPet( \u00a0    @MatrixVariable MultiValueMap<String, String> matrixVars, \u00a0    @MatrixVariable(pathVar=\"petId\") MultiValueMap<String, String> petMatrixVars) { \u00a0  // matrixVars: [\"q\" : [11,22], \"r\" : 12, \"s\" : 23] \u00a0  // petMatrixVars: [\"q\" : 22, \"s\" : 23] } 897", "chunk_char_count": 744, "chunk_word_count": 106, "chunk_token_count": 186.0}, {"page_number": 898, "sentence_chunk": "Kotlin // GET /owners/42;q=11;r=12/pets/21;q=22;s=23 @GetMapping(\"/owners/{ownerId}/pets/{petId}\") fun findPet( \u00a0    @MatrixVariable matrixVars: MultiValueMap<String, String>, \u00a0    @MatrixVariable(pathVar=\"petId\") petMatrixVars: MultiValueMap<String, String>) { \u00a0  // matrixVars: [\"q\" : [11,22], \"r\" : 12, \"s\" : 23] \u00a0  // petMatrixVars: [\"q\" : 22, \"s\" : 23] } Note that you need to enable the use of matrix variables. In the MVC Java configuration, you need to set a UrlPathHelper with removeSemicolonContent=false through Path Matching. In the MVC XML namespace, you can set <mvc:annotation-driven enable-matrix-variables=\"true\"/>.@RequestParam WebFlux You can use the @RequestParam annotation to bind Servlet request parameters (that is, query parameters or form data) to a method argument in a controller. The following example shows how to do so: Java @Controller @RequestMapping(\"/pets\") public class EditPetForm { \u00a0  // ... \u00a0  @GetMapping \u00a0  public String setupForm(@RequestParam(\"petId\") int petId, Model model) { \u2460 \u00a0    Pet pet = this.clinic.loadPet(petId); \u00a0    model.addAttribute(\"pet\", pet); \u00a0    return \"petForm\"; \u00a0  } \u00a0  // ... } \u2460 Using @RequestParam to bind petId.898", "chunk_char_count": 1182, "chunk_word_count": 178, "chunk_token_count": 295.5}, {"page_number": 899, "sentence_chunk": "Kotlin import org.springframework.ui.set @Controller @RequestMapping(\"/pets\") class EditPetForm { \u00a0  // ... \u00a0  @GetMapping \u00a0  fun setupForm(@RequestParam(\"petId\") petId: Int, model: Model): String { \u2460 \u00a0    val pet = this.clinic.loadPet(petId); \u00a0    model[\"pet\"] = pet \u00a0    return \"petForm\" \u00a0  } \u00a0  // ... } \u2460 Using @RequestParam to bind petId. By default, method parameters that use this annotation are required, but you can specify that a method parameter is optional by setting the @RequestParam annotation\u2019s required flag to false or by declaring the argument with an java.util. Optional wrapper. Type conversion is automatically applied if the target method parameter type is not String. See Type Conversion. Declaring the argument type as an array or list allows for resolving multiple parameter values for the same parameter name. When an @RequestParam annotation is declared as a Map<String, String> or MultiValueMap<String, String>, without a parameter name specified in the annotation, then the map is populated with the request parameter values for each given parameter name. Note that use of @RequestParam is optional (for example, to set its attributes). By default, any argument that is a simple value type (as determined by BeanUtils#isSimpleProperty) and is not resolved by any other argument resolver, is treated as if it were annotated with @RequestParam.@RequestHeader WebFlux You can use the @RequestHeader annotation to bind a request header to a method argument in a controller.", "chunk_char_count": 1499, "chunk_word_count": 237, "chunk_token_count": 374.75}, {"page_number": 900, "sentence_chunk": "Host          localhost:8080 Accept         text/html,application/xhtml+xml,application/xml;q=0.9 Accept-Language     fr,en-gb;q=0.7,en;q=0.3 Accept-Encoding     gzip,deflate Accept-Charset     ISO-8859-1,utf-8;q=0.7,*;q=0.7 Keep-Alive       300 The following example gets the value of the Accept-Encoding and Keep-Alive headers: Java @GetMapping(\"/demo\") public void handle( \u00a0    @RequestHeader(\"Accept-Encoding\") String encoding, \u2460 \u00a0    @RequestHeader(\"Keep-Alive\") long keepAlive) { \u2461 \u00a0  //... } \u2460 Get the value of the Accept-Encoding header.\u2461 Get the value of the Keep-Alive header. Kotlin @GetMapping(\"/demo\") fun handle( \u00a0    @RequestHeader(\"Accept-Encoding\") encoding: String, \u2460 \u00a0    @RequestHeader(\"Keep-Alive\") keepAlive: Long) { \u2461 \u00a0  //... } \u2460 Get the value of the Accept-Encoding header.\u2461 Get the value of the Keep-Alive header. If the target method parameter type is not String, type conversion is automatically applied. See Type Conversion. When an @RequestHeader annotation is used on a Map<String, String>, MultiValueMap<String, String>, or HttpHeaders argument, the map is populated with all header values.\uf0eb Built-in support is available for converting a comma-separated string into an array or collection of strings or other types known to the type conversion system. For example, a method parameter annotated with @RequestHeader(\"Accept\") can be of type String but also String[] or List<String>.@CookieValue WebFlux You can use the @CookieValue annotation to bind the value of an HTTP cookie to a method argument 900", "chunk_char_count": 1534, "chunk_word_count": 243, "chunk_token_count": 383.5}, {"page_number": 901, "sentence_chunk": "in a controller. Consider a request with the following cookie: JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84 The following example shows how to get the cookie value: Java @GetMapping(\"/demo\") public void handle(@CookieValue(\"JSESSIONID\") String cookie) { \u2460 \u00a0  //... } \u2460 Get the value of the JSESSIONID cookie. Kotlin @GetMapping(\"/demo\") fun handle(@CookieValue(\"JSESSIONID\") cookie: String) { \u2460 \u00a0  //... } \u2460 Get the value of the JSESSIONID cookie. If the target method parameter type is not String, type conversion is applied automatically. See Type Conversion.@ModelAttribute WebFlux You can use the @ModelAttribute annotation on a method argument to access an attribute from the model or have it be instantiated if not present. The model attribute is also overlain with values from HTTP Servlet request parameters whose names match to field names. This is referred to as data binding, and it saves you from having to deal with parsing and converting individual query parameters and form fields. The following example shows how to do so: Java @PostMapping(\"/owners/{ownerId}/pets/{petId}/edit\") public String processSubmit(@ModelAttribute Pet pet) { \u00a0  // method logic... } 901", "chunk_char_count": 1177, "chunk_word_count": 172, "chunk_token_count": 294.25}, {"page_number": 902, "sentence_chunk": "Kotlin @PostMapping(\"/owners/{ownerId}/pets/{petId}/edit\") fun processSubmit(@ModelAttribute pet: Pet): String { \u00a0  // method logic... } The Pet instance above is sourced in one of the following ways: \u2022 Retrieved from the model where it may have been added by a @ModelAttribute method. \u2022Retrieved from the HTTP session if the model attribute was listed in the class-level @SessionAttributes annotation. \u2022Obtained through a Converter where the model attribute name matches the name of a request value such as a path variable or a request parameter (see next example). \u2022Instantiated using its default constructor. \u2022Instantiated through a \u201cprimary constructor\u201d with arguments that match to Servlet request parameters. Argument names are determined through JavaBeans @ConstructorProperties or through runtime-retained parameter names in the bytecode. One alternative to using a @ModelAttribute method to supply it or relying on the framework to create the model attribute, is to have a Converter<String, T> to provide the instance. This is applied when the model attribute name matches to the name of a request value such as a path variable or a request parameter, and there is a Converter from String to the model attribute type. In the following example, the model attribute name is account which matches the URI path variable account, and there is a registered Converter<String, Account> which could load the Account from a data store: Java @PutMapping(\"/accounts/{account}\") public String save(@ModelAttribute(\"account\") Account account) { \u00a0  // ... } Kotlin @PutMapping(\"/accounts/{account}\") fun save(@ModelAttribute(\"account\") account: Account): String { \u00a0  // ... } After the model attribute instance is obtained, data binding is applied. The WebDataBinder class matches Servlet request parameter names (query parameters and form fields) to field names on the target Object.", "chunk_char_count": 1878, "chunk_word_count": 275, "chunk_token_count": 469.5}, {"page_number": 902, "sentence_chunk": "Matching fields are populated after type conversion is applied, where necessary. For more on data binding (and validation), see Validation. For more on customizing data binding, see DataBinder.902", "chunk_char_count": 196, "chunk_word_count": 28, "chunk_token_count": 49.0}, {"page_number": 903, "sentence_chunk": "Data binding can result in errors. By default, a BindException is raised. However, to check for such errors in the controller method, you can add a BindingResult argument immediately next to the @ModelAttribute, as the following example shows: Java @PostMapping(\"/owners/{ownerId}/pets/{petId}/edit\") public String processSubmit(@ModelAttribute(\"pet\") Pet pet, BindingResult result) { \u2460 \u00a0  if (result.hasErrors()) { \u00a0    return \"petForm\"; \u00a0  } \u00a0  // ... } \u2460 Adding a BindingResult next to the @ModelAttribute. Kotlin @PostMapping(\"/owners/{ownerId}/pets/{petId}/edit\") fun processSubmit(@ModelAttribute(\"pet\") pet: Pet, result: BindingResult): String { \u2460 \u00a0  if (result.hasErrors()) { \u00a0    return \"petForm\" \u00a0  } \u00a0  // ... } \u2460 Adding a BindingResult next to the @ModelAttribute. In some cases, you may want access to a model attribute without data binding. For such cases, you can inject the Model into the controller and access it directly or, alternatively, set @ModelAttribute(binding=false), as the following example shows: Java @ModelAttribute public AccountForm setUpForm() { \u00a0  return new AccountForm(); } @ModelAttribute public Account findAccount(@PathVariable String accountId) { \u00a0  return accountRepository.findOne(accountId); } @PostMapping(\"update\") public String update(@Valid AccountForm form, BindingResult result, \u00a0    @ModelAttribute(binding=false) Account account) { \u2460 \u00a0  // ... } \u2460 Setting @ModelAttribute(binding=false).903", "chunk_char_count": 1442, "chunk_word_count": 201, "chunk_token_count": 360.5}, {"page_number": 904, "sentence_chunk": "Kotlin @ModelAttribute fun setUpForm(): AccountForm { \u00a0  return AccountForm() } @ModelAttribute fun findAccount(@PathVariable accountId: String): Account { \u00a0  return accountRepository.findOne(accountId) } @PostMapping(\"update\") fun update(@Valid form: AccountForm, result: BindingResult, \u00a0     @ModelAttribute(binding = false) account: Account): String { \u2460 \u00a0  // ... } \u2460 Setting @ModelAttribute(binding=false). You can automatically apply validation after data binding by adding the jakarta.validation. Valid annotation or Spring\u2019s @Validated annotation (Bean Validation and Spring validation). The following example shows how to do so: Java @PostMapping(\"/owners/{ownerId}/pets/{petId}/edit\") public String processSubmit(@Valid @ModelAttribute(\"pet\") Pet pet, BindingResult result) { \u2460 \u00a0  if (result.hasErrors()) { \u00a0    return \"petForm\"; \u00a0  } \u00a0  // ... } \u2460 Validate the Pet instance. Kotlin @PostMapping(\"/owners/{ownerId}/pets/{petId}/edit\") fun processSubmit(@Valid @ModelAttribute(\"pet\") pet: Pet, result: BindingResult): String { \u2460 \u00a0  if (result.hasErrors()) { \u00a0    return \"petForm\" \u00a0  } \u00a0  // ... } Note that using @ModelAttribute is optional (for example, to set its attributes). By default, any argument that is not a simple value type (as determined by BeanUtils#isSimpleProperty) and is not 904", "chunk_char_count": 1304, "chunk_word_count": 180, "chunk_token_count": 326.0}, {"page_number": 905, "sentence_chunk": "resolved by any other argument resolver is treated as if it were annotated with @ModelAttribute.@SessionAttributes WebFlux @SessionAttributes is used to store model attributes in the HTTP Servlet session between requests. It is a type-level annotation that declares the session attributes used by a specific controller. This typically lists the names of model attributes or types of model attributes that should be transparently stored in the session for subsequent requests to access. The following example uses the @SessionAttributes annotation: Java @Controller @SessionAttributes(\"pet\") \u2460 public class EditPetForm { \u00a0  // ... } \u2460 Using the @SessionAttributes annotation. Kotlin @Controller @SessionAttributes(\"pet\") \u2460 class EditPetForm { \u00a0  // ... } \u2460 Using the @SessionAttributes annotation. On the first request, when a model attribute with the name, pet, is added to the model, it is automatically promoted to and saved in the HTTP Servlet session. It remains there until another controller method uses a SessionStatus method argument to clear the storage, as the following example shows: 905", "chunk_char_count": 1099, "chunk_word_count": 164, "chunk_token_count": 274.75}, {"page_number": 906, "sentence_chunk": "Java @Controller @SessionAttributes(\"pet\") \u2460 public class EditPetForm { \u00a0  // ... \u00a0  @PostMapping(\"/pets/{id}\") \u00a0  public String handle(Pet pet, BindingResult errors, SessionStatus status) { \u00a0    if (errors.hasErrors) { \u00a0      // ... \u00a0    } \u00a0    status.setComplete(); \u2461 \u00a0    // ... \u00a0  } } \u2460 Storing the Pet value in the Servlet session.\u2461 Clearing the Pet value from the Servlet session. Kotlin @Controller @SessionAttributes(\"pet\") \u2460 class EditPetForm { \u00a0  // ... \u00a0  @PostMapping(\"/pets/{id}\") \u00a0  fun handle(pet: Pet, errors: BindingResult, status: SessionStatus): String { \u00a0    if (errors.hasErrors()) { \u00a0      // ... \u00a0    } \u00a0    status.setComplete() \u2461 \u00a0    // ... \u00a0  } } \u2460 Storing the Pet value in the Servlet session.\u2461 Clearing the Pet value from the Servlet session.@SessionAttribute WebFlux If you need access to pre-existing session attributes that are managed globally (that is, outside the controller\u2009\u2014\u2009for example, by a filter) and may or may not be present, you can use the @SessionAttribute annotation on a method parameter, as the following example shows: 906", "chunk_char_count": 1071, "chunk_word_count": 202, "chunk_token_count": 267.75}, {"page_number": 907, "sentence_chunk": "Java @RequestMapping(\"/\") public String handle(@SessionAttribute User user) { \u2460 \u00a0  // ... } \u2460 Using a @SessionAttribute annotation. Kotlin @RequestMapping(\"/\") fun handle(@SessionAttribute user: User): String { \u2460 \u00a0  // ... } For use cases that require adding or removing session attributes, consider injecting org.springframework.web.context.request. WebRequest or jakarta.servlet.http. HttpSession into the controller method. For temporary storage of model attributes in the session as part of a controller workflow, consider using @SessionAttributes as described in @SessionAttributes.@RequestAttribute WebFlux Similar to @SessionAttribute, you can use the @RequestAttribute annotations to access pre-existing request attributes created earlier (for example, by a Servlet Filter or HandlerInterceptor): Java @GetMapping(\"/\") public String handle(@RequestAttribute Client client) { \u2460 \u00a0  // ... } \u2460 Using the @RequestAttribute annotation. Kotlin @GetMapping(\"/\") fun handle(@RequestAttribute client: Client): String { \u2460 \u00a0  // ... } \u2460 Using the @RequestAttribute annotation. Redirect Attributes By default, all model attributes are considered to be exposed as URI template variables in the 907", "chunk_char_count": 1192, "chunk_word_count": 158, "chunk_token_count": 298.0}, {"page_number": 908, "sentence_chunk": "redirect URL. Of the remaining attributes, those that are primitive types or collections or arrays of primitive types are automatically appended as query parameters. Appending primitive type attributes as query parameters can be the desired result if a model instance was prepared specifically for the redirect. However, in annotated controllers, the model can contain additional attributes added for rendering purposes (for example, drop-down field values). To avoid the possibility of having such attributes appear in the URL, a @RequestMapping method can declare an argument of type RedirectAttributes and use it to specify the exact attributes to make available to RedirectView. If the method does redirect, the content of RedirectAttributes is used. Otherwise, the content of the model is used. The RequestMappingHandlerAdapter provides a flag called ignoreDefaultModelOnRedirect, which you can use to indicate that the content of the default Model should never be used if a controller method redirects. Instead, the controller method should declare an attribute of type RedirectAttributes or, if it does not do so, no attributes should be passed on to RedirectView. Both the MVC namespace and the MVC Java configuration keep this flag set to false, to maintain backwards compatibility.", "chunk_char_count": 1291, "chunk_word_count": 193, "chunk_token_count": 322.75}, {"page_number": 908, "sentence_chunk": "However, for new applications, we recommend setting it to true. Note that URI template variables from the present request are automatically made available when expanding a redirect URL, and you don\u2019t need to explicitly add them through Model or RedirectAttributes. The following example shows how to define a redirect: Java @PostMapping(\"/files/{path}\") public String upload(...) { \u00a0  // ... \u00a0  return \"redirect:files/{path}\"; } Kotlin @PostMapping(\"/files/{path}\") fun upload(...): String { \u00a0  // ... \u00a0  return \"redirect:files/{path}\" } Another way of passing data to the redirect target is by using flash attributes. Unlike other redirect attributes, flash attributes are saved in the HTTP session (and, hence, do not appear in the URL). See Flash Attributes for more information. Flash Attributes Flash attributes provide a way for one request to store attributes that are intended for use in another. This is most commonly needed when redirecting\u2009\u2014\u2009for example, the Post-Redirect-Get pattern. Flash attributes are saved temporarily before the redirect (typically in the session) to be made available to the request after the redirect and are removed immediately.908", "chunk_char_count": 1169, "chunk_word_count": 176, "chunk_token_count": 292.25}, {"page_number": 909, "sentence_chunk": "Spring MVC has two main abstractions in support of flash attributes. FlashMap is used to hold flash attributes, while FlashMapManager is used to store, retrieve, and manage FlashMap instances. Flash attribute support is always \u201con\u201d and does not need to be enabled explicitly. However, if not used, it never causes HTTP session creation. On each request, there is an \u201cinput\u201d FlashMap with attributes passed from a previous request (if any) and an \u201coutput\u201d FlashMap with attributes to save for a subsequent request. Both FlashMap instances are accessible from anywhere in Spring MVC through static methods in RequestContextUtils. Annotated controllers typically do not need to work with FlashMap directly. Instead, a @RequestMapping method can accept an argument of type RedirectAttributes and use it to add flash attributes for a redirect scenario. Flash attributes added through RedirectAttributes are automatically propagated to the \u201coutput\u201d FlashMap. Similarly, after the redirect, attributes from the \u201cinput\u201d FlashMap are automatically added to the Model of the controller that serves the target URL.", "chunk_char_count": 1103, "chunk_word_count": 165, "chunk_token_count": 275.75}, {"page_number": 909, "sentence_chunk": "Matching requests to flash attributes The concept of flash attributes exists in many other web frameworks and has proven to sometimes be exposed to concurrency issues. This is because, by definition, flash attributes are to be stored until the next request. However the very \u201cnext\u201d request may not be the intended recipient but another asynchronous request (for example, polling or resource requests), in which case the flash attributes are removed too early. To reduce the possibility of such issues, RedirectView automatically \u201cstamps\u201d FlashMap instances with the path and query parameters of the target redirect URL. In turn, the default FlashMapManager matches that information to incoming requests when it looks up the \u201cinput\u201d FlashMap. This does not entirely eliminate the possibility of a concurrency issue but reduces it greatly with information that is already available in the redirect URL. Therefore, we recommend that you use flash attributes mainly for redirect scenarios. Multipart WebFlux After a MultipartResolver has been enabled, the content of POST requests with multipart/form-data is parsed and accessible as regular request parameters. The following example accesses one regular form field and one uploaded file: 909", "chunk_char_count": 1238, "chunk_word_count": 186, "chunk_token_count": 309.5}, {"page_number": 910, "sentence_chunk": "Java @Controller public class FileUploadController { \u00a0  @PostMapping(\"/form\") \u00a0  public String handleFormUpload(@RequestParam(\"name\") String name, \u00a0      @RequestParam(\"file\") MultipartFile file) { \u00a0    if (!file.isEmpty()) { \u00a0      byte[] bytes = file.getBytes(); \u00a0      // store the bytes somewhere \u00a0      return \"redirect:uploadSuccess\"; \u00a0    } \u00a0    return \"redirect:uploadFailure\"; \u00a0  } } Kotlin @Controller class FileUploadController { \u00a0  @PostMapping(\"/form\") \u00a0  fun handleFormUpload(@RequestParam(\"name\") name: String, \u00a0            @RequestParam(\"file\") file: MultipartFile): String { \u00a0    if (!file.isEmpty) { \u00a0      val bytes = file.bytes \u00a0      // store the bytes somewhere \u00a0      return \"redirect:uploadSuccess\" \u00a0    } \u00a0    return \"redirect:uploadFailure\" \u00a0  } } Declaring the argument type as a List<MultipartFile> allows for resolving multiple files for the same parameter name. When the @RequestParam annotation is declared as a Map<String, MultipartFile> or MultiValueMap<String, MultipartFile>, without a parameter name specified in the annotation, then the map is populated with the multipart files for each given parameter name.\uf05a With Servlet multipart parsing, you may also declare jakarta.servlet.http. Part instead of Spring\u2019s MultipartFile, as a method argument or collection value type. You can also use multipart content as part of data binding to a command object. For example, the form field and file from the preceding example could be fields on a form object, as the following example shows: 910", "chunk_char_count": 1523, "chunk_word_count": 272, "chunk_token_count": 380.75}, {"page_number": 911, "sentence_chunk": "Java class MyForm { \u00a0  private String name; \u00a0  private MultipartFile file; \u00a0  // ... } @Controller public class FileUploadController { \u00a0  @PostMapping(\"/form\") \u00a0  public String handleFormUpload(MyForm form, BindingResult errors) { \u00a0    if (!form.getFile().isEmpty()) { \u00a0      byte[] bytes = form.getFile().getBytes(); \u00a0      // store the bytes somewhere \u00a0      return \"redirect:uploadSuccess\"; \u00a0    } \u00a0    return \"redirect:uploadFailure\"; \u00a0  } } Kotlin class MyForm(val name: String, val file: MultipartFile, ...) @Controller class FileUploadController { \u00a0  @PostMapping(\"/form\") \u00a0  fun handleFormUpload(form: MyForm, errors: BindingResult): String { \u00a0    if (!form.file.isEmpty) { \u00a0      val bytes = form.file.bytes \u00a0      // store the bytes somewhere \u00a0      return \"redirect:uploadSuccess\" \u00a0    } \u00a0    return \"redirect:uploadFailure\" \u00a0  } } Multipart requests can also be submitted from non-browser clients in a RESTful service scenario. The following example shows a file with JSON: 911", "chunk_char_count": 989, "chunk_word_count": 186, "chunk_token_count": 247.25}, {"page_number": 912, "sentence_chunk": "POST /someUrl Content-Type: multipart/mixed --edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp Content-Disposition: form-data; name=\"meta-data\" Content-Type: application/json; charset=UTF-8 Content-Transfer-Encoding: 8bit { \u00a0  \"name\": \"value\" } --edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp Content-Disposition: form-data; name=\"file-data\"; filename=\"file.properties\" Content-Type: text/xml Content-Transfer-Encoding: 8bit ... File Data ... You can access the \"meta-data\" part with @RequestParam as a String but you\u2019ll probably want it deserialized from JSON (similar to @RequestBody). Use the @RequestPart annotation to access a multipart after converting it with an HttpMessageConverter: Java @PostMapping(\"/\") public String handle(@RequestPart(\"meta-data\") MetaData metadata, \u00a0    @RequestPart(\"file-data\") MultipartFile file) { \u00a0  // ... } Kotlin @PostMapping(\"/\") fun handle(@RequestPart(\"meta-data\") metadata: MetaData, \u00a0    @RequestPart(\"file-data\") file: MultipartFile): String { \u00a0  // ... } You can use @RequestPart in combination with jakarta.validation. Valid or use Spring\u2019s @Validated annotation, both of which cause Standard Bean Validation to be applied. By default, validation errors cause a MethodArgumentNotValidException, which is turned into a 400 (BAD_REQUEST) response. Alternatively, you can handle validation errors locally within the controller through an Errors or BindingResult argument, as the following example shows: 912", "chunk_char_count": 1435, "chunk_word_count": 169, "chunk_token_count": 358.75}, {"page_number": 913, "sentence_chunk": "Java @PostMapping(\"/\") public String handle(@Valid @RequestPart(\"meta-data\") MetaData metadata, \u00a0    BindingResult result) { \u00a0  // ... } Kotlin @PostMapping(\"/\") fun handle(@Valid @RequestPart(\"meta-data\") metadata: MetaData, \u00a0    result: BindingResult): String { \u00a0  // ... } @RequestBody WebFlux You can use the @RequestBody annotation to have the request body read and deserialized into an Object through an HttpMessageConverter. The following example uses a @RequestBody argument: Java @PostMapping(\"/accounts\") public void handle(@RequestBody Account account) { \u00a0  // ... } Kotlin @PostMapping(\"/accounts\") fun handle(@RequestBody account: Account) { \u00a0  // ... } You can use the Message Converters option of the MVC Config to configure or customize message conversion. You can use @RequestBody in combination with jakarta.validation. Valid or Spring\u2019s @Validated annotation, both of which cause Standard Bean Validation to be applied. By default, validation errors cause a MethodArgumentNotValidException, which is turned into a 400 (BAD_REQUEST) response. Alternatively, you can handle validation errors locally within the controller through an Errors or BindingResult argument, as the following example shows: 913", "chunk_char_count": 1219, "chunk_word_count": 171, "chunk_token_count": 304.75}, {"page_number": 914, "sentence_chunk": "Java @PostMapping(\"/accounts\") public void handle(@Valid @RequestBody Account account, BindingResult result) { \u00a0  // ... } Kotlin @PostMapping(\"/accounts\") fun handle(@Valid @RequestBody account: Account, result: BindingResult) { \u00a0  // ... } HttpEntity WebFlux HttpEntity is more or less identical to using @RequestBody but is based on a container object that exposes request headers and body. The following listing shows an example: Java @PostMapping(\"/accounts\") public void handle(HttpEntity<Account> entity) { \u00a0  // ... } Kotlin @PostMapping(\"/accounts\") fun handle(entity: HttpEntity<Account>) { \u00a0  // ... } @ResponseBody WebFlux You can use the @ResponseBody annotation on a method to have the return serialized to the response body through an HttpMessageConverter. The following listing shows an example: Java @GetMapping(\"/accounts/{id}\") @ResponseBody public Account handle() { \u00a0  // ... } 914", "chunk_char_count": 902, "chunk_word_count": 126, "chunk_token_count": 225.5}, {"page_number": 915, "sentence_chunk": "Kotlin @GetMapping(\"/accounts/{id}\") @ResponseBody fun handle(): Account { \u00a0  // ... } @ResponseBody is also supported at the class level, in which case it is inherited by all controller methods. This is the effect of @RestController, which is nothing more than a meta-annotation marked with @Controller and @ResponseBody. You can use @ResponseBody with reactive types. See Asynchronous Requests and Reactive Types for more details. You can use the Message Converters option of the MVC Config to configure or customize message conversion. You can combine @ResponseBody methods with JSON serialization views. See Jackson JSON for details. ResponseEntity WebFlux ResponseEntity is like @ResponseBody but with status and headers. For example: Java @GetMapping(\"/something\") public ResponseEntity<String> handle() { \u00a0  String body = ... ; \u00a0  String etag = ... ; \u00a0  return ResponseEntity.ok().eTag(etag).body(body); } Kotlin @GetMapping(\"/something\") fun handle(): ResponseEntity<String> { \u00a0  val body = ... \u00a0  val etag = ... \u00a0  return ResponseEntity.ok().eTag(etag).build(body) } Spring MVC supports using a single value reactive type to produce the ResponseEntity asynchronously, and/or single and multi-value reactive types for the body. This allows the following types of async responses: \u2022 ResponseEntity<Mono<T>> or ResponseEntity<Flux<T>> make the response status and headers 915", "chunk_char_count": 1381, "chunk_word_count": 198, "chunk_token_count": 345.25}, {"page_number": 916, "sentence_chunk": "known immediately while the body is provided asynchronously at a later point. Use Mono if the body consists of 0..1 values or Flux if it can produce multiple values. \u2022Mono<ResponseEntity<T>> provides all three\u2009\u2014\u2009response status, headers, and body, asynchronously at a later point. This allows the response status and headers to vary depending on the outcome of asynchronous request handling. Jackson JSON Spring offers support for the Jackson JSON library. JSON Views WebFlux Spring MVC provides built-in support for Jackson\u2019s Serialization Views, which allow rendering only a subset of all fields in an Object. To use it with @ResponseBody or ResponseEntity controller methods, you can use Jackson\u2019s @JsonView annotation to activate a serialization view class, as the following example shows: 916", "chunk_char_count": 797, "chunk_word_count": 120, "chunk_token_count": 199.25}, {"page_number": 917, "sentence_chunk": "Java @RestController public class UserController { \u00a0  @GetMapping(\"/user\") \u00a0  @JsonView(User. WithoutPasswordView.class) \u00a0  public User getUser() { \u00a0    return new User(\"eric\", \"7!jd#h23\"); \u00a0  } } public class User { \u00a0  public interface WithoutPasswordView {}; \u00a0  public interface WithPasswordView extends WithoutPasswordView {}; \u00a0  private String username; \u00a0  private String password; \u00a0  public User() { \u00a0  } \u00a0  public User(String username, String password) { \u00a0    this.username = username; \u00a0    this.password = password; \u00a0  } \u00a0  @JsonView(WithoutPasswordView.class) \u00a0  public String getUsername() { \u00a0    return this.username; \u00a0  } \u00a0  @JsonView(WithPasswordView.class) \u00a0  public String getPassword() { \u00a0    return this.password; \u00a0  } } 917", "chunk_char_count": 740, "chunk_word_count": 130, "chunk_token_count": 185.0}, {"page_number": 918, "sentence_chunk": "Kotlin @RestController class UserController { \u00a0  @GetMapping(\"/user\") \u00a0  @JsonView(User. WithoutPasswordView::class) \u00a0  fun getUser() = User(\"eric\", \"7!jd#h23\") } class User( \u00a0    @JsonView(WithoutPasswordView::class) val username: String, \u00a0    @JsonView(WithPasswordView::class) val password: String) { \u00a0  interface WithoutPasswordView \u00a0  interface WithPasswordView : WithoutPasswordView } \uf05a @JsonView allows an array of view classes, but you can specify only one per controller method. If you need to activate multiple views, you can use a composite interface. If you want to do the above programmatically, instead of declaring an @JsonView annotation, wrap the return value with MappingJacksonValue and use it to supply the serialization view: Java @RestController public class UserController { \u00a0  @GetMapping(\"/user\") \u00a0  public MappingJacksonValue getUser() { \u00a0    User user = new User(\"eric\", \"7!jd#h23\"); \u00a0    MappingJacksonValue value = new MappingJacksonValue(user); \u00a0    value.setSerializationView(User. WithoutPasswordView.class); \u00a0    return value; \u00a0  } } 918", "chunk_char_count": 1070, "chunk_word_count": 159, "chunk_token_count": 267.5}, {"page_number": 919, "sentence_chunk": "Kotlin @RestController class UserController { \u00a0  @GetMapping(\"/user\") \u00a0  fun getUser(): MappingJacksonValue { \u00a0    val value = MappingJacksonValue(User(\"eric\", \"7!jd#h23\")) \u00a0    value.serializationView = User. WithoutPasswordView::class.java \u00a0    return value \u00a0  } } For controllers that rely on view resolution, you can add the serialization view class to the model, as the following example shows: Java @Controller public class UserController extends AbstractController { \u00a0  @GetMapping(\"/user\") \u00a0  public String getUser(Model model) { \u00a0    model.addAttribute(\"user\", new User(\"eric\", \"7!jd#h23\")); \u00a0    model.addAttribute(JsonView.class.getName(), User. WithoutPasswordView.class); \u00a0    return \"userView\"; \u00a0  } } Kotlin import org.springframework.ui.set @Controller class UserController : AbstractController() { \u00a0  @GetMapping(\"/user\") \u00a0  fun getUser(model: Model): String { \u00a0    model[\"user\"] = User(\"eric\", \"7!jd#h23\") \u00a0    model[JsonView::class.qualifiedName] = User. WithoutPasswordView::class.java \u00a0    return \"userView\" \u00a0  } } Model WebFlux You can use the @ModelAttribute annotation: 919", "chunk_char_count": 1097, "chunk_word_count": 160, "chunk_token_count": 274.25}, {"page_number": 920, "sentence_chunk": "\u2022 On a method argument in @RequestMapping methods to create or access an Object from the model and to bind it to the request through a WebDataBinder. \u2022As a method-level annotation in @Controller or @ControllerAdvice classes that help to initialize the model prior to any @RequestMapping method invocation. \u2022On a @RequestMapping method to mark its return value is a model attribute. This section discusses @ModelAttribute methods\u2009\u2014\u2009the second item in the preceding list. A controller can have any number of @ModelAttribute methods. All such methods are invoked before @RequestMapping methods in the same controller. A @ModelAttribute method can also be shared across controllers through @ControllerAdvice. See the section on Controller Advice for more details.@ModelAttribute methods have flexible method signatures. They support many of the same arguments as @RequestMapping methods, except for @ModelAttribute itself or anything related to the request body.", "chunk_char_count": 958, "chunk_word_count": 139, "chunk_token_count": 239.5}, {"page_number": 920, "sentence_chunk": "The following example shows a @ModelAttribute method: Java @ModelAttribute public void populateModel(@RequestParam String number, Model model) { \u00a0  model.addAttribute(accountRepository.findAccount(number)); \u00a0  // add more ... } Kotlin @ModelAttribute fun populateModel(@RequestParam number: String, model: Model) { \u00a0  model.addAttribute(accountRepository.findAccount(number)) \u00a0  // add more ... } The following example adds only one attribute: Java @ModelAttribute public Account addAccount(@RequestParam String number) { \u00a0  return accountRepository.findAccount(number); } 920", "chunk_char_count": 576, "chunk_word_count": 67, "chunk_token_count": 144.0}, {"page_number": 921, "sentence_chunk": "Kotlin @ModelAttribute fun addAccount(@RequestParam number: String): Account { \u00a0  return accountRepository.findAccount(number) } \uf05a When a name is not explicitly specified, a default name is chosen based on the Object type, as explained in the javadoc for Conventions. You can always assign an explicit name by using the overloaded addAttribute method or through the name attribute on @ModelAttribute (for a return value). You can also use @ModelAttribute as a method-level annotation on @RequestMapping methods, in which case the return value of the @RequestMapping method is interpreted as a model attribute. This is typically not required, as it is the default behavior in HTML controllers, unless the return value is a String that would otherwise be interpreted as a view name.@ModelAttribute can also customize the model attribute name, as the following example shows: Java @GetMapping(\"/accounts/{id}\") @ModelAttribute(\"myAccount\") public Account handle() { \u00a0  // ... \u00a0  return account; } Kotlin @GetMapping(\"/accounts/{id}\") @ModelAttribute(\"myAccount\") fun handle(): Account { \u00a0  // ... \u00a0  return account } DataBinder WebFlux @Controller or @ControllerAdvice classes can have @InitBinder methods that initialize instances of WebDataBinder, and those, in turn, can: \u2022 Bind request parameters (that is, form or query data) to a model object. \u2022Convert String-based request values (such as request parameters, path variables, headers, cookies, and others) to the target type of controller method arguments. \u2022Format model object values as String values when rendering HTML forms.921", "chunk_char_count": 1584, "chunk_word_count": 231, "chunk_token_count": 396.0}, {"page_number": 922, "sentence_chunk": "@InitBinder methods can register controller-specific java.beans. PropertyEditor or Spring Converter and Formatter components. In addition, you can use the MVC config to register Converter and Formatter types in a globally shared FormattingConversionService.@InitBinder methods support many of the same arguments that @RequestMapping methods do, except for @ModelAttribute (command object) arguments. Typically, they are declared with a WebDataBinder argument (for registrations) and a void return value. The following listing shows an example: Java @Controller public class FormController { \u00a0  @InitBinder \u2460 \u00a0  public void initBinder(WebDataBinder binder) { \u00a0    SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\"); \u00a0    dateFormat.setLenient(false); \u00a0    binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false)); \u00a0  } \u00a0  // ... } \u2460 Defining an @InitBinder method. Kotlin @Controller class FormController { \u00a0  @InitBinder \u2460 \u00a0  fun initBinder(binder: WebDataBinder) { \u00a0    val dateFormat = SimpleDateFormat(\"yyyy-MM-dd\") \u00a0    dateFormat.isLenient = false \u00a0    binder.registerCustomEditor(Date::class.java, CustomDateEditor(dateFormat, false)) \u00a0  } \u00a0  // ... } \u2460 Defining an @InitBinder method. Alternatively, when you use a Formatter-based setup through a shared FormattingConversionService, you can re-use the same approach and register controller-specific Formatter implementations, as the following example shows: 922", "chunk_char_count": 1456, "chunk_word_count": 200, "chunk_token_count": 364.0}, {"page_number": 923, "sentence_chunk": "Java @Controller public class FormController { \u00a0  @InitBinder \u2460 \u00a0  protected void initBinder(WebDataBinder binder) { \u00a0    binder.addCustomFormatter(new DateFormatter(\"yyyy-MM-dd\")); \u00a0  } \u00a0  // ... } \u2460 Defining an @InitBinder method on a custom formatter. Kotlin @Controller class FormController { \u00a0  @InitBinder \u2460 \u00a0  protected fun initBinder(binder: WebDataBinder) { \u00a0    binder.addCustomFormatter(DateFormatter(\"yyyy-MM-dd\")) \u00a0  } \u00a0  // ... } \u2460 Defining an @InitBinder method on a custom formatter. Model Design WebFlux In the context of web applications, data binding involves the binding of HTTP request parameters (that is, form data or query parameters) to properties in a model object and its nested objects. Only public properties following the JavaBeans naming conventions are exposed for data binding \u2014 for example, public String getFirstName() and public void setFirstName(String) methods for a firstName property.\uf0eb The model object, and its nested object graph, is also sometimes referred to as a command object, form-backing object, or POJO (Plain Old Java Object). By default, Spring permits binding to all public properties in the model object graph. This means you need to carefully consider what public properties the model has, since a client could target any public property path, even some that are not expected to be targeted for a given use case. For example, given an HTTP form data endpoint, a malicious client could supply values for properties that exist in the model object graph but are not part of the HTML form presented in the 923", "chunk_char_count": 1560, "chunk_word_count": 251, "chunk_token_count": 390.0}, {"page_number": 924, "sentence_chunk": "browser. This could lead to data being set on the model object and any of its nested objects, that is not expected to be updated. The recommended approach is to use a dedicated model object that exposes only properties that are relevant for the form submission. For example, on a form for changing a user\u2019s email address, the model object should declare a minimum set of properties such as in the following ChangeEmailForm.public class ChangeEmailForm { \u00a0  private String oldEmailAddress; \u00a0  private String newEmailAddress; \u00a0  public void setOldEmailAddress(String oldEmailAddress) { \u00a0    this.oldEmailAddress = oldEmailAddress; \u00a0  } \u00a0  public String getOldEmailAddress() { \u00a0    return this.oldEmailAddress; \u00a0  } \u00a0  public void setNewEmailAddress(String newEmailAddress) { \u00a0    this.newEmailAddress = newEmailAddress; \u00a0  } \u00a0  public String getNewEmailAddress() { \u00a0    return this.newEmailAddress; \u00a0  } } If you cannot or do not want to use a dedicated model object for each data binding use case, you must limit the properties that are allowed for data binding. Ideally, you can achieve this by registering allowed field patterns via the setAllowedFields() method on WebDataBinder. For example, to register allowed field patterns in your application, you can implement an @InitBinder method in a @Controller or @ControllerAdvice component as shown below: @Controller public class ChangeEmailController { \u00a0  @InitBinder \u00a0  void initBinder(WebDataBinder binder) { \u00a0    binder.setAllowedFields(\"oldEmailAddress\", \"newEmailAddress\"); \u00a0  } \u00a0  // @RequestMapping methods, etc. }924", "chunk_char_count": 1575, "chunk_word_count": 252, "chunk_token_count": 393.75}, {"page_number": 925, "sentence_chunk": "In addition to registering allowed patterns, it is also possible to register disallowed field patterns via the setDisallowedFields() method in DataBinder and its subclasses. Please note, however, that an \"allow list\" is safer than a \"deny list\". Consequently, setAllowedFields() should be favored over setDisallowedFields(). Note that matching against allowed field patterns is case-sensitive; whereas, matching against disallowed field patterns is case-insensitive. In addition, a field matching a disallowed pattern will not be accepted even if it also happens to match a pattern in the allowed list.\uf071 It is extremely important to properly configure allowed and disallowed field patterns when exposing your domain model directly for data binding purposes. Otherwise, it is a big security risk. Furthermore, it is strongly recommended that you do not use types from your domain model such as JPA or Hibernate entities as the model object in data binding scenarios. Exceptions WebFlux @Controller and @ControllerAdvice classes can have @ExceptionHandler methods to handle exceptions from controller methods, as the following example shows: Java @Controller public class SimpleController { \u00a0  // ... \u00a0  @ExceptionHandler \u00a0  public ResponseEntity<String> handle(IOException ex) { \u00a0    // ... \u00a0  } } Kotlin @Controller class SimpleController { \u00a0  // ... \u00a0  @ExceptionHandler \u00a0  fun handle(ex: IOException): ResponseEntity<String> { \u00a0    // ... \u00a0  } } 925", "chunk_char_count": 1451, "chunk_word_count": 225, "chunk_token_count": 362.75}, {"page_number": 926, "sentence_chunk": "The exception may match against a top-level exception being propagated (e.g. a direct IOException being thrown) or against a nested cause within a wrapper exception (e.g. an IOException wrapped inside an IllegalStateException). As of 5.3, this can match at arbitrary cause levels, whereas previously only an immediate cause was considered. For matching exception types, preferably declare the target exception as a method argument, as the preceding example shows. When multiple exception methods match, a root exception match is generally preferred to a cause exception match. More specifically, the ExceptionDepthComparator is used to sort exceptions based on their depth from the thrown exception type. Alternatively, the annotation declaration may narrow the exception types to match, as the following example shows: Java @ExceptionHandler({FileSystemException.class, RemoteException.class}) public ResponseEntity<String> handle(IOException ex) { \u00a0  // ... } Kotlin @ExceptionHandler(FileSystemException::class, RemoteException::class) fun handle(ex: IOException): ResponseEntity<String> { \u00a0  // ... } You can even use a list of specific exception types with a very generic argument signature, as the following example shows: Java @ExceptionHandler({FileSystemException.class, RemoteException.class}) public ResponseEntity<String> handle(Exception ex) { \u00a0  // ... } Kotlin @ExceptionHandler(FileSystemException::class, RemoteException::class) fun handle(ex: Exception): ResponseEntity<String> { \u00a0  // ... } 926", "chunk_char_count": 1513, "chunk_word_count": 193, "chunk_token_count": 378.25}, {"page_number": 927, "sentence_chunk": "\uf05a The distinction between root and cause exception matching can be surprising. In the IOException variant shown earlier, the method is typically called with the actual FileSystemException or RemoteException instance as the argument, since both of them extend from IOException. However, if any such matching exception is propagated within a wrapper exception which is itself an IOException, the passed- in exception instance is that wrapper exception. The behavior is even simpler in the handle(Exception) variant. This is always invoked with the wrapper exception in a wrapping scenario, with the actually matching exception to be found through ex.getCause() in that case. The passed-in exception is the actual FileSystemException or RemoteException instance only when these are thrown as top-level exceptions. We generally recommend that you be as specific as possible in the argument signature, reducing the potential for mismatches between root and cause exception types. Consider breaking a multi- matching method into individual @ExceptionHandler methods, each matching a single specific exception type through its signature. In a multi-@ControllerAdvice arrangement, we recommend declaring your primary root exception mappings on a @ControllerAdvice prioritized with a corresponding order. While a root exception match is preferred to a cause, this is defined among the methods of a given controller or @ControllerAdvice class.", "chunk_char_count": 1433, "chunk_word_count": 206, "chunk_token_count": 358.25}, {"page_number": 927, "sentence_chunk": "This means a cause match on a higher-priority @ControllerAdvice bean is preferred to any match (for example, root) on a lower-priority @ControllerAdvice bean. Last but not least, an @ExceptionHandler method implementation can choose to back out of dealing with a given exception instance by rethrowing it in its original form. This is useful in scenarios where you are interested only in root-level matches or in matches within a specific context that cannot be statically determined. A rethrown exception is propagated through the remaining resolution chain, as though the given @ExceptionHandler method would not have matched in the first place. Support for @ExceptionHandler methods in Spring MVC is built on the DispatcherServlet level, HandlerExceptionResolver mechanism. Method Arguments WebFlux @ExceptionHandler methods support the following arguments: Method argument Description Exception type For access to the raised exception. HandlerMethod For access to the controller method that raised the exception. WebRequest, NativeWebRequest Generic access to request parameters and request and session attributes without direct use of the Servlet API.927", "chunk_char_count": 1159, "chunk_word_count": 164, "chunk_token_count": 289.75}, {"page_number": 928, "sentence_chunk": "Method argument Description jakarta.servlet. ServletRequest, jakarta.servlet. ServletRespons e Choose any specific request or response type (for example, ServletRequest or HttpServletRequest or Spring\u2019s MultipartRequest or MultipartHttpServletRequest).jakarta.servlet.http. HttpSessi on Enforces the presence of a session. As a consequence, such an argument is never null. Note that session access is not thread-safe. Consider setting the RequestMappingHandlerAdapter instance\u2019s synchronizeOnSession flag to true if multiple requests are allowed to access a session concurrently.java.security. Principal Currently authenticated user\u2009\u2014\u2009possibly a specific Principal implementation class if known.", "chunk_char_count": 695, "chunk_word_count": 79, "chunk_token_count": 173.75}, {"page_number": 928, "sentence_chunk": "HttpMethod The HTTP method of the request.java.util. Locale The current request locale, determined by the most specific LocaleResolver available\u2009\u2014\u2009in effect, the configured LocaleResolver or LocaleContextResolver.java.util. TimeZone, java.time. ZoneId The time zone associated with the current request, as determined by a LocaleContextResolver.java.io. OutputStream, java.io. Writer For access to the raw response body, as exposed by the Servlet API.java.util.", "chunk_char_count": 460, "chunk_word_count": 57, "chunk_token_count": 115.0}, {"page_number": 928, "sentence_chunk": "Map, org.springframework.ui. Model, org.springframework.ui. ModelMa p For access to the model for an error response. Always empty. RedirectAttributes Specify attributes to use in case of a redirect\u2009\u2014\u2009(that is to be appended to the query string) and flash attributes to be stored temporarily until the request after the redirect. See Redirect Attributes and Flash Attributes.@SessionAttribute For access to any session attribute, in contrast to model attributes stored in the session as a result of a class-level @SessionAttributes declaration. See @SessionAttribute for more details.@RequestAttribute For access to request attributes. See @RequestAttribute for more details.", "chunk_char_count": 674, "chunk_word_count": 92, "chunk_token_count": 168.5}, {"page_number": 928, "sentence_chunk": "Return Values WebFlux @ExceptionHandler methods support the following return values: Return value Description @ResponseBody The return value is converted through HttpMessageConverter instances and written to the response. See @ResponseBody.928", "chunk_char_count": 243, "chunk_word_count": 29, "chunk_token_count": 60.75}, {"page_number": 929, "sentence_chunk": "Return value Description HttpEntity<B>, ResponseEntity<B> The return value specifies that the full response (including the HTTP headers and the body) be converted through HttpMessageConverter instances and written to the response. See ResponseEntity. ErrorResponse To render an RFC 7807 error response with details in the body, see Error Responses ProblemDetail To render an RFC 7807 error response with details in the body, see Error Responses String A view name to be resolved with ViewResolver implementations and used together with the implicit model\u2009\u2014\u2009determined through command objects and @ModelAttribute methods. The handler method can also programmatically enrich the model by declaring a Model argument (described earlier). View A View instance to use for rendering together with the implicit model\u2009\u2014\u2009determined through command objects and @ModelAttribute methods. The handler method may also programmatically enrich the model by declaring a Model argument (descried earlier).java.util. Map, org.springframework.ui. Model Attributes to be added to the implicit model with the view name implicitly determined through a RequestToViewNameTranslator.@ModelAttribute An attribute to be added to the model with the view name implicitly determined through a RequestToViewNameTranslator.", "chunk_char_count": 1289, "chunk_word_count": 175, "chunk_token_count": 322.25}, {"page_number": 929, "sentence_chunk": "Note that @ModelAttribute is optional. See \u201cAny other return value\u201d at the end of this table. ModelAndView object The view and model attributes to use and, optionally, a response status.void A method with a void return type (or null return value) is considered to have fully handled the response if it also has a ServletResponse an OutputStream argument, or a @ResponseStatus annotation. The same is also true if the controller has made a positive ETag or lastModified timestamp check (see Controllers for details). If none of the above is true, a void return type can also indicate \u201cno response body\u201d for REST controllers or default view name selection for HTML controllers. Any other return value If a return value is not matched to any of the above and is not a simple type (as determined by BeanUtils#isSimpleProperty), by default, it is treated as a model attribute to be added to the model. If it is a simple type, it remains unresolved.929", "chunk_char_count": 946, "chunk_word_count": 161, "chunk_token_count": 236.5}, {"page_number": 930, "sentence_chunk": "Controller Advice WebFlux @ExceptionHandler, @InitBinder, and @ModelAttribute methods apply only to the @Controller class, or class hierarchy, in which they are declared. If, instead, they are declared in an @ControllerAdvice or @RestControllerAdvice class, then they apply to any controller. Moreover, as of 5.3, @ExceptionHandler methods in @ControllerAdvice can be used to handle exceptions from any @Controller or any other handler.@ControllerAdvice is meta-annotated with @Component and therefore can be registered as a Spring bean through component scanning. @RestControllerAdvice is meta-annotated with @ControllerAdvice and @ResponseBody, and that means @ExceptionHandler methods will have their return value rendered via response body message conversion, rather than via HTML views. On startup, RequestMappingHandlerMapping and ExceptionHandlerExceptionResolver detect controller advice beans and apply them at runtime. Global @ExceptionHandler methods, from an @ControllerAdvice, are applied after local ones, from the @Controller. By contrast, global @ModelAttribute and @InitBinder methods are applied before local ones. The @ControllerAdvice annotation has attributes that let you narrow the set of controllers and handlers that they apply to. For example: Java // Target all Controllers annotated with @RestController @ControllerAdvice(annotations = RestController.class) public class ExampleAdvice1 {} // Target all Controllers within specific packages @ControllerAdvice(\"org.example.controllers\") public class ExampleAdvice2 {} // Target all Controllers assignable to specific classes @ControllerAdvice(assignableTypes = {ControllerInterface.class, AbstractController.class}) public class ExampleAdvice3 {} 930", "chunk_char_count": 1726, "chunk_word_count": 209, "chunk_token_count": 431.5}, {"page_number": 931, "sentence_chunk": "Kotlin // Target all Controllers annotated with @RestController @ControllerAdvice(annotations = [RestController::class]) class ExampleAdvice1 // Target all Controllers within specific packages @ControllerAdvice(\"org.example.controllers\") class ExampleAdvice2 // Target all Controllers assignable to specific classes @ControllerAdvice(assignableTypes = [ControllerInterface::class, AbstractController::class]) class ExampleAdvice3 The selectors in the preceding example are evaluated at runtime and may negatively impact performance if used extensively. See the @ControllerAdvice javadoc for more details.5.1.4. Functional Endpoints WebFlux Spring Web MVC includes WebMvc.fn, a lightweight functional programming model in which functions are used to route and handle requests and contracts are designed for immutability. It is an alternative to the annotation-based programming model but otherwise runs on the same DispatcherServlet. Overview WebFlux In WebMvc.fn, an HTTP request is handled with a HandlerFunction: a function that takes ServerRequest and returns a ServerResponse. Both the request and the response object have immutable contracts that offer JDK 8-friendly access to the HTTP request and response. HandlerFunction is the equivalent of the body of a @RequestMapping method in the annotation-based programming model. Incoming requests are routed to a handler function with a RouterFunction: a function that takes ServerRequest and returns an optional HandlerFunction (i.e. Optional<HandlerFunction>). When the router function matches, a handler function is returned; otherwise an empty Optional.", "chunk_char_count": 1609, "chunk_word_count": 202, "chunk_token_count": 402.25}, {"page_number": 931, "sentence_chunk": "RouterFunction is the equivalent of a @RequestMapping annotation, but with the major difference that router functions provide not just data, but also behavior. RouterFunctions.route() provides a router builder that facilitates the creation of routers, as the following example shows: 931", "chunk_char_count": 287, "chunk_word_count": 40, "chunk_token_count": 71.75}, {"page_number": 932, "sentence_chunk": "Java import static org.springframework.http. MediaType. APPLICATION_JSON; import static org.springframework.web.servlet.function. RequestPredicates.*;import static org.springframework.web.servlet.function. RouterFunctions.route; PersonRepository repository = ... PersonHandler handler = new PersonHandler(repository); RouterFunction<ServerResponse> route = route() \u00a0  . GET(\"/person/{id}\", accept(APPLICATION_JSON), handler::getPerson) \u00a0  . GET(\"/person\", accept(APPLICATION_JSON), handler::listPeople) \u00a0  . POST(\"/person\", handler::createPerson) \u00a0  .build(); public class PersonHandler { \u00a0  // ... \u00a0  public ServerResponse listPeople(ServerRequest request) { \u00a0    // ... \u00a0  } \u00a0  public ServerResponse createPerson(ServerRequest request) { \u00a0    // ... \u00a0  } \u00a0  public ServerResponse getPerson(ServerRequest request) { \u00a0    // ... \u00a0  } } 932", "chunk_char_count": 839, "chunk_word_count": 104, "chunk_token_count": 209.75}, {"page_number": 933, "sentence_chunk": "Kotlin import org.springframework.web.servlet.function.router val repository: PersonRepository = ... val handler = PersonHandler(repository) val route = router { \u2460 \u00a0  accept(APPLICATION_JSON).nest { \u00a0    GET(\"/person/{id}\", handler::getPerson) \u00a0    GET(\"/person\", handler::listPeople) \u00a0  } \u00a0  POST(\"/person\", handler::createPerson) } class PersonHandler(private val repository: PersonRepository) { \u00a0  // ... \u00a0  fun listPeople(request: ServerRequest): ServerResponse { \u00a0    // ... \u00a0  } \u00a0  fun createPerson(request: ServerRequest): ServerResponse { \u00a0    // ... \u00a0  } \u00a0  fun getPerson(request: ServerRequest): ServerResponse { \u00a0    // ... \u00a0  } } \u2460 Create router using the router DSL. If you register the RouterFunction as a bean, for instance by exposing it in a @Configuration class, it will be auto-detected by the servlet, as explained in Running a Server. HandlerFunction WebFlux ServerRequest and ServerResponse are immutable interfaces that offer JDK 8-friendly access to the HTTP request and response, including headers, body, method, and status code. ServerRequest ServerRequest provides access to the HTTP method, URI, headers, and query parameters, while access to the body is provided through the body methods. The following example extracts the request body to a String: 933", "chunk_char_count": 1282, "chunk_word_count": 199, "chunk_token_count": 320.5}, {"page_number": 934, "sentence_chunk": "Java String string = request.body(String.class); Kotlin val string = request.body<String>() The following example extracts the body to a List<Person>, where Person objects are decoded from a serialized form, such as JSON or XML: Java List<Person> people = request.body(new ParameterizedTypeReference<List<Person>>() {}); Kotlin val people = request.body<Person>() The following example shows how to access parameters: Java MultiValueMap<String, String> params = request.params(); Kotlin val map = request.params() ServerResponse ServerResponse provides access to the HTTP response and, since it is immutable, you can use a build method to create it. You can use the builder to set the response status, to add response headers, or to provide a body. The following example creates a 200 (OK) response with JSON content: Java Person person = ... ServerResponse.ok().contentType(MediaType. APPLICATION_JSON).body(person); Kotlin val person: Person = ... ServerResponse.ok().contentType(MediaType. APPLICATION_JSON).body(person) The following example shows how to build a 201 (CREATED) response with a Location header and 934", "chunk_char_count": 1120, "chunk_word_count": 148, "chunk_token_count": 280.0}, {"page_number": 935, "sentence_chunk": "no body: Java URI location = ... ServerResponse.created(location).build(); Kotlin val location: URI = ... ServerResponse.created(location).build() You can also use an asynchronous result as the body, in the form of a CompletableFuture, Publisher, or any other type supported by the ReactiveAdapterRegistry. For instance: Java Mono<Person> person = webClient.get().retrieve().bodyToMono(Person.class); ServerResponse.ok().contentType(MediaType. APPLICATION_JSON).body(person); Kotlin val person = webClient.get().retrieve().awaitBody<Person>() ServerResponse.ok().contentType(MediaType. APPLICATION_JSON).body(person) If not just the body, but also the status or headers are based on an asynchronous type, you can use the static async method on ServerResponse, which accepts CompletableFuture<ServerResponse>, Publisher<ServerResponse>, or any other asynchronous type supported by the ReactiveAdapterRegistry. For instance: Java Mono<ServerResponse> asyncResponse = webClient.get().retrieve().bodyToMono(Person.class) \u00a0 .map(p -> ServerResponse.ok().header(\"Name\", p.name()).body(p)); ServerResponse.async(asyncResponse); Server-Sent Events can be provided via the static sse method on ServerResponse. The builder provided by that method allows you to send Strings, or other objects as JSON. For example: 935", "chunk_char_count": 1307, "chunk_word_count": 139, "chunk_token_count": 326.75}, {"page_number": 936, "sentence_chunk": "Java public RouterFunction<ServerResponse> sse() { \u00a0  return route(GET(\"/sse\"), request -> ServerResponse.sse(sseBuilder -> { \u00a0        // Save the sseBuilder object somewhere.. \u00a0      })); } // In some other thread, sending a String sseBuilder.send(\"Hello world\"); // Or an object, which will be transformed into JSON Person person = ... sseBuilder.send(person); // Customize the event by using the other methods sseBuilder.id(\"42\") \u00a0    .event(\"sse event\") \u00a0    .data(person); // and done at some point sseBuilder.complete(); Kotlin fun sse(): RouterFunction<ServerResponse> = router { \u00a0  GET(\"/sse\") { request -> ServerResponse.sse { sseBuilder -> \u00a0    // Save the sseBuilder object somewhere.. \u00a0  } } // In some other thread, sending a String sseBuilder.send(\"Hello world\") // Or an object, which will be transformed into JSON val person = ... sseBuilder.send(person) // Customize the event by using the other methods sseBuilder.id(\"42\") \u00a0    .event(\"sse event\") \u00a0    .data(person) // and done at some point sseBuilder.complete() Handler Classes We can write a handler function as a lambda, as the following example shows: 936", "chunk_char_count": 1129, "chunk_word_count": 190, "chunk_token_count": 282.25}, {"page_number": 937, "sentence_chunk": "Java HandlerFunction<ServerResponse> helloWorld = \u00a0 request -> ServerResponse.ok().body(\"Hello World\"); Kotlin val helloWorld: (ServerRequest) -> ServerResponse = \u00a0 { ServerResponse.ok().body(\"Hello World\") } That is convenient, but in an application we need multiple functions, and multiple inline lambda\u2019s can get messy. Therefore, it is useful to group related handler functions together into a handler class, which has a similar role as @Controller in an annotation-based application. For example, the following class exposes a reactive Person repository: 937", "chunk_char_count": 563, "chunk_word_count": 75, "chunk_token_count": 140.75}, {"page_number": 938, "sentence_chunk": "Java import static org.springframework.http. MediaType. APPLICATION_JSON; import static org.springframework.web.reactive.function.server. ServerResponse.ok; public class PersonHandler { \u00a0  private final PersonRepository repository; \u00a0  public PersonHandler(PersonRepository repository) { \u00a0    this.repository = repository; \u00a0  } \u00a0  public ServerResponse listPeople(ServerRequest request) { \u2460 \u00a0    List<Person> people = repository.allPeople(); \u00a0    return ok().contentType(APPLICATION_JSON).body(people); \u00a0  } \u00a0  public ServerResponse createPerson(ServerRequest request) throws Exception { \u2461 \u00a0    Person person = request.body(Person.class); \u00a0    repository.savePerson(person); \u00a0    return ok().build(); \u00a0  } \u00a0  public ServerResponse getPerson(ServerRequest request) { \u2462 \u00a0    int personId = Integer.parseInt(request.pathVariable(\"id\")); \u00a0    Person person = repository.getPerson(personId); \u00a0    if (person != null) { \u00a0      return ok().contentType(APPLICATION_JSON).body(person); \u00a0    } \u00a0    else { \u00a0      return ServerResponse.notFound().build(); \u00a0    } \u00a0  } } \u2460 listPeople is a handler function that returns all Person objects found in the repository as JSON.\u2461 createPerson is a handler function that stores a new Person contained in the request body.\u2462 getPerson is a handler function that returns a single person, identified by the id path variable. We retrieve that Person from the repository and create a JSON response, if it is found. If it is not found, we return a 404 Not Found response.938", "chunk_char_count": 1495, "chunk_word_count": 238, "chunk_token_count": 373.75}, {"page_number": 939, "sentence_chunk": "Kotlin class PersonHandler(private val repository: PersonRepository) { \u00a0  fun listPeople(request: ServerRequest): ServerResponse { \u2460 \u00a0    val people: List<Person> = repository.allPeople() \u00a0    return ok().contentType(APPLICATION_JSON).body(people); \u00a0  } \u00a0  fun createPerson(request: ServerRequest): ServerResponse { \u2461 \u00a0    val person = request.body<Person>() \u00a0    repository.savePerson(person) \u00a0    return ok().build() \u00a0  } \u00a0  fun getPerson(request: ServerRequest): ServerResponse { \u2462 \u00a0    val personId = request.pathVariable(\"id\").toInt() \u00a0    return repository.getPerson(personId)?.let { ok().contentType(APPLICATION_JSON).body(it) } \u00a0        ?:ServerResponse.notFound().build() \u00a0  } } \u2460 listPeople is a handler function that returns all Person objects found in the repository as JSON.\u2461 createPerson is a handler function that stores a new Person contained in the request body.\u2462 getPerson is a handler function that returns a single person, identified by the id path variable. We retrieve that Person from the repository and create a JSON response, if it is found. If it is not found, we return a 404 Not Found response. Validation A functional endpoint can use Spring\u2019s validation facilities to apply validation to the request body. For example, given a custom Spring Validator implementation for a Person: 939", "chunk_char_count": 1313, "chunk_word_count": 205, "chunk_token_count": 328.25}, {"page_number": 940, "sentence_chunk": "Java public class PersonHandler { \u00a0  private final Validator validator = new PersonValidator(); \u2460 \u00a0  // ... \u00a0  public ServerResponse createPerson(ServerRequest request) { \u00a0    Person person = request.body(Person.class); \u00a0    validate(person); \u2461 \u00a0    repository.savePerson(person); \u00a0    return ok().build(); \u00a0  } \u00a0  private void validate(Person person) { \u00a0    Errors errors = new BeanPropertyBindingResult(person, \"person\"); \u00a0    validator.validate(person, errors); \u00a0    if (errors.hasErrors()) { \u00a0      throw new ServerWebInputException(errors.toString()); \u2462 \u00a0    } \u00a0  } } \u2460 Create Validator instance.\u2461 Apply validation.\u2462 Raise exception for a 400 response.940", "chunk_char_count": 660, "chunk_word_count": 115, "chunk_token_count": 165.0}, {"page_number": 941, "sentence_chunk": "Kotlin class PersonHandler(private val repository: PersonRepository) { \u00a0  private val validator = PersonValidator() \u2460 \u00a0  // ... \u00a0  fun createPerson(request: ServerRequest): ServerResponse { \u00a0    val person = request.body<Person>() \u00a0    validate(person) \u2461 \u00a0    repository.savePerson(person) \u00a0    return ok().build() \u00a0  } \u00a0  private fun validate(person: Person) { \u00a0    val errors: Errors = BeanPropertyBindingResult(person, \"person\") \u00a0    validator.validate(person, errors) \u00a0    if (errors.hasErrors()) { \u00a0      throw ServerWebInputException(errors.toString()) \u2462 \u00a0    } \u00a0  } } \u2460 Create Validator instance.\u2461 Apply validation.\u2462 Raise exception for a 400 response. Handlers can also use the standard bean validation API (JSR-303) by creating and injecting a global Validator instance based on LocalValidatorFactoryBean. See Spring Validation. RouterFunction WebFlux Router functions are used to route the requests to the corresponding HandlerFunction. Typically, you do not write router functions yourself, but rather use a method on the RouterFunctions utility class to create one. RouterFunctions.route() (no parameters) provides you with a fluent builder for creating a router function, whereas RouterFunctions.route(RequestPredicate, HandlerFunction) offers a direct way to create a router. Generally, it is recommended to use the route() builder, as it provides convenient short-cuts for typical mapping scenarios without requiring hard-to-discover static imports. For instance, the router function builder offers the method GET(String, HandlerFunction) to create a mapping for GET requests; and POST(String, HandlerFunction) for POSTs.", "chunk_char_count": 1636, "chunk_word_count": 244, "chunk_token_count": 409.0}, {"page_number": 941, "sentence_chunk": "Besides HTTP method-based mapping, the route builder offers a way to introduce additional predicates when mapping to requests. For each HTTP method there is an overloaded variant that takes a RequestPredicate as a parameter, through which additional constraints can be expressed.941", "chunk_char_count": 282, "chunk_word_count": 41, "chunk_token_count": 70.5}, {"page_number": 942, "sentence_chunk": "Predicates You can write your own RequestPredicate, but the RequestPredicates utility class offers commonly used implementations, based on the request path, HTTP method, content-type, and so on. The following example uses a request predicate to create a constraint based on the Accept header: Java RouterFunction<ServerResponse> route = RouterFunctions.route() \u00a0  . GET(\"/hello-world\", accept(MediaType. TEXT_PLAIN), \u00a0    request -> ServerResponse.ok().body(\"Hello World\")).build(); Kotlin import org.springframework.web.servlet.function.router val route = router { \u00a0  GET(\"/hello-world\", accept(TEXT_PLAIN)) { \u00a0    ServerResponse.ok().body(\"Hello World\") \u00a0  } } You can compose multiple request predicates together by using: \u2022 RequestPredicate.and(RequestPredicate)\u2009\u2014\u2009both must match. \u2022RequestPredicate.or(RequestPredicate)\u2009\u2014\u2009either can match. Many of the predicates from RequestPredicates are composed. For example, RequestPredicates. GET(String) is composed from RequestPredicates.method(HttpMethod) and RequestPredicates.path(String). The example shown above also uses two request predicates, as the builder uses RequestPredicates. GET internally, and composes that with the accept predicate. Routes Router functions are evaluated in order: if the first route does not match, the second is evaluated, and so on.", "chunk_char_count": 1315, "chunk_word_count": 163, "chunk_token_count": 328.75}, {"page_number": 942, "sentence_chunk": "Therefore, it makes sense to declare more specific routes before general ones. This is also important when registering router functions as Spring beans, as will be described later. Note that this behavior is different from the annotation-based programming model, where the \"most specific\" controller method is picked automatically. When using the router function builder, all defined routes are composed into one RouterFunction that is returned from build(). There are also other ways to compose multiple router functions together: \u2022 add(RouterFunction) on the RouterFunctions.route() builder \u2022 RouterFunction.and(RouterFunction) \u2022 RouterFunction.andRoute(RequestPredicate, HandlerFunction)\u2009\u2014\u2009shortcut for RouterFunction.and() with nested RouterFunctions.route().942", "chunk_char_count": 766, "chunk_word_count": 94, "chunk_token_count": 191.5}, {"page_number": 943, "sentence_chunk": "The following example shows the composition of four routes: Java import static org.springframework.http. MediaType. APPLICATION_JSON; import static org.springframework.web.servlet.function. RequestPredicates.*;PersonRepository repository = ... PersonHandler handler = new PersonHandler(repository); RouterFunction<ServerResponse> otherRoute = ... RouterFunction<ServerResponse> route = route() \u00a0  . GET(\"/person/{id}\", accept(APPLICATION_JSON), handler::getPerson) \u2460 \u00a0  . GET(\"/person\", accept(APPLICATION_JSON), handler::listPeople) \u2461 \u00a0  . POST(\"/person\", handler::createPerson) \u2462 \u00a0  .add(otherRoute) \u2463 \u00a0  .build(); \u2460 GET /person/{id} with an Accept header that matches JSON is routed to PersonHandler.getPerson \u2461 GET /person with an Accept header that matches JSON is routed to PersonHandler.listPeople \u2462 POST /person with no additional predicates is mapped to PersonHandler.createPerson, and \u2463 otherRoute is a router function that is created elsewhere, and added to the route built. Kotlin import org.springframework.http. MediaType. APPLICATION_JSON import org.springframework.web.servlet.function.router val repository: PersonRepository = ... val handler = PersonHandler(repository); val otherRoute = router { } val route = router { \u00a0  GET(\"/person/{id}\", accept(APPLICATION_JSON), handler::getPerson) \u2460 \u00a0  GET(\"/person\", accept(APPLICATION_JSON), handler::listPeople) \u2461 \u00a0  POST(\"/person\", handler::createPerson) \u2462 }.and(otherRoute) \u2463 \u2460 GET /person/{id} with an Accept header that matches JSON is routed to PersonHandler.getPerson \u2461 GET /person with an Accept header that matches JSON is routed to PersonHandler.listPeople \u2462 POST /person with no additional predicates is mapped to PersonHandler.createPerson, and \u2463 otherRoute is a router function that is created elsewhere, and added to the route built. Nested Routes It is common for a group of router functions to have a shared predicate, for instance a shared path.943", "chunk_char_count": 1926, "chunk_word_count": 241, "chunk_token_count": 481.5}, {"page_number": 944, "sentence_chunk": "In the example above, the shared predicate would be a path predicate that matches /person, used by three of the routes. When using annotations, you would remove this duplication by using a type- level @RequestMapping annotation that maps to /person. In WebMvc.fn, path predicates can be shared through the path method on the router function builder. For instance, the last few lines of the example above can be improved in the following way by using nested routes: Java RouterFunction<ServerResponse> route = route() \u00a0  .path(\"/person\", builder -> builder \u2460 \u00a0    . GET(\"/{id}\", accept(APPLICATION_JSON), handler::getPerson) \u00a0    . GET(accept(APPLICATION_JSON), handler::listPeople) \u00a0    . POST(handler::createPerson)) \u00a0  .build(); \u2460 Note that second parameter of path is a consumer that takes the router builder. Kotlin import org.springframework.web.servlet.function.router val route = router { \u00a0  \"/person\".nest { \u00a0    GET(\"/{id}\", accept(APPLICATION_JSON), handler::getPerson) \u00a0    GET(accept(APPLICATION_JSON), handler::listPeople) \u00a0    POST(handler::createPerson) \u00a0  } } Though path-based nesting is the most common, you can nest on any kind of predicate by using the nest method on the builder. The above still contains some duplication in the form of the shared Accept-header predicate. We can further improve by using the nest method together with accept: Java RouterFunction<ServerResponse> route = route() \u00a0  .path(\"/person\", b1 -> b1 \u00a0    .nest(accept(APPLICATION_JSON), b2 -> b2 \u00a0      . GET(\"/{id}\", handler::getPerson) \u00a0      . GET(handler::listPeople)) \u00a0    . POST(handler::createPerson)) \u00a0  .build(); 944", "chunk_char_count": 1620, "chunk_word_count": 257, "chunk_token_count": 405.0}, {"page_number": 945, "sentence_chunk": "Kotlin import org.springframework.web.servlet.function.router val route = router { \u00a0  \"/person\".nest { \u00a0    accept(APPLICATION_JSON).nest { \u00a0      GET(\"/{id}\", handler::getPerson) \u00a0      GET(\"\", handler::listPeople) \u00a0      POST(handler::createPerson) \u00a0    } \u00a0  } } Running a Server WebFlux You typically run router functions in a DispatcherHandler-based setup through the MVC Config, which uses Spring configuration to declare the components required to process requests. The MVC Java configuration declares the following infrastructure components to support functional endpoints: \u2022 RouterFunctionMapping: Detects one or more RouterFunction<?> beans in the Spring configuration, orders them, combines them through RouterFunction.andOther, and routes requests to the resulting composed RouterFunction. \u2022HandlerFunctionAdapter: Simple adapter that lets DispatcherHandler invoke a HandlerFunction that was mapped to a request. The preceding components let functional endpoints fit within the DispatcherServlet request processing lifecycle and also (potentially) run side by side with annotated controllers, if any are declared. It is also how functional endpoints are enabled by the Spring Boot Web starter. The following example shows a WebFlux Java configuration: 945", "chunk_char_count": 1266, "chunk_word_count": 183, "chunk_token_count": 316.5}, {"page_number": 946, "sentence_chunk": "Java @Configuration @EnableMvc public class WebConfig implements WebMvcConfigurer { \u00a0  @Bean \u00a0  public RouterFunction<?> routerFunctionA() { \u00a0    // ... \u00a0  } \u00a0  @Bean \u00a0  public RouterFunction<?> routerFunctionB() { \u00a0    // ... \u00a0  } \u00a0  // ... \u00a0  @Override \u00a0  public void configureMessageConverters(List<HttpMessageConverter<?>> converters) { \u00a0    // configure message conversion... \u00a0  } \u00a0  @Override \u00a0  public void addCorsMappings(CorsRegistry registry) { \u00a0    // configure CORS... \u00a0  } \u00a0  @Override \u00a0  public void configureViewResolvers(ViewResolverRegistry registry) { \u00a0    // configure view resolution for HTML rendering... \u00a0  } } 946", "chunk_char_count": 636, "chunk_word_count": 116, "chunk_token_count": 159.0}, {"page_number": 947, "sentence_chunk": "Kotlin @Configuration @EnableMvc class WebConfig : WebMvcConfigurer { \u00a0  @Bean \u00a0  fun routerFunctionA(): RouterFunction<*> { \u00a0    // ... \u00a0  } \u00a0  @Bean \u00a0  fun routerFunctionB(): RouterFunction<*> { \u00a0    // ... \u00a0  } \u00a0  // ... \u00a0  override fun configureMessageConverters(converters: List<HttpMessageConverter<*>>) { \u00a0    // configure message conversion... \u00a0  } \u00a0  override fun addCorsMappings(registry: CorsRegistry) { \u00a0    // configure CORS... \u00a0  } \u00a0  override fun configureViewResolvers(registry: ViewResolverRegistry) { \u00a0    // configure view resolution for HTML rendering... \u00a0  } } Filtering Handler Functions WebFlux You can filter handler functions by using the before, after, or filter methods on the routing function builder. With annotations, you can achieve similar functionality by using @ControllerAdvice, a ServletFilter, or both. The filter will apply to all routes that are built by the builder. This means that filters defined in nested routes do not apply to \"top-level\" routes. For instance, consider the following example: 947", "chunk_char_count": 1041, "chunk_word_count": 175, "chunk_token_count": 260.25}, {"page_number": 948, "sentence_chunk": "Java RouterFunction<ServerResponse> route = route() \u00a0  .path(\"/person\", b1 -> b1 \u00a0    .nest(accept(APPLICATION_JSON), b2 -> b2 \u00a0      . GET(\"/{id}\", handler::getPerson) \u00a0      . GET(handler::listPeople) \u00a0      .before(request -> ServerRequest.from(request) \u2460 \u00a0        .header(\"X-RequestHeader\", \"Value\") \u00a0        .build())) \u00a0    . POST(handler::createPerson)) \u00a0  .after((request, response) -> logResponse(response)) \u2461 \u00a0  .build(); \u2460 The before filter that adds a custom request header is only applied to the two GET routes.\u2461 The after filter that logs the response is applied to all routes, including the nested ones. Kotlin import org.springframework.web.servlet.function.router val route = router { \u00a0  \"/person\".nest { \u00a0    GET(\"/{id}\", handler::getPerson) \u00a0    GET(handler::listPeople) \u00a0    before { \u2460 \u00a0      ServerRequest.from(it) \u00a0          .header(\"X-RequestHeader\", \"Value\").build() \u00a0    } \u00a0  } \u00a0  POST(handler::createPerson) \u00a0  after { _, response -> \u2461 \u00a0    logResponse(response) \u00a0  } } \u2460 The before filter that adds a custom request header is only applied to the two GET routes.\u2461 The after filter that logs the response is applied to all routes, including the nested ones. The filter method on the router builder takes a HandlerFilterFunction: a function that takes a ServerRequest and HandlerFunction and returns a ServerResponse. The handler function parameter represents the next element in the chain. This is typically the handler that is routed to, but it can also be another filter if multiple are applied. Now we can add a simple security filter to our route, assuming that we have a SecurityManager that can determine whether a particular path is allowed. The following example shows how to do so: 948", "chunk_char_count": 1718, "chunk_word_count": 314, "chunk_token_count": 429.5}, {"page_number": 949, "sentence_chunk": "Java SecurityManager securityManager = ... RouterFunction<ServerResponse> route = route() \u00a0  .path(\"/person\", b1 -> b1 \u00a0    .nest(accept(APPLICATION_JSON), b2 -> b2 \u00a0      . GET(\"/{id}\", handler::getPerson) \u00a0      . GET(handler::listPeople)) \u00a0    . POST(handler::createPerson)) \u00a0  .filter((request, next) -> { \u00a0    if (securityManager.allowAccessTo(request.path())) { \u00a0      return next.handle(request); \u00a0    } \u00a0    else { \u00a0      return ServerResponse.status(UNAUTHORIZED).build(); \u00a0    } \u00a0  }) \u00a0  .build(); Kotlin import org.springframework.web.servlet.function.router val securityManager: SecurityManager = ... val route = router { \u00a0  (\"/person\" and accept(APPLICATION_JSON)).nest { \u00a0    GET(\"/{id}\", handler::getPerson) \u00a0    GET(\"\", handler::listPeople) \u00a0    POST(handler::createPerson) \u00a0    filter { request, next -> \u00a0      if (securityManager.allowAccessTo(request.path())) { \u00a0        next(request) \u00a0      } \u00a0      else { \u00a0        status(UNAUTHORIZED).build(); \u00a0      } \u00a0    } \u00a0  } } The preceding example demonstrates that invoking the next.handle(ServerRequest) is optional. We only let the handler function be run when access is allowed. Besides using the filter method on the router function builder, it is possible to apply a filter to an existing router function via RouterFunction.filter(HandlerFilterFunction).\uf05a CORS support for functional endpoints is provided through a dedicated CorsFilter.949", "chunk_char_count": 1409, "chunk_word_count": 257, "chunk_token_count": 352.25}, {"page_number": 950, "sentence_chunk": "5.1.5. URI Links WebFlux This section describes various options available in the Spring Framework to work with URI\u2019s. UriComponents Spring MVC and Spring WebFlux UriComponentsBuilder helps to build URI\u2019s from URI templates with variables, as the following example shows: Java UriComponents uriComponents = UriComponentsBuilder \u00a0    .fromUriString(\"https://example.com/hotels/{hotel}\") \u2460 \u00a0    .queryParam(\"q\", \"{q}\") \u2461 \u00a0    .encode() \u2462 \u00a0    .build(); \u2463 URI uri = uriComponents.expand(\"Westin\", \"123\").toUri(); \u2464 \u2460 Static factory method with a URI template.\u2461 Add or replace URI components.\u2462 Request to have the URI template and URI variables encoded.\u2463 Build a UriComponents.\u2464 Expand variables and obtain the URI. Kotlin val uriComponents = UriComponentsBuilder \u00a0    .fromUriString(\"https://example.com/hotels/{hotel}\") \u2460 \u00a0    .queryParam(\"q\", \"{q}\") \u2461 \u00a0    .encode() \u2462 \u00a0    .build() \u2463 val uri = uriComponents.expand(\"Westin\", \"123\").toUri() \u2464 \u2460 Static factory method with a URI template.\u2461 Add or replace URI components.\u2462 Request to have the URI template and URI variables encoded.", "chunk_char_count": 1078, "chunk_word_count": 166, "chunk_token_count": 269.5}, {"page_number": 950, "sentence_chunk": "\u2463 Build a UriComponents.\u2464 Expand variables and obtain the URI. The preceding example can be consolidated into one chain and shortened with buildAndExpand, as the following example shows: 950", "chunk_char_count": 190, "chunk_word_count": 29, "chunk_token_count": 47.5}, {"page_number": 951, "sentence_chunk": "Java URI uri = UriComponentsBuilder \u00a0    .fromUriString(\"https://example.com/hotels/{hotel}\") \u00a0    .queryParam(\"q\", \"{q}\") \u00a0    .encode() \u00a0    .buildAndExpand(\"Westin\", \"123\") \u00a0    .toUri(); Kotlin val uri = UriComponentsBuilder \u00a0    .fromUriString(\"https://example.com/hotels/{hotel}\") \u00a0    .queryParam(\"q\", \"{q}\") \u00a0    .encode() \u00a0    .buildAndExpand(\"Westin\", \"123\") \u00a0    .toUri() You can shorten it further by going directly to a URI (which implies encoding), as the following example shows: Java URI uri = UriComponentsBuilder \u00a0    .fromUriString(\"https://example.com/hotels/{hotel}\") \u00a0    .queryParam(\"q\", \"{q}\") \u00a0    .build(\"Westin\", \"123\"); Kotlin val uri = UriComponentsBuilder \u00a0    .fromUriString(\"https://example.com/hotels/{hotel}\") \u00a0    .queryParam(\"q\", \"{q}\") \u00a0    .build(\"Westin\", \"123\") You can shorten it further still with a full URI template, as the following example shows: Java URI uri = UriComponentsBuilder \u00a0    .fromUriString(\"https://example.com/hotels/{hotel}?q={q}\") \u00a0    .build(\"Westin\", \"123\"); 951", "chunk_char_count": 1026, "chunk_word_count": 160, "chunk_token_count": 256.5}, {"page_number": 952, "sentence_chunk": "Kotlin val uri = UriComponentsBuilder \u00a0    .fromUriString(\"https://example.com/hotels/{hotel}?q={q}\") \u00a0    .build(\"Westin\", \"123\") UriBuilder Spring MVC and Spring WebFlux UriComponentsBuilder implements UriBuilder. You can create a UriBuilder, in turn, with a UriBuilderFactory. Together, UriBuilderFactory and UriBuilder provide a pluggable mechanism to build URIs from URI templates, based on shared configuration, such as a base URL, encoding preferences, and other details. You can configure RestTemplate and WebClient with a UriBuilderFactory to customize the preparation of URIs. DefaultUriBuilderFactory is a default implementation of UriBuilderFactory that uses UriComponentsBuilder internally and exposes shared configuration options. The following example shows how to configure a RestTemplate: Java // import org.springframework.web.util. DefaultUriBuilderFactory. EncodingMode; String baseUrl = \"https://example.org\"; DefaultUriBuilderFactory factory = new DefaultUriBuilderFactory(baseUrl); factory.setEncodingMode(EncodingMode. TEMPLATE_AND_VALUES); RestTemplate restTemplate = new RestTemplate(); restTemplate.setUriTemplateHandler(factory); Kotlin // import org.springframework.web.util. DefaultUriBuilderFactory.", "chunk_char_count": 1230, "chunk_word_count": 131, "chunk_token_count": 307.5}, {"page_number": 952, "sentence_chunk": "EncodingMode val baseUrl = \"https://example.org\" val factory = DefaultUriBuilderFactory(baseUrl) factory.encodingMode = EncodingMode. TEMPLATE_AND_VALUES val restTemplate = RestTemplate() restTemplate.uriTemplateHandler = factory The following example configures a WebClient: 952", "chunk_char_count": 279, "chunk_word_count": 27, "chunk_token_count": 69.75}, {"page_number": 953, "sentence_chunk": "Java // import org.springframework.web.util. DefaultUriBuilderFactory. EncodingMode; String baseUrl = \"https://example.org\"; DefaultUriBuilderFactory factory = new DefaultUriBuilderFactory(baseUrl); factory.setEncodingMode(EncodingMode. TEMPLATE_AND_VALUES); WebClient client = WebClient.builder().uriBuilderFactory(factory).build(); Kotlin // import org.springframework.web.util. DefaultUriBuilderFactory. EncodingMode val baseUrl = \"https://example.org\" val factory = DefaultUriBuilderFactory(baseUrl) factory.encodingMode = EncodingMode. TEMPLATE_AND_VALUES val client = WebClient.builder().uriBuilderFactory(factory).build() In addition, you can also use DefaultUriBuilderFactory directly. It is similar to using UriComponentsBuilder but, instead of static factory methods, it is an actual instance that holds configuration and preferences, as the following example shows: Java String baseUrl = \"https://example.com\"; DefaultUriBuilderFactory uriBuilderFactory = new DefaultUriBuilderFactory(baseUrl); URI uri = uriBuilderFactory.uriString(\"/hotels/{hotel}\") \u00a0    .queryParam(\"q\", \"{q}\") \u00a0    .build(\"Westin\", \"123\"); Kotlin val baseUrl = \"https://example.com\" val uriBuilderFactory = DefaultUriBuilderFactory(baseUrl) val uri = uriBuilderFactory.uriString(\"/hotels/{hotel}\") \u00a0    .queryParam(\"q\", \"{q}\") \u00a0    .build(\"Westin\", \"123\") URI Encoding Spring MVC and Spring WebFlux UriComponentsBuilder exposes encoding options at two levels: \u2022 UriComponentsBuilder#encode(): Pre-encodes the URI template first and then strictly encodes 953", "chunk_char_count": 1539, "chunk_word_count": 155, "chunk_token_count": 384.75}, {"page_number": 954, "sentence_chunk": "URI variables when expanded. \u2022UriComponents#encode(): Encodes URI components after URI variables are expanded. Both options replace non-ASCII and illegal characters with escaped octets. However, the first option also replaces characters with reserved meaning that appear in URI variables.\uf0eb Consider \";\", which is legal in a path but has reserved meaning. The first option replaces \";\" with \"%3B\" in URI variables but not in the URI template. By contrast, the second option never replaces \";\", since it is a legal character in a path. For most cases, the first option is likely to give the expected result, because it treats URI variables as opaque data to be fully encoded, while the second option is useful if URI variables do intentionally contain reserved characters. The second option is also useful when not expanding URI variables at all since that will also encode anything that incidentally looks like a URI variable. The following example uses the first option: Java URI uri = UriComponentsBuilder.fromPath(\"/hotel list/{city}\") \u00a0    .queryParam(\"q\", \"{q}\") \u00a0    .encode() \u00a0    .buildAndExpand(\"New York\", \"foo+bar\") \u00a0    .toUri(); // Result is \"/hotel%20list/New%20York?q=foo%2Bbar\" Kotlin val uri = UriComponentsBuilder.fromPath(\"/hotel list/{city}\") \u00a0    .queryParam(\"q\", \"{q}\") \u00a0    .encode() \u00a0    .buildAndExpand(\"New York\", \"foo+bar\") \u00a0    .toUri() // Result is \"/hotel%20list/New%20York?q=foo%2Bbar\" You can shorten the preceding example by going directly to the URI (which implies encoding), as the following example shows: Java URI uri = UriComponentsBuilder.fromPath(\"/hotel list/{city}\") \u00a0    .queryParam(\"q\", \"{q}\") \u00a0    .build(\"New York\", \"foo+bar\"); 954", "chunk_char_count": 1676, "chunk_word_count": 261, "chunk_token_count": 419.0}, {"page_number": 955, "sentence_chunk": "Kotlin val uri = UriComponentsBuilder.fromPath(\"/hotel list/{city}\") \u00a0    .queryParam(\"q\", \"{q}\") \u00a0    .build(\"New York\", \"foo+bar\") You can shorten it further still with a full URI template, as the following example shows: Java URI uri = UriComponentsBuilder.fromUriString(\"/hotel list/{city}?q={q}\") \u00a0    .build(\"New York\", \"foo+bar\"); Kotlin val uri = UriComponentsBuilder.fromUriString(\"/hotel list/{city}?q={q}\") \u00a0    .build(\"New York\", \"foo+bar\") The WebClient and the RestTemplate expand and encode URI templates internally through the UriBuilderFactory strategy. Both can be configured with a custom strategy, as the following example shows: Java String baseUrl = \"https://example.com\"; DefaultUriBuilderFactory factory = new DefaultUriBuilderFactory(baseUrl) factory.setEncodingMode(EncodingMode. TEMPLATE_AND_VALUES); // Customize the RestTemplate.. RestTemplate restTemplate = new RestTemplate(); restTemplate.setUriTemplateHandler(factory); // Customize the WebClient.. WebClient client = WebClient.builder().uriBuilderFactory(factory).build(); 955", "chunk_char_count": 1060, "chunk_word_count": 120, "chunk_token_count": 265.0}, {"page_number": 956, "sentence_chunk": "Kotlin val baseUrl = \"https://example.com\" val factory = DefaultUriBuilderFactory(baseUrl).apply { \u00a0  encodingMode = EncodingMode. TEMPLATE_AND_VALUES } // Customize the RestTemplate.. val restTemplate = RestTemplate().apply { \u00a0  uriTemplateHandler = factory } // Customize the WebClient.. val client = WebClient.builder().uriBuilderFactory(factory).build() The DefaultUriBuilderFactory implementation uses UriComponentsBuilder internally to expand and encode URI templates. As a factory, it provides a single place to configure the approach to encoding, based on one of the below encoding modes: \u2022 TEMPLATE_AND_VALUES: Uses UriComponentsBuilder#encode(), corresponding to the first option in the earlier list, to pre-encode the URI template and strictly encode URI variables when expanded. \u2022VALUES_ONLY: Does not encode the URI template and, instead, applies strict encoding to URI variables through UriUtils#encodeUriVariables prior to expanding them into the template. \u2022URI_COMPONENT: Uses UriComponents#encode(), corresponding to the second option in the earlier list, to encode URI component value after URI variables are expanded. \u2022NONE: No encoding is applied. The RestTemplate is set to EncodingMode. URI_COMPONENT for historic reasons and for backwards compatibility. The WebClient relies on the default value in DefaultUriBuilderFactory, which was changed from EncodingMode. URI_COMPONENT in 5.0.x to EncodingMode.", "chunk_char_count": 1424, "chunk_word_count": 183, "chunk_token_count": 356.0}, {"page_number": 956, "sentence_chunk": "TEMPLATE_AND_VALUES in 5.1. Relative Servlet Requests You can use ServletUriComponentsBuilder to create URIs relative to the current request, as the following example shows: Java HttpServletRequest request = ... // Re-uses scheme, host, port, path, and query string... URI uri = ServletUriComponentsBuilder.fromRequest(request) \u00a0    .replaceQueryParam(\"accountId\", \"{id}\") \u00a0    .build(\"123\"); 956", "chunk_char_count": 396, "chunk_word_count": 53, "chunk_token_count": 99.0}, {"page_number": 957, "sentence_chunk": "Kotlin val request: HttpServletRequest = ... // Re-uses scheme, host, port, path, and query string... val uri = ServletUriComponentsBuilder.fromRequest(request) \u00a0    .replaceQueryParam(\"accountId\", \"{id}\") \u00a0    .build(\"123\") You can create URIs relative to the context path, as the following example shows: Java HttpServletRequest request = ... // Re-uses scheme, host, port, and context path... URI uri = ServletUriComponentsBuilder.fromContextPath(request) \u00a0    .path(\"/accounts\") \u00a0    .build() \u00a0    .toUri(); Kotlin val request: HttpServletRequest = ... // Re-uses scheme, host, port, and context path... val uri = ServletUriComponentsBuilder.fromContextPath(request) \u00a0    .path(\"/accounts\") \u00a0    .build() \u00a0    .toUri() You can create URIs relative to a Servlet (for example, /main/*), as the following example shows: Java HttpServletRequest request = ... // Re-uses scheme, host, port, context path, and Servlet mapping prefix... URI uri = ServletUriComponentsBuilder.fromServletMapping(request) \u00a0    .path(\"/accounts\") \u00a0    .build() \u00a0    .toUri(); 957", "chunk_char_count": 1056, "chunk_word_count": 161, "chunk_token_count": 264.0}, {"page_number": 958, "sentence_chunk": "Kotlin val request: HttpServletRequest = ... // Re-uses scheme, host, port, context path, and Servlet mapping prefix... val uri = ServletUriComponentsBuilder.fromServletMapping(request) \u00a0    .path(\"/accounts\") \u00a0    .build() \u00a0    .toUri() \uf05a As of 5.1, ServletUriComponentsBuilder ignores information from the Forwarded and X-Forwarded-* headers, which specify the client-originated address. Consider using the ForwardedHeaderFilter to extract and use or to discard such headers. Links to Controllers Spring MVC provides a mechanism to prepare links to controller methods. For example, the following MVC controller allows for link creation: Java @Controller @RequestMapping(\"/hotels/{hotel}\") public class BookingController { \u00a0  @GetMapping(\"/bookings/{booking}\") \u00a0  public ModelAndView getBooking(@PathVariable Long booking) { \u00a0    // ... \u00a0  } } Kotlin @Controller @RequestMapping(\"/hotels/{hotel}\") class BookingController { \u00a0  @GetMapping(\"/bookings/{booking}\") \u00a0  fun getBooking(@PathVariable booking: Long): ModelAndView { \u00a0    // ... \u00a0  } } You can prepare a link by referring to the method by name, as the following example shows: 958", "chunk_char_count": 1139, "chunk_word_count": 164, "chunk_token_count": 284.75}, {"page_number": 959, "sentence_chunk": "Java UriComponents uriComponents = MvcUriComponentsBuilder \u00a0  .fromMethodName(BookingController.class, \"getBooking\", 21).buildAndExpand(42); URI uri = uriComponents.encode().toUri(); Kotlin val uriComponents = MvcUriComponentsBuilder \u00a0  .fromMethodName(BookingController::class.java, \"getBooking\", 21).buildAndExpand(42) val uri = uriComponents.encode().toUri() In the preceding example, we provide actual method argument values (in this case, the long value: 21) to be used as a path variable and inserted into the URL. Furthermore, we provide the value, 42, to fill in any remaining URI variables, such as the hotel variable inherited from the type-level request mapping. If the method had more arguments, we could supply null for arguments not needed for the URL. In general, only @PathVariable and @RequestParam arguments are relevant for constructing the URL. There are additional ways to use MvcUriComponentsBuilder. For example, you can use a technique akin to mock testing through proxies to avoid referring to the controller method by name, as the following example shows (the example assumes static import of MvcUriComponentsBuilder.on): Java UriComponents uriComponents = MvcUriComponentsBuilder \u00a0  .fromMethodCall(on(BookingController.class).getBooking(21)).buildAndExpand(42); URI uri = uriComponents.encode().toUri(); Kotlin val uriComponents = MvcUriComponentsBuilder \u00a0 .fromMethodCall(on(BookingController::class.java).getBooking(21)).buildAndExpand(42) val uri = uriComponents.encode().toUri() 959", "chunk_char_count": 1514, "chunk_word_count": 176, "chunk_token_count": 378.5}, {"page_number": 960, "sentence_chunk": "\uf05a Controller method signatures are limited in their design when they are supposed to be usable for link creation with fromMethodCall. Aside from needing a proper parameter signature, there is a technical limitation on the return type (namely, generating a runtime proxy for link builder invocations), so the return type must not be final. In particular, the common String return type for view names does not work here. You should use ModelAndView or even plain Object (with a String return value) instead. The earlier examples use static methods in MvcUriComponentsBuilder. Internally, they rely on ServletUriComponentsBuilder to prepare a base URL from the scheme, host, port, context path, and servlet path of the current request. This works well in most cases. However, sometimes, it can be insufficient. For example, you may be outside the context of a request (such as a batch process that prepares links) or perhaps you need to insert a path prefix (such as a locale prefix that was removed from the request path and needs to be re-inserted into links). For such cases, you can use the static fromXxx overloaded methods that accept a UriComponentsBuilder to use a base URL.", "chunk_char_count": 1179, "chunk_word_count": 193, "chunk_token_count": 294.75}, {"page_number": 960, "sentence_chunk": "Alternatively, you can create an instance of MvcUriComponentsBuilder with a base URL and then use the instance-based withXxx methods. For example, the following listing uses withMethodCall: Java UriComponentsBuilder base = ServletUriComponentsBuilder.fromCurrentContextPath().path(\"/en\"); MvcUriComponentsBuilder builder = MvcUriComponentsBuilder.relativeTo(base); builder.withMethodCall(on(BookingController.class).getBooking(21)).buildAndExpand(42); URI uri = uriComponents.encode().toUri(); Kotlin val base = ServletUriComponentsBuilder.fromCurrentContextPath().path(\"/en\") val builder = MvcUriComponentsBuilder.relativeTo(base) builder.withMethodCall(on(BookingController::class.java).getBooking(21)).buildAndExpan d(42) val uri = uriComponents.encode().toUri() \uf05a As of 5.1, MvcUriComponentsBuilder ignores information from the Forwarded and X- Forwarded-* headers, which specify the client-originated address. Consider using the ForwardedHeaderFilter to extract and use or to discard such headers. Links in Views In views such as Thymeleaf, FreeMarker, or JSP, you can build links to annotated controllers by referring to the implicitly or explicitly assigned name for each request mapping. Consider the following example: 960", "chunk_char_count": 1231, "chunk_word_count": 123, "chunk_token_count": 307.75}, {"page_number": 961, "sentence_chunk": "Java @RequestMapping(\"/people/{id}/addresses\") public class PersonAddressController { \u00a0  @RequestMapping(\"/{country}\") \u00a0  public HttpEntity<PersonAddress> getAddress(@PathVariable String country) { ... } } Kotlin @RequestMapping(\"/people/{id}/addresses\") class PersonAddressController { \u00a0  @RequestMapping(\"/{country}\") \u00a0  fun getAddress(@PathVariable country: String): HttpEntity<PersonAddress> { ... } } Given the preceding controller, you can prepare a link from a JSP, as follows: <%@ taglib uri=\"http://www.springframework.org/tags\" prefix=\"s\" %> ... <a href=\"${s:mvcUrl('PAC#getAddress').arg(0,'US').buildAndExpand('123')}\">Get Address</a> The preceding example relies on the mvcUrl function declared in the Spring tag library (that is, META-INF/spring.tld), but it is easy to define your own function or prepare a similar one for other templating technologies. Here is how this works. On startup, every @RequestMapping is assigned a default name through HandlerMethodMappingNamingStrategy, whose default implementation uses the capital letters of the class and the method name (for example, the getThing method in ThingController becomes \"TC#getThing\"). If there is a name clash, you can use @RequestMapping(name=\"..\") to assign an explicit name or implement your own HandlerMethodMappingNamingStrategy.5.1.6. Asynchronous Requests Compared to WebFlux Spring MVC has an extensive integration with Servlet asynchronous request processing: \u2022 DeferredResult and Callable return values in controller methods provide basic support for a single asynchronous return value. \u2022Controllers can stream multiple values, including SSE and raw data. \u2022Controllers can use reactive clients and return reactive types for response handling.961", "chunk_char_count": 1731, "chunk_word_count": 212, "chunk_token_count": 432.75}, {"page_number": 962, "sentence_chunk": "DeferredResult Compared to WebFlux Once the asynchronous request processing feature is enabled in the Servlet container, controller methods can wrap any supported controller method return value with DeferredResult, as the following example shows: Java @GetMapping(\"/quotes\") @ResponseBody public DeferredResult<String> quotes() { \u00a0  DeferredResult<String> deferredResult = new DeferredResult<String>(); \u00a0  // Save the deferredResult somewhere.. \u00a0  return deferredResult; } // From some other thread... deferredResult.setResult(result); Kotlin @GetMapping(\"/quotes\") @ResponseBody fun quotes(): DeferredResult<String> { \u00a0  val deferredResult = DeferredResult<String>() \u00a0  // Save the deferredResult somewhere.. \u00a0  return deferredResult } // From some other thread... deferredResult.setResult(result) The controller can produce the return value asynchronously, from a different thread\u2009\u2014\u2009for example, in response to an external event (JMS message), a scheduled task, or other event. Callable Compared to WebFlux A controller can wrap any supported return value with java.util.concurrent. Callable, as the following example shows: 962", "chunk_char_count": 1130, "chunk_word_count": 144, "chunk_token_count": 282.5}, {"page_number": 963, "sentence_chunk": "Java @PostMapping public Callable<String> processUpload(final MultipartFile file) { \u00a0  return new Callable<String>() { \u00a0    public String call() throws Exception { \u00a0      // ... \u00a0      return \"someView\"; \u00a0    } \u00a0  }; } Kotlin @PostMapping fun processUpload(file: MultipartFile) = Callable<String> { \u00a0  // ... \u00a0  \"someView\" } The return value can then be obtained by running the given task through the configured TaskExecutor. Processing Compared to WebFlux Here is a very concise overview of Servlet asynchronous request processing: \u2022 A ServletRequest can be put in asynchronous mode by calling request.startAsync(). The main effect of doing so is that the Servlet (as well as any filters) can exit, but the response remains open to let processing complete later. \u2022The call to request.startAsync() returns AsyncContext, which you can use for further control over asynchronous processing. For example, it provides the dispatch method, which is similar to a forward from the Servlet API, except that it lets an application resume request processing on a Servlet container thread. \u2022The ServletRequest provides access to the current DispatcherType, which you can use to distinguish between processing the initial request, an asynchronous dispatch, a forward, and other dispatcher types. DeferredResult processing works as follows: \u2022 The controller returns a DeferredResult and saves it in some in-memory queue or list where it can be accessed. \u2022Spring MVC calls request.startAsync(). \u2022Meanwhile, the DispatcherServlet and all configured filters exit the request processing thread, but the response remains open.963", "chunk_char_count": 1610, "chunk_word_count": 256, "chunk_token_count": 402.5}, {"page_number": 964, "sentence_chunk": "\u2022 The application sets the DeferredResult from some thread, and Spring MVC dispatches the request back to the Servlet container. \u2022The DispatcherServlet is invoked again, and processing resumes with the asynchronously produced return value. Callable processing works as follows: \u2022 The controller returns a Callable. \u2022Spring MVC calls request.startAsync() and submits the Callable to a TaskExecutor for processing in a separate thread. \u2022Meanwhile, the DispatcherServlet and all filters exit the Servlet container thread, but the response remains open. \u2022Eventually the Callable produces a result, and Spring MVC dispatches the request back to the Servlet container to complete processing. \u2022The DispatcherServlet is invoked again, and processing resumes with the asynchronously produced return value from the Callable. For further background and context, you can also read the blog posts that introduced asynchronous request processing support in Spring MVC 3.2. Exception Handling When you use a DeferredResult, you can choose whether to call setResult or setErrorResult with an exception. In both cases, Spring MVC dispatches the request back to the Servlet container to complete processing.", "chunk_char_count": 1189, "chunk_word_count": 172, "chunk_token_count": 297.25}, {"page_number": 964, "sentence_chunk": "It is then treated either as if the controller method returned the given value or as if it produced the given exception. The exception then goes through the regular exception handling mechanism (for example, invoking @ExceptionHandler methods). When you use Callable, similar processing logic occurs, the main difference being that the result is returned from the Callable or an exception is raised by it. Interception HandlerInterceptor instances can be of type AsyncHandlerInterceptor, to receive the afterConcurrentHandlingStarted callback on the initial request that starts asynchronous processing (instead of postHandle and afterCompletion). HandlerInterceptor implementations can also register a CallableProcessingInterceptor or a DeferredResultProcessingInterceptor, to integrate more deeply with the lifecycle of an asynchronous request (for example, to handle a timeout event). See AsyncHandlerInterceptor for more details. DeferredResult provides onTimeout(Runnable) and onCompletion(Runnable) callbacks. See the javadoc of DeferredResult for more details. Callable can be substituted for WebAsyncTask that exposes additional methods for timeout and completion callbacks.964", "chunk_char_count": 1184, "chunk_word_count": 152, "chunk_token_count": 296.0}, {"page_number": 965, "sentence_chunk": "Compared to WebFlux The Servlet API was originally built for making a single pass through the Filter-Servlet chain. Asynchronous request processing lets applications exit the Filter-Servlet chain but leave the response open for further processing. The Spring MVC asynchronous support is built around that mechanism. When a controller returns a DeferredResult, the Filter-Servlet chain is exited, and the Servlet container thread is released. Later, when the DeferredResult is set, an ASYNC dispatch (to the same URL) is made, during which the controller is mapped again but, rather than invoking it, the DeferredResult value is used (as if the controller returned it) to resume processing. By contrast, Spring WebFlux is neither built on the Servlet API, nor does it need such an asynchronous request processing feature, because it is asynchronous by design. Asynchronous handling is built into all framework contracts and is intrinsically supported through all stages of request processing. From a programming model perspective, both Spring MVC and Spring WebFlux support asynchronous and Reactive Types as return values in controller methods. Spring MVC even supports streaming, including reactive back pressure. However, individual writes to the response remain blocking (and are performed on a separate thread), unlike WebFlux, which relies on non- blocking I/O and does not need an extra thread for each write.", "chunk_char_count": 1415, "chunk_word_count": 213, "chunk_token_count": 353.75}, {"page_number": 965, "sentence_chunk": "Another fundamental difference is that Spring MVC does not support asynchronous or reactive types in controller method arguments (for example, @RequestBody, @RequestPart, and others), nor does it have any explicit support for asynchronous and reactive types as model attributes. Spring WebFlux does support all that. HTTP Streaming WebFlux You can use DeferredResult and Callable for a single asynchronous return value. What if you want to produce multiple asynchronous values and have those written to the response?This section describes how to do so. Objects You can use the ResponseBodyEmitter return value to produce a stream of objects, where each object is serialized with an HttpMessageConverter and written to the response, as the following example shows: 965", "chunk_char_count": 767, "chunk_word_count": 115, "chunk_token_count": 191.75}, {"page_number": 966, "sentence_chunk": "Java @GetMapping(\"/events\") public ResponseBodyEmitter handle() { \u00a0  ResponseBodyEmitter emitter = new ResponseBodyEmitter(); \u00a0  // Save the emitter somewhere.. \u00a0  return emitter; } // In some other thread emitter.send(\"Hello once\"); // and again later on emitter.send(\"Hello again\"); // and done at some point emitter.complete(); Kotlin @GetMapping(\"/events\") fun handle() = ResponseBodyEmitter().apply { \u00a0  // Save the emitter somewhere.. } // In some other thread emitter.send(\"Hello once\") // and again later on emitter.send(\"Hello again\") // and done at some point emitter.complete() You can also use ResponseBodyEmitter as the body in a ResponseEntity, letting you customize the status and headers of the response. When an emitter throws an IOException (for example, if the remote client went away), applications are not responsible for cleaning up the connection and should not invoke emitter.complete or emitter.completeWithError. Instead, the servlet container automatically initiates an AsyncListener error notification, in which Spring MVC makes a completeWithError call. This call, in turn, performs one final ASYNC dispatch to the application, during which Spring MVC invokes the configured exception resolvers and completes the request. SSE SseEmitter (a subclass of ResponseBodyEmitter) provides support for Server-Sent Events, where events sent from the server are formatted according to the W3C SSE specification. To produce an SSE stream from a controller, return SseEmitter, as the following example shows: 966", "chunk_char_count": 1529, "chunk_word_count": 217, "chunk_token_count": 382.25}, {"page_number": 967, "sentence_chunk": "Java @GetMapping(path=\"/events\", produces=MediaType. TEXT_EVENT_STREAM_VALUE) public SseEmitter handle() { \u00a0  SseEmitter emitter = new SseEmitter(); \u00a0  // Save the emitter somewhere.. \u00a0  return emitter; } // In some other thread emitter.send(\"Hello once\"); // and again later on emitter.send(\"Hello again\"); // and done at some point emitter.complete(); Kotlin @GetMapping(\"/events\", produces = [MediaType. TEXT_EVENT_STREAM_VALUE]) fun handle() = SseEmitter().apply { \u00a0  // Save the emitter somewhere.. } // In some other thread emitter.send(\"Hello once\") // and again later on emitter.send(\"Hello again\") // and done at some point emitter.complete() While SSE is the main option for streaming into browsers, note that Internet Explorer does not support Server-Sent Events. Consider using Spring\u2019s WebSocket messaging with SockJS fallback transports (including SSE) that target a wide range of browsers. See also previous section for notes on exception handling. Raw Data Sometimes, it is useful to bypass message conversion and stream directly to the response OutputStream (for example, for a file download). You can use the StreamingResponseBody return value type to do so, as the following example shows: 967", "chunk_char_count": 1212, "chunk_word_count": 174, "chunk_token_count": 303.0}, {"page_number": 968, "sentence_chunk": "Java @GetMapping(\"/download\") public StreamingResponseBody handle() { \u00a0  return new StreamingResponseBody() { \u00a0    @Override \u00a0    public void writeTo(OutputStream outputStream) throws IOException { \u00a0      // write... \u00a0    } \u00a0  }; } Kotlin @GetMapping(\"/download\") fun handle() = StreamingResponseBody { \u00a0  // write... } You can use StreamingResponseBody as the body in a ResponseEntity to customize the status and headers of the response. Reactive Types WebFlux Spring MVC supports use of reactive client libraries in a controller (also read Reactive Libraries in the WebFlux section). This includes the WebClient from spring-webflux and others, such as Spring Data reactive data repositories. In such scenarios, it is convenient to be able to return reactive types from the controller method. Reactive return values are handled as follows: \u2022 A single-value promise is adapted to, similar to using DeferredResult. Examples include Mono (Reactor) or Single (RxJava). \u2022A multi-value stream with a streaming media type (such as application/x-ndjson or text/event- stream) is adapted to, similar to using ResponseBodyEmitter or SseEmitter. Examples include Flux (Reactor) or Observable (RxJava). Applications can also return Flux<ServerSentEvent> or Observable<ServerSentEvent>. \u2022A multi-value stream with any other media type (such as application/json) is adapted to, similar to using DeferredResult<List<?", "chunk_char_count": 1403, "chunk_word_count": 210, "chunk_token_count": 350.75}, {"page_number": 968, "sentence_chunk": ">>.\uf0eb Spring MVC supports Reactor and RxJava through the ReactiveAdapterRegistry from spring-core, which lets it adapt from multiple reactive libraries. For streaming to the response, reactive back pressure is supported, but writes to the response are still blocking and are run on a separate thread through the configured TaskExecutor, to avoid blocking the upstream source (such as a Flux returned from WebClient). By default, 968", "chunk_char_count": 431, "chunk_word_count": 65, "chunk_token_count": 107.75}, {"page_number": 969, "sentence_chunk": "SimpleAsyncTaskExecutor is used for the blocking writes, but that is not suitable under load. If you plan to stream with a reactive type, you should use the MVC configuration to configure a task executor. Context Propagation It is common to propagate context via java.lang. ThreadLocal. This works transparently for handling on the same thread, but requires additional work for asynchronous handling across multiple threads. The Micrometer Context Propagation library simplifies context propagation across threads, and across context mechanisms such as ThreadLocal values, Reactor context, GraphQL Java context, and others. If Micrometer Context Propagation is present on the classpath, when a controller method returns a reactive type such as Flux or Mono, all ThreadLocal values, for which there is a registered io.micrometer. ThreadLocalAccessor, are written to the Reactor Context as key-value pairs, using the key assigned by the ThreadLocalAccessor. For other asynchronous handling scenarios, you can use the Context Propagation library directly. For example: Java // Capture ThreadLocal values from the main thread ... ContextSnapshot snapshot = ContextSnapshot.captureAll(); // On a different thread: restore ThreadLocal values try (ContextSnapshot.", "chunk_char_count": 1257, "chunk_word_count": 177, "chunk_token_count": 314.25}, {"page_number": 969, "sentence_chunk": "Scope scoped = snapshot.setThreadLocals()) { \u00a0  // ... } For more details, see the documentation of the Micrometer Context Propagation library. Disconnects WebFlux The Servlet API does not provide any notification when a remote client goes away. Therefore, while streaming to the response, whether through SseEmitter or reactive types, it is important to send data periodically, since the write fails if the client has disconnected. The send could take the form of an empty (comment-only) SSE event or any other data that the other side would have to interpret as a heartbeat and ignore. Alternatively, consider using web messaging solutions (such as STOMP over WebSocket or WebSocket with SockJS) that have a built-in heartbeat mechanism. Configuration Compared to WebFlux The asynchronous request processing feature must be enabled at the Servlet container level. The 969", "chunk_char_count": 873, "chunk_word_count": 135, "chunk_token_count": 218.25}, {"page_number": 970, "sentence_chunk": "MVC configuration also exposes several options for asynchronous requests. Servlet Container Filter and Servlet declarations have an asyncSupported flag that needs to be set to true to enable asynchronous request processing. In addition, Filter mappings should be declared to handle the ASYNC jakarta.servlet. DispatchType. In Java configuration, when you use AbstractAnnotationConfigDispatcherServletInitializer to initialize the Servlet container, this is done automatically. In web.xml configuration, you can add <async-supported>true</async-supported> to the DispatcherServlet and to Filter declarations and add <dispatcher>ASYNC</dispatcher> to filter mappings. Spring MVC The MVC configuration exposes the following options related to asynchronous request processing: \u2022 Java configuration: Use the configureAsyncSupport callback on WebMvcConfigurer. \u2022XML namespace: Use the <async-support> element under <mvc:annotation-driven>. You can configure the following: \u2022 Default timeout value for async requests, which if not set, depends on the underlying Servlet container. \u2022AsyncTaskExecutor to use for blocking writes when streaming with Reactive Types and for executing Callable instances returned from controller methods.", "chunk_char_count": 1225, "chunk_word_count": 153, "chunk_token_count": 306.25}, {"page_number": 970, "sentence_chunk": "We highly recommended configuring this property if you stream with reactive types or have controller methods that return Callable, since by default, it is a SimpleAsyncTaskExecutor. \u2022DeferredResultProcessingInterceptor implementations and CallableProcessingInterceptor implementations. Note that you can also set the default timeout value on a DeferredResult, a ResponseBodyEmitter, and an SseEmitter. For a Callable, you can use WebAsyncTask to provide a timeout value.5.1.7. CORS WebFlux Spring MVC lets you handle CORS (Cross-Origin Resource Sharing). This section describes how to do so. Introduction WebFlux For security reasons, browsers prohibit AJAX calls to resources outside the current origin. For example, you could have your bank account in one tab and evil.com in another. Scripts from evil.com should not be able to make AJAX requests to your bank API with your credentials\u2009\u2014\u2009for 970", "chunk_char_count": 898, "chunk_word_count": 128, "chunk_token_count": 224.5}, {"page_number": 971, "sentence_chunk": "example withdrawing money from your account!Cross-Origin Resource Sharing (CORS) is a W3C specification implemented by most browsers that lets you specify what kind of cross-domain requests are authorized, rather than using less secure and less powerful workarounds based on IFRAME or JSONP. Processing WebFlux The CORS specification distinguishes between preflight, simple, and actual requests. To learn how CORS works, you can read this article, among many others, or see the specification for more details. Spring MVC HandlerMapping implementations provide built-in support for CORS. After successfully mapping a request to a handler, HandlerMapping implementations check the CORS configuration for the given request and handler and take further actions. Preflight requests are handled directly, while simple and actual CORS requests are intercepted, validated, and have required CORS response headers set. In order to enable cross-origin requests (that is, the Origin header is present and differs from the host of the request), you need to have some explicitly declared CORS configuration. If no matching CORS configuration is found, preflight requests are rejected. No CORS headers are added to the responses of simple and actual CORS requests and, consequently, browsers reject them.", "chunk_char_count": 1290, "chunk_word_count": 188, "chunk_token_count": 322.5}, {"page_number": 971, "sentence_chunk": "Each HandlerMapping can be configured individually with URL pattern-based CorsConfiguration mappings. In most cases, applications use the MVC Java configuration or the XML namespace to declare such mappings, which results in a single global map being passed to all HandlerMapping instances. You can combine global CORS configuration at the HandlerMapping level with more fine-grained, handler-level CORS configuration. For example, annotated controllers can use class- or method- level @CrossOrigin annotations (other handlers can implement CorsConfigurationSource). The rules for combining global and local configuration are generally additive\u2009\u2014\u2009for example, all global and all local origins. For those attributes where only a single value can be accepted, e.g. allowCredentials and maxAge, the local overrides the global value. See CorsConfiguration#combine(CorsConfiguration) for more details.\uf0eb To learn more from the source or make advanced customizations, check the code behind: \u2022 CorsConfiguration \u2022 CorsProcessor, DefaultCorsProcessor \u2022 AbstractHandlerMapping @CrossOrigin WebFlux The @CrossOrigin annotation enables cross-origin requests on annotated controller methods, as the 971", "chunk_char_count": 1189, "chunk_word_count": 154, "chunk_token_count": 297.25}, {"page_number": 972, "sentence_chunk": "following example shows: Java @RestController @RequestMapping(\"/account\") public class AccountController { \u00a0  @CrossOrigin \u00a0  @GetMapping(\"/{id}\") \u00a0  public Account retrieve(@PathVariable Long id) { \u00a0    // ... \u00a0  } \u00a0  @DeleteMapping(\"/{id}\") \u00a0  public void remove(@PathVariable Long id) { \u00a0    // ... \u00a0  } } Kotlin @RestController @RequestMapping(\"/account\") class AccountController { \u00a0  @CrossOrigin \u00a0  @GetMapping(\"/{id}\") \u00a0  fun retrieve(@PathVariable id: Long): Account { \u00a0    // ... \u00a0  } \u00a0  @DeleteMapping(\"/{id}\") \u00a0  fun remove(@PathVariable id: Long) { \u00a0    // ... \u00a0  } } By default, @CrossOrigin allows: \u2022 All origins. \u2022All headers. \u2022All HTTP methods to which the controller method is mapped.allowCredentials is not enabled by default, since that establishes a trust level that exposes sensitive user-specific information (such as cookies and CSRF tokens) and should only be used where appropriate. When it is enabled either allowOrigins must be set to one or more specific domain (but not the special value \"*\") or alternatively the allowOriginPatterns property may be used to match to a dynamic set of origins.972", "chunk_char_count": 1124, "chunk_word_count": 188, "chunk_token_count": 281.0}, {"page_number": 973, "sentence_chunk": "maxAge is set to 30 minutes.@CrossOrigin is supported at the class level, too, and is inherited by all methods, as the following example shows: Java @CrossOrigin(origins = \"https://domain2.com\", maxAge = 3600) @RestController @RequestMapping(\"/account\") public class AccountController { \u00a0  @GetMapping(\"/{id}\") \u00a0  public Account retrieve(@PathVariable Long id) { \u00a0    // ... \u00a0  } \u00a0  @DeleteMapping(\"/{id}\") \u00a0  public void remove(@PathVariable Long id) { \u00a0    // ... \u00a0  } } Kotlin @CrossOrigin(origins = [\"https://domain2.com\"], maxAge = 3600) @RestController @RequestMapping(\"/account\") class AccountController { \u00a0  @GetMapping(\"/{id}\") \u00a0  fun retrieve(@PathVariable id: Long): Account { \u00a0    // ... \u00a0  } \u00a0  @DeleteMapping(\"/{id}\") \u00a0  fun remove(@PathVariable id: Long) { \u00a0    // ... \u00a0  } You can use @CrossOrigin at both the class level and the method level, as the following example shows: 973", "chunk_char_count": 895, "chunk_word_count": 148, "chunk_token_count": 223.75}, {"page_number": 974, "sentence_chunk": "Java @CrossOrigin(maxAge = 3600) @RestController @RequestMapping(\"/account\") public class AccountController { \u00a0  @CrossOrigin(\"https://domain2.com\") \u00a0  @GetMapping(\"/{id}\") \u00a0  public Account retrieve(@PathVariable Long id) { \u00a0    // ... \u00a0  } \u00a0  @DeleteMapping(\"/{id}\") \u00a0  public void remove(@PathVariable Long id) { \u00a0    // ... \u00a0  } } Kotlin @CrossOrigin(maxAge = 3600) @RestController @RequestMapping(\"/account\") class AccountController { \u00a0  @CrossOrigin(\"https://domain2.com\") \u00a0  @GetMapping(\"/{id}\") \u00a0  fun retrieve(@PathVariable id: Long): Account { \u00a0    // ... \u00a0  } \u00a0  @DeleteMapping(\"/{id}\") \u00a0  fun remove(@PathVariable id: Long) { \u00a0    // ... \u00a0  } } Global Configuration WebFlux In addition to fine-grained, controller method level configuration, you probably want to define some global CORS configuration, too. You can set URL-based CorsConfiguration mappings individually on any HandlerMapping. Most applications, however, use the MVC Java configuration or the MVC XML namespace to do that. By default, global configuration enables the following: \u2022 All origins.974", "chunk_char_count": 1073, "chunk_word_count": 163, "chunk_token_count": 268.25}, {"page_number": 975, "sentence_chunk": "\u2022 All headers. \u2022GET, HEAD, and POST methods.allowCredentials is not enabled by default, since that establishes a trust level that exposes sensitive user-specific information (such as cookies and CSRF tokens) and should only be used where appropriate. When it is enabled either allowOrigins must be set to one or more specific domain (but not the special value \"*\") or alternatively the allowOriginPatterns property may be used to match to a dynamic set of origins.maxAge is set to 30 minutes. Java Configuration WebFlux To enable CORS in the MVC Java config, you can use the CorsRegistry callback, as the following example shows: Java @Configuration @EnableWebMvc public class WebConfig implements WebMvcConfigurer { \u00a0  @Override \u00a0  public void addCorsMappings(CorsRegistry registry) { \u00a0    registry.addMapping(\"/api/**\") \u00a0      .allowedOrigins(\"https://domain2.com\") \u00a0      .allowedMethods(\"PUT\", \"DELETE\") \u00a0      .allowedHeaders(\"header1\", \"header2\", \"header3\") \u00a0      .exposedHeaders(\"header1\", \"header2\") \u00a0      .allowCredentials(true).maxAge(3600); \u00a0    // Add more mappings... \u00a0  } } 975", "chunk_char_count": 1093, "chunk_word_count": 177, "chunk_token_count": 273.25}, {"page_number": 976, "sentence_chunk": "Kotlin @Configuration @EnableWebMvc class WebConfig : WebMvcConfigurer { \u00a0  override fun addCorsMappings(registry: CorsRegistry) { \u00a0    registry.addMapping(\"/api/**\") \u00a0        .allowedOrigins(\"https://domain2.com\") \u00a0        .allowedMethods(\"PUT\", \"DELETE\") \u00a0        .allowedHeaders(\"header1\", \"header2\", \"header3\") \u00a0        .exposedHeaders(\"header1\", \"header2\") \u00a0        .allowCredentials(true).maxAge(3600) \u00a0    // Add more mappings... \u00a0  } } XML Configuration To enable CORS in the XML namespace, you can use the <mvc:cors> element, as the following example shows: <mvc:cors> \u00a0  <mvc:mapping path=\"/api/**\" \u00a0    allowed-origins=\"https://domain1.com, https://domain2.com\" \u00a0    allowed-methods=\"GET, PUT\" \u00a0    allowed-headers=\"header1, header2, header3\" \u00a0    exposed-headers=\"header1, header2\" allow-credentials=\"true\" \u00a0    max-age=\"123\" /> \u00a0  <mvc:mapping path=\"/resources/**\" \u00a0    allowed-origins=\"https://domain1.com\" /> </mvc:cors> CORS Filter WebFlux You can apply CORS support through the built-in CorsFilter.\uf05a If you try to use the CorsFilter with Spring Security, keep in mind that Spring Security has built-in support for CORS. To configure the filter, pass a CorsConfigurationSource to its constructor, as the following example shows: 976", "chunk_char_count": 1248, "chunk_word_count": 198, "chunk_token_count": 312.0}, {"page_number": 977, "sentence_chunk": "Java CorsConfiguration config = new CorsConfiguration(); // Possibly... // config.applyPermitDefaultValues() config.setAllowCredentials(true); config.addAllowedOrigin(\"https://domain1.com\"); config.addAllowedHeader(\"*\"); config.addAllowedMethod(\"*\"); UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); source.registerCorsConfiguration(\"/**\", config); CorsFilter filter = new CorsFilter(source); Kotlin val config = CorsConfiguration() // Possibly... // config.applyPermitDefaultValues() config.allowCredentials = true config.addAllowedOrigin(\"https://domain1.com\") config.addAllowedHeader(\"*\") config.addAllowedMethod(\"*\") val source = UrlBasedCorsConfigurationSource() source.registerCorsConfiguration(\"/**\", config) val filter = CorsFilter(source) 5.1.8. Error Responses WebFlux A common requirement for REST services is to include details in the body of error responses. The Spring Framework supports the \"Problem Details for HTTP APIs\" specification, RFC 7807. The following are the main abstractions for this support: \u2022 ProblemDetail\u2009\u2014\u2009representation for an RFC 7807 problem detail; a simple container for both standard fields defined in the spec, and for non-standard ones. \u2022ErrorResponse\u2009\u2014\u2009contract to expose HTTP error response details including HTTP status, response headers, and a body in the format of RFC 7807; this allows exceptions to encapsulate and expose the details of how they map to an HTTP response. All Spring MVC exceptions implement this. \u2022ErrorResponseException\u2009\u2014\u2009basic ErrorResponse implementation that others can use as a 977", "chunk_char_count": 1581, "chunk_word_count": 170, "chunk_token_count": 395.25}, {"page_number": 978, "sentence_chunk": "convenient base class. \u2022ResponseEntityExceptionHandler\u2009\u2014\u2009convenient base class for an @ControllerAdvice that handles all Spring MVC exceptions, and any ErrorResponseException, and renders an error response with a body. Render WebFlux You can return ProblemDetail or ErrorResponse from any @ExceptionHandler or from any @RequestMapping method to render an RFC 7807 response. This is processed as follows: \u2022 The status property of ProblemDetail determines the HTTP status. \u2022The instance property of ProblemDetail is set from the current URL path, if not already set. \u2022For content negotiation, the Jackson HttpMessageConverter prefers \"application/problem+json\" over \"application/json\" when rendering a ProblemDetail, and also falls back on it if no compatible media type is found. To enable RFC 7807 responses for Spring WebFlux exceptions and for any ErrorResponseException, extend ResponseEntityExceptionHandler and declare it as an @ControllerAdvice in Spring configuration. The handler has an @ExceptionHandler method that handles any ErrorResponse exception, which includes all built-in web exceptions. You can add more exception handling methods, and use a protected method to map any exception to a ProblemDetail. Non-Standard Fields WebFlux You can extend an RFC 7807 response with non-standard fields in one of two ways.", "chunk_char_count": 1327, "chunk_word_count": 184, "chunk_token_count": 331.75}, {"page_number": 978, "sentence_chunk": "One, insert into the \"properties\" Map of ProblemDetail. When using the Jackson library, the Spring Framework registers ProblemDetailJacksonMixin that ensures this \"properties\" Map is unwrapped and rendered as top level JSON properties in the response, and likewise any unknown property during deserialization is inserted into this Map. You can also extend ProblemDetail to add dedicated non-standard properties. The copy constructor in ProblemDetail allows a subclass to make it easy to be created from an existing ProblemDetail. This could be done centrally, e.g. from an @ControllerAdvice such as ResponseEntityExceptionHandler that re-creates the ProblemDetail of an exception into a subclass with the additional non-standard fields. Internationalization WebFlux It is a common requirement to internationalize error response details, and good practice to customize the problem details for Spring MVC exceptions. This is supported as follows: \u2022 Each ErrorResponse exposes a message code and arguments to resolve the \"detail\" field through a MessageSource. The actual message code value is parameterized with placeholders, e.g. \"HTTP method {0} not supported\" to be expanded from the arguments.978", "chunk_char_count": 1198, "chunk_word_count": 170, "chunk_token_count": 299.5}, {"page_number": 979, "sentence_chunk": "\u2022 Each ErrorResponse also exposes a message code to resolve the \"title\" field. \u2022ResponseEntityExceptionHandler uses the message code and arguments to resolve the \"detail\" and the \"title\" fields. By default, the message code for the \"detail\" field is \"problemDetail.\"+ the fully qualified exception class name. Some exceptions may expose additional message codes in which case a suffix is added to the default message code. The table below lists message arguments and codes for Spring MVC exceptions: Exception Message Code Message Code Arguments AsyncRequestTimeoutExc eption (default) ConversionNotSupported Exception (default) {0} property name, {1} property value HttpMediaTypeNotAccept ableException (default) {0} list of supported media types HttpMediaTypeNotAccept ableException (default) + \".parseError\" HttpMediaTypeNotSuppor tedException (default) {0} the media type that is not supported, {1} list of supported media types HttpMediaTypeNotSuppor tedException (default) + \".parseError\" HttpMessageNotReadable Exception (default) HttpMessageNotWritable Exception (default) HttpRequestMethodNotSu pportedException (default) {0} the current HTTP method, {1} the list of supported HTTP methods MethodArgumentNotValid Exception (default) {0} the list of global errors, {1} the list of field errors. Message codes and arguments for each error within the BindingResult are also resolved via MessageSource. MissingRequestHeaderEx ception (default) {0} the header name MissingServletRequestP arameterException (default) {0} the request parameter name MissingMatrixVariableE xception (default) {0} the matrix variable name MissingPathVariableExc eption (default) {0} the path variable name MissingRequestCookieEx ception (default) {0} the cookie name MissingServletRequestP artException (default) {0} the part name 979", "chunk_char_count": 1817, "chunk_word_count": 227, "chunk_token_count": 454.25}, {"page_number": 980, "sentence_chunk": "Exception Message Code Message Code Arguments NoHandlerFoundExceptio n (default) TypeMismatchException (default) {0} property name, {1} property value UnsatisfiedServletRequ estParameterException (default) {0} the list of parameter conditions By default, the message code for the \"title\" field is \"problemDetail.title.\"+ the fully qualified exception class name. Client Handling WebFlux A client application can catch WebClientResponseException, when using the WebClient, or RestClientResponseException when using the RestTemplate, and use their getResponseBodyAs methods to decode the error response body to any target type such as ProblemDetail, or a subclass of ProblemDetail.5.1.9. Web Security WebFlux The Spring Security project provides support for protecting web applications from malicious exploits. See the Spring Security reference documentation, including: \u2022 Spring MVC Security \u2022 Spring MVC Test Support \u2022 CSRF protection \u2022 Security Response Headers HDIV is another web security framework that integrates with Spring MVC.5.1.10. HTTP Caching WebFlux HTTP caching can significantly improve the performance of a web application. HTTP caching revolves around the Cache-Control response header and, subsequently, conditional request headers (such as Last-Modified and ETag). Cache-Control advises private (for example, browser) and public (for example, proxy) caches on how to cache and re-use responses.", "chunk_char_count": 1413, "chunk_word_count": 186, "chunk_token_count": 353.25}, {"page_number": 980, "sentence_chunk": "An ETag header is used to make a conditional request that may result in a 304 (NOT_MODIFIED) without a body, if the content has not changed. ETag can be seen as a more sophisticated successor to the Last-Modified header. This section describes the HTTP caching-related options that are available in Spring Web MVC.980", "chunk_char_count": 317, "chunk_word_count": 53, "chunk_token_count": 79.25}, {"page_number": 981, "sentence_chunk": "CacheControl WebFlux CacheControl provides support for configuring settings related to the Cache-Control header and is accepted as an argument in a number of places: \u2022 WebContentInterceptor \u2022 WebContentGenerator \u2022 Controllers \u2022 Static Resources While RFC 7234 describes all possible directives for the Cache-Control response header, the CacheControl type takes a use case-oriented approach that focuses on the common scenarios: Java // Cache for an hour - \"Cache-Control: max-age=3600\" CacheControl ccCacheOneHour = CacheControl.maxAge(1, TimeUnit. HOURS); // Prevent caching - \"Cache-Control: no-store\" CacheControl ccNoStore = CacheControl.noStore(); // Cache for ten days in public and private caches, // public caches should not transform the response // \"Cache-Control: max-age=864000, public, no-transform\" CacheControl ccCustom = CacheControl.maxAge(10, TimeUnit. DAYS).noTransform().cachePublic(); Kotlin // Cache for an hour - \"Cache-Control: max-age=3600\" val ccCacheOneHour = CacheControl.maxAge(1, TimeUnit. HOURS) // Prevent caching - \"Cache-Control: no-store\" val ccNoStore = CacheControl.noStore() // Cache for ten days in public and private caches, // public caches should not transform the response // \"Cache-Control: max-age=864000, public, no-transform\" val ccCustom = CacheControl.maxAge(10, TimeUnit. DAYS).noTransform().cachePublic() WebContentGenerator also accepts a simpler cachePeriod property (defined in seconds) that works as follows: \u2022 A -1 value does not generate a Cache-Control response header. \u2022A 0 value prevents caching by using the 'Cache-Control: no-store' directive. \u2022An n > 0 value caches the given response for n seconds by using the 'Cache-Control: max-age=n' 981", "chunk_char_count": 1705, "chunk_word_count": 221, "chunk_token_count": 426.25}, {"page_number": 982, "sentence_chunk": "directive. Controllers WebFlux Controllers can add explicit support for HTTP caching. We recommended doing so, since the lastModified or ETag value for a resource needs to be calculated before it can be compared against conditional request headers. A controller can add an ETag header and Cache-Control settings to a ResponseEntity, as the following example shows: Java @GetMapping(\"/book/{id}\") public ResponseEntity<Book> showBook(@PathVariable Long id) { \u00a0  Book book = findBook(id); \u00a0  String version = book.getVersion(); \u00a0  return ResponseEntity \u00a0      .ok() \u00a0      .cacheControl(CacheControl.maxAge(30, TimeUnit. DAYS)) \u00a0      .eTag(version) // lastModified is also available \u00a0      .body(book); } Kotlin @GetMapping(\"/book/{id}\") fun showBook(@PathVariable id: Long): ResponseEntity<Book> { \u00a0  val book = findBook(id); \u00a0  val version = book.getVersion() \u00a0  return ResponseEntity \u00a0      .ok() \u00a0      .cacheControl(CacheControl.maxAge(30, TimeUnit. DAYS)) \u00a0      .eTag(version) // lastModified is also available \u00a0      .body(book) } The preceding example sends a 304 (NOT_MODIFIED) response with an empty body if the comparison to the conditional request headers indicates that the content has not changed. Otherwise, the ETag and Cache-Control headers are added to the response. You can also make the check against conditional request headers in the controller, as the following example shows: 982", "chunk_char_count": 1403, "chunk_word_count": 232, "chunk_token_count": 350.75}, {"page_number": 983, "sentence_chunk": "Java @RequestMapping public String myHandleMethod(WebRequest request, Model model) { \u00a0  long eTag = ... \u2460 \u00a0  if (request.checkNotModified(eTag)) { \u00a0    return null; \u2461 \u00a0  } \u00a0  model.addAttribute(...); \u2462 \u00a0  return \"myViewName\"; } \u2460 Application-specific calculation.\u2461 The response has been set to 304 (NOT_MODIFIED)\u2009\u2014\u2009no further processing.\u2462 Continue with the request processing. Kotlin @RequestMapping fun myHandleMethod(request: WebRequest, model: Model): String? {\u00a0  val eTag: Long = ... \u2460 \u00a0  if (request.checkNotModified(eTag)) { \u00a0    return null \u2461 \u00a0  } \u00a0  model[...] = ... \u2462 \u00a0  return \"myViewName\" } \u2460 Application-specific calculation.\u2461 The response has been set to 304 (NOT_MODIFIED)\u2009\u2014\u2009no further processing.\u2462 Continue with the request processing. There are three variants for checking conditional requests against eTag values, lastModified values, or both. For conditional GET and HEAD requests, you can set the response to 304 (NOT_MODIFIED). For conditional POST, PUT, and DELETE, you can instead set the response to 412 (PRECONDITION_FAILED), to prevent concurrent modification.", "chunk_char_count": 1085, "chunk_word_count": 166, "chunk_token_count": 271.25}, {"page_number": 983, "sentence_chunk": "Static Resources WebFlux You should serve static resources with a Cache-Control and conditional response headers for optimal performance. See the section on configuring Static Resources.983", "chunk_char_count": 189, "chunk_word_count": 25, "chunk_token_count": 47.25}, {"page_number": 984, "sentence_chunk": "ETag Filter You can use the ShallowEtagHeaderFilter to add \u201cshallow\u201d eTag values that are computed from the response content and, thus, save bandwidth but not CPU time. See Shallow ETag.5.1.11. View Technologies WebFlux The use of view technologies in Spring MVC is pluggable. Whether you decide to use Thymeleaf, Groovy Markup Templates, JSPs, or other technologies is primarily a matter of a configuration change. This chapter covers view technologies integrated with Spring MVC. We assume you are already familiar with View Resolution.\uf071 The views of a Spring MVC application live within the internal trust boundaries of that application. Views have access to all the beans of your application context. As such, it is not recommended to use Spring MVC\u2019s template support in applications where the templates are editable by external sources, since this can have security implications.", "chunk_char_count": 885, "chunk_word_count": 137, "chunk_token_count": 221.25}, {"page_number": 984, "sentence_chunk": "Thymeleaf WebFlux Thymeleaf is a modern server-side Java template engine that emphasizes natural HTML templates that can be previewed in a browser by double-clicking, which is very helpful for independent work on UI templates (for example, by a designer) without the need for a running server. If you want to replace JSPs, Thymeleaf offers one of the most extensive sets of features to make such a transition easier. Thymeleaf is actively developed and maintained. For a more complete introduction, see the Thymeleaf project home page. The Thymeleaf integration with Spring MVC is managed by the Thymeleaf project. The configuration involves a few bean declarations, such as ServletContextTemplateResolver, SpringTemplateEngine, and ThymeleafViewResolver. See Thymeleaf+Spring for more details. FreeMarker WebFlux Apache FreeMarker is a template engine for generating any kind of text output from HTML to email and others. The Spring Framework has built-in integration for using Spring MVC with FreeMarker templates. View Configuration WebFlux The following example shows how to configure FreeMarker as a view technology: 984", "chunk_char_count": 1125, "chunk_word_count": 165, "chunk_token_count": 281.25}, {"page_number": 985, "sentence_chunk": "Java @Configuration @EnableWebMvc public class WebConfig implements WebMvcConfigurer { \u00a0  @Override \u00a0  public void configureViewResolvers(ViewResolverRegistry registry) { \u00a0    registry.freeMarker(); \u00a0  } \u00a0  // Configure FreeMarker... \u00a0  @Bean \u00a0  public FreeMarkerConfigurer freeMarkerConfigurer() { \u00a0    FreeMarkerConfigurer configurer = new FreeMarkerConfigurer(); \u00a0    configurer.setTemplateLoaderPath(\"/WEB-INF/freemarker\"); \u00a0    return configurer; \u00a0  } } Kotlin @Configuration @EnableWebMvc class WebConfig : WebMvcConfigurer { \u00a0  override fun configureViewResolvers(registry: ViewResolverRegistry) { \u00a0    registry.freeMarker() \u00a0  } \u00a0  // Configure FreeMarker... \u00a0  @Bean \u00a0  fun freeMarkerConfigurer() = FreeMarkerConfigurer().apply { \u00a0    setTemplateLoaderPath(\"/WEB-INF/freemarker\") \u00a0  } } The following example shows how to configure the same in XML: 985", "chunk_char_count": 861, "chunk_word_count": 124, "chunk_token_count": 215.25}, {"page_number": 986, "sentence_chunk": "<mvc:annotation-driven/> <mvc:view-resolvers> \u00a0  <mvc:freemarker/> </mvc:view-resolvers> <!--Configure FreeMarker... --> <mvc:freemarker-configurer> \u00a0  <mvc:template-loader-path location=\"/WEB-INF/freemarker\"/> </mvc:freemarker-configurer> Alternatively, you can also declare the FreeMarkerConfigurer bean for full control over all properties, as the following example shows: <bean id=\"freemarkerConfig\" class=\"org.springframework.web.servlet.view.freemarker. FreeMarkerConfigurer\"> \u00a0  <property name=\"templateLoaderPath\" value=\"/WEB-INF/freemarker/\"/> </bean> Your templates need to be stored in the directory specified by the FreeMarkerConfigurer shown in the preceding example. Given the preceding configuration, if your controller returns a view name of welcome, the resolver looks for the /WEB-INF/freemarker/welcome.ftl template. FreeMarker Configuration WebFlux You can pass FreeMarker 'Settings' and 'SharedVariables' directly to the FreeMarker Configuration object (which is managed by Spring) by setting the appropriate bean properties on the FreeMarkerConfigurer bean. The freemarkerSettings property requires a java.util. Properties object, and the freemarkerVariables property requires a java.util. Map. The following example shows how to use a FreeMarkerConfigurer: <bean id=\"freemarkerConfig\" class=\"org.springframework.web.servlet.view.freemarker. FreeMarkerConfigurer\"> \u00a0  <property name=\"templateLoaderPath\" value=\"/WEB-INF/freemarker/\"/> \u00a0  <property name=\"freemarkerVariables\"> \u00a0    <map> \u00a0      <entry key=\"xml_escape\" value-ref=\"fmXmlEscape\"/> \u00a0    </map> \u00a0  </property> </bean> <bean id=\"fmXmlEscape\" class=\"freemarker.template.utility.", "chunk_char_count": 1659, "chunk_word_count": 177, "chunk_token_count": 414.75}, {"page_number": 986, "sentence_chunk": "XmlEscape\"/> See the FreeMarker documentation for details of settings and variables as they apply to the Configuration object.986", "chunk_char_count": 129, "chunk_word_count": 18, "chunk_token_count": 32.25}, {"page_number": 987, "sentence_chunk": "Form Handling Spring provides a tag library for use in JSPs that contains, among others, a <spring:bind/> element. This element primarily lets forms display values from form-backing objects and show the results of failed validations from a Validator in the web or business tier. Spring also has support for the same functionality in FreeMarker, with additional convenience macros for generating form input elements themselves. The Bind Macros WebFlux A standard set of macros are maintained within the spring-webmvc.jar file for FreeMarker, so they are always available to a suitably configured application. Some of the macros defined in the Spring templating libraries are considered internal (private), but no such scoping exists in the macro definitions, making all macros visible to calling code and user templates. The following sections concentrate only on the macros you need to directly call from within your templates. If you wish to view the macro code directly, the file is called spring.ftl and is in the org.springframework.web.servlet.view.freemarker package. Simple Binding In your HTML forms based on FreeMarker templates that act as a form view for a Spring MVC controller, you can use code similar to the next example to bind to field values and display error messages for each input field in similar fashion to the JSP equivalent. The following example shows a personForm view: <!--FreeMarker macros have to be imported into a namespace.", "chunk_char_count": 1456, "chunk_word_count": 227, "chunk_token_count": 364.0}, {"page_number": 987, "sentence_chunk": "We strongly recommend sticking to 'spring'. --> <#import \"/spring.ftl\" as spring/> <html> \u00a0  ... \u00a0  <form action=\"\" method=\"POST\"> \u00a0    Name: \u00a0    <@spring.bind \"personForm.name\"/> \u00a0    <input type=\"text\" \u00a0      name=\"${spring.status.expression}\" \u00a0      value=\"${spring.status.value?html}\"/><br /> \u00a0    <#list spring.status.errorMessages as error> <b>${error}</b> <br /> </#list> \u00a0    <br /> \u00a0    ... \u00a0    <input type=\"submit\" value=\"submit\"/> \u00a0  </form> \u00a0  ... </html> <@spring.bind> requires a 'path' argument, which consists of the name of your command object (it is 'command', unless you changed it in your controller configuration) followed by a period and the name of the field on the command object to which you wish to bind. You can also use nested fields, 987", "chunk_char_count": 768, "chunk_word_count": 141, "chunk_token_count": 192.0}, {"page_number": 988, "sentence_chunk": "such as command.address.street. The bind macro assumes the default HTML escaping behavior specified by the ServletContext parameter defaultHtmlEscape in web.xml. An alternative form of the macro called <@spring.bindEscaped> takes a second argument that explicitly specifies whether HTML escaping should be used in the status error messages or values. You can set it to true or false as required. Additional form handling macros simplify the use of HTML escaping, and you should use these macros wherever possible. They are explained in the next section. Input Macros Additional convenience macros for FreeMarker simplify both binding and form generation (including validation error display). It is never necessary to use these macros to generate form input fields, and you can mix and match them with simple HTML or direct calls to the Spring bind macros that we highlighted previously. The following table of available macros shows the FreeMarker Template (FTL) definitions and the parameter list that each takes: Table 26. Table of macro definitions macro FTL definition message (output a string from a resource bundle based on the code parameter) <@spring.message code/> messageText (output a string from a resource bundle based on the code parameter, falling back to the value of the default parameter) <@spring.messageText code, text/> url (prefix a relative URL with the application\u2019s context root) <@spring.url relativeUrl/> formInput (standard input field for gathering user input) <@spring.formInput path, attributes, fieldType/> formHiddenInput (hidden input field for submitting non-user input) <@spring.formHiddenI nput path, attributes/> formPasswordInput (standard input field for gathering passwords.", "chunk_char_count": 1715, "chunk_word_count": 246, "chunk_token_count": 428.75}, {"page_number": 988, "sentence_chunk": "Note that no value is ever populated in fields of this type.)<@spring.formPasswor dInput path, attributes/> formTextarea (large text field for gathering long, freeform text input) <@spring.formTextarea path, attributes/> formSingleSelect (drop down box of options that let a single required value be selected) <@spring.formSingleSe lect path, options, attributes/> formMultiSelect (a list box of options that let the user select 0 or more values) <@spring.formMultiSel ect path, options, attributes/> 988", "chunk_char_count": 504, "chunk_word_count": 68, "chunk_token_count": 126.0}, {"page_number": 989, "sentence_chunk": "macro FTL definition formRadioButtons (a set of radio buttons that let a single selection be made from the available choices) <@spring.formRadioBu ttons path, options separator, attributes/> formCheckboxes (a set of checkboxes that let 0 or more values be selected) <@spring.formCheckbo xes path, options, separator, attributes/> formCheckbox (a single checkbox) <@spring.formCheckbo x path, attributes/> showErrors (simplify display of validation errors for the bound field) <@spring.showErrors separator, classOrStyle/> \uf05a In FreeMarker templates, formHiddenInput and formPasswordInput are not actually required, as you can use the normal formInput macro, specifying hidden or password as the value for the fieldType parameter. The parameters to any of the above macros have consistent meanings: \u2022 path: The name of the field to bind to (ie \"command.name\") \u2022 options: A Map of all the available values that can be selected from in the input field. The keys to the map represent the values that are POSTed back from the form and bound to the command object. Map objects stored against the keys are the labels displayed on the form to the user and may be different from the corresponding values posted back by the form. Usually, such a map is supplied as reference data by the controller. You can use any Map implementation, depending on required behavior. For strictly sorted maps, you can use a SortedMap (such as a TreeMap) with a suitable Comparator and, for arbitrary Maps that should return values in insertion order, use a LinkedHashMap or a LinkedMap from commons-collections. \u2022separator: Where multiple options are available as discreet elements (radio buttons or checkboxes), the sequence of characters used to separate each one in the list (such as <br>). \u2022attributes: An additional string of arbitrary tags or text to be included within the HTML tag itself. This string is echoed literally by the macro.", "chunk_char_count": 1914, "chunk_word_count": 298, "chunk_token_count": 478.5}, {"page_number": 989, "sentence_chunk": "For example, in a textarea field, you may supply attributes (such as 'rows=\"5\" cols=\"60\"'), or you could pass style information such as 'style=\"border:1px solid silver\"'. \u2022classOrStyle: For the showErrors macro, the name of the CSS class that the span element that wraps each error uses. If no information is supplied (or the value is empty), the errors are wrapped in <b></b> tags. The following sections outline examples of the macros. Input Fields The formInput macro takes the path parameter (command.name) and an additional attributes parameter (which is empty in the upcoming example). The macro, along with all other form generation macros, performs an implicit Spring bind on the path parameter. The binding remains 989", "chunk_char_count": 727, "chunk_word_count": 114, "chunk_token_count": 181.75}, {"page_number": 990, "sentence_chunk": "valid until a new bind occurs, so the showErrors macro does not need to pass the path parameter again\u2009\u2014\u2009it operates on the field for which a binding was last created. The showErrors macro takes a separator parameter (the characters that are used to separate multiple errors on a given field) and also accepts a second parameter\u2009\u2014\u2009this time, a class name or style attribute. Note that FreeMarker can specify default values for the attributes parameter. The following example shows how to use the formInput and showErrors macros: <@spring.formInput \"command.name\"/> <@spring.showErrors \"<br>\"/> The next example shows the output of the form fragment, generating the name field and displaying a validation error after the form was submitted with no value in the field. Validation occurs through Spring\u2019s Validation framework. The generated HTML resembles the following example: Name: <input type=\"text\" name=\"name\" value=\"\"> <br> \u00a0  <b>required</b> <br> <br> The formTextarea macro works the same way as the formInput macro and accepts the same parameter list. Commonly, the second parameter (attributes) is used to pass style information or rows and cols attributes for the textarea. Selection Fields You can use four selection field macros to generate common UI value selection inputs in your HTML forms: \u2022 formSingleSelect \u2022 formMultiSelect \u2022 formRadioButtons \u2022 formCheckboxes Each of the four macros accepts a Map of options that contains the value for the form field and the label that corresponds to that value. The value and the label can be the same. The next example is for radio buttons in FTL.", "chunk_char_count": 1601, "chunk_word_count": 252, "chunk_token_count": 400.25}, {"page_number": 990, "sentence_chunk": "The form-backing object specifies a default value of 'London' for this field, so no validation is necessary. When the form is rendered, the entire list of cities to choose from is supplied as reference data in the model under the name 'cityMap'. The following listing shows the example: 990", "chunk_char_count": 290, "chunk_word_count": 49, "chunk_token_count": 72.5}, {"page_number": 991, "sentence_chunk": "... Town: <@spring.formRadioButtons \"command.address.town\", cityMap, \"\"/><br><br> The preceding listing renders a line of radio buttons, one for each value in cityMap, and uses a separator of \"\". No additional attributes are supplied (the last parameter to the macro is missing). The cityMap uses the same String for each key-value pair in the map. The map\u2019s keys are what the form actually submits as POST request parameters. The map values are the labels that the user sees. In the preceding example, given a list of three well known cities and a default value in the form backing object, the HTML resembles the following: Town: <input type=\"radio\" name=\"address.town\" value=\"London\">London</input> <input type=\"radio\" name=\"address.town\" value=\"Paris\" checked=\"checked\">Paris</input> <input type=\"radio\" name=\"address.town\" value=\"New York\">New York</input> If your application expects to handle cities by internal codes (for example), you can create the map of codes with suitable keys, as the following example shows: Java protected Map<String, ?> referenceData(HttpServletRequest request) throws Exception { \u00a0  Map<String, String> cityMap = new LinkedHashMap<>(); \u00a0  cityMap.put(\"LDN\", \"London\"); \u00a0  cityMap.put(\"PRS\", \"Paris\"); \u00a0  cityMap.put(\"NYC\", \"New York\"); \u00a0  Map<String, Object> model = new HashMap<>(); \u00a0  model.put(\"cityMap\", cityMap); \u00a0  return model; } Kotlin protected fun referenceData(request: HttpServletRequest): Map<String, *> { \u00a0  val cityMap = linkedMapOf( \u00a0      \"LDN\" to \"London\", \u00a0      \"PRS\" to \"Paris\", \u00a0      \"NYC\" to \"New York\" \u00a0  ) \u00a0  return hashMapOf(\"cityMap\" to cityMap) } The code now produces output where the radio values are the relevant codes, but the user still sees the more user-friendly city names, as follows: 991", "chunk_char_count": 1760, "chunk_word_count": 270, "chunk_token_count": 440.0}, {"page_number": 992, "sentence_chunk": "Town: <input type=\"radio\" name=\"address.town\" value=\"LDN\">London</input> <input type=\"radio\" name=\"address.town\" value=\"PRS\" checked=\"checked\">Paris</input> <input type=\"radio\" name=\"address.town\" value=\"NYC\">New York</input> HTML Escaping Default usage of the form macros described earlier results in HTML elements that are HTML 4.01 compliant and that use the default value for HTML escaping defined in your web.xml file, as used by Spring\u2019s bind support. To make the elements be XHTML compliant or to override the default HTML escaping value, you can specify two variables in your template (or in your model, where they are visible to your templates). The advantage of specifying them in the templates is that they can be changed to different values later in the template processing to provide different behavior for different fields in your form. To switch to XHTML compliance for your tags, specify a value of true for a model or context variable named xhtmlCompliant, as the following example shows: <#-- for FreeMarker --> <#assign xhtmlCompliant = true> After processing this directive, any elements generated by the Spring macros are now XHTML compliant. In similar fashion, you can specify HTML escaping per field, as the following example shows: <#-- until this point, default HTML escaping is used --> <#assign htmlEscape = true> <#-- next field will use HTML escaping --> <@spring.formInput \"command.name\"/> <#assign htmlEscape = false in spring> <#-- all future fields will be bound with HTML escaping off --> Groovy Markup The Groovy Markup Template Engine is primarily aimed at generating XML-like markup (XML, XHTML, HTML5, and others), but you can use it to generate any text-based content. The Spring Framework has a built-in integration for using Spring MVC with Groovy Markup.\uf05a The Groovy Markup Template engine requires Groovy 2.3.1+. Configuration The following example shows how to configure the Groovy Markup Template Engine: 992", "chunk_char_count": 1954, "chunk_word_count": 291, "chunk_token_count": 488.5}, {"page_number": 993, "sentence_chunk": "Java @Configuration @EnableWebMvc public class WebConfig implements WebMvcConfigurer { \u00a0  @Override \u00a0  public void configureViewResolvers(ViewResolverRegistry registry) { \u00a0    registry.groovy(); \u00a0  } \u00a0  // Configure the Groovy Markup Template Engine... \u00a0  @Bean \u00a0  public GroovyMarkupConfigurer groovyMarkupConfigurer() { \u00a0    GroovyMarkupConfigurer configurer = new GroovyMarkupConfigurer(); \u00a0    configurer.setResourceLoaderPath(\"/WEB-INF/\"); \u00a0    return configurer; \u00a0  } } Kotlin @Configuration @EnableWebMvc class WebConfig : WebMvcConfigurer { \u00a0  override fun configureViewResolvers(registry: ViewResolverRegistry) { \u00a0    registry.groovy() \u00a0  } \u00a0  // Configure the Groovy Markup Template Engine... \u00a0  @Bean \u00a0  fun groovyMarkupConfigurer() = GroovyMarkupConfigurer().apply { \u00a0    resourceLoaderPath = \"/WEB-INF/\" \u00a0  } } The following example shows how to configure the same in XML: 993", "chunk_char_count": 889, "chunk_word_count": 134, "chunk_token_count": 222.25}, {"page_number": 994, "sentence_chunk": "<mvc:annotation-driven/> <mvc:view-resolvers> \u00a0  <mvc:groovy/> </mvc:view-resolvers> <!--Configure the Groovy Markup Template Engine... --> <mvc:groovy-configurer resource-loader-path=\"/WEB-INF/\"/> Example Unlike traditional template engines, Groovy Markup relies on a DSL that uses a builder syntax. The following example shows a sample template for an HTML page: yieldUnescaped '<!DOCTYPE html>' html(lang:'en') { \u00a0  head { \u00a0    meta('http-equiv':'\"Content-Type\" content=\"text/html; charset=utf-8\"') \u00a0    title('My page') \u00a0  } \u00a0  body { \u00a0    p('This is an example of HTML contents') \u00a0  } } Script Views WebFlux The Spring Framework has a built-in integration for using Spring MVC with any templating library that can run on top of the JSR-223 Java scripting engine. We have tested the following templating libraries on different script engines: Scripting Library Scripting Engine Handlebars Nashorn Mustache Nashorn React Nashorn EJS Nashorn ERB JRuby String templates Jython Kotlin Script templating Kotlin \uf0eb The basic rule for integrating any other script engine is that it must implement the ScriptEngine and Invocable interfaces.994", "chunk_char_count": 1138, "chunk_word_count": 167, "chunk_token_count": 284.5}, {"page_number": 995, "sentence_chunk": "Requirements WebFlux You need to have the script engine on your classpath, the details of which vary by script engine: \u2022 The Nashorn JavaScript engine is provided with Java 8+. Using the latest update release available is highly recommended. \u2022JRuby should be added as a dependency for Ruby support. \u2022Jython should be added as a dependency for Python support. \u2022org.jetbrains.kotlin:kotlin-script-util dependency and a META- INF/services/javax.script. ScriptEngineFactory file containing a org.jetbrains.kotlin.script.jsr223. KotlinJsr223JvmLocalScriptEngineFactory line should be added for Kotlin script support. See this example for more details. You need to have the script templating library. One way to do that for JavaScript is through WebJars. Script Templates WebFlux You can declare a ScriptTemplateConfigurer bean to specify the script engine to use, the script files to load, what function to call to render templates, and so on.", "chunk_char_count": 938, "chunk_word_count": 134, "chunk_token_count": 234.5}, {"page_number": 995, "sentence_chunk": "The following example uses Mustache templates and the Nashorn JavaScript engine: Java @Configuration @EnableWebMvc public class WebConfig implements WebMvcConfigurer { \u00a0  @Override \u00a0  public void configureViewResolvers(ViewResolverRegistry registry) { \u00a0    registry.scriptTemplate(); \u00a0  } \u00a0  @Bean \u00a0  public ScriptTemplateConfigurer configurer() { \u00a0    ScriptTemplateConfigurer configurer = new ScriptTemplateConfigurer(); \u00a0    configurer.setEngineName(\"nashorn\"); \u00a0    configurer.setScripts(\"mustache.js\"); \u00a0    configurer.setRenderObject(\"Mustache\"); \u00a0    configurer.setRenderFunction(\"render\"); \u00a0    return configurer; \u00a0  } } 995", "chunk_char_count": 632, "chunk_word_count": 87, "chunk_token_count": 158.0}, {"page_number": 996, "sentence_chunk": "Kotlin @Configuration @EnableWebMvc class WebConfig : WebMvcConfigurer { \u00a0  override fun configureViewResolvers(registry: ViewResolverRegistry) { \u00a0    registry.scriptTemplate() \u00a0  } \u00a0  @Bean \u00a0  fun configurer() = ScriptTemplateConfigurer().apply { \u00a0    engineName = \"nashorn\" \u00a0    setScripts(\"mustache.js\") \u00a0    renderObject = \"Mustache\" \u00a0    renderFunction = \"render\" \u00a0  } } The following example shows the same arrangement in XML: <mvc:annotation-driven/> <mvc:view-resolvers> \u00a0  <mvc:script-template/> </mvc:view-resolvers> <mvc:script-template-configurer engine-name=\"nashorn\" render-object=\"Mustache\" render- function=\"render\"> \u00a0  <mvc:script location=\"mustache.js\"/> </mvc:script-template-configurer> The controller would look no different for the Java and XML configurations, as the following example shows: Java @Controller public class SampleController { \u00a0  @GetMapping(\"/sample\") \u00a0  public String test(Model model) { \u00a0    model.addAttribute(\"title\", \"Sample title\"); \u00a0    model.addAttribute(\"body\", \"Sample body\"); \u00a0    return \"template\"; \u00a0  } } 996", "chunk_char_count": 1059, "chunk_word_count": 146, "chunk_token_count": 264.75}, {"page_number": 997, "sentence_chunk": "Kotlin @Controller class SampleController { \u00a0  @GetMapping(\"/sample\") \u00a0  fun test(model: Model): String { \u00a0    model[\"title\"] = \"Sample title\" \u00a0    model[\"body\"] = \"Sample body\" \u00a0    return \"template\" \u00a0  } } The following example shows the Mustache template: <html> \u00a0  <head> \u00a0    <title>{{title}}</title> \u00a0  </head> \u00a0  <body> \u00a0    <p>{{body}}</p> \u00a0  </body> </html> The render function is called with the following parameters: \u2022 String template: The template content \u2022 Map model: The view model \u2022 RenderingContext renderingContext: The RenderingContext that gives access to the application context, the locale, the template loader, and the URL (since 5.0) Mustache.render() is natively compatible with this signature, so you can call it directly. If your templating technology requires some customization, you can provide a script that implements a custom render function. For example, Handlerbars needs to compile templates before using them and requires a polyfill to emulate some browser facilities that are not available in the server-side script engine. The following example shows how to do so: 997", "chunk_char_count": 1105, "chunk_word_count": 183, "chunk_token_count": 276.25}, {"page_number": 998, "sentence_chunk": "Java @Configuration @EnableWebMvc public class WebConfig implements WebMvcConfigurer { \u00a0  @Override \u00a0  public void configureViewResolvers(ViewResolverRegistry registry) { \u00a0    registry.scriptTemplate(); \u00a0  } \u00a0  @Bean \u00a0  public ScriptTemplateConfigurer configurer() { \u00a0    ScriptTemplateConfigurer configurer = new ScriptTemplateConfigurer(); \u00a0    configurer.setEngineName(\"nashorn\"); \u00a0    configurer.setScripts(\"polyfill.js\", \"handlebars.js\", \"render.js\"); \u00a0    configurer.setRenderFunction(\"render\"); \u00a0    configurer.setSharedEngine(false); \u00a0    return configurer; \u00a0  } } Kotlin @Configuration @EnableWebMvc class WebConfig : WebMvcConfigurer { \u00a0  override fun configureViewResolvers(registry: ViewResolverRegistry) { \u00a0    registry.scriptTemplate() \u00a0  } \u00a0  @Bean \u00a0  fun configurer() = ScriptTemplateConfigurer().apply { \u00a0    engineName = \"nashorn\" \u00a0    setScripts(\"polyfill.js\", \"handlebars.js\", \"render.js\") \u00a0    renderFunction = \"render\" \u00a0    isSharedEngine = false \u00a0  } } \uf05a Setting the sharedEngine property to false is required when using non-thread-safe script engines with templating libraries not designed for concurrency, such as Handlebars or React running on Nashorn. In that case, Java SE 8 update 60 is required, due to this bug, but it is generally recommended to use a recent Java SE patch release in any case.polyfill.js defines only the window object needed by Handlebars to run properly, as follows: 998", "chunk_char_count": 1421, "chunk_word_count": 215, "chunk_token_count": 355.25}, {"page_number": 999, "sentence_chunk": "var window = {}; This basic render.js implementation compiles the template before using it. A production-ready implementation should also store any reused cached templates or pre-compiled templates. You can do so on the script side (and handle any customization you need\u2009\u2014\u2009managing template engine configuration, for example). The following example shows how to do so: function render(template, model) { \u00a0  var compiledTemplate = Handlebars.compile(template); \u00a0  return compiledTemplate(model); } Check out the Spring Framework unit tests, Java, and resources, for more configuration examples. JSP and JSTL The Spring Framework has a built-in integration for using Spring MVC with JSP and JSTL. View Resolvers When developing with JSPs, you typically declare an InternalResourceViewResolver bean. InternalResourceViewResolver can be used for dispatching to any Servlet resource but in particular for JSPs. As a best practice, we strongly encourage placing your JSP files in a directory under the 'WEB-INF' directory so there can be no direct access by clients.<bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view. InternalResourceViewResolver\"> \u00a0  <property name=\"viewClass\" value=\"org.springframework.web.servlet.view.", "chunk_char_count": 1234, "chunk_word_count": 163, "chunk_token_count": 308.5}, {"page_number": 999, "sentence_chunk": "JstlView\"/> \u00a0  <property name=\"prefix\" value=\"/WEB-INF/jsp/\"/> \u00a0  <property name=\"suffix\" value=\".jsp\"/> </bean> JSPs versus JSTL When using the JSP Standard Tag Library (JSTL) you must use a special view class, the JstlView, as JSTL needs some preparation before things such as the I18N features can work. Spring\u2019s JSP Tag Library Spring provides data binding of request parameters to command objects, as described in earlier chapters. To facilitate the development of JSP pages in combination with those data binding features, Spring provides a few tags that make things even easier. All Spring tags have HTML escaping features to enable or disable escaping of characters. The spring.tld tag library descriptor (TLD) is included in the spring-webmvc.jar. For a comprehensive reference on individual tags, browse the API reference or see the tag library 999", "chunk_char_count": 858, "chunk_word_count": 131, "chunk_token_count": 214.5}, {"page_number": 1000, "sentence_chunk": "description. Spring\u2019s form tag library As of version 2.0, Spring provides a comprehensive set of data binding-aware tags for handling form elements when using JSP and Spring Web MVC. Each tag provides support for the set of attributes of its corresponding HTML tag counterpart, making the tags familiar and intuitive to use. The tag-generated HTML is HTML 4.01/XHTML 1.0 compliant. Unlike other form/input tag libraries, Spring\u2019s form tag library is integrated with Spring Web MVC, giving the tags access to the command object and reference data your controller deals with. As we show in the following examples, the form tags make JSPs easier to develop, read, and maintain. We go through the form tags and look at an example of how each tag is used. We have included generated HTML snippets where certain tags require further commentary. Configuration The form tag library comes bundled in spring-webmvc.jar. The library descriptor is called spring- form.tld.", "chunk_char_count": 960, "chunk_word_count": 153, "chunk_token_count": 240.0}, {"page_number": 1000, "sentence_chunk": "To use the tags from this library, add the following directive to the top of your JSP page: <%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %> where form is the tag name prefix you want to use for the tags from this library. The Form Tag This tag renders an HTML 'form' element and exposes a binding path to inner tags for binding. It puts the command object in the PageContext so that the command object can be accessed by inner tags. All the other tags in this library are nested tags of the form tag. Assume that we have a domain object called User. It is a JavaBean with properties such as firstName and lastName. We can use it as the form-backing object of our form controller, which returns form.jsp. The following example shows what form.jsp could look like: 1000", "chunk_char_count": 794, "chunk_word_count": 138, "chunk_token_count": 198.5}, {"page_number": 1001, "sentence_chunk": "<form:form> \u00a0  <table> \u00a0    <tr> \u00a0      <td>First Name:</td> \u00a0      <td><form:input path=\"firstName\"/></td> \u00a0    </tr> \u00a0    <tr> \u00a0      <td>Last Name:</td> \u00a0      <td><form:input path=\"lastName\"/></td> \u00a0    </tr> \u00a0    <tr> \u00a0      <td colspan=\"2\"> \u00a0        <input type=\"submit\" value=\"Save Changes\"/> \u00a0      </td> \u00a0    </tr> \u00a0  </table> </form:form> The firstName and lastName values are retrieved from the command object placed in the PageContext by the page controller. Keep reading to see more complex examples of how inner tags are used with the form tag. The following listing shows the generated HTML, which looks like a standard form: <form method=\"POST\"> \u00a0  <table> \u00a0    <tr> \u00a0      <td>First Name:</td> \u00a0      <td><input name=\"firstName\" type=\"text\" value=\"Harry\"/></td> \u00a0    </tr> \u00a0    <tr> \u00a0      <td>Last Name:</td> \u00a0      <td><input name=\"lastName\" type=\"text\" value=\"Potter\"/></td> \u00a0    </tr> \u00a0    <tr> \u00a0      <td colspan=\"2\"> \u00a0        <input type=\"submit\" value=\"Save Changes\"/> \u00a0      </td> \u00a0    </tr> \u00a0  </table> </form> The preceding JSP assumes that the variable name of the form-backing object is command. If you have put the form-backing object into the model under another name (definitely a best practice), you can bind the form to the named variable, as the following example shows: 1001", "chunk_char_count": 1310, "chunk_word_count": 294, "chunk_token_count": 327.5}, {"page_number": 1002, "sentence_chunk": "<form:form modelAttribute=\"user\"> \u00a0  <table> \u00a0    <tr> \u00a0      <td>First Name:</td> \u00a0      <td><form:input path=\"firstName\"/></td> \u00a0    </tr> \u00a0    <tr> \u00a0      <td>Last Name:</td> \u00a0      <td><form:input path=\"lastName\"/></td> \u00a0    </tr> \u00a0    <tr> \u00a0      <td colspan=\"2\"> \u00a0        <input type=\"submit\" value=\"Save Changes\"/> \u00a0      </td> \u00a0    </tr> \u00a0  </table> </form:form> The input Tag This tag renders an HTML input element with the bound value and type='text' by default. For an example of this tag, see The Form Tag. You can also use HTML5-specific types, such as email, tel, date, and others. The checkbox Tag This tag renders an HTML input tag with the type set to checkbox. Assume that our User has preferences such as newsletter subscription and a list of hobbies. The following example shows the Preferences class: 1002", "chunk_char_count": 826, "chunk_word_count": 178, "chunk_token_count": 206.5}, {"page_number": 1003, "sentence_chunk": "Java public class Preferences { \u00a0  private boolean receiveNewsletter; \u00a0  private String[] interests; \u00a0  private String favouriteWord; \u00a0  public boolean isReceiveNewsletter() { \u00a0    return receiveNewsletter; \u00a0  } \u00a0  public void setReceiveNewsletter(boolean receiveNewsletter) { \u00a0    this.receiveNewsletter = receiveNewsletter; \u00a0  } \u00a0  public String[] getInterests() { \u00a0    return interests; \u00a0  } \u00a0  public void setInterests(String[] interests) { \u00a0    this.interests = interests; \u00a0  } \u00a0  public String getFavouriteWord() { \u00a0    return favouriteWord; \u00a0  } \u00a0  public void setFavouriteWord(String favouriteWord) { \u00a0    this.favouriteWord = favouriteWord; \u00a0  } } Kotlin class Preferences( \u00a0    var receiveNewsletter: Boolean, \u00a0    var interests: StringArray, \u00a0    var favouriteWord: String ) The corresponding form.jsp could then resemble the following: 1003", "chunk_char_count": 852, "chunk_word_count": 151, "chunk_token_count": 213.0}, {"page_number": 1004, "sentence_chunk": "<form:form> \u00a0  <table> \u00a0    <tr> \u00a0      <td>Subscribe to newsletter?:</td> \u00a0      <%-- Approach 1: Property is of type java.lang. Boolean --%> \u00a0      <td><form:checkbox path=\"preferences.receiveNewsletter\"/></td> \u00a0    </tr> \u00a0    <tr> \u00a0      <td>Interests:</td> \u00a0      <%-- Approach 2: Property is of an array or of type java.util. Collection --%> \u00a0      <td> \u00a0        Quidditch: <form:checkbox path=\"preferences.interests\" value=\"Quidditch\"/> \u00a0        Herbology: <form:checkbox path=\"preferences.interests\" value=\"Herbology\"/> \u00a0        Defence Against the Dark Arts: <form:checkbox path=\"preferences.interests\" value=\"Defence Against the Dark Arts\"/> \u00a0      </td> \u00a0    </tr> \u00a0    <tr> \u00a0      <td>Favourite Word:</td> \u00a0      <%-- Approach 3: Property is of type java.lang. Object --%> \u00a0      <td> \u00a0        Magic: <form:checkbox path=\"preferences.favouriteWord\" value=\"Magic\"/> \u00a0      </td> \u00a0    </tr> \u00a0  </table> </form:form> There are three approaches to the checkbox tag, which should meet all your checkbox needs. \u2022Approach One: When the bound value is of type java.lang. Boolean, the input(checkbox) is marked as checked if the bound value is true. The value attribute corresponds to the resolved value of the setValue(Object) value property. \u2022Approach Two: When the bound value is of type array or java.util. Collection, the input(checkbox) is marked as checked if the configured setValue(Object) value is present in the bound Collection. \u2022Approach Three: For any other bound value type, the input(checkbox) is marked as checked if the configured setValue(Object) is equal to the bound value.", "chunk_char_count": 1596, "chunk_word_count": 311, "chunk_token_count": 399.0}, {"page_number": 1004, "sentence_chunk": "Note that, regardless of the approach, the same HTML structure is generated. The following HTML snippet defines some checkboxes: 1004", "chunk_char_count": 133, "chunk_word_count": 20, "chunk_token_count": 33.25}, {"page_number": 1005, "sentence_chunk": "<tr> \u00a0  <td>Interests:</td> \u00a0  <td> \u00a0    Quidditch: <input name=\"preferences.interests\" type=\"checkbox\" value=\"Quidditch\"/> \u00a0    <input type=\"hidden\" value=\"1\" name=\"_preferences.interests\"/> \u00a0    Herbology: <input name=\"preferences.interests\" type=\"checkbox\" value=\"Herbology\"/> \u00a0    <input type=\"hidden\" value=\"1\" name=\"_preferences.interests\"/> \u00a0    Defence Against the Dark Arts: <input name=\"preferences.interests\" type=\"checkbox\" value=\"Defence Against the Dark Arts\"/> \u00a0    <input type=\"hidden\" value=\"1\" name=\"_preferences.interests\"/> \u00a0  </td> </tr> You might not expect to see the additional hidden field after each checkbox. When a checkbox in an HTML page is not checked, its value is not sent to the server as part of the HTTP request parameters once the form is submitted, so we need a workaround for this quirk in HTML for Spring form data binding to work. The checkbox tag follows the existing Spring convention of including a hidden parameter prefixed by an underscore (_) for each checkbox. By doing this, you are effectively telling Spring that \u201cthe checkbox was visible in the form, and I want my object to which the form data binds to reflect the state of the checkbox, no matter what.\u201dThe checkboxes Tag This tag renders multiple HTML input tags with the type set to checkbox. This section build on the example from the previous checkbox tag section. Sometimes, you prefer not to have to list all the possible hobbies in your JSP page. You would rather provide a list at runtime of the available options and pass that in to the tag. That is the purpose of the checkboxes tag. You can pass in an Array, a List, or a Map that contains the available options in the items property.", "chunk_char_count": 1699, "chunk_word_count": 278, "chunk_token_count": 424.75}, {"page_number": 1005, "sentence_chunk": "Typically, the bound property is a collection so that it can hold multiple values selected by the user. The following example shows a JSP that uses this tag: <form:form> \u00a0  <table> \u00a0    <tr> \u00a0      <td>Interests:</td> \u00a0      <td> \u00a0        <%-- Property is of an array or of type java.util. Collection --%> \u00a0        <form:checkboxes path=\"preferences.interests\" items=\"${interestList}\"/> \u00a0      </td> \u00a0    </tr> \u00a0  </table> </form:form> This example assumes that the interestList is a List available as a model attribute that contains 1005", "chunk_char_count": 538, "chunk_word_count": 115, "chunk_token_count": 134.5}, {"page_number": 1006, "sentence_chunk": "strings of the values to be selected from. If you use a Map, the map entry key is used as the value, and the map entry\u2019s value is used as the label to be displayed. You can also use a custom object where you can provide the property names for the value by using itemValue and the label by using itemLabel. The radiobutton Tag This tag renders an HTML input element with the type set to radio. A typical usage pattern involves multiple tag instances bound to the same property but with different values, as the following example shows: <tr> \u00a0  <td>Sex:</td> \u00a0  <td> \u00a0    Male: <form:radiobutton path=\"sex\" value=\"M\"/> <br/> \u00a0    Female: <form:radiobutton path=\"sex\" value=\"F\"/> \u00a0  </td> </tr> The radiobuttons Tag This tag renders multiple HTML input elements with the type set to radio. As with the checkboxes tag, you might want to pass in the available options as a runtime variable. For this usage, you can use the radiobuttons tag. You pass in an Array, a List, or a Map that contains the available options in the items property. If you use a Map, the map entry key is used as the value and the map entry\u2019s value are used as the label to be displayed. You can also use a custom object where you can provide the property names for the value by using itemValue and the label by using itemLabel, as the following example shows: <tr> \u00a0  <td>Sex:</td> \u00a0  <td><form:radiobuttons path=\"sex\" items=\"${sexOptions}\"/></td> </tr> The password Tag This tag renders an HTML input tag with the type set to password with the bound value.", "chunk_char_count": 1526, "chunk_word_count": 277, "chunk_token_count": 381.5}, {"page_number": 1007, "sentence_chunk": "Note that, by default, the password value is not shown. If you do want the password value to be shown, you can set the value of the showPassword attribute to true, as the following example shows: <tr> \u00a0  <td>Password:</td> \u00a0  <td> \u00a0    <form:password path=\"password\" value=\"^76525bvHGq\" showPassword=\"true\"/> \u00a0  </td> </tr> The select Tag This tag renders an HTML 'select' element. It supports data binding to the selected option as well as the use of nested option and options tags. Assume that a User has a list of skills. The corresponding HTML could be as follows: <tr> \u00a0  <td>Skills:</td> \u00a0  <td><form:select path=\"skills\" items=\"${skills}\"/></td> </tr> If the User\u2019s skill are in Herbology, the HTML source of the 'Skills' row could be as follows: <tr> \u00a0  <td>Skills:</td> \u00a0  <td> \u00a0    <select name=\"skills\" multiple=\"true\"> \u00a0      <option value=\"Potions\">Potions</option> \u00a0      <option value=\"Herbology\" selected=\"selected\">Herbology</option> \u00a0      <option value=\"Quidditch\">Quidditch</option> \u00a0    </select> \u00a0  </td> </tr> The option Tag This tag renders an HTML option element. It sets selected, based on the bound value. The following HTML shows typical output for it: 1007", "chunk_char_count": 1185, "chunk_word_count": 203, "chunk_token_count": 296.25}, {"page_number": 1008, "sentence_chunk": "<tr> \u00a0  <td>House:</td> \u00a0  <td> \u00a0    <form:select path=\"house\"> \u00a0      <form:option value=\"Gryffindor\"/> \u00a0      <form:option value=\"Hufflepuff\"/> \u00a0      <form:option value=\"Ravenclaw\"/> \u00a0      <form:option value=\"Slytherin\"/> \u00a0    </form:select> \u00a0  </td> </tr> If the User\u2019s house was in Gryffindor, the HTML source of the 'House' row would be as follows: <tr> \u00a0  <td>House:</td> \u00a0  <td> \u00a0    <select name=\"house\"> \u00a0      <option value=\"Gryffindor\" selected=\"selected\">Gryffindor</option> \u2460 \u00a0      <option value=\"Hufflepuff\">Hufflepuff</option> \u00a0      <option value=\"Ravenclaw\">Ravenclaw</option> \u00a0      <option value=\"Slytherin\">Slytherin</option> \u00a0    </select> \u00a0  </td> </tr> \u2460 Note the addition of a selected attribute. The options Tag This tag renders a list of HTML option elements. It sets the selected attribute, based on the bound value. The following HTML shows typical output for it: <tr> \u00a0  <td>Country:</td> \u00a0  <td> \u00a0    <form:select path=\"country\"> \u00a0      <form:option value=\"-\" label=\"--Please Select\"/> \u00a0      <form:options items=\"${countryList}\" itemValue=\"code\" itemLabel=\"name\"/> \u00a0    </form:select> \u00a0  </td> </tr> If the User lived in the UK, the HTML source of the 'Country' row would be as follows: 1008", "chunk_char_count": 1225, "chunk_word_count": 227, "chunk_token_count": 306.25}, {"page_number": 1009, "sentence_chunk": "<tr> \u00a0  <td>Country:</td> \u00a0  <td> \u00a0    <select name=\"country\"> \u00a0      <option value=\"-\">--Please Select</option> \u00a0      <option value=\"AT\">Austria</option> \u00a0      <option value=\"UK\" selected=\"selected\">United Kingdom</option> \u2460 \u00a0      <option value=\"US\">United States</option> \u00a0    </select> \u00a0  </td> </tr> \u2460 Note the addition of a selected attribute. As the preceding example shows, the combined usage of an option tag with the options tag generates the same standard HTML but lets you explicitly specify a value in the JSP that is for display only (where it belongs), such as the default string in the example: \"-- Please Select\". The items attribute is typically populated with a collection or array of item objects.itemValue and itemLabel refer to bean properties of those item objects, if specified. Otherwise, the item objects themselves are turned into strings. Alternatively, you can specify a Map of items, in which case the map keys are interpreted as option values and the map values correspond to option labels. If itemValue or itemLabel (or both) happen to be specified as well, the item value property applies to the map key, and the item label property applies to the map value. The textarea Tag This tag renders an HTML textarea element. The following HTML shows typical output for it: <tr> \u00a0  <td>Notes:</td> \u00a0  <td><form:textarea path=\"notes\" rows=\"3\" cols=\"20\"/></td> \u00a0  <td><form:errors path=\"notes\"/></td> </tr> The hidden Tag This tag renders an HTML input tag with the type set to hidden with the bound value. To submit an unbound hidden value, use the HTML input tag with the type set to hidden.", "chunk_char_count": 1619, "chunk_word_count": 280, "chunk_token_count": 404.75}, {"page_number": 1009, "sentence_chunk": "The following HTML shows typical output for it: <form:hidden path=\"house\"/> If we choose to submit the house value as a hidden one, the HTML would be as follows: <input name=\"house\" type=\"hidden\" value=\"Gryffindor\"/> 1009", "chunk_char_count": 221, "chunk_word_count": 33, "chunk_token_count": 55.25}, {"page_number": 1010, "sentence_chunk": "The errors Tag This tag renders field errors in an HTML span element. It provides access to the errors created in your controller or those that were created by any validators associated with your controller. Assume that we want to display all error messages for the firstName and lastName fields once we submit the form. We have a validator for instances of the User class called UserValidator, as the following example shows: Java public class UserValidator implements Validator { \u00a0  public boolean supports(Class candidate) { \u00a0    return User.class.isAssignableFrom(candidate); \u00a0  } \u00a0  public void validate(Object obj, Errors errors) { \u00a0    ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"firstName\", \"required\", \"Field is required.\");\u00a0    ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"lastName\", \"required\", \"Field is required.\");\u00a0  } } Kotlin class UserValidator : Validator { \u00a0  override fun supports(candidate: Class<*>): Boolean { \u00a0    return User::class.java.isAssignableFrom(candidate) \u00a0  } \u00a0  override fun validate(obj: Any, errors: Errors) { \u00a0    ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"firstName\", \"required\", \"Field is required.\")\u00a0    ValidationUtils.rejectIfEmptyOrWhitespace(errors, \"lastName\", \"required\", \"Field is required.\")\u00a0  } } The form.jsp could be as follows: 1010", "chunk_char_count": 1307, "chunk_word_count": 187, "chunk_token_count": 326.75}, {"page_number": 1011, "sentence_chunk": "<form:form> \u00a0  <table> \u00a0    <tr> \u00a0      <td>First Name:</td> \u00a0      <td><form:input path=\"firstName\"/></td> \u00a0      <%-- Show errors for firstName field --%> \u00a0      <td><form:errors path=\"firstName\"/></td> \u00a0    </tr> \u00a0    <tr> \u00a0      <td>Last Name:</td> \u00a0      <td><form:input path=\"lastName\"/></td> \u00a0      <%-- Show errors for lastName field --%> \u00a0      <td><form:errors path=\"lastName\"/></td> \u00a0    </tr> \u00a0    <tr> \u00a0      <td colspan=\"3\"> \u00a0        <input type=\"submit\" value=\"Save Changes\"/> \u00a0      </td> \u00a0    </tr> \u00a0  </table> </form:form> If we submit a form with empty values in the firstName and lastName fields, the HTML would be as follows: <form method=\"POST\"> \u00a0  <table> \u00a0    <tr> \u00a0      <td>First Name:</td> \u00a0      <td><input name=\"firstName\" type=\"text\" value=\"\"/></td> \u00a0      <%-- Associated errors to firstName field displayed --%> \u00a0      <td><span name=\"firstName.errors\">Field is required.</span></td> \u00a0    </tr> \u00a0    <tr> \u00a0      <td>Last Name:</td> \u00a0      <td><input name=\"lastName\" type=\"text\" value=\"\"/></td> \u00a0      <%-- Associated errors to lastName field displayed --%> \u00a0      <td><span name=\"lastName.errors\">Field is required.</span></td> \u00a0    </tr> \u00a0    <tr> \u00a0      <td colspan=\"3\"> \u00a0        <input type=\"submit\" value=\"Save Changes\"/> \u00a0      </td> \u00a0    </tr> \u00a0  </table> </form> 1011", "chunk_char_count": 1306, "chunk_word_count": 310, "chunk_token_count": 326.5}, {"page_number": 1012, "sentence_chunk": "What if we want to display the entire list of errors for a given page?The next example shows that the errors tag also supports some basic wildcarding functionality. \u2022path=\"*\": Displays all errors. \u2022path=\"lastName\": Displays all errors associated with the lastName field. \u2022If path is omitted, only object errors are displayed. The following example displays a list of errors at the top of the page, followed by field-specific errors next to the fields: <form:form> \u00a0  <form:errors path=\"*\" cssClass=\"errorBox\"/> \u00a0  <table> \u00a0    <tr> \u00a0      <td>First Name:</td> \u00a0      <td><form:input path=\"firstName\"/></td> \u00a0      <td><form:errors path=\"firstName\"/></td> \u00a0    </tr> \u00a0    <tr> \u00a0      <td>Last Name:</td> \u00a0      <td><form:input path=\"lastName\"/></td> \u00a0      <td><form:errors path=\"lastName\"/></td> \u00a0    </tr> \u00a0    <tr> \u00a0      <td colspan=\"3\"> \u00a0        <input type=\"submit\" value=\"Save Changes\"/> \u00a0      </td> \u00a0    </tr> \u00a0  </table> </form:form> The HTML would be as follows: 1012", "chunk_char_count": 977, "chunk_word_count": 197, "chunk_token_count": 244.25}, {"page_number": 1013, "sentence_chunk": "<form method=\"POST\"> \u00a0  <span name=\"*.errors\" class=\"errorBox\">Field is required.<br/>Field is required.</span> \u00a0  <table> \u00a0    <tr> \u00a0      <td>First Name:</td> \u00a0      <td><input name=\"firstName\" type=\"text\" value=\"\"/></td> \u00a0      <td><span name=\"firstName.errors\">Field is required.</span></td> \u00a0    </tr> \u00a0    <tr> \u00a0      <td>Last Name:</td> \u00a0      <td><input name=\"lastName\" type=\"text\" value=\"\"/></td> \u00a0      <td><span name=\"lastName.errors\">Field is required.</span></td> \u00a0    </tr> \u00a0    <tr> \u00a0      <td colspan=\"3\"> \u00a0        <input type=\"submit\" value=\"Save Changes\"/> \u00a0      </td> \u00a0    </tr> \u00a0  </table> </form> The spring-form.tld tag library descriptor (TLD) is included in the spring-webmvc.jar. For a comprehensive reference on individual tags, browse the API reference or see the tag library description. HTTP Method Conversion A key principle of REST is the use of the \u201cUniform Interface\u201d. This means that all resources (URLs) can be manipulated by using the same four HTTP methods: GET, PUT, POST, and DELETE. For each method, the HTTP specification defines the exact semantics. For instance, a GET should always be a safe operation, meaning that it has no side effects, and a PUT or DELETE should be idempotent, meaning that you can repeat these operations over and over again, but the end result should be the same. While HTTP defines these four methods, HTML only supports two: GET and POST. Fortunately, there are two possible workarounds: you can either use JavaScript to do your PUT or DELETE, or you can do a POST with the \u201creal\u201d method as an additional parameter (modeled as a hidden input field in an HTML form). Spring\u2019s HiddenHttpMethodFilter uses this latter trick. This filter is a plain Servlet filter and, therefore, it can be used in combination with any web framework (not just Spring MVC).", "chunk_char_count": 1821, "chunk_word_count": 332, "chunk_token_count": 455.25}, {"page_number": 1013, "sentence_chunk": "Add this filter to your web.xml, and a POST with a hidden method parameter is converted into the corresponding HTTP method request. To support HTTP method conversion, the Spring MVC form tag was updated to support setting the HTTP method. For example, the following snippet comes from the Pet Clinic sample: 1013", "chunk_char_count": 312, "chunk_word_count": 52, "chunk_token_count": 78.0}, {"page_number": 1014, "sentence_chunk": "<form:form method=\"delete\"> \u00a0  <p class=\"submit\"><input type=\"submit\" value=\"Delete Pet\"/></p> </form:form> The preceding example performs an HTTP POST, with the \u201creal\u201d DELETE method hidden behind a request parameter. It is picked up by the HiddenHttpMethodFilter, which is defined in web.xml, as the following example shows: <filter> \u00a0  <filter-name>httpMethodFilter</filter-name> \u00a0  <filter-class>org.springframework.web.filter. HiddenHttpMethodFilter</filter-class> </filter> <filter-mapping> \u00a0  <filter-name>httpMethodFilter</filter-name> \u00a0  <servlet-name>petclinic</servlet-name> </filter-mapping> The following example shows the corresponding @Controller method: Java @RequestMapping(method = RequestMethod. DELETE) public String deletePet(@PathVariable int ownerId, @PathVariable int petId) { \u00a0  this.clinic.deletePet(petId); \u00a0  return \"redirect:/owners/\" + ownerId; } Kotlin @RequestMapping(method = [RequestMethod. DELETE]) fun deletePet(@PathVariable ownerId: Int, @PathVariable petId: Int): String { \u00a0  clinic.deletePet(petId) \u00a0  return \"redirect:/owners/$ownerId\" } HTML5 Tags The Spring form tag library allows entering dynamic attributes, which means you can enter any HTML5 specific attributes. The form input tag supports entering a type attribute other than text. This is intended to allow rendering new HTML5 specific input types, such as email, date, range, and others. Note that entering type='text' is not required, since text is the default type.1014", "chunk_char_count": 1472, "chunk_word_count": 178, "chunk_token_count": 368.0}, {"page_number": 1015, "sentence_chunk": "Tiles You can integrate Tiles - just as any other view technology - in web applications that use Spring. This section describes, in a broad way, how to do so.\uf05a This section focuses on Spring\u2019s support for Tiles version 3 in the org.springframework.web.servlet.view.tiles3 package. Dependencies To be able to use Tiles, you have to add a dependency on Tiles version 3.0.1 or higher and its transitive dependencies to your project. Configuration To be able to use Tiles, you have to configure it by using files that contain definitions (for basic information on definitions and other Tiles concepts, see https://tiles.apache.org). In Spring, this is done by using the TilesConfigurer. The following example ApplicationContext configuration shows how to do so: <bean id=\"tilesConfigurer\" class=\"org.springframework.web.servlet.view.tiles3. TilesConfigurer\"> \u00a0  <property name=\"definitions\"> \u00a0    <list> \u00a0      <value>/WEB-INF/defs/general.xml</value> \u00a0      <value>/WEB-INF/defs/widgets.xml</value> \u00a0      <value>/WEB-INF/defs/administrator.xml</value> \u00a0      <value>/WEB-INF/defs/customer.xml</value> \u00a0      <value>/WEB-INF/defs/templates.xml</value> \u00a0    </list> \u00a0  </property> </bean> The preceding example defines five files that contain definitions. The files are all located in the WEB- INF/defs directory. At initialization of the WebApplicationContext, the files are loaded, and the definitions factory are initialized. After that has been done, the Tiles included in the definition files can be used as views within your Spring web application.", "chunk_char_count": 1550, "chunk_word_count": 231, "chunk_token_count": 387.5}, {"page_number": 1015, "sentence_chunk": "To be able to use the views, you have to have a ViewResolver as with any other view technology in Spring: typically a convenient TilesViewResolver. You can specify locale-specific Tiles definitions by adding an underscore and then the locale, as the following example shows: 1015", "chunk_char_count": 279, "chunk_word_count": 45, "chunk_token_count": 69.75}, {"page_number": 1016, "sentence_chunk": "<bean id=\"tilesConfigurer\" class=\"org.springframework.web.servlet.view.tiles3. TilesConfigurer\"> \u00a0  <property name=\"definitions\"> \u00a0    <list> \u00a0      <value>/WEB-INF/defs/tiles.xml</value> \u00a0      <value>/WEB-INF/defs/tiles_fr_FR.xml</value> \u00a0    </list> \u00a0  </property> </bean> With the preceding configuration, tiles_fr_FR.xml is used for requests with the fr_FR locale, and tiles.xml is used by default.\uf05a Since underscores are used to indicate locales, we recommended not using them otherwise in the file names for Tiles definitions. UrlBasedViewResolver The UrlBasedViewResolver instantiates the given viewClass for each view it has to resolve. The following bean defines a UrlBasedViewResolver: <bean id=\"viewResolver\" class=\"org.springframework.web.servlet.view. UrlBasedViewResolver\"> \u00a0  <property name=\"viewClass\" value=\"org.springframework.web.servlet.view.tiles3. TilesView\"/> </bean> SimpleSpringPreparerFactory and SpringBeanPreparerFactory As an advanced feature, Spring also supports two special Tiles PreparerFactory implementations. See the Tiles documentation for details on how to use ViewPreparer references in your Tiles definition files. You can specify SimpleSpringPreparerFactory to autowire ViewPreparer instances based on specified preparer classes, applying Spring\u2019s container callbacks as well as applying configured Spring BeanPostProcessors. If Spring\u2019s context-wide annotation configuration has been activated, annotations in ViewPreparer classes are automatically detected and applied. Note that this expects preparer classes in the Tiles definition files, as the default PreparerFactory does. You can specify SpringBeanPreparerFactory to operate on specified preparer names (instead of classes), obtaining the corresponding Spring bean from the DispatcherServlet\u2019s application context.", "chunk_char_count": 1814, "chunk_word_count": 218, "chunk_token_count": 453.5}, {"page_number": 1016, "sentence_chunk": "The full bean creation process is in the control of the Spring application context in this case, allowing for the use of explicit dependency injection configuration, scoped beans, and so on. Note that you need to define one Spring bean definition for each preparer name (as used in your Tiles definitions). The following example shows how to define a SpringBeanPreparerFactory property on a TilesConfigurer bean: 1016", "chunk_char_count": 417, "chunk_word_count": 66, "chunk_token_count": 104.25}, {"page_number": 1017, "sentence_chunk": "<bean id=\"tilesConfigurer\" class=\"org.springframework.web.servlet.view.tiles3. TilesConfigurer\"> \u00a0  <property name=\"definitions\"> \u00a0    <list> \u00a0      <value>/WEB-INF/defs/general.xml</value> \u00a0      <value>/WEB-INF/defs/widgets.xml</value> \u00a0      <value>/WEB-INF/defs/administrator.xml</value> \u00a0      <value>/WEB-INF/defs/customer.xml</value> \u00a0      <value>/WEB-INF/defs/templates.xml</value> \u00a0    </list> \u00a0  </property> \u00a0  <!--resolving preparer names as Spring bean definition names --> \u00a0  <property name=\"preparerFactoryClass\" \u00a0 value=\"org.springframework.web.servlet.view.tiles3. SpringBeanPreparerFactory\"/> </bean> RSS and Atom Both AbstractAtomFeedView and AbstractRssFeedView inherit from the AbstractFeedView base class and are used to provide Atom and RSS Feed views, respectively. They are based on ROME project and are located in the package org.springframework.web.servlet.view.feed. AbstractAtomFeedView requires you to implement the buildFeedEntries() method and optionally override the buildFeedMetadata() method (the default implementation is empty). The following example shows how to do so: Java public class SampleContentAtomView extends AbstractAtomFeedView { \u00a0  @Override \u00a0  protected void buildFeedMetadata(Map<String, Object> model, \u00a0      Feed feed, HttpServletRequest request) { \u00a0    // implementation omitted \u00a0  } \u00a0  @Override \u00a0  protected List<Entry> buildFeedEntries(Map<String, Object> model, \u00a0      HttpServletRequest request, HttpServletResponse response) throws Exception { \u00a0    // implementation omitted \u00a0  } } 1017", "chunk_char_count": 1547, "chunk_word_count": 212, "chunk_token_count": 386.75}, {"page_number": 1018, "sentence_chunk": "Kotlin class SampleContentAtomView : AbstractAtomFeedView() { \u00a0  override fun buildFeedMetadata(model: Map<String, Any>, \u00a0      feed: Feed, request: HttpServletRequest) { \u00a0    // implementation omitted \u00a0  } \u00a0  override fun buildFeedEntries(model: Map<String, Any>, \u00a0      request: HttpServletRequest, response: HttpServletResponse): List<Entry> { \u00a0    // implementation omitted \u00a0  } } Similar requirements apply for implementing AbstractRssFeedView, as the following example shows: Java public class SampleContentRssView extends AbstractRssFeedView { \u00a0  @Override \u00a0  protected void buildFeedMetadata(Map<String, Object> model, \u00a0      Channel feed, HttpServletRequest request) { \u00a0    // implementation omitted \u00a0  } \u00a0  @Override \u00a0  protected List<Item> buildFeedItems(Map<String, Object> model, \u00a0      HttpServletRequest request, HttpServletResponse response) throws Exception { \u00a0    // implementation omitted \u00a0  } } Kotlin class SampleContentRssView : AbstractRssFeedView() { \u00a0  override fun buildFeedMetadata(model: Map<String, Any>, \u00a0                feed: Channel, request: HttpServletRequest) { \u00a0    // implementation omitted \u00a0  } \u00a0  override fun buildFeedItems(model: Map<String, Any>, \u00a0      request: HttpServletRequest, response: HttpServletResponse): List<Item> { \u00a0    // implementation omitted \u00a0  } } 1018", "chunk_char_count": 1312, "chunk_word_count": 222, "chunk_token_count": 328.0}, {"page_number": 1019, "sentence_chunk": "The buildFeedItems() and buildFeedEntries() methods pass in the HTTP request, in case you need to access the Locale. The HTTP response is passed in only for the setting of cookies or other HTTP headers. The feed is automatically written to the response object after the method returns. For an example of creating an Atom view, see Alef Arendsen\u2019s Spring Team Blog entry. PDF and Excel Spring offers ways to return output other than HTML, including PDF and Excel spreadsheets. This section describes how to use those features. Introduction to Document Views An HTML page is not always the best way for the user to view the model output, and Spring makes it simple to generate a PDF document or an Excel spreadsheet dynamically from the model data. The document is the view and is streamed from the server with the correct content type, to (hopefully) enable the client PC to run their spreadsheet or PDF viewer application in response. In order to use Excel views, you need to add the Apache POI library to your classpath. For PDF generation, you need to add (preferably) the OpenPDF library.", "chunk_char_count": 1091, "chunk_word_count": 187, "chunk_token_count": 272.75}, {"page_number": 1019, "sentence_chunk": "\uf05a You should use the latest versions of the underlying document-generation libraries, if possible. In particular, we strongly recommend OpenPDF (for example, OpenPDF 1.2.12) instead of the outdated original iText 2.1.7, since OpenPDF is actively maintained and fixes an important vulnerability for untrusted PDF content. PDF Views A simple PDF view for a word list could extend org.springframework.web.servlet.view.document. AbstractPdfView and implement the buildPdfDocument() method, as the following example shows: Java public class PdfWordList extends AbstractPdfView { \u00a0  protected void buildPdfDocument(Map<String, Object> model, Document doc, PdfWriter writer, \u00a0      HttpServletRequest request, HttpServletResponse response) throws Exception { \u00a0    List<String> words = (List<String>) model.get(\"wordList\"); \u00a0    for (String word : words) { \u00a0      doc.add(new Paragraph(word)); \u00a0    } \u00a0  } } 1019", "chunk_char_count": 904, "chunk_word_count": 137, "chunk_token_count": 226.0}, {"page_number": 1020, "sentence_chunk": "Kotlin class PdfWordList : AbstractPdfView() { \u00a0  override fun buildPdfDocument(model: Map<String, Any>, doc: Document, writer: PdfWriter, \u00a0      request: HttpServletRequest, response: HttpServletResponse) { \u00a0    val words = model[\"wordList\"] as List<String> \u00a0    for (word in words) { \u00a0      doc.add(Paragraph(word)) \u00a0    } \u00a0  } } A controller can return such a view either from an external view definition (referencing it by name) or as a View instance from the handler method. Excel Views Since Spring Framework 4.2, org.springframework.web.servlet.view.document. AbstractXlsView is provided as a base class for Excel views. It is based on Apache POI, with specialized subclasses (AbstractXlsxView and AbstractXlsxStreamingView) that supersede the outdated AbstractExcelView class. The programming model is similar to AbstractPdfView, with buildExcelDocument() as the central template method and controllers being able to return such a view from an external definition (by name) or as a View instance from the handler method. Jackson WebFlux Spring offers support for the Jackson JSON library. Jackson-based JSON MVC Views WebFlux The MappingJackson2JsonView uses the Jackson library\u2019s ObjectMapper to render the response content as JSON. By default, the entire contents of the model map (with the exception of framework-specific classes) are encoded as JSON. For cases where the contents of the map need to be filtered, you can specify a specific set of model attributes to encode by using the modelKeys property. You can also use the extractValueFromSingleKeyModel property to have the value in single-key models extracted and serialized directly rather than as a map of model attributes.", "chunk_char_count": 1693, "chunk_word_count": 264, "chunk_token_count": 423.25}, {"page_number": 1020, "sentence_chunk": "You can customize JSON mapping as needed by using Jackson\u2019s provided annotations. When you need further control, you can inject a custom ObjectMapper through the ObjectMapper property, for cases where you need to provide custom JSON serializers and deserializers for specific types.1020", "chunk_char_count": 286, "chunk_word_count": 42, "chunk_token_count": 71.5}, {"page_number": 1021, "sentence_chunk": "Jackson-based XML Views WebFlux MappingJackson2XmlView uses the Jackson XML extension\u2019s XmlMapper to render the response content as XML. If the model contains multiple entries, you should explicitly set the object to be serialized by using the modelKey bean property. If the model contains a single entry, it is serialized automatically. You can customized XML mapping as needed by using JAXB or Jackson\u2019s provided annotations. When you need further control, you can inject a custom XmlMapper through the ObjectMapper property, for cases where custom XML you need to provide serializers and deserializers for specific types. XML Marshalling The MarshallingView uses an XML Marshaller (defined in the org.springframework.oxm package) to render the response content as XML. You can explicitly set the object to be marshalled by using a MarshallingView instance\u2019s modelKey bean property. Alternatively, the view iterates over all model properties and marshals the first type that is supported by the Marshaller. For more information on the functionality in the org.springframework.oxm package, see Marshalling XML using O/X Mappers. XSLT Views XSLT is a transformation language for XML and is popular as a view technology within web applications.", "chunk_char_count": 1243, "chunk_word_count": 185, "chunk_token_count": 310.75}, {"page_number": 1021, "sentence_chunk": "XSLT can be a good choice as a view technology if your application naturally deals with XML or if your model can easily be converted to XML. The following section shows how to produce an XML document as model data and have it transformed with XSLT in a Spring Web MVC application. This example is a trivial Spring application that creates a list of words in the Controller and adds them to the model map. The map is returned, along with the view name of our XSLT view. See Annotated Controllers for details of Spring Web MVC\u2019s Controller interface. The XSLT controller turns the list of words into a simple XML document ready for transformation. Beans Configuration is standard for a simple Spring web application: The MVC configuration has to define an XsltViewResolver bean and regular MVC annotation configuration. The following example shows how to do so: 1021", "chunk_char_count": 864, "chunk_word_count": 148, "chunk_token_count": 216.0}, {"page_number": 1022, "sentence_chunk": "Java @EnableWebMvc @ComponentScan @Configuration public class WebConfig implements WebMvcConfigurer { \u00a0  @Bean \u00a0  public XsltViewResolver xsltViewResolver() { \u00a0    XsltViewResolver viewResolver = new XsltViewResolver(); \u00a0    viewResolver.setPrefix(\"/WEB-INF/xsl/\"); \u00a0    viewResolver.setSuffix(\".xslt\"); \u00a0    return viewResolver; \u00a0  } } Kotlin @EnableWebMvc @ComponentScan @Configuration class WebConfig : WebMvcConfigurer { \u00a0  @Bean \u00a0  fun xsltViewResolver() = XsltViewResolver().apply { \u00a0    setPrefix(\"/WEB-INF/xsl/\") \u00a0    setSuffix(\".xslt\") \u00a0  } } Controller We also need a Controller that encapsulates our word-generation logic. The controller logic is encapsulated in a @Controller class, with the handler method being defined as follows: 1022", "chunk_char_count": 749, "chunk_word_count": 110, "chunk_token_count": 187.25}, {"page_number": 1023, "sentence_chunk": "Java @Controller public class XsltController { \u00a0  @RequestMapping(\"/\") \u00a0  public String home(Model model) throws Exception { \u00a0    Document document = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument(); \u00a0    Element root = document.createElement(\"wordList\"); \u00a0    List<String> words = Arrays.asList(\"Hello\", \"Spring\", \"Framework\"); \u00a0    for (String word : words) { \u00a0      Element wordNode = document.createElement(\"word\"); \u00a0      Text textNode = document.createTextNode(word); \u00a0      wordNode.appendChild(textNode); \u00a0      root.appendChild(wordNode); \u00a0    } \u00a0    model.addAttribute(\"wordList\", root); \u00a0    return \"home\"; \u00a0  } } Kotlin import org.springframework.ui.set @Controller class XsltController { \u00a0  @RequestMapping(\"/\") \u00a0  fun home(model: Model): String { \u00a0    val document = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument() \u00a0    val root = document.createElement(\"wordList\") \u00a0    val words = listOf(\"Hello\", \"Spring\", \"Framework\") \u00a0    for (word in words) { \u00a0      val wordNode = document.createElement(\"word\") \u00a0      val textNode = document.createTextNode(word) \u00a0      wordNode.appendChild(textNode) \u00a0      root.appendChild(wordNode) \u00a0    } \u00a0    model[\"wordList\"] = root \u00a0    return \"home\" \u00a0  } } 1023", "chunk_char_count": 1254, "chunk_word_count": 218, "chunk_token_count": 313.5}, {"page_number": 1024, "sentence_chunk": "So far, we have only created a DOM document and added it to the Model map. Note that you can also load an XML file as a Resource and use it instead of a custom DOM document. There are software packages available that automatically 'domify' an object graph, but, within Spring, you have complete flexibility to create the DOM from your model in any way you choose. This prevents the transformation of XML playing too great a part in the structure of your model data, which is a danger when using tools to manage the DOMification process. Transformation Finally, the XsltViewResolver resolves the \u201chome\u201d XSLT template file and merges the DOM document into it to generate our view. As shown in the XsltViewResolver configuration, XSLT templates live in the war file in the WEB-INF/xsl directory and end with an xslt file extension. The following example shows an XSLT transform: <?xml version=\"1.0\" encoding=\"utf-8\"?> <xsl:stylesheet version=\"1.0\" xmlns:xsl=\"http://www.w3.org/1999/XSL/Transform\"> \u00a0  <xsl:output method=\"html\" omit-xml-declaration=\"yes\"/> \u00a0  <xsl:template match=\"/\"> \u00a0    <html> \u00a0      <head><title>Hello!</title></head> \u00a0      <body> \u00a0        <h1>My First Words</h1> \u00a0        <ul> \u00a0          <xsl:apply-templates/> \u00a0        </ul> \u00a0      </body> \u00a0    </html> \u00a0  </xsl:template> \u00a0  <xsl:template match=\"word\"> \u00a0    <li><xsl:value-of select=\".\"/></li> \u00a0  </xsl:template> </xsl:stylesheet> The preceding transform is rendered as the following HTML: 1024", "chunk_char_count": 1464, "chunk_word_count": 262, "chunk_token_count": 366.0}, {"page_number": 1025, "sentence_chunk": "<html> \u00a0  <head> \u00a0    <META http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"> \u00a0    <title>Hello!</title> \u00a0  </head> \u00a0  <body> \u00a0    <h1>My First Words</h1> \u00a0    <ul> \u00a0      <li>Hello</li> \u00a0      <li>Spring</li> \u00a0      <li>Framework</li> \u00a0    </ul> \u00a0  </body> </html> 5.1.12. MVC Config WebFlux The MVC Java configuration and the MVC XML namespace provide default configuration suitable for most applications and a configuration API to customize it. For more advanced customizations, which are not available in the configuration API, see Advanced Java Config and Advanced XML Config. You do not need to understand the underlying beans created by the MVC Java configuration and the MVC namespace. If you want to learn more, see Special Bean Types and Web MVC Config. Enable MVC Configuration WebFlux In Java configuration, you can use the @EnableWebMvc annotation to enable MVC configuration, as the following example shows: Java @Configuration @EnableWebMvc public class WebConfig { } Kotlin @Configuration @EnableWebMvc class WebConfig In XML configuration, you can use the <mvc:annotation-driven> element to enable MVC 1025", "chunk_char_count": 1135, "chunk_word_count": 193, "chunk_token_count": 283.75}, {"page_number": 1026, "sentence_chunk": "configuration, as the following example shows: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:mvc=\"http://www.springframework.org/schema/mvc\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/mvc \u00a0    https://www.springframework.org/schema/mvc/spring-mvc.xsd\"> \u00a0  <mvc:annotation-driven/> </beans> The preceding example registers a number of Spring MVC infrastructure beans and adapts to dependencies available on the classpath (for example, payload converters for JSON, XML, and others). MVC Config API WebFlux In Java configuration, you can implement the WebMvcConfigurer interface, as the following example shows: Java @Configuration @EnableWebMvc public class WebConfig implements WebMvcConfigurer { \u00a0  // Implement configuration methods... } Kotlin @Configuration @EnableWebMvc class WebConfig : WebMvcConfigurer { \u00a0  // Implement configuration methods... } In XML, you can check attributes and sub-elements of <mvc:annotation-driven/>. You can view the Spring MVC XML schema or use the code completion feature of your IDE to discover what attributes and sub-elements are available.1026", "chunk_char_count": 1341, "chunk_word_count": 156, "chunk_token_count": 335.25}, {"page_number": 1027, "sentence_chunk": "Type Conversion WebFlux By default, formatters for various number and date types are installed, along with support for customization via @NumberFormat and @DateTimeFormat on fields. To register custom formatters and converters in Java config, use the following: Java @Configuration @EnableWebMvc public class WebConfig implements WebMvcConfigurer { \u00a0  @Override \u00a0  public void addFormatters(FormatterRegistry registry) { \u00a0    // ... \u00a0  } } Kotlin @Configuration @EnableWebMvc class WebConfig : WebMvcConfigurer { \u00a0  override fun addFormatters(registry: FormatterRegistry) { \u00a0    // ... \u00a0  } } To do the same in XML config, use the following: 1027", "chunk_char_count": 646, "chunk_word_count": 102, "chunk_token_count": 161.5}, {"page_number": 1028, "sentence_chunk": "<?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:mvc=\"http://www.springframework.org/schema/mvc\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/mvc \u00a0    https://www.springframework.org/schema/mvc/spring-mvc.xsd\"> \u00a0  <mvc:annotation-driven conversion-service=\"conversionService\"/> \u00a0  <bean id=\"conversionService\" \u00a0 class=\"org.springframework.format.support. FormattingConversionServiceFactoryBean\"> \u00a0    <property name=\"converters\"> \u00a0      <set> \u00a0        <bean class=\"org.example. MyConverter\"/> \u00a0      </set> \u00a0    </property> \u00a0    <property name=\"formatters\"> \u00a0      <set> \u00a0        <bean class=\"org.example. MyFormatter\"/> \u00a0        <bean class=\"org.example. MyAnnotationFormatterFactory\"/> \u00a0      </set> \u00a0    </property> \u00a0    <property name=\"formatterRegistrars\"> \u00a0      <set> \u00a0        <bean class=\"org.example. MyFormatterRegistrar\"/> \u00a0      </set> \u00a0    </property> \u00a0  </bean> </beans> By default Spring MVC considers the request Locale when parsing and formatting date values. This works for forms where dates are represented as Strings with \"input\" form fields. For \"date\" and \"time\" form fields, however, browsers use a fixed format defined in the HTML spec.", "chunk_char_count": 1413, "chunk_word_count": 213, "chunk_token_count": 353.25}, {"page_number": 1029, "sentence_chunk": "Java @Configuration @EnableWebMvc public class WebConfig implements WebMvcConfigurer { \u00a0  @Override \u00a0  public void addFormatters(FormatterRegistry registry) { \u00a0    DateTimeFormatterRegistrar registrar = new DateTimeFormatterRegistrar(); \u00a0    registrar.setUseIsoFormat(true); \u00a0    registrar.registerFormatters(registry); \u00a0  } } Kotlin @Configuration @EnableWebMvc class WebConfig : WebMvcConfigurer { \u00a0  override fun addFormatters(registry: FormatterRegistry) { \u00a0    val registrar = DateTimeFormatterRegistrar() \u00a0    registrar.setUseIsoFormat(true) \u00a0    registrar.registerFormatters(registry) \u00a0  } } \uf05a See the FormatterRegistrar SPI and the FormattingConversionServiceFactoryBean for more information on when to use FormatterRegistrar implementations. Validation WebFlux By default, if Bean Validation is present on the classpath (for example, Hibernate Validator), the LocalValidatorFactoryBean is registered as a global Validator for use with @Valid and Validated on controller method arguments. In Java configuration, you can customize the global Validator instance, as the following example shows: 1029", "chunk_char_count": 1105, "chunk_word_count": 146, "chunk_token_count": 276.25}, {"page_number": 1030, "sentence_chunk": "Java @Configuration @EnableWebMvc public class WebConfig implements WebMvcConfigurer { \u00a0  @Override \u00a0  public Validator getValidator() { \u00a0    // ... \u00a0  } } Kotlin @Configuration @EnableWebMvc class WebConfig : WebMvcConfigurer { \u00a0  override fun getValidator(): Validator { \u00a0    // ... \u00a0  } } The following example shows how to achieve the same configuration in XML: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:mvc=\"http://www.springframework.org/schema/mvc\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/mvc \u00a0    https://www.springframework.org/schema/mvc/spring-mvc.xsd\"> \u00a0  <mvc:annotation-driven validator=\"globalValidator\"/> </beans> Note that you can also register Validator implementations locally, as the following example shows: 1030", "chunk_char_count": 998, "chunk_word_count": 119, "chunk_token_count": 249.5}, {"page_number": 1031, "sentence_chunk": "Java @Controller public class MyController { \u00a0  @InitBinder \u00a0  protected void initBinder(WebDataBinder binder) { \u00a0    binder.addValidators(new FooValidator()); \u00a0  } } Kotlin @Controller class MyController { \u00a0  @InitBinder \u00a0  protected fun initBinder(binder: WebDataBinder) { \u00a0    binder.addValidators(FooValidator()) \u00a0  } } \uf0eb If you need to have a LocalValidatorFactoryBean injected somewhere, create a bean and mark it with @Primary in order to avoid conflict with the one declared in the MVC configuration. Interceptors In Java configuration, you can register interceptors to apply to incoming requests, as the following example shows: Java @Configuration @EnableWebMvc public class WebConfig implements WebMvcConfigurer { \u00a0  @Override \u00a0  public void addInterceptors(InterceptorRegistry registry) { \u00a0    registry.addInterceptor(new LocaleChangeInterceptor()); \u00a0    registry.addInterceptor(new ThemeChangeInterceptor()).addPathPatterns(\"/**\").excludePathPatterns(\"/admin/**\"); \u00a0  } } 1031", "chunk_char_count": 989, "chunk_word_count": 135, "chunk_token_count": 247.25}, {"page_number": 1032, "sentence_chunk": "Kotlin @Configuration @EnableWebMvc class WebConfig : WebMvcConfigurer { \u00a0  override fun addInterceptors(registry: InterceptorRegistry) { \u00a0    registry.addInterceptor(LocaleChangeInterceptor()) \u00a0 registry.addInterceptor(ThemeChangeInterceptor()).addPathPatterns(\"/**\").excludePathPa tterns(\"/admin/**\") \u00a0  } } The following example shows how to achieve the same configuration in XML: <mvc:interceptors> \u00a0  <bean class=\"org.springframework.web.servlet.i18n. LocaleChangeInterceptor\"/> \u00a0  <mvc:interceptor> \u00a0    <mvc:mapping path=\"/**\"/> \u00a0    <mvc:exclude-mapping path=\"/admin/**\"/> \u00a0    <bean class=\"org.springframework.web.servlet.theme. ThemeChangeInterceptor\"/> \u00a0  </mvc:interceptor> </mvc:interceptors> \uf05a Mapped interceptors are not ideally suited as a security layer due to the potential for a mismatch with annotated controller path matching, which can also match trailing slashes and path extensions transparently, along with other path matching options. Many of these options have been deprecated but the potential for a mismatch remains. Generally, we recommend using Spring Security which includes a dedicated MvcRequestMatcher to align with Spring MVC path matching and also has a security firewall that blocks many unwanted characters in URL paths. Content Types WebFlux You can configure how Spring MVC determines the requested media types from the request (for example, Accept header, URL path extension, query parameter, and others). By default, only the Accept header is checked. If you must use URL-based content type resolution, consider using the query parameter strategy over path extensions. See Suffix Match and Suffix Match and RFD for more details. In Java configuration, you can customize requested content type resolution, as the following example shows: 1032", "chunk_char_count": 1784, "chunk_word_count": 236, "chunk_token_count": 446.0}, {"page_number": 1033, "sentence_chunk": "Java @Configuration @EnableWebMvc public class WebConfig implements WebMvcConfigurer { \u00a0  @Override \u00a0  public void configureContentNegotiation(ContentNegotiationConfigurer configurer) { \u00a0    configurer.mediaType(\"json\", MediaType. APPLICATION_JSON); \u00a0    configurer.mediaType(\"xml\", MediaType. APPLICATION_XML); \u00a0  } } Kotlin @Configuration @EnableWebMvc class WebConfig : WebMvcConfigurer { \u00a0  override fun configureContentNegotiation(configurer: ContentNegotiationConfigurer) { \u00a0    configurer.mediaType(\"json\", MediaType. APPLICATION_JSON) \u00a0    configurer.mediaType(\"xml\", MediaType. APPLICATION_XML) \u00a0  } } The following example shows how to achieve the same configuration in XML: <mvc:annotation-driven content-negotiation-manager=\"contentNegotiationManager\"/> <bean id=\"contentNegotiationManager\" class=\"org.springframework.web.accept. ContentNegotiationManagerFactoryBean\"> \u00a0  <property name=\"mediaTypes\"> \u00a0    <value> \u00a0      json=application/json \u00a0      xml=application/xml \u00a0    </value> \u00a0  </property> </bean> Message Converters WebFlux You can customize HttpMessageConverter in Java configuration by overriding configureMessageConverters() (to replace the default converters created by Spring MVC) or by overriding extendMessageConverters() (to customize the default converters or add additional converters to the default ones).1033", "chunk_char_count": 1342, "chunk_word_count": 159, "chunk_token_count": 335.5}, {"page_number": 1034, "sentence_chunk": "The following example adds XML and Jackson JSON converters with a customized ObjectMapper instead of the default ones: Java @Configuration @EnableWebMvc public class WebConfiguration implements WebMvcConfigurer { \u00a0  @Override \u00a0  public void configureMessageConverters(List<HttpMessageConverter<?>> converters) { \u00a0    Jackson2ObjectMapperBuilder builder = new Jackson2ObjectMapperBuilder() \u00a0        .indentOutput(true) \u00a0        .dateFormat(new SimpleDateFormat(\"yyyy-MM-dd\")) \u00a0        .modulesToInstall(new ParameterNamesModule()); \u00a0    converters.add(new MappingJackson2HttpMessageConverter(builder.build())); \u00a0    converters.add(new MappingJackson2XmlHttpMessageConverter(builder.createXmlMapper(true).build())); \u00a0  } } Kotlin @Configuration @EnableWebMvc class WebConfiguration : WebMvcConfigurer { \u00a0  override fun configureMessageConverters(converters: MutableList<HttpMessageConverter<*>>) { \u00a0    val builder = Jackson2ObjectMapperBuilder() \u00a0        .indentOutput(true) \u00a0        .dateFormat(SimpleDateFormat(\"yyyy-MM-dd\")) \u00a0        .modulesToInstall(ParameterNamesModule()) \u00a0    converters.add(MappingJackson2HttpMessageConverter(builder.build())) \u00a0 converters.add(MappingJackson2XmlHttpMessageConverter(builder.createXmlMapper(true).bu ild())) In the preceding example, Jackson2ObjectMapperBuilder is used to create a common configuration for both MappingJackson2HttpMessageConverter and MappingJackson2XmlHttpMessageConverter with indentation enabled, a customized date format, and the registration of jackson-module-parameter- names, Which adds support for accessing parameter names (a feature added in Java 8). This builder customizes Jackson\u2019s default properties as follows: \u2022 DeserializationFeature. FAIL_ON_UNKNOWN_PROPERTIES is disabled. \u2022MapperFeature. DEFAULT_VIEW_INCLUSION is disabled. It also automatically registers the following well-known modules if they are detected on the 1034", "chunk_char_count": 1899, "chunk_word_count": 224, "chunk_token_count": 474.75}, {"page_number": 1035, "sentence_chunk": "classpath: \u2022 jackson-datatype-joda: Support for Joda-Time types. \u2022jackson-datatype-jsr310: Support for Java 8 Date and Time API types. \u2022jackson-datatype-jdk8: Support for other Java 8 types, such as Optional. \u2022jackson-module-kotlin: Support for Kotlin classes and data classes.\uf05a Enabling indentation with Jackson XML support requires woodstox-core-asl dependency in addition to jackson-dataformat-xml one. Other interesting Jackson modules are available: \u2022 jackson-datatype-money: Support for javax.money types (unofficial module). \u2022jackson-datatype-hibernate: Support for Hibernate-specific types and properties (including lazy- loading aspects). The following example shows how to achieve the same configuration in XML: <mvc:annotation-driven> \u00a0  <mvc:message-converters> \u00a0    <bean class=\"org.springframework.http.converter.json. MappingJackson2HttpMessageConverter\"> \u00a0      <property name=\"objectMapper\" ref=\"objectMapper\"/> \u00a0    </bean> \u00a0    <bean class=\"org.springframework.http.converter.xml. MappingJackson2XmlHttpMessageConverter\"> \u00a0      <property name=\"objectMapper\" ref=\"xmlMapper\"/> \u00a0    </bean> \u00a0  </mvc:message-converters> </mvc:annotation-driven> <bean id=\"objectMapper\" class=\"org.springframework.http.converter.json.", "chunk_char_count": 1234, "chunk_word_count": 139, "chunk_token_count": 308.5}, {"page_number": 1035, "sentence_chunk": "Jackson2ObjectMapperFactoryBean\" \u00a0   p:indentOutput=\"true\" \u00a0   p:simpleDateFormat=\"yyyy-MM-dd\" \u00a0 p:modulesToInstall=\"com.fasterxml.jackson.module.paramnames. ParameterNamesModule\"/> <bean id=\"xmlMapper\" parent=\"objectMapper\" p:createXmlMapper=\"true\"/> View Controllers This is a shortcut for defining a ParameterizableViewController that immediately forwards to a view when invoked. You can use it in static cases when there is no Java controller logic to run before the view generates the response. The following example of Java configuration forwards a request for / to a view called home: 1035", "chunk_char_count": 596, "chunk_word_count": 73, "chunk_token_count": 149.0}, {"page_number": 1036, "sentence_chunk": "Java @Configuration @EnableWebMvc public class WebConfig implements WebMvcConfigurer { \u00a0  @Override \u00a0  public void addViewControllers(ViewControllerRegistry registry) { \u00a0    registry.addViewController(\"/\").setViewName(\"home\"); \u00a0  } } Kotlin @Configuration @EnableWebMvc class WebConfig : WebMvcConfigurer { \u00a0  override fun addViewControllers(registry: ViewControllerRegistry) { \u00a0    registry.addViewController(\"/\").setViewName(\"home\") \u00a0  } } The following example achieves the same thing as the preceding example, but with XML, by using the <mvc:view-controller> element: <mvc:view-controller path=\"/\" view-name=\"home\"/> If an @RequestMapping method is mapped to a URL for any HTTP method then a view controller cannot be used to handle the same URL. This is because a match by URL to an annotated controller is considered a strong enough indication of endpoint ownership so that a 405 (METHOD_NOT_ALLOWED), a 415 (UNSUPPORTED_MEDIA_TYPE), or similar response can be sent to the client to help with debugging. For this reason it is recommended to avoid splitting URL handling across an annotated controller and a view controller. View Resolvers WebFlux The MVC configuration simplifies the registration of view resolvers. The following Java configuration example configures content negotiation view resolution by using JSP and Jackson as a default View for JSON rendering: 1036", "chunk_char_count": 1377, "chunk_word_count": 194, "chunk_token_count": 344.25}, {"page_number": 1037, "sentence_chunk": "Java @Configuration @EnableWebMvc public class WebConfig implements WebMvcConfigurer { \u00a0  @Override \u00a0  public void configureViewResolvers(ViewResolverRegistry registry) { \u00a0    registry.enableContentNegotiation(new MappingJackson2JsonView()); \u00a0    registry.jsp(); \u00a0  } } Kotlin @Configuration @EnableWebMvc class WebConfig : WebMvcConfigurer { \u00a0  override fun configureViewResolvers(registry: ViewResolverRegistry) { \u00a0    registry.enableContentNegotiation(MappingJackson2JsonView()) \u00a0    registry.jsp() \u00a0  } } The following example shows how to achieve the same configuration in XML: <mvc:view-resolvers> \u00a0  <mvc:content-negotiation> \u00a0    <mvc:default-views> \u00a0      <bean class=\"org.springframework.web.servlet.view.json. MappingJackson2JsonView\"/> \u00a0    </mvc:default-views> \u00a0  </mvc:content-negotiation> \u00a0  <mvc:jsp/> </mvc:view-resolvers> Note, however, that FreeMarker, Tiles, Groovy Markup, and script templates also require configuration of the underlying view technology. The MVC namespace provides dedicated elements. The following example works with FreeMarker: 1037", "chunk_char_count": 1073, "chunk_word_count": 136, "chunk_token_count": 268.25}, {"page_number": 1038, "sentence_chunk": "<mvc:view-resolvers> \u00a0  <mvc:content-negotiation> \u00a0    <mvc:default-views> \u00a0      <bean class=\"org.springframework.web.servlet.view.json. MappingJackson2JsonView\"/> \u00a0    </mvc:default-views> \u00a0  </mvc:content-negotiation> \u00a0  <mvc:freemarker cache=\"false\"/> </mvc:view-resolvers> <mvc:freemarker-configurer> \u00a0  <mvc:template-loader-path location=\"/freemarker\"/> </mvc:freemarker-configurer> In Java configuration, you can add the respective Configurer bean, as the following example shows: Java @Configuration @EnableWebMvc public class WebConfig implements WebMvcConfigurer { \u00a0  @Override \u00a0  public void configureViewResolvers(ViewResolverRegistry registry) { \u00a0    registry.enableContentNegotiation(new MappingJackson2JsonView()); \u00a0    registry.freeMarker().cache(false); \u00a0  } \u00a0  @Bean \u00a0  public FreeMarkerConfigurer freeMarkerConfigurer() { \u00a0    FreeMarkerConfigurer configurer = new FreeMarkerConfigurer(); \u00a0    configurer.setTemplateLoaderPath(\"/freemarker\"); \u00a0    return configurer; \u00a0  } } 1038", "chunk_char_count": 997, "chunk_word_count": 119, "chunk_token_count": 249.25}, {"page_number": 1039, "sentence_chunk": "Kotlin @Configuration @EnableWebMvc class WebConfig : WebMvcConfigurer { \u00a0  override fun configureViewResolvers(registry: ViewResolverRegistry) { \u00a0    registry.enableContentNegotiation(MappingJackson2JsonView()) \u00a0    registry.freeMarker().cache(false) \u00a0  } \u00a0  @Bean \u00a0  fun freeMarkerConfigurer() = FreeMarkerConfigurer().apply { \u00a0    setTemplateLoaderPath(\"/freemarker\") \u00a0  } } Static Resources WebFlux This option provides a convenient way to serve static resources from a list of Resource-based locations. In the next example, given a request that starts with /resources, the relative path is used to find and serve static resources relative to /public under the web application root or on the classpath under /static. The resources are served with a one-year future expiration to ensure maximum use of the browser cache and a reduction in HTTP requests made by the browser. The Last-Modified information is deduced from Resource#lastModified so that HTTP conditional requests are supported with \"Last-Modified\" headers. The following listing shows how to do so with Java configuration: Java @Configuration @EnableWebMvc public class WebConfig implements WebMvcConfigurer { \u00a0  @Override \u00a0  public void addResourceHandlers(ResourceHandlerRegistry registry) { \u00a0    registry.addResourceHandler(\"/resources/**\") \u00a0        .addResourceLocations(\"/public\", \"classpath:/static/\") \u00a0        .setCacheControl(CacheControl.maxAge(Duration.ofDays(365))); \u00a0  } } 1039", "chunk_char_count": 1455, "chunk_word_count": 205, "chunk_token_count": 363.75}, {"page_number": 1040, "sentence_chunk": "Kotlin @Configuration @EnableWebMvc class WebConfig : WebMvcConfigurer { \u00a0  override fun addResourceHandlers(registry: ResourceHandlerRegistry) { \u00a0    registry.addResourceHandler(\"/resources/**\") \u00a0        .addResourceLocations(\"/public\", \"classpath:/static/\") \u00a0        .setCacheControl(CacheControl.maxAge(Duration.ofDays(365))) \u00a0  } } The following example shows how to achieve the same configuration in XML: <mvc:resources mapping=\"/resources/**\" \u00a0  location=\"/public, classpath:/static/\" \u00a0  cache-period=\"31556926\" /> See also HTTP caching support for static resources. The resource handler also supports a chain of ResourceResolver implementations and ResourceTransformer implementations, which you can use to create a toolchain for working with optimized resources. You can use the VersionResourceResolver for versioned resource URLs based on an MD5 hash computed from the content, a fixed application version, or other. A ContentVersionStrategy (MD5 hash) is a good choice\u2009\u2014\u2009with some notable exceptions, such as JavaScript resources used with a module loader. The following example shows how to use VersionResourceResolver in Java configuration: Java @Configuration @EnableWebMvc public class WebConfig implements WebMvcConfigurer { \u00a0  @Override \u00a0  public void addResourceHandlers(ResourceHandlerRegistry registry) { \u00a0    registry.addResourceHandler(\"/resources/**\") \u00a0        .addResourceLocations(\"/public/\") \u00a0        .resourceChain(true) \u00a0        .addResolver(new VersionResourceResolver().addContentVersionStrategy(\"/**\")); \u00a0  } } 1040", "chunk_char_count": 1545, "chunk_word_count": 211, "chunk_token_count": 386.25}, {"page_number": 1041, "sentence_chunk": "Kotlin @Configuration @EnableWebMvc class WebConfig : WebMvcConfigurer { \u00a0  override fun addResourceHandlers(registry: ResourceHandlerRegistry) { \u00a0    registry.addResourceHandler(\"/resources/**\") \u00a0        .addResourceLocations(\"/public/\") \u00a0        .resourceChain(true) \u00a0 .addResolver(VersionResourceResolver().addContentVersionStrategy(\"/**\")) \u00a0  } } The following example shows how to achieve the same configuration in XML: <mvc:resources mapping=\"/resources/**\" location=\"/public/\"> \u00a0  <mvc:resource-chain resource-cache=\"true\"> \u00a0    <mvc:resolvers> \u00a0      <mvc:version-resolver> \u00a0        <mvc:content-version-strategy patterns=\"/**\"/> \u00a0      </mvc:version-resolver> \u00a0    </mvc:resolvers> \u00a0  </mvc:resource-chain> </mvc:resources> You can then use ResourceUrlProvider to rewrite URLs and apply the full chain of resolvers and transformers\u2009\u2014\u2009for example, to insert versions. The MVC configuration provides a ResourceUrlProvider bean so that it can be injected into others. You can also make the rewrite transparent with the ResourceUrlEncodingFilter for Thymeleaf, JSPs, FreeMarker, and others with URL tags that rely on HttpServletResponse#encodeURL. Note that, when using both EncodedResourceResolver (for example, for serving gzipped or brotli- encoded resources) and VersionResourceResolver, you must register them in this order. That ensures content-based versions are always computed reliably, based on the unencoded file. For WebJars, versioned URLs like /webjars/jquery/1.2.0/jquery.min.js are the recommended and most efficient way to use them. The related resource location is configured out of the box with Spring Boot (or can be configured manually via ResourceHandlerRegistry) and does not require to add the org.webjars:webjars-locator-core dependency. Version-less URLs like /webjars/jquery/jquery.min.js are supported through the WebJarsResourceResolver which is automatically registered when the org.webjars:webjars-locator- core library is present on the classpath, at the cost of a classpath scanning that could slow down application startup. The resolver can re-write URLs to include the version of the jar and can also match against incoming URLs without versions\u2009\u2014\u2009for example, from /webjars/jquery/jquery.min.js to /webjars/jquery/1.2.0/jquery.min.js.1041", "chunk_char_count": 2279, "chunk_word_count": 304, "chunk_token_count": 569.75}, {"page_number": 1042, "sentence_chunk": "\uf0eb The Java configuration based on ResourceHandlerRegistry provides further options for fine-grained control, e.g. last-modified behavior and optimized resource resolution. Default Servlet Spring MVC allows for mapping the DispatcherServlet to / (thus overriding the mapping of the container\u2019s default Servlet), while still allowing static resource requests to be handled by the container\u2019s default Servlet. It configures a DefaultServletHttpRequestHandler with a URL mapping of /** and the lowest priority relative to other URL mappings. This handler forwards all requests to the default Servlet. Therefore, it must remain last in the order of all other URL HandlerMappings. That is the case if you use <mvc:annotation-driven>. Alternatively, if you set up your own customized HandlerMapping instance, be sure to set its order property to a value lower than that of the DefaultServletHttpRequestHandler, which is Integer. MAX_VALUE. The following example shows how to enable the feature by using the default setup: Java @Configuration @EnableWebMvc public class WebConfig implements WebMvcConfigurer { \u00a0  @Override \u00a0  public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) { \u00a0    configurer.enable(); \u00a0  } } Kotlin @Configuration @EnableWebMvc class WebConfig : WebMvcConfigurer { \u00a0  override fun configureDefaultServletHandling(configurer: DefaultServletHandlerConfigurer) { \u00a0    configurer.enable() \u00a0  } } The following example shows how to achieve the same configuration in XML: <mvc:default-servlet-handler/> The caveat to overriding the / Servlet mapping is that the RequestDispatcher for the default Servlet 1042", "chunk_char_count": 1651, "chunk_word_count": 229, "chunk_token_count": 412.75}, {"page_number": 1043, "sentence_chunk": "must be retrieved by name rather than by path. The DefaultServletHttpRequestHandler tries to auto- detect the default Servlet for the container at startup time, using a list of known names for most of the major Servlet containers (including Tomcat, Jetty, GlassFish, JBoss, Resin, WebLogic, and WebSphere). If the default Servlet has been custom-configured with a different name, or if a different Servlet container is being used where the default Servlet name is unknown, then you must explicitly provide the default Servlet\u2019s name, as the following example shows: Java @Configuration @EnableWebMvc public class WebConfig implements WebMvcConfigurer { \u00a0  @Override \u00a0  public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) { \u00a0    configurer.enable(\"myCustomDefaultServlet\"); \u00a0  } } Kotlin @Configuration @EnableWebMvc class WebConfig : WebMvcConfigurer { \u00a0  override fun configureDefaultServletHandling(configurer: DefaultServletHandlerConfigurer) { \u00a0    configurer.enable(\"myCustomDefaultServlet\") \u00a0  } } The following example shows how to achieve the same configuration in XML: <mvc:default-servlet-handler default-servlet-name=\"myCustomDefaultServlet\"/> Path Matching WebFlux You can customize options related to path matching and treatment of the URL. For details on the individual options, see the PathMatchConfigurer javadoc. The following example shows how to customize path matching in Java configuration: 1043", "chunk_char_count": 1452, "chunk_word_count": 192, "chunk_token_count": 363.0}, {"page_number": 1044, "sentence_chunk": "Java @Configuration @EnableWebMvc public class WebConfig implements WebMvcConfigurer { \u00a0  @Override \u00a0  public void configurePathMatch(PathMatchConfigurer configurer) { \u00a0    configurer.addPathPrefix(\"/api\", HandlerTypePredicate.forAnnotation(RestController.class)); \u00a0  } \u00a0  private PathPatternParser patternParser() { \u00a0    // ... \u00a0  } } Kotlin @Configuration @EnableWebMvc class WebConfig : WebMvcConfigurer { \u00a0  override fun configurePathMatch(configurer: PathMatchConfigurer) { \u00a0    configurer.addPathPrefix(\"/api\", HandlerTypePredicate.forAnnotation(RestController::class.java)) \u00a0  } \u00a0  fun patternParser(): PathPatternParser { \u00a0    //... \u00a0  } } The following example shows how to customize path matching in XML configuration: <mvc:annotation-driven> \u00a0  <mvc:path-matching \u00a0    path-helper=\"pathHelper\" \u00a0    path-matcher=\"pathMatcher\"/> </mvc:annotation-driven> <bean id=\"pathHelper\" class=\"org.example.app. MyPathHelper\"/> <bean id=\"pathMatcher\" class=\"org.example.app. MyPathMatcher\"/> Advanced Java Config WebFlux @EnableWebMvc imports DelegatingWebMvcConfiguration, which: 1044", "chunk_char_count": 1083, "chunk_word_count": 127, "chunk_token_count": 270.75}, {"page_number": 1045, "sentence_chunk": "\u2022 Provides default Spring configuration for Spring MVC applications \u2022 Detects and delegates to WebMvcConfigurer implementations to customize that configuration. For advanced mode, you can remove @EnableWebMvc and extend directly from DelegatingWebMvcConfiguration instead of implementing WebMvcConfigurer, as the following example shows: Java @Configuration public class WebConfig extends DelegatingWebMvcConfiguration { \u00a0  // ... } Kotlin @Configuration class WebConfig : DelegatingWebMvcConfiguration() { \u00a0  // ... } You can keep existing methods in WebConfig, but you can now also override bean declarations from the base class, and you can still have any number of other WebMvcConfigurer implementations on the classpath. Advanced XML Config The MVC namespace does not have an advanced mode. If you need to customize a property on a bean that you cannot change otherwise, you can use the BeanPostProcessor lifecycle hook of the Spring ApplicationContext, as the following example shows: Java @Component public class MyPostProcessor implements BeanPostProcessor { \u00a0  public Object postProcessBeforeInitialization(Object bean, String name) throws BeansException { \u00a0    // ... \u00a0  } } 1045", "chunk_char_count": 1189, "chunk_word_count": 172, "chunk_token_count": 297.25}, {"page_number": 1046, "sentence_chunk": "Kotlin @Component class MyPostProcessor : BeanPostProcessor { \u00a0  override fun postProcessBeforeInitialization(bean: Any, name: String): Any { \u00a0    // ... \u00a0  } } Note that you need to declare MyPostProcessor as a bean, either explicitly in XML or by letting it be detected through a <component-scan/> declaration.5.1.13. HTTP/2 WebFlux Servlet 4 containers are required to support HTTP/2, and Spring Framework 5 is compatible with Servlet API 4. From a programming model perspective, there is nothing specific that applications need to do. However, there are considerations related to server configuration. For more details, see the HTTP/2 wiki page. The Servlet API does expose one construct related to HTTP/2. You can use the jakarta.servlet.http. PushBuilder to proactively push resources to clients, and it is supported as a method argument to @RequestMapping methods.5.2.", "chunk_char_count": 875, "chunk_word_count": 134, "chunk_token_count": 218.75}, {"page_number": 1046, "sentence_chunk": "REST Clients This section describes options for client-side access to REST endpoints.5.2.1. RestTemplate RestTemplate is a synchronous client to perform HTTP requests. It is the original Spring REST client and exposes a simple, template-method API over underlying HTTP client libraries.\uf05a As of 5.0 the RestTemplate is in maintenance mode, with only requests for minor changes and bugs to be accepted. Please, consider using the WebClient which offers a more modern API and supports sync, async, and streaming scenarios. See REST Endpoints for details.5.2.2. WebClient WebClient is a non-blocking, reactive client to perform HTTP requests. It was introduced in 5.0 and offers a modern alternative to the RestTemplate, with efficient support for both synchronous and asynchronous, as well as streaming scenarios.", "chunk_char_count": 810, "chunk_word_count": 120, "chunk_token_count": 202.5}, {"page_number": 1047, "sentence_chunk": "\u2022 Non-blocking I/O. \u2022 Reactive Streams back pressure. \u2022High concurrency with fewer hardware resources. \u2022Functional-style, fluent API that takes advantage of Java 8 lambdas. \u2022Synchronous and asynchronous interactions. \u2022Streaming up to or streaming down from a server. See WebClient for more details.5.2.3. HTTP Interface The Spring Frameworks lets you define an HTTP service as a Java interface with HTTP exchange methods. You can then generate a proxy that implements this interface and performs the exchanges. This helps to simplify HTTP remote access and provides additional flexibility for to choose an API style such as synchronous or reactive.", "chunk_char_count": 648, "chunk_word_count": 97, "chunk_token_count": 162.0}, {"page_number": 1047, "sentence_chunk": "See REST Endpoints for details.5.3. Testing Same in Spring WebFlux This section summarizes the options available in spring-test for Spring MVC applications. \u2022Servlet API Mocks: Mock implementations of Servlet API contracts for unit testing controllers, filters, and other web components. See Servlet API mock objects for more details. \u2022TestContext Framework: Support for loading Spring configuration in JUnit and TestNG tests, including efficient caching of the loaded configuration across test methods and support for loading a WebApplicationContext with a MockServletContext. See TestContext Framework for more details. \u2022Spring MVC Test: A framework, also known as MockMvc, for testing annotated controllers through the DispatcherServlet (that is, supporting annotations), complete with the Spring MVC infrastructure but without an HTTP server. See Spring MVC Test for more details. \u2022Client-side REST: spring-test provides a MockRestServiceServer that you can use as a mock server for testing client-side code that internally uses the RestTemplate.", "chunk_char_count": 1050, "chunk_word_count": 146, "chunk_token_count": 262.5}, {"page_number": 1047, "sentence_chunk": "See Client REST Tests for more details. \u2022WebTestClient: Built for testing WebFlux applications, but it can also be used for end-to-end integration testing, to any server, over an HTTP connection. It is a non-blocking, reactive client and is well suited for testing asynchronous and streaming scenarios.5.4. WebSockets WebFlux This part of the reference documentation covers support for Servlet stack, WebSocket messaging 1047", "chunk_char_count": 425, "chunk_word_count": 62, "chunk_token_count": 106.25}, {"page_number": 1048, "sentence_chunk": "that includes raw WebSocket interactions, WebSocket emulation through SockJS, and publish- subscribe messaging through STOMP as a sub-protocol over WebSocket.= Introduction to WebSocket The WebSocket protocol, RFC 6455, provides a standardized way to establish a full-duplex, two-way communication channel between client and server over a single TCP connection. It is a different TCP protocol from HTTP but is designed to work over HTTP, using ports 80 and 443 and allowing re- use of existing firewall rules. A WebSocket interaction begins with an HTTP request that uses the HTTP Upgrade header to upgrade or, in this case, to switch to the WebSocket protocol. The following example shows such an interaction: GET /spring-websocket-portfolio/portfolio HTTP/1.1 Host: localhost:8080 Upgrade: websocket \u2460 Connection: Upgrade \u2461 Sec-WebSocket-Key: Uc9l9TMkWGbHFD2qnFHltg== Sec-WebSocket-Protocol: v10.stomp, v11.stomp Sec-WebSocket-Version: 13 Origin: http://localhost:8080 \u2460 The Upgrade header.\u2461 Using the Upgrade connection. Instead of the usual 200 status code, a server with WebSocket support returns output similar to the following: HTTP/1.1 101 Switching Protocols \u2460 Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: 1qVdfYHU9hPOl4JYYNXF623Gzn0= Sec-WebSocket-Protocol: v10.stomp \u2460 Protocol switch After a successful handshake, the TCP socket underlying the HTTP upgrade request remains open for both the client and the server to continue to send and receive messages. A complete introduction of how WebSockets work is beyond the scope of this document. See RFC 6455, the WebSocket chapter of HTML5, or any of the many introductions and tutorials on the Web. Note that, if a WebSocket server is running behind a web server (e.g. nginx), you likely need to configure it to pass WebSocket upgrade requests on to the WebSocket server.", "chunk_char_count": 1845, "chunk_word_count": 262, "chunk_token_count": 461.25}, {"page_number": 1048, "sentence_chunk": "Likewise, if the application runs in a cloud environment, check the instructions of the cloud provider related to WebSocket support.== HTTP Versus WebSocket 1048", "chunk_char_count": 161, "chunk_word_count": 24, "chunk_token_count": 40.25}, {"page_number": 1049, "sentence_chunk": "Even though WebSocket is designed to be HTTP-compatible and starts with an HTTP request, it is important to understand that the two protocols lead to very different architectures and application programming models. In HTTP and REST, an application is modeled as many URLs. To interact with the application, clients access those URLs, request-response style. Servers route requests to the appropriate handler based on the HTTP URL, method, and headers. By contrast, in WebSockets, there is usually only one URL for the initial connect. Subsequently, all application messages flow on that same TCP connection. This points to an entirely different asynchronous, event-driven, messaging architecture. WebSocket is also a low-level transport protocol, which, unlike HTTP, does not prescribe any semantics to the content of messages. That means that there is no way to route or process a message unless the client and the server agree on message semantics. WebSocket clients and servers can negotiate the use of a higher-level, messaging protocol (for example, STOMP), through the Sec-WebSocket-Protocol header on the HTTP handshake request.", "chunk_char_count": 1135, "chunk_word_count": 171, "chunk_token_count": 283.75}, {"page_number": 1049, "sentence_chunk": "In the absence of that, they need to come up with their own conventions.== When to Use WebSockets WebSockets can make a web page be dynamic and interactive. However, in many cases, a combination of Ajax and HTTP streaming or long polling can provide a simple and effective solution. For example, news, mail, and social feeds need to update dynamically, but it may be perfectly okay to do so every few minutes. Collaboration, games, and financial apps, on the other hand, need to be much closer to real-time. Latency alone is not a deciding factor. If the volume of messages is relatively low (for example, monitoring network failures) HTTP streaming or polling can provide an effective solution. It is the combination of low latency, high frequency, and high volume that make the best case for the use of WebSocket. Keep in mind also that over the Internet, restrictive proxies that are outside of your control may preclude WebSocket interactions, either because they are not configured to pass on the Upgrade header or because they close long-lived connections that appear idle. This means that the use of WebSocket for internal applications within the firewall is a more straightforward decision than it is for public facing applications.", "chunk_char_count": 1240, "chunk_word_count": 205, "chunk_token_count": 310.0}, {"page_number": 1049, "sentence_chunk": "5.4.1. WebSocket API WebFlux The Spring Framework provides a WebSocket API that you can use to write client- and server-side applications that handle WebSocket messages.1049", "chunk_char_count": 173, "chunk_word_count": 25, "chunk_token_count": 43.25}, {"page_number": 1050, "sentence_chunk": "WebSocketHandler WebFlux Creating a WebSocket server is as simple as implementing WebSocketHandler or, more likely, extending either TextWebSocketHandler or BinaryWebSocketHandler. The following example uses TextWebSocketHandler: import org.springframework.web.socket. WebSocketHandler; import org.springframework.web.socket. WebSocketSession; import org.springframework.web.socket. TextMessage; public class MyHandler extends TextWebSocketHandler { \u00a0  @Override \u00a0  public void handleTextMessage(WebSocketSession session, TextMessage message) { \u00a0    // ... \u00a0  } } There is dedicated WebSocket Java configuration and XML namespace support for mapping the preceding WebSocket handler to a specific URL, as the following example shows: import org.springframework.web.socket.config.annotation. EnableWebSocket; import org.springframework.web.socket.config.annotation. WebSocketConfigurer; import org.springframework.web.socket.config.annotation. WebSocketHandlerRegistry; @Configuration @EnableWebSocket public class WebSocketConfig implements WebSocketConfigurer { \u00a0  @Override \u00a0  public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) { \u00a0    registry.addHandler(myHandler(), \"/myHandler\"); \u00a0  } \u00a0  @Bean \u00a0  public WebSocketHandler myHandler() { \u00a0    return new MyHandler(); \u00a0  } } The following example shows the XML configuration equivalent of the preceding example: 1050", "chunk_char_count": 1388, "chunk_word_count": 156, "chunk_token_count": 347.0}, {"page_number": 1051, "sentence_chunk": "<beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:websocket=\"http://www.springframework.org/schema/websocket\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/websocket \u00a0    https://www.springframework.org/schema/websocket/spring-websocket.xsd\"> \u00a0  <websocket:handlers> \u00a0    <websocket:mapping path=\"/myHandler\" handler=\"myHandler\"/> \u00a0  </websocket:handlers> \u00a0  <bean id=\"myHandler\" class=\"org.springframework.samples. MyHandler\"/> </beans> The preceding example is for use in Spring MVC applications and should be included in the configuration of a DispatcherServlet. However, Spring\u2019s WebSocket support does not depend on Spring MVC. It is relatively simple to integrate a WebSocketHandler into other HTTP-serving environments with the help of WebSocketHttpRequestHandler. When using the WebSocketHandler API directly vs indirectly, e.g. through the STOMP messaging, the application must synchronize the sending of messages since the underlying standard WebSocket session (JSR-356) does not allow concurrent sending. One option is to wrap the WebSocketSession with ConcurrentWebSocketSessionDecorator. WebSocket Handshake WebFlux The easiest way to customize the initial HTTP WebSocket handshake request is through a HandshakeInterceptor, which exposes methods for \u201cbefore\u201d and \u201cafter\u201d the handshake. You can use such an interceptor to preclude the handshake or to make any attributes available to the WebSocketSession. The following example uses a built-in interceptor to pass HTTP session attributes to the WebSocket session: @Configuration @EnableWebSocket public class WebSocketConfig implements WebSocketConfigurer { \u00a0  @Override \u00a0  public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) { \u00a0    registry.addHandler(new MyHandler(), \"/myHandler\") \u00a0      .addInterceptors(new HttpSessionHandshakeInterceptor()); \u00a0  } } 1051", "chunk_char_count": 2055, "chunk_word_count": 240, "chunk_token_count": 513.75}, {"page_number": 1052, "sentence_chunk": "The following example shows the XML configuration equivalent of the preceding example: <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:websocket=\"http://www.springframework.org/schema/websocket\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/websocket \u00a0    https://www.springframework.org/schema/websocket/spring-websocket.xsd\"> \u00a0  <websocket:handlers> \u00a0    <websocket:mapping path=\"/myHandler\" handler=\"myHandler\"/> \u00a0    <websocket:handshake-interceptors> \u00a0      <bean class=\"org.springframework.web.socket.server.support. HttpSessionHandshakeInterceptor\"/ > \u00a0    </websocket:handshake-interceptors> \u00a0  </websocket:handlers> \u00a0  <bean id=\"myHandler\" class=\"org.springframework.samples. MyHandler\"/> </beans> A more advanced option is to extend the DefaultHandshakeHandler that performs the steps of the WebSocket handshake, including validating the client origin, negotiating a sub-protocol, and other details. An application may also need to use this option if it needs to configure a custom RequestUpgradeStrategy in order to adapt to a WebSocket server engine and version that is not yet supported (see Deployment for more on this subject). Both the Java configuration and XML namespace make it possible to configure a custom HandshakeHandler.\uf0eb Spring provides a WebSocketHandlerDecorator base class that you can use to decorate a WebSocketHandler with additional behavior. Logging and exception handling implementations are provided and added by default when using the WebSocket Java configuration or XML namespace. The ExceptionWebSocketHandlerDecorator catches all uncaught exceptions that arise from any WebSocketHandler method and closes the WebSocket session with status 1011, which indicates a server error. Deployment The Spring WebSocket API is easy to integrate into a Spring MVC application where the DispatcherServlet serves both HTTP WebSocket handshake and other HTTP requests. It is also easy to integrate into other HTTP processing scenarios by invoking WebSocketHttpRequestHandler.", "chunk_char_count": 2214, "chunk_word_count": 268, "chunk_token_count": 553.5}, {"page_number": 1052, "sentence_chunk": "This is convenient and easy to understand. However, special considerations apply with regards to JSR-356 runtimes. The Java WebSocket API (JSR-356) provides two deployment mechanisms. The first involves a 1052", "chunk_char_count": 209, "chunk_word_count": 30, "chunk_token_count": 52.25}, {"page_number": 1053, "sentence_chunk": "Servlet container classpath scan (a Servlet 3 feature) at startup. The other is a registration API to use at Servlet container initialization. Neither of these mechanism makes it possible to use a single \u201cfront controller\u201d for all HTTP processing\u2009\u2014\u2009including WebSocket handshake and all other HTTP requests\u2009\u2014\u2009such as Spring MVC\u2019s DispatcherServlet. This is a significant limitation of JSR-356 that Spring\u2019s WebSocket support addresses with server- specific RequestUpgradeStrategy implementations even when running in a JSR-356 runtime. Such strategies currently exist for Tomcat, Jetty, GlassFish, WebLogic, WebSphere, and Undertow (and WildFly).\uf05a A request to overcome the preceding limitation in the Java WebSocket API has been created and can be followed at eclipse-ee4j/websocket-api#211. Tomcat, Undertow, and WebSphere provide their own API alternatives that make it possible to do this, and it is also possible with Jetty. We are hopeful that more servers will do the same. A secondary consideration is that Servlet containers with JSR-356 support are expected to perform a ServletContainerInitializer (SCI) scan that can slow down application startup\u2009\u2014\u2009in some cases, dramatically. If a significant impact is observed after an upgrade to a Servlet container version with JSR-356 support, it should be possible to selectively enable or disable web fragments (and SCI scanning) through the use of the <absolute-ordering /> element in web.xml, as the following example shows: <web-app xmlns=\"https://jakarta.ee/xml/ns/jakartaee\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xsi:schemaLocation=\" \u00a0    https://jakarta.ee/xml/ns/jakartaee \u00a0    https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd\" \u00a0  version=\"5.0\"> \u00a0  <absolute-ordering/> </web-app> You can then selectively enable web fragments by name, such as Spring\u2019s own SpringServletContainerInitializer that provides support for the Servlet 3 Java initialization API.", "chunk_char_count": 1941, "chunk_word_count": 264, "chunk_token_count": 485.25}, {"page_number": 1054, "sentence_chunk": "<web-app xmlns=\"https://jakarta.ee/xml/ns/jakartaee\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xsi:schemaLocation=\" \u00a0    https://jakarta.ee/xml/ns/jakartaee \u00a0    https://jakarta.ee/xml/ns/jakartaee/web-app_5_0.xsd\" \u00a0  version=\"5.0\"> \u00a0  <absolute-ordering> \u00a0    <name>spring_web</name> \u00a0  </absolute-ordering> </web-app> Server Configuration WebFlux Each underlying WebSocket engine exposes configuration properties that control runtime characteristics, such as the size of message buffer sizes, idle timeout, and others. For Tomcat, WildFly, and GlassFish, you can add a ServletServerContainerFactoryBean to your WebSocket Java config, as the following example shows: @Configuration @EnableWebSocket public class WebSocketConfig implements WebSocketConfigurer { \u00a0  @Bean \u00a0  public ServletServerContainerFactoryBean createWebSocketContainer() { \u00a0    ServletServerContainerFactoryBean container = new ServletServerContainerFactoryBean(); \u00a0    container.setMaxTextMessageBufferSize(8192); \u00a0    container.setMaxBinaryMessageBufferSize(8192); \u00a0    return container; \u00a0  } } The following example shows the XML configuration equivalent of the preceding example: 1054", "chunk_char_count": 1177, "chunk_word_count": 138, "chunk_token_count": 294.25}, {"page_number": 1055, "sentence_chunk": "<beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:websocket=\"http://www.springframework.org/schema/websocket\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/websocket \u00a0    https://www.springframework.org/schema/websocket/spring-websocket.xsd\"> \u00a0  <bean class=\"org.springframework... ServletServerContainerFactoryBean\"> \u00a0    <property name=\"maxTextMessageBufferSize\" value=\"8192\"/> \u00a0    <property name=\"maxBinaryMessageBufferSize\" value=\"8192\"/> \u00a0  </bean> </beans> \uf05a For client-side WebSocket configuration, you should use WebSocketContainerFactoryBean (XML) or ContainerProvider.getWebSocketContainer() (Java configuration). For Jetty, you need to supply a pre-configured Jetty WebSocketServerFactory and plug that into Spring\u2019s DefaultHandshakeHandler through your WebSocket Java config. The following example shows how to do so: @Configuration @EnableWebSocket public class WebSocketConfig implements WebSocketConfigurer { \u00a0  @Override \u00a0  public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) { \u00a0    registry.addHandler(echoWebSocketHandler(), \u00a0      \"/echo\").setHandshakeHandler(handshakeHandler()); \u00a0  } \u00a0  @Bean \u00a0  public DefaultHandshakeHandler handshakeHandler() { \u00a0    WebSocketPolicy policy = new WebSocketPolicy(WebSocketBehavior. SERVER); \u00a0    policy.setInputBufferSize(8192); \u00a0    policy.setIdleTimeout(600000); \u00a0    return new DefaultHandshakeHandler( \u00a0        new JettyRequestUpgradeStrategy(new WebSocketServerFactory(policy))); \u00a0  } } The following example shows the XML configuration equivalent of the preceding example: 1055", "chunk_char_count": 1773, "chunk_word_count": 194, "chunk_token_count": 443.25}, {"page_number": 1056, "sentence_chunk": "<beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:websocket=\"http://www.springframework.org/schema/websocket\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/websocket \u00a0    https://www.springframework.org/schema/websocket/spring-websocket.xsd\"> \u00a0  <websocket:handlers> \u00a0    <websocket:mapping path=\"/echo\" handler=\"echoHandler\"/> \u00a0    <websocket:handshake-handler ref=\"handshakeHandler\"/> \u00a0  </websocket:handlers> \u00a0  <bean id=\"handshakeHandler\" class=\"org.springframework... DefaultHandshakeHandler\"> \u00a0    <constructor-arg ref=\"upgradeStrategy\"/> \u00a0  </bean> \u00a0  <bean id=\"upgradeStrategy\" class=\"org.springframework... JettyRequestUpgradeStrategy\"> \u00a0    <constructor-arg ref=\"serverFactory\"/> \u00a0  </bean> \u00a0  <bean id=\"serverFactory\" class=\"org.eclipse.jetty... WebSocketServerFactory\"> \u00a0    <constructor-arg> \u00a0      <bean class=\"org.eclipse.jetty... WebSocketPolicy\"> \u00a0        <constructor-arg value=\"SERVER\"/> \u00a0        <property name=\"inputBufferSize\" value=\"8092\"/> \u00a0        <property name=\"idleTimeout\" value=\"600000\"/> \u00a0      </bean> \u00a0    </constructor-arg> \u00a0  </bean> </beans> Allowed Origins WebFlux As of Spring Framework 4.1.5, the default behavior for WebSocket and SockJS is to accept only same-origin requests. It is also possible to allow all or a specified list of origins. This check is mostly designed for browser clients. Nothing prevents other types of clients from modifying the Origin header value (see RFC 6454: The Web Origin Concept for more details). The three possible behaviors are: \u2022 Allow only same-origin requests (default): In this mode, when SockJS is enabled, the Iframe HTTP response header X-Frame-Options is set to SAMEORIGIN, and JSONP transport is disabled, since it does not allow checking the origin of a request. As a consequence, IE6 and IE7 are not supported when this mode is enabled.1056", "chunk_char_count": 2038, "chunk_word_count": 270, "chunk_token_count": 509.5}, {"page_number": 1057, "sentence_chunk": "\u2022 Allow a specified list of origins: Each allowed origin must start with http:// or https://. In this mode, when SockJS is enabled, IFrame transport is disabled. As a consequence, IE6 through IE9 are not supported when this mode is enabled. \u2022Allow all origins: To enable this mode, you should provide * as the allowed origin value. In this mode, all transports are available. You can configure WebSocket and SockJS allowed origins, as the following example shows: import org.springframework.web.socket.config.annotation. EnableWebSocket; import org.springframework.web.socket.config.annotation. WebSocketConfigurer; import org.springframework.web.socket.config.annotation. WebSocketHandlerRegistry; @Configuration @EnableWebSocket public class WebSocketConfig implements WebSocketConfigurer { \u00a0  @Override \u00a0  public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) { \u00a0    registry.addHandler(myHandler(), \"/myHandler\").setAllowedOrigins(\"https://mydomain.com\"); \u00a0  } \u00a0  @Bean \u00a0  public WebSocketHandler myHandler() { \u00a0    return new MyHandler(); \u00a0  } } The following example shows the XML configuration equivalent of the preceding example: <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:websocket=\"http://www.springframework.org/schema/websocket\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/websocket \u00a0    https://www.springframework.org/schema/websocket/spring-websocket.xsd\"> \u00a0  <websocket:handlers allowed-origins=\"https://mydomain.com\"> \u00a0    <websocket:mapping path=\"/myHandler\" handler=\"myHandler\" /> \u00a0  </websocket:handlers> \u00a0  <bean id=\"myHandler\" class=\"org.springframework.samples. MyHandler\"/> </beans> 1057", "chunk_char_count": 1851, "chunk_word_count": 199, "chunk_token_count": 462.75}, {"page_number": 1058, "sentence_chunk": "5.4.2. SockJS Fallback Over the public Internet, restrictive proxies outside your control may preclude WebSocket interactions, either because they are not configured to pass on the Upgrade header or because they close long-lived connections that appear to be idle. The solution to this problem is WebSocket emulation\u2009\u2014\u2009that is, attempting to use WebSocket first and then falling back on HTTP-based techniques that emulate a WebSocket interaction and expose the same application-level API. On the Servlet stack, the Spring Framework provides both server (and also client) support for the SockJS protocol. Overview The goal of SockJS is to let applications use a WebSocket API but fall back to non-WebSocket alternatives when necessary at runtime, without the need to change application code. SockJS consists of: \u2022 The SockJS protocol defined in the form of executable narrated tests. \u2022The SockJS JavaScript client\u2009\u2014\u2009a client library for use in browsers. \u2022SockJS server implementations, including one in the Spring Framework spring-websocket module. \u2022A SockJS Java client in the spring-websocket module (since version 4.1). SockJS is designed for use in browsers.", "chunk_char_count": 1161, "chunk_word_count": 173, "chunk_token_count": 290.25}, {"page_number": 1058, "sentence_chunk": "It uses a variety of techniques to support a wide range of browser versions. For the full list of SockJS transport types and browsers, see the SockJS client page. Transports fall in three general categories: WebSocket, HTTP Streaming, and HTTP Long Polling. For an overview of these categories, see this blog post. The SockJS client begins by sending GET /info to obtain basic information from the server. After that, it must decide what transport to use. If possible, WebSocket is used. If not, in most browsers, there is at least one HTTP streaming option. If not, then HTTP (long) polling is used. All transport requests have the following URL structure: https://host:port/myApp/myEndpoint/{server-id}/{session-id}/{transport} where: \u2022 {server-id} is useful for routing requests in a cluster but is not used otherwise. \u2022 {", "chunk_char_count": 825, "chunk_word_count": 129, "chunk_token_count": 206.25}, {"page_number": 1058, "sentence_chunk": "session-id} correlates HTTP requests belonging to a SockJS session. \u2022 {transport} indicates the transport type (for example, websocket, xhr-streaming, and others). The WebSocket transport needs only a single HTTP request to do the WebSocket handshake. All messages thereafter are exchanged on that socket.1058", "chunk_char_count": 309, "chunk_word_count": 43, "chunk_token_count": 77.25}, {"page_number": 1059, "sentence_chunk": "HTTP transports require more requests. Ajax/XHR streaming, for example, relies on one long- running request for server-to-client messages and additional HTTP POST requests for client-to- server messages. Long polling is similar, except that it ends the current request after each server-to- client send. SockJS adds minimal message framing. For example, the server sends the letter o (\u201copen\u201d frame) initially, messages are sent as a[\"message1\",\"message2\"] (JSON-encoded array), the letter h (\u201cheartbeat\u201d frame) if no messages flow for 25 seconds (by default), and the letter c (\u201cclose\u201d frame) to close the session. To learn more, run an example in a browser and watch the HTTP requests. The SockJS client allows fixing the list of transports, so it is possible to see each transport one at a time. The SockJS client also provides a debug flag, which enables helpful messages in the browser console. On the server side, you can enable TRACE logging for org.springframework.web.socket. For even more detail, see the SockJS protocol narrated test.", "chunk_char_count": 1044, "chunk_word_count": 162, "chunk_token_count": 261.0}, {"page_number": 1059, "sentence_chunk": "Enabling SockJS You can enable SockJS through Java configuration, as the following example shows: @Configuration @EnableWebSocket public class WebSocketConfig implements WebSocketConfigurer { \u00a0  @Override \u00a0  public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) { \u00a0    registry.addHandler(myHandler(), \"/myHandler\").withSockJS(); \u00a0  } \u00a0  @Bean \u00a0  public WebSocketHandler myHandler() { \u00a0    return new MyHandler(); \u00a0  } } The following example shows the XML configuration equivalent of the preceding example: 1059", "chunk_char_count": 531, "chunk_word_count": 74, "chunk_token_count": 132.75}, {"page_number": 1060, "sentence_chunk": "<beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:websocket=\"http://www.springframework.org/schema/websocket\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/websocket \u00a0    https://www.springframework.org/schema/websocket/spring-websocket.xsd\"> \u00a0  <websocket:handlers> \u00a0    <websocket:mapping path=\"/myHandler\" handler=\"myHandler\"/> \u00a0    <websocket:sockjs/> \u00a0  </websocket:handlers> \u00a0  <bean id=\"myHandler\" class=\"org.springframework.samples. MyHandler\"/> </beans> The preceding example is for use in Spring MVC applications and should be included in the configuration of a DispatcherServlet. However, Spring\u2019s WebSocket and SockJS support does not depend on Spring MVC. It is relatively simple to integrate into other HTTP serving environments with the help of SockJsHttpRequestHandler. On the browser side, applications can use the sockjs-client (version 1.0.x). It emulates the W3C WebSocket API and communicates with the server to select the best transport option, depending on the browser in which it runs. See the sockjs-client page and the list of transport types supported by browser. The client also provides several configuration options\u2009\u2014\u2009for example, to specify which transports to include. IE 8 and 9 Internet Explorer 8 and 9 remain in use. They are a key reason for having SockJS.", "chunk_char_count": 1505, "chunk_word_count": 187, "chunk_token_count": 376.25}, {"page_number": 1060, "sentence_chunk": "This section covers important considerations about running in those browsers. The SockJS client supports Ajax/XHR streaming in IE 8 and 9 by using Microsoft\u2019s XDomainRequest. That works across domains but does not support sending cookies. Cookies are often essential for Java applications. However, since the SockJS client can be used with many server types (not just Java ones), it needs to know whether cookies matter. If so, the SockJS client prefers Ajax/XHR for streaming. Otherwise, it relies on an iframe-based technique. The first /info request from the SockJS client is a request for information that can influence the client\u2019s choice of transports. One of those details is whether the server application relies on cookies (for example, for authentication purposes or clustering with sticky sessions). Spring\u2019s SockJS support includes a property called sessionCookieNeeded.", "chunk_char_count": 882, "chunk_word_count": 132, "chunk_token_count": 220.5}, {"page_number": 1060, "sentence_chunk": "It is enabled by default, since most Java applications rely on the JSESSIONID cookie. If your application does not need it, you can turn off this option, and SockJS client should then choose xdr-streaming in IE 8 and 9. If you do use an iframe-based transport, keep in mind that browsers can be instructed to block the use of IFrames on a given page by setting the HTTP response header X-Frame-Options to DENY, 1060", "chunk_char_count": 415, "chunk_word_count": 74, "chunk_token_count": 103.75}, {"page_number": 1061, "sentence_chunk": "SAMEORIGIN, or ALLOW-FROM <origin>. This is used to prevent clickjacking.\uf05a Spring Security 3.2+ provides support for setting X-Frame-Options on every response. By default, the Spring Security Java configuration sets it to DENY. In 3.2, the Spring Security XML namespace does not set that header by default but can be configured to do so. In the future, it may set it by default. See Default Security Headers of the Spring Security documentation for details on how to configure the setting of the X-Frame-Options header. You can also see gh- 2718 for additional background. If your application adds the X-Frame-Options response header (as it should!)and relies on an iframe- based transport, you need to set the header value to SAMEORIGIN or ALLOW-FROM <origin>.", "chunk_char_count": 761, "chunk_word_count": 121, "chunk_token_count": 190.25}, {"page_number": 1061, "sentence_chunk": "The Spring SockJS support also needs to know the location of the SockJS client, because it is loaded from the iframe. By default, the iframe is set to download the SockJS client from a CDN location. It is a good idea to configure this option to use a URL from the same origin as the application. The following example shows how to do so in Java configuration: @Configuration @EnableWebSocketMessageBroker public class WebSocketConfig implements WebSocketMessageBrokerConfigurer { \u00a0  @Override \u00a0  public void registerStompEndpoints(StompEndpointRegistry registry) { \u00a0    registry.addEndpoint(\"/portfolio\").withSockJS() \u00a0        .setClientLibraryUrl(\"http://localhost:8080/myapp/js/sockjs- client.js\"); \u00a0  } \u00a0  // ... } The XML namespace provides a similar option through the <websocket:sockjs> element.\uf05a During initial development, do enable the SockJS client devel mode that prevents the browser from caching SockJS requests (like the iframe) that would otherwise be cached. For details on how to enable it see the SockJS client page. Heartbeats The SockJS protocol requires servers to send heartbeat messages to preclude proxies from concluding that a connection is hung. The Spring SockJS configuration has a property called heartbeatTime that you can use to customize the frequency. By default, a heartbeat is sent after 25 seconds, assuming no other messages were sent on that connection. This 25-second value is in line with the following IETF recommendation for public Internet applications.", "chunk_char_count": 1497, "chunk_word_count": 227, "chunk_token_count": 374.25}, {"page_number": 1062, "sentence_chunk": "\uf05a When using STOMP over WebSocket and SockJS, if the STOMP client and server negotiate heartbeats to be exchanged, the SockJS heartbeats are disabled. The Spring SockJS support also lets you configure the TaskScheduler to schedule heartbeats tasks. The task scheduler is backed by a thread pool, with default settings based on the number of available processors. Your should consider customizing the settings according to your specific needs. Client Disconnects HTTP streaming and HTTP long polling SockJS transports require a connection to remain open longer than usual. For an overview of these techniques, see this blog post. In Servlet containers, this is done through Servlet 3 asynchronous support that allows exiting the Servlet container thread, processing a request, and continuing to write to the response from another thread. A specific issue is that the Servlet API does not provide notifications for a client that has gone away. See eclipse-ee4j/servlet-api#44. However, Servlet containers raise an exception on subsequent attempts to write to the response.", "chunk_char_count": 1070, "chunk_word_count": 163, "chunk_token_count": 267.5}, {"page_number": 1062, "sentence_chunk": "Since Spring\u2019s SockJS Service supports server-sent heartbeats (every 25 seconds by default), that means a client disconnect is usually detected within that time period (or earlier, if messages are sent more frequently).\uf05a As a result, network I/O failures can occur because a client has disconnected, which can fill the log with unnecessary stack traces. Spring makes a best effort to identify such network failures that represent client disconnects (specific to each server) and log a minimal message by using the dedicated log category, DISCONNECTED_CLIENT_LOG_CATEGORY (defined in AbstractSockJsSession). If you need to see the stack traces, you can set that log category to TRACE. SockJS and CORS If you allow cross-origin requests (see Allowed Origins), the SockJS protocol uses CORS for cross- domain support in the XHR streaming and polling transports. Therefore, CORS headers are added automatically, unless the presence of CORS headers in the response is detected. So, if an application is already configured to provide CORS support (for example, through a Servlet Filter), Spring\u2019s SockJsService skips this part. It is also possible to disable the addition of these CORS headers by setting the suppressCors property in Spring\u2019s SockJsService. SockJS expects the following headers and values: \u2022 Access-Control-Allow-Origin: Initialized from the value of the Origin request header. \u2022Access-Control-Allow-Credentials: Always set to true. \u2022", "chunk_char_count": 1445, "chunk_word_count": 213, "chunk_token_count": 361.25}, {"page_number": 1062, "sentence_chunk": "Access-Control-Request-Headers: Initialized from values from the equivalent request header. \u2022Access-Control-Allow-Methods: The HTTP methods a transport supports (see TransportType enum).1062", "chunk_char_count": 190, "chunk_word_count": 19, "chunk_token_count": 47.5}, {"page_number": 1063, "sentence_chunk": "\u2022 Access-Control-Max-Age: Set to 31536000 (1 year). For the exact implementation, see addCorsHeaders in AbstractSockJsService and the TransportType enum in the source code. Alternatively, if the CORS configuration allows it, consider excluding URLs with the SockJS endpoint prefix, thus letting Spring\u2019s SockJsService handle it. SockJsClient Spring provides a SockJS Java client to connect to remote SockJS endpoints without using a browser. This can be especially useful when there is a need for bidirectional communication between two servers over a public network (that is, where network proxies can preclude the use of the WebSocket protocol). A SockJS Java client is also very useful for testing purposes (for example, to simulate a large number of concurrent users). The SockJS Java client supports the websocket, xhr-streaming, and xhr-polling transports. The remaining ones only make sense for use in a browser. You can configure the WebSocketTransport with: \u2022 StandardWebSocketClient in a JSR-356 runtime. \u2022JettyWebSocketClient by using the Jetty 9+ native WebSocket API. \u2022", "chunk_char_count": 1082, "chunk_word_count": 159, "chunk_token_count": 270.5}, {"page_number": 1063, "sentence_chunk": "Any implementation of Spring\u2019s WebSocketClient. An XhrTransport, by definition, supports both xhr-streaming and xhr-polling, since, from a client perspective, there is no difference other than in the URL used to connect to the server. At present there are two implementations: \u2022 RestTemplateXhrTransport uses Spring\u2019s RestTemplate for HTTP requests. \u2022JettyXhrTransport uses Jetty\u2019s HttpClient for HTTP requests. The following example shows how to create a SockJS client and connect to a SockJS endpoint: List<Transport> transports = new ArrayList<>(2); transports.add(new WebSocketTransport(new StandardWebSocketClient())); transports.add(new RestTemplateXhrTransport()); SockJsClient sockJsClient = new SockJsClient(transports); sockJsClient.doHandshake(new MyWebSocketHandler(), \"ws://example.com:8080/sockjs\"); \uf05a SockJS uses JSON formatted arrays for messages. By default, Jackson 2 is used and needs to be on the classpath. Alternatively, you can configure a custom implementation of SockJsMessageCodec and configure it on the SockJsClient. To use SockJsClient to simulate a large number of concurrent users, you need to configure the underlying HTTP client (for XHR transports) to allow a sufficient number of connections and threads. The following example shows how to do so with Jetty: 1063", "chunk_char_count": 1297, "chunk_word_count": 167, "chunk_token_count": 324.25}, {"page_number": 1064, "sentence_chunk": "HttpClient jettyHttpClient = new HttpClient(); jettyHttpClient.setMaxConnectionsPerDestination(1000); jettyHttpClient.setExecutor(new QueuedThreadPool(1000)); The following example shows the server-side SockJS-related properties (see javadoc for details) that you should also consider customizing: @Configuration public class WebSocketConfig extends WebSocketMessageBrokerConfigurationSupport { \u00a0  @Override \u00a0  public void registerStompEndpoints(StompEndpointRegistry registry) { \u00a0    registry.addEndpoint(\"/sockjs\").withSockJS() \u00a0      .setStreamBytesLimit(512 * 1024) \u2460 \u00a0      .setHttpMessageCacheSize(1000) \u2461 \u00a0      .setDisconnectDelay(30 * 1000); \u2462 \u00a0  } \u00a0  // ... } \u2460 Set the streamBytesLimit property to 512KB (the default is 128KB\u2009\u2014\u2009128 * 1024).\u2461 Set the httpMessageCacheSize property to 1,000 (the default is 100).\u2462 Set the disconnectDelay property to 30 property seconds (the default is five seconds\u2009\u2014\u20095 * 1000).5.4.3. STOMP The WebSocket protocol defines two types of messages (text and binary), but their content is undefined. The protocol defines a mechanism for client and server to negotiate a sub-protocol (that is, a higher-level messaging protocol) to use on top of WebSocket to define what kind of messages each can send, what the format is, the content of each message, and so on. The use of a sub-protocol is optional but, either way, the client and the server need to agree on some protocol that defines message content. Overview STOMP (Simple Text Oriented Messaging Protocol) was originally created for scripting languages (such as Ruby, Python, and Perl) to connect to enterprise message brokers. It is designed to address a minimal subset of commonly used messaging patterns. STOMP can be used over any reliable two- way streaming network protocol, such as TCP and WebSocket.", "chunk_char_count": 1799, "chunk_word_count": 265, "chunk_token_count": 449.75}, {"page_number": 1064, "sentence_chunk": "Although STOMP is a text-oriented protocol, message payloads can be either text or binary. STOMP is a frame-based protocol whose frames are modeled on HTTP. The following listing shows the structure of a STOMP frame: 1064", "chunk_char_count": 221, "chunk_word_count": 36, "chunk_token_count": 55.25}, {"page_number": 1065, "sentence_chunk": "COMMAND header1:value1 header2:value2 Body^@ Clients can use the SEND or SUBSCRIBE commands to send or subscribe for messages, along with a destination header that describes what the message is about and who should receive it. This enables a simple publish-subscribe mechanism that you can use to send messages through the broker to other connected clients or to send messages to the server to request that some work be performed. When you use Spring\u2019s STOMP support, the Spring WebSocket application acts as the STOMP broker to clients. Messages are routed to @Controller message-handling methods or to a simple in-memory broker that keeps track of subscriptions and broadcasts messages to subscribed users. You can also configure Spring to work with a dedicated STOMP broker (such as RabbitMQ, ActiveMQ, and others) for the actual broadcasting of messages. In that case, Spring maintains TCP connections to the broker, relays messages to it, and passes messages from it down to connected WebSocket clients. Thus, Spring web applications can rely on unified HTTP-based security, common validation, and a familiar programming model for message handling. The following example shows a client subscribing to receive stock quotes, which the server may emit periodically (for example, via a scheduled task that sends messages through a SimpMessagingTemplate to the broker): SUBSCRIBE id:sub-1 destination:/topic/price.stock.*^@ The following example shows a client that sends a trade request, which the server can handle through an @MessageMapping method: SEND destination:/queue/trade content-type:application/json content-length:44 {\"action\":\"BUY\",\"ticker\":\"MMM\",\"shares\",44}^@ After the execution, the server can broadcast a trade confirmation message and details down to the client. The meaning of a destination is intentionally left opaque in the STOMP spec.", "chunk_char_count": 1859, "chunk_word_count": 268, "chunk_token_count": 464.75}, {"page_number": 1065, "sentence_chunk": "It can be any string, and it is entirely up to STOMP servers to define the semantics and the syntax of the destinations 1065", "chunk_char_count": 124, "chunk_word_count": 24, "chunk_token_count": 31.0}, {"page_number": 1066, "sentence_chunk": "that they support. It is very common, however, for destinations to be path-like strings where /topic/.. implies publish-subscribe (one-to-many) and /queue/ implies point-to-point (one-to-one) message exchanges. STOMP servers can use the MESSAGE command to broadcast messages to all subscribers. The following example shows a server sending a stock quote to a subscribed client: MESSAGE message-id:nxahklf6-1 subscription:sub-1 destination:/topic/price.stock. MMM {\"ticker\":\"MMM\",\"price\":129.45}^@ A server cannot send unsolicited messages. All messages from a server must be in response to a specific client subscription, and the subscription header of the server message must match the id header of the client subscription. The preceding overview is intended to provide the most basic understanding of the STOMP protocol. We recommended reviewing the protocol specification in full. Benefits Using STOMP as a sub-protocol lets the Spring Framework and Spring Security provide a richer programming model versus using raw WebSockets. The same point can be made about HTTP versus raw TCP and how it lets Spring MVC and other web frameworks provide rich functionality.", "chunk_char_count": 1165, "chunk_word_count": 165, "chunk_token_count": 291.25}, {"page_number": 1066, "sentence_chunk": "The following is a list of benefits: \u2022 No need to invent a custom messaging protocol and message format. \u2022STOMP clients, including a Java client in the Spring Framework, are available. \u2022You can (optionally) use message brokers (such as RabbitMQ, ActiveMQ, and others) to manage subscriptions and broadcast messages. \u2022Application logic can be organized in any number of @Controller instances and messages can be routed to them based on the STOMP destination header versus handling raw WebSocket messages with a single WebSocketHandler for a given connection. \u2022You can use Spring Security to secure messages based on STOMP destinations and message types. Enable STOMP STOMP over WebSocket support is available in the spring-messaging and spring-websocket modules. Once you have those dependencies, you can expose a STOMP endpoints, over WebSocket with SockJS Fallback, as the following example shows: 1066", "chunk_char_count": 903, "chunk_word_count": 137, "chunk_token_count": 225.75}, {"page_number": 1067, "sentence_chunk": "import org.springframework.web.socket.config.annotation. EnableWebSocketMessageBroker; import org.springframework.web.socket.config.annotation. StompEndpointRegistry; @Configuration @EnableWebSocketMessageBroker public class WebSocketConfig implements WebSocketMessageBrokerConfigurer { \u00a0  @Override \u00a0  public void registerStompEndpoints(StompEndpointRegistry registry) { \u00a0    registry.addEndpoint(\"/portfolio\").withSockJS(); \u2460 \u00a0  } \u00a0  @Override \u00a0  public void configureMessageBroker(MessageBrokerRegistry config) { \u00a0    config.setApplicationDestinationPrefixes(\"/app\"); \u2461 \u00a0    config.enableSimpleBroker(\"/topic\", \"/queue\"); \u2462 \u00a0  } } \u2460 /portfolio is the HTTP URL for the endpoint to which a WebSocket (or SockJS) client needs to connect for the WebSocket handshake.\u2461 STOMP messages whose destination header begins with /app are routed to @MessageMapping methods in @Controller classes.\u2462 Use the built-in message broker for subscriptions and broadcasting and route messages whose destination header begins with /topic `or `/queue to the broker. The following example shows the XML configuration equivalent of the preceding example: <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:websocket=\"http://www.springframework.org/schema/websocket\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/websocket \u00a0    https://www.springframework.org/schema/websocket/spring-websocket.xsd\"> \u00a0  <websocket:message-broker application-destination-prefix=\"/app\"> \u00a0    <websocket:stomp-endpoint path=\"/portfolio\"> \u00a0      <websocket:sockjs/> \u00a0    </websocket:stomp-endpoint> \u00a0    <websocket:simple-broker prefix=\"/topic, /queue\"/> \u00a0  </websocket:message-broker> </beans> 1067", "chunk_char_count": 1864, "chunk_word_count": 199, "chunk_token_count": 466.0}, {"page_number": 1068, "sentence_chunk": "\uf05a For the built-in simple broker, the /topic and /queue prefixes do not have any special meaning. They are merely a convention to differentiate between pub-sub versus point-to-point messaging (that is, many subscribers versus one consumer). When you use an external broker, check the STOMP page of the broker to understand what kind of STOMP destinations and prefixes it supports. To connect from a browser, for SockJS, you can use the sockjs-client. For STOMP, many applications have used the jmesnil/stomp-websocket library (also known as stomp.js), which is feature-complete and has been used in production for years but is no longer maintained. At present the JSteunou/webstomp-client is the most actively maintained and evolving successor of that library. The following example code is based on it: var socket = new SockJS(\"/spring-websocket-portfolio/portfolio\"); var stompClient = webstomp.over(socket); stompClient.connect({}, function(frame) { } Alternatively, if you connect through WebSocket (without SockJS), you can use the following code: var socket = new WebSocket(\"/spring-websocket-portfolio/portfolio\"); var stompClient = Stomp.over(socket); stompClient.connect({}, function(frame) { } Note that stompClient in the preceding example does not need to specify login and passcode headers. Even if it did, they would be ignored (or, rather, overridden) on the server side. See Connecting to a Broker and Authentication for more information on authentication. For more example code see: \u2022 Using WebSocket to build an interactive web application\u2009\u2014\u2009a getting started guide. \u2022", "chunk_char_count": 1586, "chunk_word_count": 225, "chunk_token_count": 396.5}, {"page_number": 1068, "sentence_chunk": "Stock Portfolio\u2009\u2014\u2009a sample application. WebSocket Server To configure the underlying WebSocket server, the information in Server Configuration applies. For Jetty, however you need to set the HandshakeHandler and WebSocketPolicy through the StompEndpointRegistry: 1068", "chunk_char_count": 267, "chunk_word_count": 33, "chunk_token_count": 66.75}, {"page_number": 1069, "sentence_chunk": "@Configuration @EnableWebSocketMessageBroker public class WebSocketConfig implements WebSocketMessageBrokerConfigurer { \u00a0  @Override \u00a0  public void registerStompEndpoints(StompEndpointRegistry registry) { \u00a0    registry.addEndpoint(\"/portfolio\").setHandshakeHandler(handshakeHandler()); \u00a0  } \u00a0  @Bean \u00a0  public DefaultHandshakeHandler handshakeHandler() { \u00a0    WebSocketPolicy policy = new WebSocketPolicy(WebSocketBehavior. SERVER); \u00a0    policy.setInputBufferSize(8192); \u00a0    policy.setIdleTimeout(600000); \u00a0    return new DefaultHandshakeHandler( \u00a0        new JettyRequestUpgradeStrategy(new WebSocketServerFactory(policy))); \u00a0  } } Flow of Messages Once a STOMP endpoint is exposed, the Spring application becomes a STOMP broker for connected clients. This section describes the flow of messages on the server side. The spring-messaging module contains foundational support for messaging applications that originated in Spring Integration and was later extracted and incorporated into the Spring Framework for broader use across many Spring projects and application scenarios. The following list briefly describes a few of the available messaging abstractions: \u2022 Message: Simple representation for a message, including headers and payload. \u2022MessageHandler: Contract for handling a message. \u2022MessageChannel: Contract for sending a message that enables loose coupling between producers and consumers. \u2022SubscribableChannel: MessageChannel with MessageHandler subscribers. \u2022ExecutorSubscribableChannel: SubscribableChannel that uses an Executor for delivering messages. Both the Java configuration (that is, @EnableWebSocketMessageBroker) and the XML namespace configuration (that is, <websocket:message-broker>) use the preceding components to assemble a message workflow.", "chunk_char_count": 1771, "chunk_word_count": 222, "chunk_token_count": 442.75}, {"page_number": 1070, "sentence_chunk": "The preceding diagram shows three message channels: \u2022 clientInboundChannel: For passing messages received from WebSocket clients. \u2022clientOutboundChannel: For sending server messages to WebSocket clients. \u2022brokerChannel: For sending messages to the message broker from within server-side application code. The next diagram shows the components used when an external broker (such as RabbitMQ) is configured for managing subscriptions and broadcasting messages: The main difference between the two preceding diagrams is the use of the \u201cbroker relay\u201d for passing messages up to the external STOMP broker over TCP and for passing messages down from the broker to subscribed clients. When messages are received from a WebSocket connection, they are decoded to STOMP frames, turned into a Spring Message representation, and sent to the clientInboundChannel for further processing. For example, STOMP messages whose destination headers start with /app may be routed to @MessageMapping methods in annotated controllers, while /topic and /queue messages may be routed directly to the message broker. An annotated @Controller that handles a STOMP message from a client may send a message to the 1070", "chunk_char_count": 1188, "chunk_word_count": 174, "chunk_token_count": 297.0}, {"page_number": 1071, "sentence_chunk": "message broker through the brokerChannel, and the broker broadcasts the message to matching subscribers through the clientOutboundChannel. The same controller can also do the same in response to HTTP requests, so a client can perform an HTTP POST, and then a @PostMapping method can send a message to the message broker to broadcast to subscribed clients. We can trace the flow through a simple example. Consider the following example, which sets up a server: @Configuration @EnableWebSocketMessageBroker public class WebSocketConfig implements WebSocketMessageBrokerConfigurer { \u00a0  @Override \u00a0  public void registerStompEndpoints(StompEndpointRegistry registry) { \u00a0    registry.addEndpoint(\"/portfolio\"); \u00a0  } \u00a0  @Override \u00a0  public void configureMessageBroker(MessageBrokerRegistry registry) { \u00a0    registry.setApplicationDestinationPrefixes(\"/app\"); \u00a0    registry.enableSimpleBroker(\"/topic\"); \u00a0  } } @Controller public class GreetingController { \u00a0  @MessageMapping(\"/greeting\") \u00a0  public String handle(String greeting) { \u00a0    return \"[\" + getTimestamp() + \": \" + greeting; \u00a0  } } The preceding example supports the following flow: 1. The client connects to http://localhost:8080/portfolio and, once a WebSocket connection is established, STOMP frames begin to flow on it.2. The client sends a SUBSCRIBE frame with a destination header of /topic/greeting. Once received and decoded, the message is sent to the clientInboundChannel and is then routed to the message broker, which stores the client subscription.3. The client sends a SEND frame to /app/greeting.", "chunk_char_count": 1563, "chunk_word_count": 227, "chunk_token_count": 390.75}, {"page_number": 1071, "sentence_chunk": "The /app prefix helps to route it to annotated controllers. After the /app prefix is stripped, the remaining /greeting part of the destination is mapped to the @MessageMapping method in GreetingController.4. The value returned from GreetingController is turned into a Spring Message with a payload based on the return value and a default destination header of /topic/greeting (derived from the input destination with /app replaced by /topic). The resulting message is sent to the brokerChannel and handled by the message broker.1071", "chunk_char_count": 532, "chunk_word_count": 81, "chunk_token_count": 133.0}, {"page_number": 1072, "sentence_chunk": "5. The message broker finds all matching subscribers and sends a MESSAGE frame to each one through the clientOutboundChannel, from where messages are encoded as STOMP frames and sent on the WebSocket connection. The next section provides more details on annotated methods, including the kinds of arguments and return values that are supported. Annotated Controllers Applications can use annotated @Controller classes to handle messages from clients. Such classes can declare @MessageMapping, @SubscribeMapping, and @ExceptionHandler methods, as described in the following topics: \u2022 @MessageMapping \u2022 @SubscribeMapping \u2022 @MessageExceptionHandler @MessageMapping You can use @MessageMapping to annotate methods that route messages based on their destination. It is supported at the method level as well as at the type level. At the type level, @MessageMapping is used to express shared mappings across all methods in a controller. By default, the mapping values are Ant-style path patterns (for example /thing*, /thing/**), including support for template variables (for example, /thing/{id}). The values can be referenced through @DestinationVariable method arguments. Applications can also switch to a dot-separated destination convention for mappings, as explained in Dots as Separators.", "chunk_char_count": 1287, "chunk_word_count": 180, "chunk_token_count": 321.75}, {"page_number": 1072, "sentence_chunk": "Supported Method Arguments The following table describes the method arguments: Method argument Description Message For access to the complete message. MessageHeaders For access to the headers within the Message. MessageHeaderAccessor, SimpMessageHeaderAccessor, and StompHeaderAccessor For access to the headers through typed accessor methods.@Payload For access to the payload of the message, converted (for example, from JSON) by a configured MessageConverter. The presence of this annotation is not required since it is, by default, assumed if no other argument is matched. You can annotate payload arguments with @jakarta.validation. Valid or Spring\u2019s @Validated, to have the payload arguments be automatically validated.1072", "chunk_char_count": 729, "chunk_word_count": 98, "chunk_token_count": 182.25}, {"page_number": 1073, "sentence_chunk": "Method argument Description @Header For access to a specific header value\u2009\u2014\u2009along with type conversion using an org.springframework.core.convert.converter. Converter, if necessary.@Headers For access to all headers in the message. This argument must be assignable to java.util. Map.@DestinationVariable For access to template variables extracted from the message destination. Values are converted to the declared method argument type as necessary.java.security. Principal Reflects the user logged in at the time of the WebSocket HTTP handshake. Return Values By default, the return value from a @MessageMapping method is serialized to a payload through a matching MessageConverter and sent as a Message to the brokerChannel, from where it is broadcast to subscribers.", "chunk_char_count": 767, "chunk_word_count": 106, "chunk_token_count": 191.75}, {"page_number": 1073, "sentence_chunk": "The destination of the outbound message is the same as that of the inbound message but prefixed with /topic. You can use the @SendTo and @SendToUser annotations to customize the destination of the output message.@SendTo is used to customize the target destination or to specify multiple destinations.@SendToUser is used to direct the output message to only the user associated with the input message. See User Destinations. You can use both @SendTo and @SendToUser at the same time on the same method, and both are supported at the class level, in which case they act as a default for methods in the class. However, keep in mind that any method-level @SendTo or @SendToUser annotations override any such annotations at the class level. Messages can be handled asynchronously and a @MessageMapping method can return ListenableFuture, CompletableFuture, or CompletionStage. Note that @SendTo and @SendToUser are merely a convenience that amounts to using the SimpMessagingTemplate to send messages. If necessary, for more advanced scenarios, @MessageMapping methods can fall back on using the SimpMessagingTemplate directly.", "chunk_char_count": 1122, "chunk_word_count": 170, "chunk_token_count": 280.5}, {"page_number": 1073, "sentence_chunk": "This can be done instead of, or possibly in addition to, returning a value. See Sending Messages.@SubscribeMapping @SubscribeMapping is similar to @MessageMapping but narrows the mapping to subscription messages only. It supports the same method arguments as @MessageMapping. However for the return value, by default, a message is sent directly to the client (through clientOutboundChannel, in response to the subscription) and not to the broker (through brokerChannel, as a broadcast to matching subscriptions). Adding @SendTo or @SendToUser overrides this behavior and sends to the broker instead. When is this useful?Assume that the broker is mapped to /topic and /queue, while application 1073", "chunk_char_count": 697, "chunk_word_count": 102, "chunk_token_count": 174.25}, {"page_number": 1074, "sentence_chunk": "controllers are mapped to /app. In this setup, the broker stores all subscriptions to /topic and /queue that are intended for repeated broadcasts, and there is no need for the application to get involved. A client could also subscribe to some /app destination, and a controller could return a value in response to that subscription without involving the broker without storing or using the subscription again (effectively a one-time request-reply exchange). One use case for this is populating a UI with initial data on startup. When is this not useful?Do not try to map broker and controllers to the same destination prefix unless you want both to independently process messages, including subscriptions, for some reason. Inbound messages are handled in parallel. There are no guarantees whether a broker or a controller processes a given message first. If the goal is to be notified when a subscription is stored and ready for broadcasts, a client should ask for a receipt if the server supports it (simple broker does not). For example, with the Java STOMP client, you could do the following to add a receipt: @Autowired private TaskScheduler messageBrokerTaskScheduler; // During initialization.. stompClient.setTaskScheduler(this.messageBrokerTaskScheduler); // When subscribing.. StompHeaders headers = new StompHeaders(); headers.setDestination(\"/topic/...\"); headers.setReceipt(\"r1\"); FrameHandler handler = ...; stompSession.subscribe(headers, handler).addReceiptTask(receiptHeaders -> { \u00a0  // Subscription ready... }); A server side option is to register an ExecutorChannelInterceptor on the brokerChannel and implement the afterMessageHandled method that is invoked after messages, including subscriptions, have been handled.", "chunk_char_count": 1736, "chunk_word_count": 243, "chunk_token_count": 434.0}, {"page_number": 1074, "sentence_chunk": "@MessageExceptionHandler An application can use @MessageExceptionHandler methods to handle exceptions from @MessageMapping methods. You can declare exceptions in the annotation itself or through a method argument if you want to get access to the exception instance. The following example declares an exception through a method argument: 1074", "chunk_char_count": 341, "chunk_word_count": 47, "chunk_token_count": 85.25}, {"page_number": 1075, "sentence_chunk": "@Controller public class MyController { \u00a0  // ... \u00a0  @MessageExceptionHandler \u00a0  public ApplicationError handleException(MyException exception) { \u00a0    // ... \u00a0    return appError; \u00a0  } } @MessageExceptionHandler methods support flexible method signatures and support the same method argument types and return values as @MessageMapping methods. Typically, @MessageExceptionHandler methods apply within the @Controller class (or class hierarchy) in which they are declared. If you want such methods to apply more globally (across controllers), you can declare them in a class marked with @ControllerAdvice. This is comparable to the similar support available in Spring MVC. Sending Messages What if you want to send messages to connected clients from any part of the application?Any application component can send messages to the brokerChannel. The easiest way to do so is to inject a SimpMessagingTemplate and use it to send messages. Typically, you would inject it by type, as the following example shows: @Controller public class GreetingController { \u00a0  private SimpMessagingTemplate template; \u00a0  @Autowired \u00a0  public GreetingController(SimpMessagingTemplate template) { \u00a0    this.template = template; \u00a0  } \u00a0  @RequestMapping(path=\"/greetings\", method=POST) \u00a0  public void greet(String greeting) { \u00a0    String text = \"[\" + getTimestamp() + \"]:\" + greeting; \u00a0    this.template.convertAndSend(\"/topic/greetings\", text); \u00a0  } } However, you can also qualify it by its name (brokerMessagingTemplate), if another bean of the same type exists.1075", "chunk_char_count": 1542, "chunk_word_count": 239, "chunk_token_count": 385.5}, {"page_number": 1076, "sentence_chunk": "Simple Broker The built-in simple message broker handles subscription requests from clients, stores them in memory, and broadcasts messages to connected clients that have matching destinations. The broker supports path-like destinations, including subscriptions to Ant-style destination patterns.\uf05a Applications can also use dot-separated (rather than slash-separated) destinations. See Dots as Separators. If configured with a task scheduler, the simple broker supports STOMP heartbeats. To configure a scheduler, you can declare your own TaskScheduler bean and set it through the MessageBrokerRegistry. Alternatively, you can use the one that is automatically declared in the built- in WebSocket configuration, however, you\u2019ll' need @Lazy to avoid a cycle between the built-in WebSocket configuration and your WebSocketMessageBrokerConfigurer. For example: @Configuration @EnableWebSocketMessageBroker public class WebSocketConfig implements WebSocketMessageBrokerConfigurer { \u00a0  private TaskScheduler messageBrokerTaskScheduler; \u00a0  @Autowired \u00a0  public void setMessageBrokerTaskScheduler(@Lazy TaskScheduler taskScheduler) { \u00a0    this.messageBrokerTaskScheduler = taskScheduler; \u00a0  } \u00a0  @Override \u00a0  public void configureMessageBroker(MessageBrokerRegistry registry) { \u00a0    registry.enableSimpleBroker(\"/queue/\", \"/topic/\") \u00a0        .setHeartbeatValue(new long[] {10000, 20000}) \u00a0        .setTaskScheduler(this.messageBrokerTaskScheduler); \u00a0    // ... \u00a0  } } External Broker The simple broker is great for getting started but supports only a subset of STOMP commands (it does not support acks, receipts, and some other features), relies on a simple message-sending loop, and is not suitable for clustering. As an alternative, you can upgrade your applications to use a full- featured message broker. See the STOMP documentation for your message broker of choice (such as RabbitMQ, ActiveMQ, and others), install the broker, and run it with STOMP support enabled.", "chunk_char_count": 1964, "chunk_word_count": 275, "chunk_token_count": 491.0}, {"page_number": 1076, "sentence_chunk": "Then you can enable the STOMP broker relay (instead of the simple broker) in the Spring configuration. The following example configuration enables a full-featured broker: 1076", "chunk_char_count": 175, "chunk_word_count": 26, "chunk_token_count": 43.75}, {"page_number": 1077, "sentence_chunk": "@Configuration @EnableWebSocketMessageBroker public class WebSocketConfig implements WebSocketMessageBrokerConfigurer { \u00a0  @Override \u00a0  public void registerStompEndpoints(StompEndpointRegistry registry) { \u00a0    registry.addEndpoint(\"/portfolio\").withSockJS(); \u00a0  } \u00a0  @Override \u00a0  public void configureMessageBroker(MessageBrokerRegistry registry) { \u00a0    registry.enableStompBrokerRelay(\"/topic\", \"/queue\"); \u00a0    registry.setApplicationDestinationPrefixes(\"/app\"); \u00a0  } } The following example shows the XML configuration equivalent of the preceding example: <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:websocket=\"http://www.springframework.org/schema/websocket\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/websocket \u00a0    https://www.springframework.org/schema/websocket/spring-websocket.xsd\"> \u00a0  <websocket:message-broker application-destination-prefix=\"/app\"> \u00a0    <websocket:stomp-endpoint path=\"/portfolio\" /> \u00a0      <websocket:sockjs/> \u00a0    </websocket:stomp-endpoint> \u00a0    <websocket:stomp-broker-relay prefix=\"/topic,/queue\" /> \u00a0  </websocket:message-broker> </beans> The STOMP broker relay in the preceding configuration is a Spring MessageHandler that handles messages by forwarding them to an external message broker. To do so, it establishes TCP connections to the broker, forwards all messages to it, and then forwards all messages received from the broker to clients through their WebSocket sessions. Essentially, it acts as a \u201crelay\u201d that forwards messages in both directions.\uf05a Add io.projectreactor.netty:reactor-netty and io.netty:netty-all dependencies to your project for TCP connection management. Furthermore, application components (such as HTTP request handling methods, business services, and others) can also send messages to the broker relay, as described in Sending Messages, to 1077", "chunk_char_count": 2028, "chunk_word_count": 233, "chunk_token_count": 507.0}, {"page_number": 1078, "sentence_chunk": "broadcast messages to subscribed WebSocket clients. In effect, the broker relay enables robust and scalable message broadcasting. Connecting to a Broker A STOMP broker relay maintains a single \u201csystem\u201d TCP connection to the broker. This connection is used for messages originating from the server-side application only, not for receiving messages. You can configure the STOMP credentials (that is, the STOMP frame login and passcode headers) for this connection. This is exposed in both the XML namespace and Java configuration as the systemLogin and systemPasscode properties with default values of guest and guest. The STOMP broker relay also creates a separate TCP connection for every connected WebSocket client. You can configure the STOMP credentials that are used for all TCP connections created on behalf of clients. This is exposed in both the XML namespace and Java configuration as the clientLogin and clientPasscode properties with default values of guest and guest.\uf05a The STOMP broker relay always sets the login and passcode headers on every CONNECT frame that it forwards to the broker on behalf of clients.", "chunk_char_count": 1121, "chunk_word_count": 174, "chunk_token_count": 280.25}, {"page_number": 1078, "sentence_chunk": "Therefore, WebSocket clients need not set those headers. They are ignored. As the Authentication section explains, WebSocket clients should instead rely on HTTP authentication to protect the WebSocket endpoint and establish the client identity. The STOMP broker relay also sends and receives heartbeats to and from the message broker over the \u201csystem\u201d TCP connection. You can configure the intervals for sending and receiving heartbeats (10 seconds each by default). If connectivity to the broker is lost, the broker relay continues to try to reconnect, every 5 seconds, until it succeeds. Any Spring bean can implement ApplicationListener<BrokerAvailabilityEvent> to receive notifications when the \u201csystem\u201d connection to the broker is lost and re-established. For example, a Stock Quote service that broadcasts stock quotes can stop trying to send messages when there is no active \u201csystem\u201d connection. By default, the STOMP broker relay always connects, and reconnects as needed if connectivity is lost, to the same host and port. If you wish to supply multiple addresses, on each attempt to connect, you can configure a supplier of addresses, instead of a fixed host and port.", "chunk_char_count": 1178, "chunk_word_count": 181, "chunk_token_count": 294.5}, {"page_number": 1079, "sentence_chunk": "@Configuration @EnableWebSocketMessageBroker public class WebSocketConfig extends AbstractWebSocketMessageBrokerConfigurer { \u00a0  // ... \u00a0  @Override \u00a0  public void configureMessageBroker(MessageBrokerRegistry registry) { \u00a0    registry.enableStompBrokerRelay(\"/queue/\", \"/topic/\").setTcpClient(createTcpClient()); \u00a0    registry.setApplicationDestinationPrefixes(\"/app\"); \u00a0  } \u00a0  private ReactorNettyTcpClient<byte[]> createTcpClient() { \u00a0    return new ReactorNettyTcpClient<>( \u00a0        client -> client.addressSupplier(() -> ... ), \u00a0        new StompReactorNettyCodec()); \u00a0  } } You can also configure the STOMP broker relay with a virtualHost property. The value of this property is set as the host header of every CONNECT frame and can be useful (for example, in a cloud environment where the actual host to which the TCP connection is established differs from the host that provides the cloud-based STOMP service). Dots as Separators When messages are routed to @MessageMapping methods, they are matched with AntPathMatcher. By default, patterns are expected to use slash (/) as the separator. This is a good convention in web applications and similar to HTTP URLs. However, if you are more used to messaging conventions, you can switch to using dot (.)as the separator. The following example shows how to do so in Java configuration: @Configuration @EnableWebSocketMessageBroker public class WebSocketConfig implements WebSocketMessageBrokerConfigurer { \u00a0  // ... \u00a0  @Override \u00a0  public void configureMessageBroker(MessageBrokerRegistry registry) { \u00a0    registry.setPathMatcher(new AntPathMatcher(\".\"));\u00a0    registry.enableStompBrokerRelay(\"/queue\", \"/topic\"); \u00a0    registry.setApplicationDestinationPrefixes(\"/app\"); \u00a0  } } 1079", "chunk_char_count": 1732, "chunk_word_count": 247, "chunk_token_count": 433.0}, {"page_number": 1080, "sentence_chunk": "The following example shows the XML configuration equivalent of the preceding example: <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0    xmlns:websocket=\"http://www.springframework.org/schema/websocket\" \u00a0    xsi:schemaLocation=\" \u00a0        http://www.springframework.org/schema/beans \u00a0        https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0        http://www.springframework.org/schema/websocket \u00a0        https://www.springframework.org/schema/websocket/spring- websocket.xsd\"> \u00a0  <websocket:message-broker application-destination-prefix=\"/app\" path- matcher=\"pathMatcher\"> \u00a0    <websocket:stomp-endpoint path=\"/stomp\"/> \u00a0    <websocket:stomp-broker-relay prefix=\"/topic,/queue\" /> \u00a0  </websocket:message-broker> \u00a0  <bean id=\"pathMatcher\" class=\"org.springframework.util. AntPathMatcher\"> \u00a0    <constructor-arg index=\"0\" value=\".\"/> \u00a0  </bean> </beans> After that, a controller can use a dot (.)as the separator in @MessageMapping methods, as the following example shows: @Controller @MessageMapping(\"red\") public class RedController { \u00a0  @MessageMapping(\"blue.{green}\") \u00a0  public void handleGreen(@DestinationVariable String green) { \u00a0    // ... \u00a0  } } The client can now send a message to /app/red.blue.green123. In the preceding example, we did not change the prefixes on the \u201cbroker relay\u201d, because those depend entirely on the external message broker. See the STOMP documentation pages for the broker you use to see what conventions it supports for the destination header. The \u201csimple broker\u201d, on the other hand, does rely on the configured PathMatcher, so, if you switch the separator, that change also applies to the broker and the way the broker matches destinations from a message to patterns in subscriptions.1080", "chunk_char_count": 1810, "chunk_word_count": 243, "chunk_token_count": 452.5}, {"page_number": 1081, "sentence_chunk": "Authentication Every STOMP over WebSocket messaging session begins with an HTTP request. That can be a request to upgrade to WebSockets (that is, a WebSocket handshake) or, in the case of SockJS fallbacks, a series of SockJS HTTP transport requests. Many web applications already have authentication and authorization in place to secure HTTP requests. Typically, a user is authenticated through Spring Security by using some mechanism such as a login page, HTTP basic authentication, or another way. The security context for the authenticated user is saved in the HTTP session and is associated with subsequent requests in the same cookie-based session. Therefore, for a WebSocket handshake or for SockJS HTTP transport requests, typically, there is already an authenticated user accessible through HttpServletRequest#getUserPrincipal(). Spring automatically associates that user with a WebSocket or SockJS session created for them and, subsequently, with all STOMP messages transported over that session through a user header. In short, a typical web application needs to do nothing beyond what it already does for security. The user is authenticated at the HTTP request level with a security context that is maintained through a cookie-based HTTP session (which is then associated with WebSocket or SockJS sessions created for that user) and results in a user header being stamped on every Message flowing through the application. The STOMP protocol does have login and passcode headers on the CONNECT frame.", "chunk_char_count": 1510, "chunk_word_count": 229, "chunk_token_count": 377.5}, {"page_number": 1081, "sentence_chunk": "Those were originally designed for and are needed for STOMP over TCP. However, for STOMP over WebSocket, by default, Spring ignores authentication headers at the STOMP protocol level, and assumes that the user is already authenticated at the HTTP transport level. The expectation is that the WebSocket or SockJS session contain the authenticated user. Token Authentication Spring Security OAuth provides support for token based security, including JSON Web Token (JWT). You can use this as the authentication mechanism in Web applications, including STOMP over WebSocket interactions, as described in the previous section (that is, to maintain identity through a cookie-based session). At the same time, cookie-based sessions are not always the best fit (for example, in applications that do not maintain a server-side session or in mobile applications where it is common to use headers for authentication). The WebSocket protocol, RFC 6455 \"doesn\u2019t prescribe any particular way that servers can authenticate clients during the WebSocket handshake.\"In practice, however, browser clients can use only standard authentication headers (that is, basic HTTP authentication) or cookies and cannot (for example) provide custom headers. Likewise, the SockJS JavaScript client does not provide a way to send HTTP headers with SockJS transport requests. See sockjs-client issue 196.", "chunk_char_count": 1372, "chunk_word_count": 202, "chunk_token_count": 343.0}, {"page_number": 1081, "sentence_chunk": "Instead, it does allow sending query parameters that you can use to send a token, but that has its own drawbacks (for example, the token may be inadvertently logged with the URL in server logs).1081", "chunk_char_count": 198, "chunk_word_count": 35, "chunk_token_count": 49.5}, {"page_number": 1082, "sentence_chunk": "\uf05a The preceding limitations are for browser-based clients and do not apply to the Spring Java-based STOMP client, which does support sending headers with both WebSocket and SockJS requests. Therefore, applications that wish to avoid the use of cookies may not have any good alternatives for authentication at the HTTP protocol level. Instead of using cookies, they may prefer to authenticate with headers at the STOMP messaging protocol level. Doing so requires two simple steps: 1. Use the STOMP client to pass authentication headers at connect time.2. Process the authentication headers with a ChannelInterceptor. The next example uses server-side configuration to register a custom authentication interceptor. Note that an interceptor needs only to authenticate and set the user header on the CONNECT Message. Spring notes and saves the authenticated user and associate it with subsequent STOMP messages on the same session.", "chunk_char_count": 927, "chunk_word_count": 141, "chunk_token_count": 231.75}, {"page_number": 1082, "sentence_chunk": "The following example shows how register a custom authentication interceptor: @Configuration @EnableWebSocketMessageBroker public class MyConfig implements WebSocketMessageBrokerConfigurer { \u00a0  @Override \u00a0  public void configureClientInboundChannel(ChannelRegistration registration) { \u00a0    registration.interceptors(new ChannelInterceptor() { \u00a0      @Override \u00a0      public Message<?> preSend(Message<?> message, MessageChannel channel) { \u00a0        StompHeaderAccessor accessor = \u00a0            MessageHeaderAccessor.getAccessor(message, StompHeaderAccessor.class); \u00a0        if (StompCommand. CONNECT.equals(accessor.getCommand())) { \u00a0          Authentication user = ... ; // access authentication header(s) \u00a0          accessor.setUser(user); \u00a0        } \u00a0        return message; \u00a0      } \u00a0    }); \u00a0  } } Also, note that, when you use Spring Security\u2019s authorization for messages, at present, you need to ensure that the authentication ChannelInterceptor config is ordered ahead of Spring Security\u2019s. This is best done by declaring the custom interceptor in its own implementation of WebSocketMessageBrokerConfigurer that is marked with @Order(Ordered. HIGHEST_PRECEDENCE + 99). Authorization Spring Security provides WebSocket sub-protocol authorization that uses a ChannelInterceptor to authorize messages based on the user header in them. Also, Spring Session provides WebSocket 1082", "chunk_char_count": 1382, "chunk_word_count": 235, "chunk_token_count": 345.5}, {"page_number": 1083, "sentence_chunk": "integration that ensures the user\u2019s HTTP session does not expire while the WebSocket session is still active. User Destinations An application can send messages that target a specific user, and Spring\u2019s STOMP support recognizes destinations prefixed with /user/ for this purpose. For example, a client might subscribe to the /user/queue/position-updates destination. UserDestinationMessageHandler handles this destination and transforms it into a destination unique to the user session (such as /queue/position-updates-user123). This provides the convenience of subscribing to a generically named destination while, at the same time, ensuring no collisions with other users who subscribe to the same destination so that each user can receive unique stock position updates.\uf0eb When working with user destinations, it is important to configure broker and application destination prefixes as shown in Enable STOMP, or otherwise the broker would handle \"/user\" prefixed messages that should only be handled by UserDestinationMessageHandler. On the sending side, messages can be sent to a destination such as /user/{username}/queue/position-updates, which in turn is translated by the UserDestinationMessageHandler into one or more destinations, one for each session associated with the user. This lets any component within the application send messages that target a specific user without necessarily knowing anything more than their name and the generic destination. This is also supported through an annotation and a messaging template. A message-handling method can send messages to the user associated with the message being handled through the @SendToUser annotation (also supported on the class-level to share a common destination), as the following example shows: @Controller public class PortfolioController { \u00a0  @MessageMapping(\"/trade\") \u00a0  @SendToUser(\"/queue/position-updates\") \u00a0  public TradeResult executeTrade(Trade trade, Principal principal) { \u00a0    // ... \u00a0    return tradeResult; \u00a0  } } If the user has more than one session, by default, all of the sessions subscribed to the given destination are targeted.", "chunk_char_count": 2118, "chunk_word_count": 306, "chunk_token_count": 529.5}, {"page_number": 1083, "sentence_chunk": "However, sometimes, it may be necessary to target only the session that sent the message being handled. You can do so by setting the broadcast attribute to false, as the following example shows: 1083", "chunk_char_count": 199, "chunk_word_count": 34, "chunk_token_count": 49.75}, {"page_number": 1084, "sentence_chunk": "@Controller public class MyController { \u00a0  @MessageMapping(\"/action\") \u00a0  public void handleAction() throws Exception{ \u00a0    // raise MyBusinessException here \u00a0  } \u00a0  @MessageExceptionHandler \u00a0  @SendToUser(destinations=\"/queue/errors\", broadcast=false) \u00a0  public ApplicationError handleException(MyBusinessException exception) { \u00a0    // ... \u00a0    return appError; \u00a0  } } \uf05a While user destinations generally imply an authenticated user, it is not strictly required. A WebSocket session that is not associated with an authenticated user can subscribe to a user destination. In such cases, the @SendToUser annotation behaves exactly the same as with broadcast=false (that is, targeting only the session that sent the message being handled). You can send a message to user destinations from any application component by, for example, injecting the SimpMessagingTemplate created by the Java configuration or the XML namespace. (The bean name is brokerMessagingTemplate if required for qualification with @Qualifier.)The following example shows how to do so: @Service public class TradeServiceImpl implements TradeService { \u00a0  private final SimpMessagingTemplate messagingTemplate; \u00a0  @Autowired \u00a0  public TradeServiceImpl(SimpMessagingTemplate messagingTemplate) { \u00a0    this.messagingTemplate = messagingTemplate; \u00a0  } \u00a0  // ... \u00a0  public void afterTradeExecuted(Trade trade) { \u00a0    this.messagingTemplate.convertAndSendToUser( \u00a0        trade.getUserName(), \"/queue/position-updates\", trade.getResult()); \u00a0  } } 1084", "chunk_char_count": 1509, "chunk_word_count": 221, "chunk_token_count": 377.25}, {"page_number": 1085, "sentence_chunk": "\uf05a When you use user destinations with an external message broker, you should check the broker documentation on how to manage inactive queues, so that, when the user session is over, all unique user queues are removed. For example, RabbitMQ creates auto-delete queues when you use destinations such as /exchange/amq.direct/position-updates. So, in that case, the client could subscribe to /user/exchange/amq.direct/position-updates. Similarly, ActiveMQ has configuration options for purging inactive destinations. In a multi-application server scenario, a user destination may remain unresolved because the user is connected to a different server. In such cases, you can configure a destination to broadcast unresolved messages so that other servers have a chance to try. This can be done through the userDestinationBroadcast property of the MessageBrokerRegistry in Java configuration and the user- destination-broadcast attribute of the message-broker element in XML. Order of Messages Messages from the broker are published to the clientOutboundChannel, from where they are written to WebSocket sessions. As the channel is backed by a ThreadPoolExecutor, messages are processed in different threads, and the resulting sequence received by the client may not match the exact order of publication. If this is an issue, enable the setPreservePublishOrder flag, as the following example shows: @Configuration @EnableWebSocketMessageBroker public class MyConfig implements WebSocketMessageBrokerConfigurer { \u00a0  @Override \u00a0  protected void configureMessageBroker(MessageBrokerRegistry registry) { \u00a0    // ... \u00a0    registry.setPreservePublishOrder(true); \u00a0  } } The following example shows the XML configuration equivalent of the preceding example: 1085", "chunk_char_count": 1748, "chunk_word_count": 245, "chunk_token_count": 437.0}, {"page_number": 1086, "sentence_chunk": "<beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:websocket=\"http://www.springframework.org/schema/websocket\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/websocket \u00a0    https://www.springframework.org/schema/websocket/spring-websocket.xsd\"> \u00a0  <websocket:message-broker preserve-publish-order=\"true\"> \u00a0    <!-- ... --> \u00a0  </websocket:message-broker> </beans> When the flag is set, messages within the same client session are published to the clientOutboundChannel one at a time, so that the order of publication is guaranteed. Note that this incurs a small performance overhead, so you should enable it only if it is required. Events Several ApplicationContext events are published and can be received by implementing Spring\u2019s ApplicationListener interface: \u2022 BrokerAvailabilityEvent: Indicates when the broker becomes available or unavailable. While the \u201csimple\u201d broker becomes available immediately on startup and remains so while the application is running, the STOMP \u201cbroker relay\u201d can lose its connection to the full featured broker (for example, if the broker is restarted). The broker relay has reconnect logic and re- establishes the \u201csystem\u201d connection to the broker when it comes back. As a result, this event is published whenever the state changes from connected to disconnected and vice-versa. Components that use the SimpMessagingTemplate should subscribe to this event and avoid sending messages at times when the broker is not available. In any case, they should be prepared to handle MessageDeliveryException when sending a message. \u2022SessionConnectEvent: Published when a new STOMP CONNECT is received to indicate the start of a new client session.", "chunk_char_count": 1879, "chunk_word_count": 244, "chunk_token_count": 469.75}, {"page_number": 1086, "sentence_chunk": "The event contains the message that represents the connect, including the session ID, user information (if any), and any custom headers the client sent. This is useful for tracking client sessions. Components subscribed to this event can wrap the contained message with SimpMessageHeaderAccessor or StompMessageHeaderAccessor. \u2022SessionConnectedEvent: Published shortly after a SessionConnectEvent when the broker has sent a STOMP CONNECTED frame in response to the CONNECT. At this point, the STOMP session can be considered fully established. \u2022SessionSubscribeEvent: Published when a new STOMP SUBSCRIBE is received. \u2022SessionUnsubscribeEvent: Published when a new STOMP UNSUBSCRIBE is received. \u2022SessionDisconnectEvent: Published when a STOMP session ends. The DISCONNECT may have been sent from the client or it may be automatically generated when the WebSocket session is closed. In some cases, this event is published more than once per session.", "chunk_char_count": 949, "chunk_word_count": 134, "chunk_token_count": 237.25}, {"page_number": 1087, "sentence_chunk": "be idempotent with regard to multiple disconnect events.\uf05a When you use a full-featured broker, the STOMP \u201cbroker relay\u201d automatically reconnects the \u201csystem\u201d connection if broker becomes temporarily unavailable. Client connections, however, are not automatically reconnected. Assuming heartbeats are enabled, the client typically notices the broker is not responding within 10 seconds. Clients need to implement their own reconnecting logic. Interception Events provide notifications for the lifecycle of a STOMP connection but not for every client message. Applications can also register a ChannelInterceptor to intercept any message and in any part of the processing chain. The following example shows how to intercept inbound messages from clients: @Configuration @EnableWebSocketMessageBroker public class WebSocketConfig implements WebSocketMessageBrokerConfigurer { \u00a0  @Override \u00a0  public void configureClientInboundChannel(ChannelRegistration registration) { \u00a0    registration.interceptors(new MyChannelInterceptor()); \u00a0  } } A custom ChannelInterceptor can use StompHeaderAccessor or SimpMessageHeaderAccessor to access information about the message, as the following example shows: public class MyChannelInterceptor implements ChannelInterceptor { \u00a0  @Override \u00a0  public Message<?> preSend(Message<?> message, MessageChannel channel) { \u00a0    StompHeaderAccessor accessor = StompHeaderAccessor.wrap(message); \u00a0    StompCommand command = accessor.getStompCommand(); \u00a0    // ... \u00a0    return message; \u00a0  } } Applications can also implement ExecutorChannelInterceptor, which is a sub-interface of ChannelInterceptor with callbacks in the thread in which the messages are handled.", "chunk_char_count": 1682, "chunk_word_count": 224, "chunk_token_count": 420.5}, {"page_number": 1087, "sentence_chunk": "While a ChannelInterceptor is invoked once for each message sent to a channel, the ExecutorChannelInterceptor provides hooks in the thread of each MessageHandler subscribed to messages from the channel. Note that, as with the SessionDisconnectEvent described earlier, a DISCONNECT message can be from the client or it can also be automatically generated when the WebSocket session is closed. In 1087", "chunk_char_count": 399, "chunk_word_count": 60, "chunk_token_count": 99.75}, {"page_number": 1088, "sentence_chunk": "some cases, an interceptor may intercept this message more than once for each session. Components should be idempotent with regard to multiple disconnect events. STOMP Client Spring provides a STOMP over WebSocket client and a STOMP over TCP client. To begin, you can create and configure WebSocketStompClient, as the following example shows: WebSocketClient webSocketClient = new StandardWebSocketClient(); WebSocketStompClient stompClient = new WebSocketStompClient(webSocketClient); stompClient.setMessageConverter(new StringMessageConverter()); stompClient.setTaskScheduler(taskScheduler); // for heartbeats In the preceding example, you could replace StandardWebSocketClient with SockJsClient, since that is also an implementation of WebSocketClient. The SockJsClient can use WebSocket or HTTP-based transport as a fallback. For more details, see SockJsClient. Next, you can establish a connection and provide a handler for the STOMP session, as the following example shows: String url = \"ws://127.0.0.1:8080/endpoint\"; StompSessionHandler sessionHandler = new MyStompSessionHandler(); stompClient.connect(url, sessionHandler); When the session is ready for use, the handler is notified, as the following example shows: public class MyStompSessionHandler extends StompSessionHandlerAdapter { \u00a0  @Override \u00a0  public void afterConnected(StompSession session, StompHeaders connectedHeaders) { \u00a0    // ... \u00a0  } } Once the session is established, any payload can be sent and is serialized with the configured MessageConverter, as the following example shows: session.send(\"/topic/something\", \"payload\"); You can also subscribe to destinations. The subscribe methods require a handler for messages on the subscription and returns a Subscription handle that you can use to unsubscribe. For each received message, the handler can specify the target Object type to which the payload should be deserialized, as the following example shows: 1088", "chunk_char_count": 1939, "chunk_word_count": 253, "chunk_token_count": 484.75}, {"page_number": 1089, "sentence_chunk": "session.subscribe(\"/topic/something\", new StompFrameHandler() { \u00a0  @Override \u00a0  public Type getPayloadType(StompHeaders headers) { \u00a0    return String.class; \u00a0  } \u00a0  @Override \u00a0  public void handleFrame(StompHeaders headers, Object payload) { \u00a0    // ... \u00a0  } }); To enable STOMP heartbeat, you can configure WebSocketStompClient with a TaskScheduler and optionally customize the heartbeat intervals (10 seconds for write inactivity, which causes a heartbeat to be sent, and 10 seconds for read inactivity, which closes the connection). WebSocketStompClient sends a heartbeat only in case of inactivity, i.e. when no other messages are sent. This can present a challenge when using an external broker since messages with a non-broker destination represent activity but aren\u2019t actually forwarded to the broker. In that case you can configure a TaskScheduler when initializing the External Broker which ensures a heartbeat is forwarded to the broker also when only messages with a non-broker destination are sent.\uf05a When you use WebSocketStompClient for performance tests to simulate thousands of clients from the same machine, consider turning off heartbeats, since each connection schedules its own heartbeat tasks and that is not optimized for a large number of clients running on the same machine. The STOMP protocol also supports receipts, where the client must add a receipt header to which the server responds with a RECEIPT frame after the send or subscribe are processed. To support this, the StompSession offers setAutoReceipt(boolean) that causes a receipt header to be added on every subsequent send or subscribe event. Alternatively, you can also manually add a receipt header to the StompHeaders. Both send and subscribe return an instance of Receiptable that you can use to register for receipt success and failure callbacks. For this feature, you must configure the client with a TaskScheduler and the amount of time before a receipt expires (15 seconds by default).", "chunk_char_count": 1978, "chunk_word_count": 310, "chunk_token_count": 494.5}, {"page_number": 1089, "sentence_chunk": "Note that StompSessionHandler itself is a StompFrameHandler, which lets it handle ERROR frames in addition to the handleException callback for exceptions from the handling of messages and handleTransportError for transport-level errors including ConnectionLostException. WebSocket Scope Each WebSocket session has a map of attributes. The map is attached as a header to inbound client messages and may be accessed from a controller method, as the following example shows: 1089", "chunk_char_count": 476, "chunk_word_count": 68, "chunk_token_count": 119.0}, {"page_number": 1090, "sentence_chunk": "@Controller public class MyController { \u00a0  @MessageMapping(\"/action\") \u00a0  public void handle(SimpMessageHeaderAccessor headerAccessor) { \u00a0    Map<String, Object> attrs = headerAccessor.getSessionAttributes(); \u00a0    // ... \u00a0  } } You can declare a Spring-managed bean in the websocket scope. You can inject WebSocket-scoped beans into controllers and any channel interceptors registered on the clientInboundChannel. Those are typically singletons and live longer than any individual WebSocket session. Therefore, you need to use a scope proxy mode for WebSocket-scoped beans, as the following example shows: @Component @Scope(scopeName = \"websocket\", proxyMode = ScopedProxyMode. TARGET_CLASS) public class MyBean { \u00a0  @PostConstruct \u00a0  public void init() { \u00a0    // Invoked after dependencies injected \u00a0  } \u00a0  // ... \u00a0  @PreDestroy \u00a0  public void destroy() { \u00a0    // Invoked when the WebSocket session ends \u00a0  } } @Controller public class MyController { \u00a0  private final MyBean myBean; \u00a0  @Autowired \u00a0  public MyController(MyBean myBean) { \u00a0    this.myBean = myBean; \u00a0  } \u00a0  @MessageMapping(\"/action\") \u00a0  public void handle() { \u00a0    // this.myBean from the current WebSocket session \u00a0  } } 1090", "chunk_char_count": 1191, "chunk_word_count": 204, "chunk_token_count": 297.75}, {"page_number": 1091, "sentence_chunk": "As with any custom scope, Spring initializes a new MyBean instance the first time it is accessed from the controller and stores the instance in the WebSocket session attributes. The same instance is subsequently returned until the session ends. WebSocket-scoped beans have all Spring lifecycle methods invoked, as shown in the preceding examples. Performance There is no silver bullet when it comes to performance. Many factors affect it, including the size and volume of messages, whether application methods perform work that requires blocking, and external factors (such as network speed and other issues). The goal of this section is to provide an overview of the available configuration options along with some thoughts on how to reason about scaling. In a messaging application, messages are passed through channels for asynchronous executions that are backed by thread pools. Configuring such an application requires good knowledge of the channels and the flow of messages. Therefore, it is recommended to review Flow of Messages. The obvious place to start is to configure the thread pools that back the clientInboundChannel and the clientOutboundChannel.", "chunk_char_count": 1163, "chunk_word_count": 178, "chunk_token_count": 290.75}, {"page_number": 1091, "sentence_chunk": "By default, both are configured at twice the number of available processors. If the handling of messages in annotated methods is mainly CPU-bound, the number of threads for the clientInboundChannel should remain close to the number of processors. If the work they do is more IO-bound and requires blocking or waiting on a database or other external system, the thread pool size probably needs to be increased.\uf05a ThreadPoolExecutor has three important properties: the core thread pool size, the max thread pool size, and the capacity for the queue to store tasks for which there are no available threads. A common point of confusion is that configuring the core pool size (for example, 10) and max pool size (for example, 20) results in a thread pool with 10 to 20 threads. In fact, if the capacity is left at its default value of Integer. MAX_VALUE, the thread pool never increases beyond the core pool size, since all additional tasks are queued. See the javadoc of ThreadPoolExecutor to learn how these properties work and understand the various queuing strategies. On the clientOutboundChannel side, it is all about sending messages to WebSocket clients. If clients are on a fast network, the number of threads should remain close to the number of available processors.", "chunk_char_count": 1271, "chunk_word_count": 210, "chunk_token_count": 317.75}, {"page_number": 1091, "sentence_chunk": "If they are slow or on low bandwidth, they take longer to consume messages and put a burden on the thread pool. Therefore, increasing the thread pool size becomes necessary. While the workload for the clientInboundChannel is possible to predict\u2009\u2014\u2009after all, it is based on what the application does\u2009\u2014\u2009how to configure the \"clientOutboundChannel\" is harder, as it is based on factors beyond the control of the application. For this reason, two additional properties relate to the sending of messages: sendTimeLimit and sendBufferSizeLimit. You can use those methods to configure how long a send is allowed to take and how much data can be buffered when sending 1091", "chunk_char_count": 664, "chunk_word_count": 107, "chunk_token_count": 166.0}, {"page_number": 1092, "sentence_chunk": "messages to a client. The general idea is that, at any given time, only a single thread can be used to send to a client. All additional messages, meanwhile, get buffered, and you can use these properties to decide how long sending a message is allowed to take and how much data can be buffered in the meantime. See the javadoc and documentation of the XML schema for important additional details. The following example shows a possible configuration: @Configuration @EnableWebSocketMessageBroker public class WebSocketConfig implements WebSocketMessageBrokerConfigurer { \u00a0  @Override \u00a0  public void configureWebSocketTransport(WebSocketTransportRegistration registration) { \u00a0    registration.setSendTimeLimit(15 * 1000).setSendBufferSizeLimit(512 * 1024); \u00a0  } \u00a0  // ... } The following example shows the XML configuration equivalent of the preceding example: <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:websocket=\"http://www.springframework.org/schema/websocket\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/websocket \u00a0    https://www.springframework.org/schema/websocket/spring-websocket.xsd\"> \u00a0  <websocket:message-broker> \u00a0    <websocket:transport send-timeout=\"15000\" send-buffer-size=\"524288\" /> \u00a0    <!-- ... --> \u00a0  </websocket:message-broker> </beans> You can also use the WebSocket transport configuration shown earlier to configure the maximum allowed size for incoming STOMP messages. In theory, a WebSocket message can be almost unlimited in size. In practice, WebSocket servers impose limits\u2009\u2014\u2009for example, 8K on Tomcat and 64K on Jetty. For this reason, STOMP clients (such as the JavaScript webstomp-client and others) split larger STOMP messages at 16K boundaries and send them as multiple WebSocket messages, which requires the server to buffer and re-assemble.1092", "chunk_char_count": 2001, "chunk_word_count": 257, "chunk_token_count": 500.25}, {"page_number": 1093, "sentence_chunk": "Spring\u2019s STOMP-over-WebSocket support does this ,so applications can configure the maximum size for STOMP messages irrespective of WebSocket server-specific message sizes. Keep in mind that the WebSocket message size is automatically adjusted, if necessary, to ensure they can carry 16K WebSocket messages at a minimum. The following example shows one possible configuration: @Configuration @EnableWebSocketMessageBroker public class WebSocketConfig implements WebSocketMessageBrokerConfigurer { \u00a0  @Override \u00a0  public void configureWebSocketTransport(WebSocketTransportRegistration registration) { \u00a0    registration.setMessageSizeLimit(128 * 1024); \u00a0  } \u00a0  // ... } The following example shows the XML configuration equivalent of the preceding example: <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:websocket=\"http://www.springframework.org/schema/websocket\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans \u00a0    https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/websocket \u00a0    https://www.springframework.org/schema/websocket/spring-websocket.xsd\"> \u00a0  <websocket:message-broker> \u00a0    <websocket:transport message-size=\"131072\" /> \u00a0    <!-- ... --> \u00a0  </websocket:message-broker> </beans> An important point about scaling involves using multiple application instances. Currently, you cannot do that with the simple broker. However, when you use a full-featured broker (such as RabbitMQ), each application instance connects to the broker, and messages broadcast from one application instance can be broadcast through the broker to WebSocket clients connected through any other application instances. Monitoring When you use @EnableWebSocketMessageBroker or <websocket:message-broker>, key infrastructure 1093", "chunk_char_count": 1866, "chunk_word_count": 217, "chunk_token_count": 466.5}, {"page_number": 1094, "sentence_chunk": "components automatically gather statistics and counters that provide important insight into the internal state of the application. The configuration also declares a bean of type WebSocketMessageBrokerStats that gathers all available information in one place and by default logs it at the INFO level once every 30 minutes. This bean can be exported to JMX through Spring\u2019s MBeanExporter for viewing at runtime (for example, through JDK\u2019s jconsole). The following list summarizes the available information: Client WebSocket Sessions Current Indicates how many client sessions there are currently, with the count further broken down by WebSocket versus HTTP streaming and polling SockJS sessions. Total Indicates how many total sessions have been established. Abnormally Closed Connect Failures Sessions that got established but were closed after not having received any messages within 60 seconds. This is usually an indication of proxy or network issues. Send Limit Exceeded Sessions closed after exceeding the configured send timeout or the send buffer limits, which can occur with slow clients (see previous section). Transport Errors Sessions closed after a transport error, such as failure to read or write to a WebSocket connection or HTTP request or response. STOMP Frames The total number of CONNECT, CONNECTED, and DISCONNECT frames processed, indicating how many clients connected on the STOMP level.", "chunk_char_count": 1408, "chunk_word_count": 209, "chunk_token_count": 352.0}, {"page_number": 1094, "sentence_chunk": "Note that the DISCONNECT count may be lower when sessions get closed abnormally or when clients close without sending a DISCONNECT frame. STOMP Broker Relay TCP Connections Indicates how many TCP connections on behalf of client WebSocket sessions are established to the broker. This should be equal to the number of client WebSocket sessions + 1 additional shared \u201csystem\u201d connection for sending messages from within the application. STOMP Frames The total number of CONNECT, CONNECTED, and DISCONNECT frames forwarded to or received from the broker on behalf of clients. Note that a DISCONNECT frame is sent to the broker regardless of how the client WebSocket session was closed. Therefore, a lower DISCONNECT frame count is an indication that the broker is pro-actively closing connections (maybe because of a heartbeat that did not arrive in time, an invalid input frame, or other issue).1094", "chunk_char_count": 896, "chunk_word_count": 142, "chunk_token_count": 224.0}, {"page_number": 1095, "sentence_chunk": "Client Inbound Channel Statistics from the thread pool that backs the clientInboundChannel that provide insight into the health of incoming message processing. Tasks queueing up here is an indication that the application may be too slow to handle messages. If there I/O bound tasks (for example, slow database queries, HTTP requests to third party REST API, and so on), consider increasing the thread pool size. Client Outbound Channel Statistics from the thread pool that backs the clientOutboundChannel that provides insight into the health of broadcasting messages to clients. Tasks queueing up here is an indication clients are too slow to consume messages. One way to address this is to increase the thread pool size to accommodate the expected number of concurrent slow clients. Another option is to reduce the send timeout and send buffer size limits (see the previous section). SockJS Task Scheduler Statistics from the thread pool of the SockJS task scheduler that is used to send heartbeats. Note that, when heartbeats are negotiated on the STOMP level, the SockJS heartbeats are disabled. Testing There are two main approaches to testing applications when you use Spring\u2019s STOMP-over- WebSocket support.", "chunk_char_count": 1214, "chunk_word_count": 190, "chunk_token_count": 303.5}, {"page_number": 1095, "sentence_chunk": "The first is to write server-side tests to verify the functionality of controllers and their annotated message-handling methods. The second is to write full end-to-end tests that involve running a client and a server. The two approaches are not mutually exclusive. On the contrary, each has a place in an overall test strategy. Server-side tests are more focused and easier to write and maintain. End-to-end integration tests, on the other hand, are more complete and test much more, but they are also more involved to write and maintain. The simplest form of server-side tests is to write controller unit tests. However, this is not useful enough, since much of what a controller does depends on its annotations. Pure unit tests simply cannot test that. Ideally, controllers under test should be invoked as they are at runtime, much like the approach to testing controllers that handle HTTP requests by using the Spring MVC Test framework\u2009\u2014\u2009that is, without running a Servlet container but relying on the Spring Framework to invoke the annotated controllers.", "chunk_char_count": 1059, "chunk_word_count": 171, "chunk_token_count": 264.75}, {"page_number": 1095, "sentence_chunk": "As with Spring MVC Test, you have two possible alternatives here, either use a \u201ccontext- based\u201d or use a \u201cstandalone\u201d setup: \u2022 Load the actual Spring configuration with the help of the Spring TestContext framework, inject clientInboundChannel as a test field, and use it to send messages to be handled by controller methods. \u2022Manually set up the minimum Spring framework infrastructure required to invoke controllers (namely the SimpAnnotationMethodMessageHandler) and pass messages for controllers directly to it. Both of these setup scenarios are demonstrated in the tests for the stock portfolio sample application.1095", "chunk_char_count": 622, "chunk_word_count": 92, "chunk_token_count": 155.5}, {"page_number": 1096, "sentence_chunk": "The second approach is to create end-to-end integration tests. For that, you need to run a WebSocket server in embedded mode and connect to it as a WebSocket client that sends WebSocket messages containing STOMP frames. The tests for the stock portfolio sample application also demonstrate this approach by using Tomcat as the embedded WebSocket server and a simple STOMP client for test purposes.5.5. Other Web Frameworks This chapter details Spring\u2019s integration with third-party web frameworks. One of the core value propositions of the Spring Framework is that of enabling choice. In a general sense, Spring does not force you to use or buy into any particular architecture, technology, or methodology (although it certainly recommends some over others). This freedom to pick and choose the architecture, technology, or methodology that is most relevant to a developer and their development team is arguably most evident in the web area, where Spring provides its own web frameworks (Spring MVC and Spring WebFlux) while, at the same time, supporting integration with a number of popular third-party web frameworks.5.5.1. Common Configuration Before diving into the integration specifics of each supported web framework, let us first take a look at common Spring configuration that is not specific to any one web framework. (", "chunk_char_count": 1329, "chunk_word_count": 208, "chunk_token_count": 332.25}, {"page_number": 1096, "sentence_chunk": "This section is equally applicable to Spring\u2019s own web framework variants.)One of the concepts (for want of a better word) espoused by Spring\u2019s lightweight application model is that of a layered architecture. Remember that in a \u201cclassic\u201d layered architecture, the web layer is but one of many layers. It serves as one of the entry points into a server-side application, and it delegates to service objects (facades) that are defined in a service layer to satisfy business-specific (and presentation-technology agnostic) use cases. In Spring, these service objects, any other business-specific objects, data-access objects, and others exist in a distinct \u201cbusiness context\u201d, which contains no web or presentation layer objects (presentation objects, such as Spring MVC controllers, are typically configured in a distinct \u201cpresentation context\u201d). This section details how you can configure a Spring container (a WebApplicationContext) that contains all of the 'business beans' in your application. Moving on to specifics, all you need to do is declare a ContextLoaderListener in the standard Jakarta EE servlet web.xml file of your web application and add a contextConfigLocation<context-param/> section (in the same file) that defines which set of Spring XML configuration files to load. Consider the following <listener/> configuration: <listener> \u00a0  <listener-class>org.springframework.web.context. ContextLoaderListener</listener- class> </listener> Further consider the following <context-param/> configuration: 1096", "chunk_char_count": 1519, "chunk_word_count": 210, "chunk_token_count": 379.75}, {"page_number": 1097, "sentence_chunk": "<context-param> \u00a0  <param-name>contextConfigLocation</param-name> \u00a0  <param-value>/WEB-INF/applicationContext*.xml</param-value> </context-param> If you do not specify the contextConfigLocation context parameter, the ContextLoaderListener looks for a file called /WEB-INF/applicationContext.xml to load. Once the context files are loaded, Spring creates a WebApplicationContext object based on the bean definitions and stores it in the ServletContext of the web application. All Java web frameworks are built on top of the Servlet API, so you can use the following code snippet to get access to this \u201cbusiness context\u201d ApplicationContext created by the ContextLoaderListener. The following example shows how to get the WebApplicationContext: WebApplicationContext ctx = WebApplicationContextUtils.getWebApplicationContext(servletContext); The WebApplicationContextUtils class is for convenience, so you need not remember the name of the ServletContext attribute. Its getWebApplicationContext() method returns null if an object does not exist under the WebApplicationContext. ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE key. Rather than risk getting NullPointerExceptions in your application, it is better to use the getRequiredWebApplicationContext() method. This method throws an exception when the ApplicationContext is missing. Once you have a reference to the WebApplicationContext, you can retrieve beans by their name or type. Most developers retrieve beans by name and then cast them to one of their implemented interfaces.", "chunk_char_count": 1525, "chunk_word_count": 190, "chunk_token_count": 381.25}, {"page_number": 1097, "sentence_chunk": "Fortunately, most of the frameworks in this section have simpler ways of looking up beans. Not only do they make it easy to get beans from a Spring container, but they also let you use dependency injection on their controllers. Each web framework section has more detail on its specific integration strategies.5.5.2. JSF JavaServer Faces (JSF) is the JCP\u2019s standard component-based, event-driven web user interface framework. It is an official part of the Jakarta EE umbrella but also individually usable, e.g. through embedding Mojarra or MyFaces within Tomcat. Please note that recent versions of JSF became closely tied to CDI infrastructure in application servers, with some new JSF functionality only working in such an environment. Spring\u2019s JSF support is not actively evolved anymore and primarily exists for migration purposes when modernizing older JSF-based applications. The key element in Spring\u2019s JSF integration is the JSF ELResolver mechanism.1097", "chunk_char_count": 962, "chunk_word_count": 146, "chunk_token_count": 240.5}, {"page_number": 1098, "sentence_chunk": "Spring Bean Resolver SpringBeanFacesELResolver is a JSF compliant ELResolver implementation, integrating with the standard Unified EL as used by JSF and JSP. It delegates to Spring\u2019s \u201cbusiness context\u201d WebApplicationContext first and then to the default resolver of the underlying JSF implementation. Configuration-wise, you can define SpringBeanFacesELResolver in your JSF faces-context.xml file, as the following example shows: <faces-config> \u00a0  <application> \u00a0    <el-resolver>org.springframework.web.jsf.el. SpringBeanFacesELResolver</el- resolver> \u00a0    ... \u00a0  </application> </faces-config> Using FacesContextUtils A custom ELResolver works well when mapping your properties to beans in faces-config.xml, but, at times, you may need to explicitly grab a bean. The FacesContextUtils class makes this easy. It is similar to WebApplicationContextUtils, except that it takes a FacesContext parameter rather than a ServletContext parameter. The following example shows how to use FacesContextUtils: ApplicationContext ctx = FacesContextUtils.getWebApplicationContext(FacesContext.getCurrentInstance()); 5.5.3. Apache Struts 2.x Invented by Craig McClanahan, Struts is an open-source project hosted by the Apache Software Foundation. At the time, it greatly simplified the JSP/Servlet programming paradigm and won over many developers who were using proprietary frameworks. It simplified the programming model, it was open source (and thus free as in beer), and it had a large community, which let the project grow and become popular among Java web developers.", "chunk_char_count": 1559, "chunk_word_count": 209, "chunk_token_count": 389.75}, {"page_number": 1098, "sentence_chunk": "As a successor to the original Struts 1.x, check out Struts 2.x and the Struts-provided Spring Plugin for the built-in Spring integration.5.5.4. Apache Tapestry 5.x Tapestry is a \"\"Component oriented framework for creating dynamic, robust, highly scalable web applications in Java.\"\"While Spring has its own powerful web layer, there are a number of unique advantages to building an enterprise Java application by using a combination of Tapestry for the web user interface and the Spring container for the lower layers.1098", "chunk_char_count": 523, "chunk_word_count": 80, "chunk_token_count": 130.75}, {"page_number": 1099, "sentence_chunk": "For more information, see Tapestry\u2019s dedicated integration module for Spring.5.5.5. Further Resources The following links go to further resources about the various web frameworks described in this chapter. \u2022The JSF homepage \u2022 The Struts homepage \u2022 The Tapestry homepage 1099", "chunk_char_count": 274, "chunk_word_count": 40, "chunk_token_count": 68.5}, {"page_number": 1100, "sentence_chunk": "Chapter 6. Web on Reactive Stack This part of the documentation covers support for reactive-stack web applications built on a Reactive Streams API to run on non-blocking servers, such as Netty, Undertow, and Servlet containers. Individual chapters cover the Spring WebFlux framework, the reactive WebClient, support for testing, and reactive libraries. For Servlet-stack web applications, see Web on Servlet Stack.6.1. Spring WebFlux The original web framework included in the Spring Framework, Spring Web MVC, was purpose- built for the Servlet API and Servlet containers. The reactive-stack web framework, Spring WebFlux, was added later in version 5.0. It is fully non-blocking, supports Reactive Streams back pressure, and runs on such servers as Netty, Undertow, and Servlet containers. Both web frameworks mirror the names of their source modules (spring-webmvc and spring- webflux) and co-exist side by side in the Spring Framework. Each module is optional.", "chunk_char_count": 964, "chunk_word_count": 143, "chunk_token_count": 241.0}, {"page_number": 1100, "sentence_chunk": "Applications can use one or the other module or, in some cases, both\u2009\u2014\u2009for example, Spring MVC controllers with the reactive WebClient.6.1.1. Overview Why was Spring WebFlux created?Part of the answer is the need for a non-blocking web stack to handle concurrency with a small number of threads and scale with fewer hardware resources. Servlet non-blocking I/O leads away from the rest of the Servlet API, where contracts are synchronous (Filter, Servlet) or blocking (getParameter, getPart). This was the motivation for a new common API to serve as a foundation across any non-blocking runtime. That is important because of servers (such as Netty) that are well- established in the async, non-blocking space. The other part of the answer is functional programming. Much as the addition of annotations in Java 5 created opportunities (such as annotated REST controllers or unit tests), the addition of lambda expressions in Java 8 created opportunities for functional APIs in Java. This is a boon for non-blocking applications and continuation-style APIs (as popularized by CompletableFuture and ReactiveX) that allow declarative composition of asynchronous logic.", "chunk_char_count": 1164, "chunk_word_count": 177, "chunk_token_count": 291.0}, {"page_number": 1100, "sentence_chunk": "At the programming-model level, Java 8 enabled Spring WebFlux to offer functional web endpoints alongside annotated controllers. Define \u201cReactive\u201d We touched on \u201cnon-blocking\u201d and \u201cfunctional\u201d but what does reactive mean?The term, \u201creactive,\u201d refers to programming models that are built around reacting to change\u2009\u2014\u2009network components reacting to I/O events, UI controllers reacting to mouse events, and others. In that sense, non-blocking is reactive, because, instead of being blocked, we are now in the mode of reacting to notifications as operations complete or data becomes available.1100", "chunk_char_count": 592, "chunk_word_count": 84, "chunk_token_count": 148.0}, {"page_number": 1101, "sentence_chunk": "There is also another important mechanism that we on the Spring team associate with \u201creactive\u201d and that is non-blocking back pressure. In synchronous, imperative code, blocking calls serve as a natural form of back pressure that forces the caller to wait. In non-blocking code, it becomes important to control the rate of events so that a fast producer does not overwhelm its destination. Reactive Streams is a small spec (also adopted in Java 9) that defines the interaction between asynchronous components with back pressure. For example a data repository (acting as Publisher) can produce data that an HTTP server (acting as Subscriber) can then write to the response. The main purpose of Reactive Streams is to let the subscriber control how quickly or how slowly the publisher produces data.\uf05a Common question: what if a publisher cannot slow down?The purpose of Reactive Streams is only to establish the mechanism and a boundary. If a publisher cannot slow down, it has to decide whether to buffer, drop, or fail. Reactive API Reactive Streams plays an important role for interoperability.", "chunk_char_count": 1094, "chunk_word_count": 177, "chunk_token_count": 273.5}, {"page_number": 1101, "sentence_chunk": "It is of interest to libraries and infrastructure components but less useful as an application API, because it is too low-level. Applications need a higher-level and richer, functional API to compose async logic\u2009\u2014\u2009similar to the Java 8 Stream API but not only for collections. This is the role that reactive libraries play. Reactor is the reactive library of choice for Spring WebFlux. It provides the Mono and Flux API types to work on data sequences of 0..1 (Mono) and 0.. N (Flux) through a rich set of operators aligned with the ReactiveX vocabulary of operators. Reactor is a Reactive Streams library and, therefore, all of its operators support non-blocking back pressure. Reactor has a strong focus on server-side Java. It is developed in close collaboration with Spring. WebFlux requires Reactor as a core dependency but it is interoperable with other reactive libraries via Reactive Streams. As a general rule, a WebFlux API accepts a plain Publisher as input, adapts it to a Reactor type internally, uses that, and returns either a Flux or a Mono as output.", "chunk_char_count": 1067, "chunk_word_count": 177, "chunk_token_count": 266.75}, {"page_number": 1101, "sentence_chunk": "So, you can pass any Publisher as input and you can apply operations on the output, but you need to adapt the output for use with another reactive library. Whenever feasible (for example, annotated controllers), WebFlux adapts transparently to the use of RxJava or another reactive library. See Reactive Libraries for more details.\uf05a In addition to Reactive APIs, WebFlux can also be used with Coroutines APIs in Kotlin which provides a more imperative style of programming. The following Kotlin code samples will be provided with Coroutines APIs. Programming Models The spring-web module contains the reactive foundation that underlies Spring WebFlux, including HTTP abstractions, Reactive Streams adapters for supported servers, codecs, and a core WebHandler API comparable to the Servlet API but with non-blocking contracts. On that foundation, Spring WebFlux provides a choice of two programming models: 1101", "chunk_char_count": 911, "chunk_word_count": 137, "chunk_token_count": 227.75}, {"page_number": 1102, "sentence_chunk": "\u2022 Annotated Controllers: Consistent with Spring MVC and based on the same annotations from the spring-web module. Both Spring MVC and WebFlux controllers support reactive (Reactor and RxJava) return types, and, as a result, it is not easy to tell them apart. One notable difference is that WebFlux also supports reactive @RequestBody arguments. \u2022Functional Endpoints: Lambda-based, lightweight, and functional programming model. You can think of this as a small library or a set of utilities that an application can use to route and handle requests. The big difference with annotated controllers is that the application is in charge of request handling from start to finish versus declaring intent through annotations and being called back. Applicability Spring MVC or WebFlux?A natural question to ask but one that sets up an unsound dichotomy. Actually, both work together to expand the range of available options. The two are designed for continuity and consistency with each other, they are available side by side, and feedback from each side benefits both sides.", "chunk_char_count": 1067, "chunk_word_count": 167, "chunk_token_count": 266.75}, {"page_number": 1102, "sentence_chunk": "The following diagram shows how the two relate, what they have in common, and what each supports uniquely: We suggest that you consider the following specific points: \u2022 If you have a Spring MVC application that works fine, there is no need to change. Imperative programming is the easiest way to write, understand, and debug code. You have maximum choice of libraries, since, historically, most are blocking. \u2022If you are already shopping for a non-blocking web stack, Spring WebFlux offers the same execution model benefits as others in this space and also provides a choice of servers (Netty, Tomcat, Jetty, Undertow, and Servlet containers), a choice of programming models (annotated controllers and functional web endpoints), and a choice of reactive libraries (Reactor, RxJava, or 1102", "chunk_char_count": 789, "chunk_word_count": 125, "chunk_token_count": 197.25}, {"page_number": 1103, "sentence_chunk": "other). \u2022If you are interested in a lightweight, functional web framework for use with Java 8 lambdas or Kotlin, you can use the Spring WebFlux functional web endpoints. That can also be a good choice for smaller applications or microservices with less complex requirements that can benefit from greater transparency and control. \u2022In a microservice architecture, you can have a mix of applications with either Spring MVC or Spring WebFlux controllers or with Spring WebFlux functional endpoints. Having support for the same annotation-based programming model in both frameworks makes it easier to re-use knowledge while also selecting the right tool for the right job. \u2022A simple way to evaluate an application is to check its dependencies. If you have blocking persistence APIs (JPA, JDBC) or networking APIs to use, Spring MVC is the best choice for common architectures at least. It is technically feasible with both Reactor and RxJava to perform blocking calls on a separate thread but you would not be making the most of a non- blocking web stack. \u2022If you have a Spring MVC application with calls to remote services, try the reactive WebClient. You can return reactive types (Reactor, RxJava, or other) directly from Spring MVC controller methods.", "chunk_char_count": 1251, "chunk_word_count": 202, "chunk_token_count": 312.75}, {"page_number": 1103, "sentence_chunk": "The greater the latency per call or the interdependency among calls, the more dramatic the benefits. Spring MVC controllers can call other reactive components too. \u2022If you have a large team, keep in mind the steep learning curve in the shift to non-blocking, functional, and declarative programming. A practical way to start without a full switch is to use the reactive WebClient. Beyond that, start small and measure the benefits. We expect that, for a wide range of applications, the shift is unnecessary. If you are unsure what benefits to look for, start by learning about how non-blocking I/O works (for example, concurrency on single- threaded Node.js) and its effects. Servers Spring WebFlux is supported on Tomcat, Jetty, Servlet containers, as well as on non-Servlet runtimes such as Netty and Undertow. All servers are adapted to a low-level, common API so that higher-level programming models can be supported across servers. Spring WebFlux does not have built-in support to start or stop a server.", "chunk_char_count": 1009, "chunk_word_count": 163, "chunk_token_count": 252.25}, {"page_number": 1103, "sentence_chunk": "However, it is easy to assemble an application from Spring configuration and WebFlux infrastructure and run it with a few lines of code. Spring Boot has a WebFlux starter that automates these steps. By default, the starter uses Netty, but it is easy to switch to Tomcat, Jetty, or Undertow by changing your Maven or Gradle dependencies. Spring Boot defaults to Netty, because it is more widely used in the asynchronous, non-blocking space and lets a client and a server share resources. Tomcat and Jetty can be used with both Spring MVC and WebFlux. Keep in mind, however, that the way they are used is very different. Spring MVC relies on Servlet blocking I/O and lets applications use the Servlet API directly if they need to. Spring WebFlux relies on Servlet non-blocking I/O and uses the Servlet API behind a low-level adapter. It is not exposed for direct use. For Undertow, Spring WebFlux uses Undertow APIs directly without the Servlet API.", "chunk_char_count": 947, "chunk_word_count": 161, "chunk_token_count": 236.75}, {"page_number": 1104, "sentence_chunk": "Performance Performance has many characteristics and meanings. Reactive and non-blocking generally do not make applications run faster. They can, in some cases, (for example, if using the WebClient to run remote calls in parallel). On the whole, it requires more work to do things the non-blocking way and that can slightly increase the required processing time. The key expected benefit of reactive and non-blocking is the ability to scale with a small, fixed number of threads and less memory. That makes applications more resilient under load, because they scale in a more predictable way. In order to observe those benefits, however, you need to have some latency (including a mix of slow and unpredictable network I/O). That is where the reactive stack begins to show its strengths, and the differences can be dramatic. Concurrency Model Both Spring MVC and Spring WebFlux support annotated controllers, but there is a key difference in the concurrency model and the default assumptions for blocking and threads. In Spring MVC (and servlet applications in general), it is assumed that applications can block the current thread, (for example, for remote calls).", "chunk_char_count": 1165, "chunk_word_count": 185, "chunk_token_count": 291.25}, {"page_number": 1104, "sentence_chunk": "For this reason, servlet containers use a large thread pool to absorb potential blocking during request handling. In Spring WebFlux (and non-blocking servers in general), it is assumed that applications do not block. Therefore, non-blocking servers use a small, fixed-size thread pool (event loop workers) to handle requests.\uf0eb \u201cTo scale\u201d and \u201csmall number of threads\u201d may sound contradictory but to never block the current thread (and rely on callbacks instead) means that you do not need extra threads, as there are no blocking calls to absorb. Invoking a Blocking API What if you do need to use a blocking library?Both Reactor and RxJava provide the publishOn operator to continue processing on a different thread. That means there is an easy escape hatch. Keep in mind, however, that blocking APIs are not a good fit for this concurrency model. Mutable State In Reactor and RxJava, you declare logic through operators. At runtime, a reactive pipeline is formed where data is processed sequentially, in distinct stages.", "chunk_char_count": 1021, "chunk_word_count": 164, "chunk_token_count": 255.25}, {"page_number": 1104, "sentence_chunk": "A key benefit of this is that it frees applications from having to protect mutable state because application code within that pipeline is never invoked concurrently. Threading Model What threads should you expect to see on a server running with Spring WebFlux? \u2022On a \u201cvanilla\u201d Spring WebFlux server (for example, no data access nor other optional dependencies), you can expect one thread for the server and several others for request processing (typically as many as the number of CPU cores). Servlet containers, however, may start with more threads (for example, 10 on Tomcat), in support of both servlet (blocking) I/O and servlet 3.1 (non-blocking) I/O usage.1104", "chunk_char_count": 666, "chunk_word_count": 106, "chunk_token_count": 166.5}, {"page_number": 1105, "sentence_chunk": "\u2022 The reactive WebClient operates in event loop style. So you can see a small, fixed number of processing threads related to that (for example, reactor-http-nio- with the Reactor Netty connector). However, if Reactor Netty is used for both client and server, the two share event loop resources by default. \u2022Reactor and RxJava provide thread pool abstractions, called schedulers, to use with the publishOn operator that is used to switch processing to a different thread pool. The schedulers have names that suggest a specific concurrency strategy\u2009\u2014\u2009for example, \u201cparallel\u201d (for CPU- bound work with a limited number of threads) or \u201celastic\u201d (for I/O-bound work with a large number of threads). If you see such threads, it means some code is using a specific thread pool Scheduler strategy. \u2022Data access libraries and other third party dependencies can also create and use threads of their own. Configuring The Spring Framework does not provide support for starting and stopping servers. To configure the threading model for a server, you need to use server-specific configuration APIs, or, if you use Spring Boot, check the Spring Boot configuration options for each server. You can configure the WebClient directly.", "chunk_char_count": 1216, "chunk_word_count": 192, "chunk_token_count": 304.0}, {"page_number": 1105, "sentence_chunk": "For all other libraries, see their respective documentation.6.1.2. Reactive Core The spring-web module contains the following foundational support for reactive web applications: \u2022 For server request processing there are two levels of support.\u25e6 HttpHandler: Basic contract for HTTP request handling with non-blocking I/O and Reactive Streams back pressure, along with adapters for Reactor Netty, Undertow, Tomcat, Jetty, and any Servlet container.\u25e6 WebHandler API: Slightly higher level, general-purpose web API for request handling, on top of which concrete programming models such as annotated controllers and functional endpoints are built. \u2022For the client side, there is a basic ClientHttpConnector contract to perform HTTP requests with non-blocking I/O and Reactive Streams back pressure, along with adapters for Reactor Netty, reactive Jetty HttpClient and Apache HttpComponents. The higher level WebClient used in applications builds on this basic contract. \u2022For client and server, codecs for serialization and deserialization of HTTP request and response content. HttpHandler HttpHandler is a simple contract with a single method to handle a request and a response. It is intentionally minimal, and its main and only purpose is to be a minimal abstraction over different HTTP server APIs.", "chunk_char_count": 1296, "chunk_word_count": 187, "chunk_token_count": 324.0}, {"page_number": 1106, "sentence_chunk": "Server name Server API used Reactive Streams support Netty Netty API Reactor Netty Undertow Undertow API spring-web: Undertow to Reactive Streams bridge Tomcat Servlet non-blocking I/O; Tomcat API to read and write ByteBuffers vs byte[] spring-web: Servlet non-blocking I/O to Reactive Streams bridge Jetty Servlet non-blocking I/O; Jetty API to write ByteBuffers vs byte[] spring-web: Servlet non-blocking I/O to Reactive Streams bridge Servlet container Servlet non-blocking I/O spring-web: Servlet non-blocking I/O to Reactive Streams bridge The following table describes server dependencies (also see supported versions): Server name Group id Artifact name Reactor Netty io.projectreactor.netty reactor-netty Undertow io.undertow undertow-core Tomcat org.apache.tomcat.embed tomcat-embed-core Jetty org.eclipse.jetty jetty-server, jetty-servlet The code snippets below show using the HttpHandler adapters with each server API: Reactor Netty Java HttpHandler handler = ... ReactorHttpHandlerAdapter adapter = new ReactorHttpHandlerAdapter(handler); HttpServer.create().host(host).port(port).handle(adapter).bind().block(); Kotlin val handler: HttpHandler = ... val adapter = ReactorHttpHandlerAdapter(handler) HttpServer.create().host(host).port(port).handle(adapter).bind().block() Undertow Java HttpHandler handler = ... UndertowHttpHandlerAdapter adapter = new UndertowHttpHandlerAdapter(handler); Undertow server = Undertow.builder().addHttpListener(port, host).setHandler(adapter).build(); server.start(); 1106", "chunk_char_count": 1518, "chunk_word_count": 160, "chunk_token_count": 379.5}, {"page_number": 1107, "sentence_chunk": "Kotlin val handler: HttpHandler = ... val adapter = UndertowHttpHandlerAdapter(handler) val server = Undertow.builder().addHttpListener(port, host).setHandler(adapter).build() server.start() Tomcat Java HttpHandler handler = ... Servlet servlet = new TomcatHttpHandlerAdapter(handler); Tomcat server = new Tomcat(); File base = new File(System.getProperty(\"java.io.tmpdir\")); Context rootContext = server.addContext(\"\", base.getAbsolutePath()); Tomcat.addServlet(rootContext, \"main\", servlet); rootContext.addServletMappingDecoded(\"/\", \"main\"); server.setHost(host); server.setPort(port); server.start(); Kotlin val handler: HttpHandler = ... val servlet = TomcatHttpHandlerAdapter(handler) val server = Tomcat() val base = File(System.getProperty(\"java.io.tmpdir\")) val rootContext = server.addContext(\"\", base.absolutePath) Tomcat.addServlet(rootContext, \"main\", servlet) rootContext.addServletMappingDecoded(\"/\", \"main\") server.host = host server.setPort(port) server.start() Jetty 1107", "chunk_char_count": 989, "chunk_word_count": 85, "chunk_token_count": 247.25}, {"page_number": 1108, "sentence_chunk": "Java HttpHandler handler = ... Servlet servlet = new JettyHttpHandlerAdapter(handler); Server server = new Server(); ServletContextHandler contextHandler = new ServletContextHandler(server, \"\"); contextHandler.addServlet(new ServletHolder(servlet), \"/\"); contextHandler.start(); ServerConnector connector = new ServerConnector(server); connector.setHost(host); connector.setPort(port); server.addConnector(connector); server.start(); Kotlin val handler: HttpHandler = ... val servlet = JettyHttpHandlerAdapter(handler) val server = Server() val contextHandler = ServletContextHandler(server, \"\") contextHandler.addServlet(ServletHolder(servlet), \"/\") contextHandler.start(); val connector = ServerConnector(server) connector.host = host connector.port = port server.addConnector(connector) server.start() Servlet Container To deploy as a WAR to any Servlet container, you can extend and include AbstractReactiveWebInitializer in the WAR. That class wraps an HttpHandler with ServletHttpHandlerAdapter and registers that as a Servlet. WebHandler API The org.springframework.web.server package builds on the HttpHandler contract to provide a general-purpose web API for processing requests through a chain of multiple WebExceptionHandler, multiple WebFilter, and a single WebHandler component. The chain can be put together with WebHttpHandlerBuilder by simply pointing to a Spring ApplicationContext where components are auto-detected, and/or by registering components with the builder. While HttpHandler has a simple goal to abstract the use of different HTTP servers, the WebHandler API aims to provide a broader set of features commonly used in web applications such as: \u2022 User session with attributes.1108", "chunk_char_count": 1708, "chunk_word_count": 196, "chunk_token_count": 427.0}, {"page_number": 1109, "sentence_chunk": "\u2022 Request attributes. \u2022Resolved Locale or Principal for the request. \u2022Access to parsed and cached form data. \u2022Abstractions for multipart data. \u2022and more.. Special bean types The table below lists the components that WebHttpHandlerBuilder can auto-detect in a Spring ApplicationContext, or that can be registered directly with it: Bean name Bean type Count Description <any> WebExceptionHandler 0.. N Provide handling for exceptions from the chain of WebFilter instances and the target WebHandler. For more details, see Exceptions.<any> WebFilter 0.. N Apply interception style logic to before and after the rest of the filter chain and the target WebHandler. For more details, see Filters.webHandler WebHandler 1 The handler for the request.webSessionManager WebSessionManager 0..1 The manager for WebSession instances exposed through a method on ServerWebExchange.", "chunk_char_count": 865, "chunk_word_count": 123, "chunk_token_count": 216.25}, {"page_number": 1109, "sentence_chunk": "DefaultWebSessionManager by default.serverCodecConfigurer ServerCodecConfigurer 0..1 For access to HttpMessageReader instances for parsing form data and multipart data that is then exposed through methods on ServerWebExchange. ServerCodecConfigurer.create() by default.localeContextResolver LocaleContextResolver 0..1 The resolver for LocaleContext exposed through a method on ServerWebExchange. AcceptHeaderLocaleContextResolver by default.forwardedHeaderTransfo rmer ForwardedHeaderTransfo rmer 0..1 For processing forwarded type headers, either by extracting and removing them or by removing them only. Not used by default.1109", "chunk_char_count": 630, "chunk_word_count": 67, "chunk_token_count": 157.5}, {"page_number": 1110, "sentence_chunk": "Form Data ServerWebExchange exposes the following method for accessing form data: Java Mono<MultiValueMap<String, String>> getFormData(); Kotlin suspend fun getFormData(): MultiValueMap<String, String> The DefaultServerWebExchange uses the configured HttpMessageReader to parse form data (application/x-www-form-urlencoded) into a MultiValueMap. By default, FormHttpMessageReader is configured for use by the ServerCodecConfigurer bean (see the Web Handler API). Multipart Data Web MVC ServerWebExchange exposes the following method for accessing multipart data: Java Mono<MultiValueMap<String, Part>> getMultipartData(); Kotlin suspend fun getMultipartData(): MultiValueMap<String, Part> The DefaultServerWebExchange uses the configured HttpMessageReader<MultiValueMap<String, Part>> to parse multipart/form-data content into a MultiValueMap. By default, this is the DefaultPartHttpMessageReader, which does not have any third-party dependencies. Alternatively, the SynchronossPartHttpMessageReader can be used, which is based on the Synchronoss NIO Multipart library. Both are configured through the ServerCodecConfigurer bean (see the Web Handler API). To parse multipart data in streaming fashion, you can use the Flux<PartEvent> returned from the PartEventHttpMessageReader instead of using @RequestPart, as that implies Map-like access to individual parts by name and, hence, requires parsing multipart data in full. By contrast, you can use @RequestBody to decode the content to Flux<PartEvent> without collecting to a MultiValueMap. Forwarded Headers Web MVC As a request goes through proxies (such as load balancers), the host, port, and scheme may change. That makes it a challenge, from a client perspective, to create links that point to the correct host, port, and scheme.", "chunk_char_count": 1785, "chunk_word_count": 225, "chunk_token_count": 446.25}, {"page_number": 1111, "sentence_chunk": "original request. There are other non-standard headers, too, including X-Forwarded-Host, X- Forwarded-Port, X-Forwarded-Proto, X-Forwarded-Ssl, and X-Forwarded-Prefix. ForwardedHeaderTransformer is a component that modifies the host, port, and scheme of the request, based on forwarded headers, and then removes those headers. If you declare it as a bean with the name forwardedHeaderTransformer, it will be detected and used. There are security considerations for forwarded headers, since an application cannot know if the headers were added by a proxy, as intended, or by a malicious client. This is why a proxy at the boundary of trust should be configured to remove untrusted forwarded traffic coming from the outside. You can also configure the ForwardedHeaderTransformer with removeOnly=true, in which case it removes but does not use the headers.\uf05a In 5.1 ForwardedHeaderFilter was deprecated and superseded by ForwardedHeaderTransformer so forwarded headers can be processed earlier, before the exchange is created. If the filter is configured anyway, it is taken out of the list of filters, and ForwardedHeaderTransformer is used instead. Filters Web MVC In the WebHandler API, you can use a WebFilter to apply interception-style logic before and after the rest of the processing chain of filters and the target WebHandler.", "chunk_char_count": 1331, "chunk_word_count": 196, "chunk_token_count": 332.75}, {"page_number": 1111, "sentence_chunk": "When using the WebFlux Config, registering a WebFilter is as simple as declaring it as a Spring bean and (optionally) expressing precedence by using @Order on the bean declaration or by implementing Ordered. CORS Web MVC Spring WebFlux provides fine-grained support for CORS configuration through annotations on controllers. However, when you use it with Spring Security, we advise relying on the built-in CorsFilter, which must be ordered ahead of Spring Security\u2019s chain of filters. See the section on CORS and the CORS WebFilter for more details. Exceptions Web MVC In the WebHandler API, you can use a WebExceptionHandler to handle exceptions from the chain of WebFilter instances and the target WebHandler. When using the WebFlux Config, registering a WebExceptionHandler is as simple as declaring it as a Spring bean and (optionally) expressing precedence by using @Order on the bean declaration or by implementing Ordered. The following table describes the available WebExceptionHandler implementations: 1111", "chunk_char_count": 1015, "chunk_word_count": 153, "chunk_token_count": 253.75}, {"page_number": 1112, "sentence_chunk": "Exception Handler Description ResponseStatusExceptionHandler Provides handling for exceptions of type ResponseStatusException by setting the response to the HTTP status code of the exception. WebFluxResponseStatusException Handler Extension of ResponseStatusExceptionHandler that can also determine the HTTP status code of a @ResponseStatus annotation on any exception. This handler is declared in the WebFlux Config. Codecs Web MVC The spring-web and spring-core modules provide support for serializing and deserializing byte content to and from higher level objects through non-blocking I/O with Reactive Streams back pressure. The following describes this support: \u2022 Encoder and Decoder are low level contracts to encode and decode content independent of HTTP. \u2022HttpMessageReader and HttpMessageWriter are contracts to encode and decode HTTP message content. \u2022An Encoder can be wrapped with EncoderHttpMessageWriter to adapt it for use in a web application, while a Decoder can be wrapped with DecoderHttpMessageReader. \u2022DataBuffer abstracts different byte buffer representations (e.g. Netty ByteBuf, java.nio. ByteBuffer, etc.)and is what all codecs work on.", "chunk_char_count": 1162, "chunk_word_count": 156, "chunk_token_count": 290.5}, {"page_number": 1112, "sentence_chunk": "See Data Buffers and Codecs in the \"Spring Core\" section for more on this topic. The spring-core module provides byte[], ByteBuffer, DataBuffer, Resource, and String encoder and decoder implementations. The spring-web module provides Jackson JSON, Jackson Smile, JAXB2, Protocol Buffers and other encoders and decoders along with web-only HTTP message reader and writer implementations for form data, multipart content, server-sent events, and others. ClientCodecConfigurer and ServerCodecConfigurer are typically used to configure and customize the codecs to use in an application. See the section on configuring HTTP message codecs. Jackson JSON JSON and binary JSON (Smile) are both supported when the Jackson library is present. The Jackson2Decoder works as follows: \u2022 Jackson\u2019s asynchronous, non-blocking parser is used to aggregate a stream of byte chunks into TokenBuffer's each representing a JSON object. \u2022Each TokenBuffer is passed to Jackson\u2019s ObjectMapper to create a higher level object. \u2022When decoding to a single-value publisher (e.g. Mono), there is one TokenBuffer. \u2022When decoding to a multi-value publisher (e.g. Flux), each TokenBuffer is passed to the ObjectMapper as soon as enough bytes are received for a fully formed object.", "chunk_char_count": 1248, "chunk_word_count": 182, "chunk_token_count": 312.0}, {"page_number": 1113, "sentence_chunk": "Text Sequences. The Jackson2Encoder works as follows: \u2022 For a single value publisher (e.g. Mono), simply serialize it through the ObjectMapper. \u2022For a multi-value publisher with application/json, by default collect the values with Flux#collectToList() and then serialize the resulting collection. \u2022For a multi-value publisher with a streaming media type such as application/x-ndjson or application/stream+x-jackson-smile, encode, write, and flush each value individually using a line-delimited JSON format. Other streaming media types may be registered with the encoder. \u2022For SSE the Jackson2Encoder is invoked per event and the output is flushed to ensure delivery without delay.\uf05a By default both Jackson2Encoder and Jackson2Decoder do not support elements of type String. Instead the default assumption is that a string or a sequence of strings represent serialized JSON content, to be rendered by the CharSequenceEncoder. If what you need is to render a JSON array from Flux<String>, use Flux#collectToList() and encode a Mono<List<String>>. Form Data FormHttpMessageReader and FormHttpMessageWriter support decoding and encoding application/x- www-form-urlencoded content.", "chunk_char_count": 1176, "chunk_word_count": 160, "chunk_token_count": 294.0}, {"page_number": 1113, "sentence_chunk": "On the server side where form content often needs to be accessed from multiple places, ServerWebExchange provides a dedicated getFormData() method that parses the content through FormHttpMessageReader and then caches the result for repeated access. See Form Data in the WebHandler API section. Once getFormData() is used, the original raw content can no longer be read from the request body. For this reason, applications are expected to go through ServerWebExchange consistently for access to the cached form data versus reading from the raw request body. Multipart MultipartHttpMessageReader and MultipartHttpMessageWriter support decoding and encoding \"multipart/form-data\" content. In turn MultipartHttpMessageReader delegates to another HttpMessageReader for the actual parsing to a Flux<Part> and then simply collects the parts into a MultiValueMap. By default, the DefaultPartHttpMessageReader is used, but this can be changed through the ServerCodecConfigurer. For more information about the DefaultPartHttpMessageReader, refer to to the javadoc of DefaultPartHttpMessageReader. On the server side where multipart form content may need to be accessed from multiple places, ServerWebExchange provides a dedicated getMultipartData() method that parses the content through MultipartHttpMessageReader and then caches the result for repeated access. See Multipart Data in the WebHandler API section.", "chunk_char_count": 1402, "chunk_word_count": 189, "chunk_token_count": 350.5}, {"page_number": 1113, "sentence_chunk": "Once getMultipartData() is used, the original raw content can no longer be read from the request body. For this reason applications have to consistently use getMultipartData() for repeated, map- 1113", "chunk_char_count": 199, "chunk_word_count": 30, "chunk_token_count": 49.75}, {"page_number": 1114, "sentence_chunk": "like access to parts, or otherwise rely on the SynchronossPartHttpMessageReader for a one-time access to Flux<Part>. Limits Decoder and HttpMessageReader implementations that buffer some or all of the input stream can be configured with a limit on the maximum number of bytes to buffer in memory. In some cases buffering occurs because input is aggregated and represented as a single object \u2014 for example, a controller method with @RequestBody byte[], x-www-form-urlencoded data, and so on. Buffering can also occur with streaming, when splitting the input stream \u2014 for example, delimited text, a stream of JSON objects, and so on. For those streaming cases, the limit applies to the number of bytes associated with one object in the stream. To configure buffer sizes, you can check if a given Decoder or HttpMessageReader exposes a maxInMemorySize property and if so the Javadoc will have details about default values. On the server side, ServerCodecConfigurer provides a single place from where to set all codecs, see HTTP message codecs. On the client side, the limit for all codecs can be changed in WebClient. Builder. For Multipart parsing the maxInMemorySize property limits the size of non-file parts.", "chunk_char_count": 1209, "chunk_word_count": 192, "chunk_token_count": 302.25}, {"page_number": 1114, "sentence_chunk": "For file parts, it determines the threshold at which the part is written to disk. For file parts written to disk, there is an additional maxDiskUsagePerPart property to limit the amount of disk space per part. There is also a maxParts property to limit the overall number of parts in a multipart request. To configure all three in WebFlux, you\u2019ll need to supply a pre-configured instance of MultipartHttpMessageReader to ServerCodecConfigurer. Streaming Web MVC When streaming to the HTTP response (for example, text/event-stream, application/x-ndjson), it is important to send data periodically, in order to reliably detect a disconnected client sooner rather than later. Such a send could be a comment-only, empty SSE event or any other \"no-op\" data that would effectively serve as a heartbeat. DataBuffer DataBuffer is the representation for a byte buffer in WebFlux. The Spring Core part of this reference has more on that in the section on Data Buffers and Codecs. The key point to understand is that on some servers like Netty, byte buffers are pooled and reference counted, and must be released when consumed to avoid memory leaks. WebFlux applications generally do not need to be concerned with such issues, unless they consume or produce data buffers directly, as opposed to relying on codecs to convert to and from higher level objects, or unless they choose to create custom codecs.", "chunk_char_count": 1393, "chunk_word_count": 225, "chunk_token_count": 348.25}, {"page_number": 1114, "sentence_chunk": "For such cases please review the information in Data Buffers and Codecs, especially the section on Using DataBuffer. Logging Web MVC DEBUG level logging in Spring WebFlux is designed to be compact, minimal, and human-friendly. It 1114", "chunk_char_count": 234, "chunk_word_count": 37, "chunk_token_count": 58.5}, {"page_number": 1115, "sentence_chunk": "focuses on high value bits of information that are useful over and over again vs others that are useful only when debugging a specific issue. TRACE level logging generally follows the same principles as DEBUG (and for example also should not be a firehose) but can be used for debugging any issue. In addition, some log messages may show a different level of detail at TRACE vs DEBUG. Good logging comes from the experience of using the logs. If you spot anything that does not meet the stated goals, please let us know. Log Id In WebFlux, a single request can be run over multiple threads and the thread ID is not useful for correlating log messages that belong to a specific request. This is why WebFlux log messages are prefixed with a request-specific ID by default. On the server side, the log ID is stored in the ServerWebExchange attribute (LOG_ID_ATTRIBUTE), while a fully formatted prefix based on that ID is available from ServerWebExchange#getLogPrefix(). On the WebClient side, the log ID is stored in the ClientRequest attribute (LOG_ID_ATTRIBUTE) ,while a fully formatted prefix is available from ClientRequest#logPrefix(). Sensitive Data Web MVC DEBUG and TRACE logging can log sensitive information.", "chunk_char_count": 1215, "chunk_word_count": 199, "chunk_token_count": 303.75}, {"page_number": 1115, "sentence_chunk": "This is why form parameters and headers are masked by default and you must explicitly enable their logging in full. The following example shows how to do so for server-side requests: Java @Configuration @EnableWebFlux class MyConfig implements WebFluxConfigurer { \u00a0  @Override \u00a0  public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) { \u00a0    configurer.defaultCodecs().enableLoggingRequestDetails(true); \u00a0  } } 1115", "chunk_char_count": 433, "chunk_word_count": 59, "chunk_token_count": 108.25}, {"page_number": 1116, "sentence_chunk": "Kotlin @Configuration @EnableWebFlux class MyConfig : WebFluxConfigurer { \u00a0  override fun configureHttpMessageCodecs(configurer: ServerCodecConfigurer) { \u00a0    configurer.defaultCodecs().enableLoggingRequestDetails(true) \u00a0  } } The following example shows how to do so for client-side requests: Java Consumer<ClientCodecConfigurer> consumer = configurer -> \u00a0    configurer.defaultCodecs().enableLoggingRequestDetails(true); WebClient webClient = WebClient.builder() \u00a0    .exchangeStrategies(strategies -> strategies.codecs(consumer)) \u00a0    .build(); Kotlin val consumer: (ClientCodecConfigurer) -> Unit = { configurer -> configurer.defaultCodecs().enableLoggingRequestDetails(true) } val webClient = WebClient.builder() \u00a0    .exchangeStrategies({ strategies -> strategies.codecs(consumer) }) \u00a0    .build() Appenders Logging libraries such as SLF4J and Log4J 2 provide asynchronous loggers that avoid blocking. While those have their own drawbacks such as potentially dropping messages that could not be queued for logging, they are the best available options currently for use in a reactive, non-blocking application. Custom codecs Applications can register custom codecs for supporting additional media types, or specific behaviors that are not supported by the default codecs. Some configuration options expressed by developers are enforced on default codecs. Custom codecs might want to get a chance to align with those preferences, like enforcing buffering limits or logging sensitive data. The following example shows how to do so for client-side requests: 1116", "chunk_char_count": 1564, "chunk_word_count": 206, "chunk_token_count": 391.0}, {"page_number": 1117, "sentence_chunk": "Java WebClient webClient = WebClient.builder() \u00a0    .codecs(configurer -> { \u00a0        CustomDecoder decoder = new CustomDecoder(); \u00a0        configurer.customCodecs().registerWithDefaultConfig(decoder); \u00a0    }) \u00a0    .build(); Kotlin val webClient = WebClient.builder() \u00a0    .codecs({ configurer -> \u00a0        val decoder = CustomDecoder() \u00a0        configurer.customCodecs().registerWithDefaultConfig(decoder) \u00a0    }) \u00a0    .build() 6.1.3. DispatcherHandler Web MVC Spring WebFlux, similarly to Spring MVC, is designed around the front controller pattern, where a central WebHandler, the DispatcherHandler, provides a shared algorithm for request processing, while actual work is performed by configurable, delegate components. This model is flexible and supports diverse workflows. DispatcherHandler discovers the delegate components it needs from Spring configuration. It is also designed to be a Spring bean itself and implements ApplicationContextAware for access to the context in which it runs. If DispatcherHandler is declared with a bean name of webHandler, it is, in turn, discovered by WebHttpHandlerBuilder, which puts together a request-processing chain, as described in WebHandler API. Spring configuration in a WebFlux application typically contains: \u2022 DispatcherHandler with the bean name webHandler \u2022 WebFilter and WebExceptionHandler beans \u2022 DispatcherHandler special beans \u2022 Others The configuration is given to WebHttpHandlerBuilder to build the processing chain, as the following example shows: Java ApplicationContext context = ... HttpHandler handler = WebHttpHandlerBuilder.applicationContext(context).build(); 1117", "chunk_char_count": 1632, "chunk_word_count": 246, "chunk_token_count": 408.0}, {"page_number": 1118, "sentence_chunk": "Kotlin val context: ApplicationContext = ... val handler = WebHttpHandlerBuilder.applicationContext(context).build() The resulting HttpHandler is ready for use with a server adapter. Special Bean Types Web MVC The DispatcherHandler delegates to special beans to process requests and render the appropriate responses. By \u201cspecial beans,\u201d we mean Spring-managed Object instances that implement WebFlux framework contracts. Those usually come with built-in contracts, but you can customize their properties, extend them, or replace them. The following table lists the special beans detected by the DispatcherHandler. Note that there are also some other beans detected at a lower level (see Special bean types in the Web Handler API). Bean type Explanation HandlerMapping Map a request to a handler. The mapping is based on some criteria, the details of which vary by HandlerMapping implementation\u2009\u2014\u2009annotated controllers, simple URL pattern mappings, and others. The main HandlerMapping implementations are RequestMappingHandlerMapping for @RequestMapping annotated methods, RouterFunctionMapping for functional endpoint routes, and SimpleUrlHandlerMapping for explicit registrations of URI path patterns and WebHandler instances. HandlerAdapter Help the DispatcherHandler to invoke a handler mapped to a request regardless of how the handler is actually invoked.", "chunk_char_count": 1360, "chunk_word_count": 182, "chunk_token_count": 340.0}, {"page_number": 1118, "sentence_chunk": "For example, invoking an annotated controller requires resolving annotations. The main purpose of a HandlerAdapter is to shield the DispatcherHandler from such details. HandlerResultHandler Process the result from the handler invocation and finalize the response. See Result Handling. WebFlux Config Web MVC Applications can declare the infrastructure beans (listed under Web Handler API and DispatcherHandler) that are required to process requests. However, in most cases, the WebFlux Config is the best starting point. It declares the required beans and provides a higher-level configuration callback API to customize it.1118", "chunk_char_count": 627, "chunk_word_count": 88, "chunk_token_count": 156.75}, {"page_number": 1119, "sentence_chunk": "\uf05a Spring Boot relies on the WebFlux config to configure Spring WebFlux and also provides many extra convenient options. Processing Web MVC DispatcherHandler processes requests as follows: \u2022 Each HandlerMapping is asked to find a matching handler, and the first match is used. \u2022If a handler is found, it is run through an appropriate HandlerAdapter, which exposes the return value from the execution as HandlerResult. \u2022The HandlerResult is given to an appropriate HandlerResultHandler to complete processing by writing to the response directly or by using a view to render. Result Handling The return value from the invocation of a handler, through a HandlerAdapter, is wrapped as a HandlerResult, along with some additional context, and passed to the first HandlerResultHandler that claims support for it. The following table shows the available HandlerResultHandler implementations, all of which are declared in the WebFlux Config: Result Handler Type Return Values Default Order ResponseEntityResultHa ndler ResponseEntity, typically from @Controller instances.0 ServerResponseResultHa ndler ServerResponse, typically from functional endpoints.0 ResponseBodyResultHand ler Handle return values from @ResponseBody methods or @RestController classes.100 ViewResolutionResultHa ndler CharSequence, View, Model, Map, Rendering, or any other Object is treated as a model attribute. See also View Resolution.", "chunk_char_count": 1404, "chunk_word_count": 194, "chunk_token_count": 351.0}, {"page_number": 1119, "sentence_chunk": "Integer. MAX_VALUE Exceptions Web MVC HandlerAdapter implementations can handle internally exceptions from invoking a request handler, such as a controller method. However, an exception may be deferred if the request handler returns an asynchronous value. A HandlerAdapter may expose its exception handling mechanism as a DispatchExceptionHandler set on the HandlerResult it returns. When that\u2019s set, DispatcherHandler will also apply it to the handling of the result. A HandlerAdapter may also choose to implement DispatchExceptionHandler. Inn that case 1119", "chunk_char_count": 559, "chunk_word_count": 78, "chunk_token_count": 139.75}, {"page_number": 1120, "sentence_chunk": "DispatcherHandler will apply it to exceptions that arise before a handler is mapped, e.g. during handler mapping, or earlier, e.g. in a WebFilter. See also Exceptions in the \u201cAnnotated Controller\u201d section or Exceptions in the WebHandler API section. View Resolution Web MVC View resolution enables rendering to a browser with an HTML template and a model without tying you to a specific view technology. In Spring WebFlux, view resolution is supported through a dedicated HandlerResultHandler that uses ViewResolver instances to map a String (representing a logical view name) to a View instance. The View is then used to render the response. Handling Web MVC The HandlerResult passed into ViewResolutionResultHandler contains the return value from the handler and the model that contains attributes added during request handling. The return value is processed as one of the following: \u2022 String, CharSequence: A logical view name to be resolved to a View through the list of configured ViewResolver implementations. \u2022void: Select a default view name based on the request path, minus the leading and trailing slash, and resolve it to a View. The same also happens when a view name was not provided (for example, model attribute was returned) or an async return value (for example, Mono completed empty). \u2022Rendering: API for view resolution scenarios.", "chunk_char_count": 1349, "chunk_word_count": 212, "chunk_token_count": 337.25}, {"page_number": 1120, "sentence_chunk": "Explore the options in your IDE with code completion. \u2022Model, Map: Extra model attributes to be added to the model for the request. \u2022Any other: Any other return value (except for simple types, as determined by BeanUtils#isSimpleProperty) is treated as a model attribute to be added to the model. The attribute name is derived from the class name by using conventions, unless a handler method @ModelAttribute annotation is present. The model can contain asynchronous, reactive types (for example, from Reactor or RxJava). Prior to rendering, AbstractView resolves such model attributes into concrete values and updates the model. Single-value reactive types are resolved to a single value or no value (if empty), while multi-value reactive types (for example, Flux<T>) are collected and resolved to List<T>. To configure view resolution is as simple as adding a ViewResolutionResultHandler bean to your Spring configuration. WebFlux Config provides a dedicated configuration API for view resolution. See View Technologies for more on the view technologies integrated with Spring WebFlux.", "chunk_char_count": 1086, "chunk_word_count": 163, "chunk_token_count": 271.5}, {"page_number": 1121, "sentence_chunk": "Redirecting Web MVC The special redirect: prefix in a view name lets you perform a redirect. The UrlBasedViewResolver (and sub-classes) recognize this as an instruction that a redirect is needed. The rest of the view name is the redirect URL. The net effect is the same as if the controller had returned a RedirectView or Rendering.redirectTo(\"abc\").build(), but now the controller itself can operate in terms of logical view names. A view name such as redirect:/some/resource is relative to the current application, while a view name such as redirect:https://example.com/arbitrary/path redirects to an absolute URL. Content Negotiation Web MVC ViewResolutionResultHandler supports content negotiation. It compares the request media types with the media types supported by each selected View. The first View that supports the requested media type(s) is used. In order to support media types such as JSON and XML, Spring WebFlux provides HttpMessageWriterView, which is a special View that renders through an HttpMessageWriter. Typically, you would configure these as default views through the WebFlux Configuration.", "chunk_char_count": 1115, "chunk_word_count": 164, "chunk_token_count": 278.75}, {"page_number": 1121, "sentence_chunk": "Default views are always selected and used if they match the requested media type.6.1.4. Annotated Controllers Web MVC Spring WebFlux provides an annotation-based programming model, where @Controller and @RestController components use annotations to express request mappings, request input, handle exceptions, and more. Annotated controllers have flexible method signatures and do not have to extend base classes nor implement specific interfaces. The following listing shows a basic example: Java @RestController public class HelloController { \u00a0  @GetMapping(\"/hello\") \u00a0  public String handle() { \u00a0    return \"Hello WebFlux\"; \u00a0  } } 1121", "chunk_char_count": 638, "chunk_word_count": 94, "chunk_token_count": 159.5}, {"page_number": 1122, "sentence_chunk": "Kotlin @RestController class HelloController { \u00a0  @GetMapping(\"/hello\") \u00a0  fun handle() = \"Hello WebFlux\" } In the preceding example, the method returns a String to be written to the response body.@Controller Web MVC You can define controller beans by using a standard Spring bean definition. The @Controller stereotype allows for auto-detection and is aligned with Spring general support for detecting @Component classes in the classpath and auto-registering bean definitions for them. It also acts as a stereotype for the annotated class, indicating its role as a web component. To enable auto-detection of such @Controller beans, you can add component scanning to your Java configuration, as the following example shows: Java @Configuration @ComponentScan(\"org.example.web\") \u2460 public class WebConfig { \u00a0  // ... } \u2460 Scan the org.example.web package. Kotlin @Configuration @ComponentScan(\"org.example.web\") \u2460 class WebConfig { \u00a0  // ... } \u2460 Scan the org.example.web package.@RestController is a composed annotation that is itself meta-annotated with @Controller and @ResponseBody, indicating a controller whose every method inherits the type-level @ResponseBody annotation and, therefore, writes directly to the response body versus view resolution and rendering with an HTML template.1122", "chunk_char_count": 1291, "chunk_word_count": 185, "chunk_token_count": 322.75}, {"page_number": 1123, "sentence_chunk": "AOP Proxies Web MVC In some cases, you may need to decorate a controller with an AOP proxy at runtime. One example is if you choose to have @Transactional annotations directly on the controller. When this is the case, for controllers specifically, we recommend using class-based proxying. This is automatically the case with such annotations directly on the controller. If the controller implements an interface, and needs AOP proxying, you may need to explicitly configure class-based proxying. For example, with @EnableTransactionManagement you can change to @EnableTransactionManagement(proxyTargetClass = true), and with <tx:annotation-driven/> you can change to <tx:annotation-driven proxy-target-class=\"true\"/>.\uf05a Keep in mind that as of 6.0, with interface proxying, Spring WebFlux no longer detects controllers based solely on a type-level @RequestMapping annotation on the interface. Please, enable class based proxying, or otherwise the interface must also have an @Controller annotation. Request Mapping Web MVC The @RequestMapping annotation is used to map requests to controllers methods. It has various attributes to match by URL, HTTP method, request parameters, headers, and media types.", "chunk_char_count": 1202, "chunk_word_count": 169, "chunk_token_count": 300.5}, {"page_number": 1123, "sentence_chunk": "You can use it at the class level to express shared mappings or at the method level to narrow down to a specific endpoint mapping. There are also HTTP method specific shortcut variants of @RequestMapping: \u2022 @GetMapping \u2022 @PostMapping \u2022 @PutMapping \u2022 @DeleteMapping \u2022 @PatchMapping The preceding annotations are Custom Annotations that are provided because, arguably, most controller methods should be mapped to a specific HTTP method versus using @RequestMapping, which, by default, matches to all HTTP methods. At the same time, a @RequestMapping is still needed at the class level to express shared mappings. The following example uses type and method level mappings: 1123", "chunk_char_count": 674, "chunk_word_count": 105, "chunk_token_count": 168.5}, {"page_number": 1124, "sentence_chunk": "Java @RestController @RequestMapping(\"/persons\") class PersonController { \u00a0  @GetMapping(\"/{id}\") \u00a0  public Person getPerson(@PathVariable Long id) { \u00a0    // ... \u00a0  } \u00a0  @PostMapping \u00a0  @ResponseStatus(HttpStatus. CREATED) \u00a0  public void add(@RequestBody Person person) { \u00a0    // ... \u00a0  } } Kotlin @RestController @RequestMapping(\"/persons\") class PersonController { \u00a0  @GetMapping(\"/{id}\") \u00a0  fun getPerson(@PathVariable id: Long): Person { \u00a0    // ... \u00a0  } \u00a0  @PostMapping \u00a0  @ResponseStatus(HttpStatus. CREATED) \u00a0  fun add(@RequestBody person: Person) { \u00a0    // ... \u00a0  } } URI Patterns Web MVC You can map requests by using glob patterns and wildcards: Pattern Description Example ?Matches one character \"/pages/t?st.html\" matches \"/pages/test.html\" and \"/pages/t3st.html\" 1124", "chunk_char_count": 780, "chunk_word_count": 127, "chunk_token_count": 195.0}, {"page_number": 1125, "sentence_chunk": "Pattern Description Example * Matches zero or more characters within a path segment \"/resources/*.png\" matches \"/resources/file.png\" \"/projects/*/versions\" matches \"/projects/spring/versions\" but does not match \"/projects/spring/boot/versions\" ** Matches zero or more path segments until the end of the path \"/resources/**\" matches \"/resources/file.png\" and \"/resources/images/file.png\" \"/resources/**/file.png\" is invalid as ** is only allowed at the end of the path. {name} Matches a path segment and captures it as a variable named \"name\" \"/projects/{project}/versions\" matches \"/projects/spring/versions\" and captures project=spring {name:[a-z]+} Matches the regexp \"[a-z]+\" as a path variable named \"name\" \"/projects/{project:[a-z]+}/versions\" matches \"/projects/spring/versions\" but not \"/projects/spring1/versions\" {*path} Matches zero or more path segments until the end of the path and captures it as a variable named \"path\" \"/resources/{*file}\" matches \"/resources/images/file.png\" and captures file=/images/file.png Captured URI variables can be accessed with @PathVariable, as the following example shows: Java @GetMapping(\"/owners/{ownerId}/pets/{petId}\") public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) { \u00a0  // ... } Kotlin @GetMapping(\"/owners/{ownerId}/pets/{petId}\") fun findPet(@PathVariable ownerId: Long, @PathVariable petId: Long): Pet { \u00a0  // ... } You can declare URI variables at the class and method levels, as the following example shows: 1125", "chunk_char_count": 1494, "chunk_word_count": 181, "chunk_token_count": 373.5}, {"page_number": 1126, "sentence_chunk": "Java @Controller @RequestMapping(\"/owners/{ownerId}\") \u2460 public class OwnerController { \u00a0  @GetMapping(\"/pets/{petId}\") \u2461 \u00a0  public Pet findPet(@PathVariable Long ownerId, @PathVariable Long petId) { \u00a0    // ... \u00a0  } } \u2460 Class-level URI mapping.\u2461 Method-level URI mapping. Kotlin @Controller @RequestMapping(\"/owners/{ownerId}\") \u2460 class OwnerController { \u00a0  @GetMapping(\"/pets/{petId}\") \u2461 \u00a0  fun findPet(@PathVariable ownerId: Long, @PathVariable petId: Long): Pet { \u00a0    // ... \u00a0  } } \u2460 Class-level URI mapping.\u2461 Method-level URI mapping. URI variables are automatically converted to the appropriate type or a TypeMismatchException is raised. Simple types (int, long, Date, and so on) are supported by default and you can register support for any other data type. See Type Conversion and DataBinder. URI variables can be named explicitly (for example, @PathVariable(\"customId\")), but you can leave that detail out if the names are the same and you compile your code with debugging information or with the -parameters compiler flag on Java 8. The syntax {*varName} declares a URI variable that matches zero or more remaining path segments. For example /resources/{*path} matches all files under /resources/, and the \"path\" variable captures the complete path under /resources.", "chunk_char_count": 1275, "chunk_word_count": 192, "chunk_token_count": 318.75}, {"page_number": 1126, "sentence_chunk": "The syntax {varName:regex} declares a URI variable with a regular expression that has the syntax: {varName:regex}. For example, given a URL of /spring-web-3.0.5.jar, the following method extracts the name, version, and file extension: 1126", "chunk_char_count": 239, "chunk_word_count": 34, "chunk_token_count": 59.75}, {"page_number": 1127, "sentence_chunk": "Java @GetMapping(\"/{name:[a-z-]+}-{version:\\\\d\\\\.\\\\d\\\\.\\\\d}{ext:\\\\.[a-z]+}\") public void handle(@PathVariable String version, @PathVariable String ext) { \u00a0  // ... } Kotlin @GetMapping(\"/{name:[a-z-]+}-{version:\\\\d\\\\.\\\\d\\\\.\\\\d}{ext:\\\\.[a-z]+}\") fun handle(@PathVariable version: String, @PathVariable ext: String) { \u00a0  // ... } URI path patterns can also have embedded ${\u2026} placeholders that are resolved on startup through PropertySourcesPlaceholderConfigurer against local, system, environment, and other property sources. You can use this to, for example, parameterize a base URL based on some external configuration.\uf05a Spring WebFlux uses PathPattern and the PathPatternParser for URI path matching support. Both classes are located in spring-web and are expressly designed for use with HTTP URL paths in web applications where a large number of URI path patterns are matched at runtime. Spring WebFlux does not support suffix pattern matching\u2009\u2014\u2009unlike Spring MVC, where a mapping such as /person also matches to /person.*. For URL-based content negotiation, if needed, we recommend using a query parameter, which is simpler, more explicit, and less vulnerable to URL path based exploits. Pattern Comparison Web MVC When multiple patterns match a URL, they must be compared to find the best match. This is done with PathPattern. SPECIFICITY_COMPARATOR, which looks for patterns that are more specific. For every pattern, a score is computed, based on the number of URI variables and wildcards, where a URI variable scores lower than a wildcard.", "chunk_char_count": 1547, "chunk_word_count": 217, "chunk_token_count": 386.75}, {"page_number": 1127, "sentence_chunk": "A pattern with a lower total score wins. If two patterns have the same score, the longer is chosen. Catch-all patterns (for example, **, {*varName}) are excluded from the scoring and are always sorted last instead. If two patterns are both catch-all, the longer is chosen. Consumable Media Types Web MVC You can narrow the request mapping based on the Content-Type of the request, as the following example shows: 1127", "chunk_char_count": 417, "chunk_word_count": 70, "chunk_token_count": 104.25}, {"page_number": 1128, "sentence_chunk": "Java @PostMapping(path = \"/pets\", consumes = \"application/json\") public void addPet(@RequestBody Pet pet) { \u00a0  // ... } Kotlin @PostMapping(\"/pets\", consumes = [\"application/json\"]) fun addPet(@RequestBody pet: Pet) { \u00a0  // ... } The consumes attribute also supports negation expressions\u2009\u2014\u2009for example, !text/plain means any content type other than text/plain. You can declare a shared consumes attribute at the class level. Unlike most other request mapping attributes, however, when used at the class level, a method-level consumes attribute overrides rather than extends the class-level declaration.\uf0eb MediaType provides constants for commonly used media types\u2009\u2014\u2009for example, APPLICATION_JSON_VALUE and APPLICATION_XML_VALUE. Producible Media Types Web MVC You can narrow the request mapping based on the Accept request header and the list of content types that a controller method produces, as the following example shows: Java @GetMapping(path = \"/pets/{petId}\", produces = \"application/json\") @ResponseBody public Pet getPet(@PathVariable String petId) { \u00a0  // ... } Kotlin @GetMapping(\"/pets/{petId}\", produces = [\"application/json\"]) @ResponseBody fun getPet(@PathVariable String petId): Pet { \u00a0  // ... } The media type can specify a character set. Negated expressions are supported\u2009\u2014\u2009for example, 1128", "chunk_char_count": 1310, "chunk_word_count": 179, "chunk_token_count": 327.5}, {"page_number": 1129, "sentence_chunk": "!text/plain means any content type other than text/plain. You can declare a shared produces attribute at the class level. Unlike most other request mapping attributes, however, when used at the class level, a method-level produces attribute overrides rather than extend the class level declaration.\uf0eb MediaType provides constants for commonly used media types\u2009\u2014\u2009e.g. APPLICATION_JSON_VALUE, APPLICATION_XML_VALUE. Parameters and Headers Web MVC You can narrow request mappings based on query parameter conditions. You can test for the presence of a query parameter (myParam), for its absence (!myParam), or for a specific value (myParam=myValue). The following examples tests for a parameter with a value: Java @GetMapping(path = \"/pets/{petId}\", params = \"myParam=myValue\") \u2460 public void findPet(@PathVariable String petId) { \u00a0  // ... } \u2460 Check that myParam equals myValue. Kotlin @GetMapping(\"/pets/{petId}\", params = [\"myParam=myValue\"]) \u2460 fun findPet(@PathVariable petId: String) { \u00a0  // ... } \u2460 Check that myParam equals myValue.", "chunk_char_count": 1034, "chunk_word_count": 147, "chunk_token_count": 258.5}, {"page_number": 1129, "sentence_chunk": "You can also use the same with request header conditions, as the following example shows: Java @GetMapping(path = \"/pets\", headers = \"myHeader=myValue\") \u2460 public void findPet(@PathVariable String petId) { \u00a0  // ... } \u2460 Check that myHeader equals myValue.1129", "chunk_char_count": 258, "chunk_word_count": 40, "chunk_token_count": 64.5}, {"page_number": 1130, "sentence_chunk": "Kotlin @GetMapping(\"/pets\", headers = [\"myHeader=myValue\"]) \u2460 fun findPet(@PathVariable petId: String) { \u00a0  // ... } \u2460 Check that myHeader equals myValue. HTTP HEAD, OPTIONS Web MVC @GetMapping and @RequestMapping(method=HttpMethod. GET) support HTTP HEAD transparently for request mapping purposes. Controller methods need not change. A response wrapper, applied in the HttpHandler server adapter, ensures a Content-Length header is set to the number of bytes written without actually writing to the response. By default, HTTP OPTIONS is handled by setting the Allow response header to the list of HTTP methods listed in all @RequestMapping methods with matching URL patterns. For a @RequestMapping without HTTP method declarations, the Allow header is set to GET,HEAD,POST,PUT,PATCH,DELETE,OPTIONS. Controller methods should always declare the supported HTTP methods (for example, by using the HTTP method specific variants\u2009\u2014\u2009@GetMapping, @PostMapping, and others). You can explicitly map a @RequestMapping method to HTTP HEAD and HTTP OPTIONS, but that is not necessary in the common case. Custom Annotations Web MVC Spring WebFlux supports the use of composed annotations for request mapping.", "chunk_char_count": 1196, "chunk_word_count": 170, "chunk_token_count": 299.0}, {"page_number": 1130, "sentence_chunk": "Those are annotations that are themselves meta-annotated with @RequestMapping and composed to redeclare a subset (or all) of the @RequestMapping attributes with a narrower, more specific purpose.@GetMapping, @PostMapping, @PutMapping, @DeleteMapping, and @PatchMapping are examples of composed annotations. They are provided, because, arguably, most controller methods should be mapped to a specific HTTP method versus using @RequestMapping, which, by default, matches to all HTTP methods. If you need an example of composed annotations, look at how those are declared. Spring WebFlux also supports custom request mapping attributes with custom request matching logic. This is a more advanced option that requires sub-classing RequestMappingHandlerMapping and overriding the getCustomMethodCondition method, where you can check the custom attribute and return your own RequestCondition. Explicit Registrations Web MVC You can programmatically register Handler methods, which can be used for dynamic registrations 1130", "chunk_char_count": 1017, "chunk_word_count": 136, "chunk_token_count": 254.25}, {"page_number": 1131, "sentence_chunk": "or for advanced cases, such as different instances of the same handler under different URLs. The following example shows how to do so: Java @Configuration public class MyConfig { \u00a0  @Autowired \u00a0  public void setHandlerMapping(RequestMappingHandlerMapping mapping, UserHandler handler) \u2460 \u00a0      throws NoSuchMethodException { \u00a0    RequestMappingInfo info = RequestMappingInfo \u00a0        .paths(\"/user/{id}\").methods(RequestMethod. GET).build(); \u2461 \u00a0    Method method = UserHandler.class.getMethod(\"getUser\", Long.class); \u2462 \u00a0    mapping.registerMapping(info, handler, method); \u2463 \u00a0  } } \u2460 Inject target handlers and the handler mapping for controllers.\u2461 Prepare the request mapping metadata.\u2462 Get the handler method.\u2463 Add the registration. Kotlin @Configuration class MyConfig { \u00a0  @Autowired \u00a0  fun setHandlerMapping(mapping: RequestMappingHandlerMapping, handler: UserHandler) { \u2460 \u00a0    val info = RequestMappingInfo.paths(\"/user/{id}\").methods(RequestMethod. GET).build() \u2461 \u00a0    val method = UserHandler::class.java.getMethod(\"getUser\", Long::class.java) \u2462 \u00a0    mapping.registerMapping(info, handler, method) \u2463 \u00a0  } } \u2460 Inject target handlers and the handler mapping for controllers.\u2461 Prepare the request mapping metadata.1131", "chunk_char_count": 1222, "chunk_word_count": 177, "chunk_token_count": 305.5}, {"page_number": 1132, "sentence_chunk": "\u2462 Get the handler method.\u2463 Add the registration. Handler Methods Web MVC @RequestMapping handler methods have a flexible signature and can choose from a range of supported controller method arguments and return values. Method Arguments Web MVC The following table shows the supported controller method arguments. Reactive types (Reactor, RxJava, or other) are supported on arguments that require blocking I/O (for example, reading the request body) to be resolved. This is marked in the Description column. Reactive types are not expected on arguments that do not require blocking. JDK 1.8\u2019s java.util. Optional is supported as a method argument in combination with annotations that have a required attribute (for example, @RequestParam, @RequestHeader, and others) and is equivalent to required=false. Controller method argument Description ServerWebExchange Access to the full ServerWebExchange\u2009\u2014\u2009container for the HTTP request and response, request and session attributes, checkNotModified methods, and others.", "chunk_char_count": 1013, "chunk_word_count": 142, "chunk_token_count": 253.25}, {"page_number": 1132, "sentence_chunk": "ServerHttpRequest, ServerHttpResponse Access to the HTTP request or response. WebSession Access to the session. This does not force the start of a new session unless attributes are added. Supports reactive types.java.security. Principal The currently authenticated user\u2009\u2014\u2009possibly a specific Principal implementation class if known. Supports reactive types.org.springframework.http. HttpM ethod The HTTP method of the request.java.util.", "chunk_char_count": 436, "chunk_word_count": 54, "chunk_token_count": 109.0}, {"page_number": 1132, "sentence_chunk": "Locale The current request locale, determined by the most specific LocaleResolver available\u2009\u2014\u2009in effect, the configured LocaleResolver/LocaleContextResolver.java.util. TimeZone + java.time. ZoneId The time zone associated with the current request, as determined by a LocaleContextResolver.@PathVariable For access to URI template variables. See URI Patterns.@MatrixVariable For access to name-value pairs in URI path segments. See Matrix Variables.1132", "chunk_char_count": 452, "chunk_word_count": 54, "chunk_token_count": 113.0}, {"page_number": 1133, "sentence_chunk": "Controller method argument Description @RequestParam For access to query parameters. Parameter values are converted to the declared method argument type. See @RequestParam. Note that use of @RequestParam is optional\u2009\u2014\u2009for example, to set its attributes. See \u201cAny other argument\u201d later in this table.@RequestHeader For access to request headers. Header values are converted to the declared method argument type. See @RequestHeader.@CookieValue For access to cookies. Cookie values are converted to the declared method argument type.", "chunk_char_count": 531, "chunk_word_count": 73, "chunk_token_count": 132.75}, {"page_number": 1133, "sentence_chunk": "See @CookieValue.@RequestBody For access to the HTTP request body. Body content is converted to the declared method argument type by using HttpMessageReader instances. Supports reactive types. See @RequestBody. HttpEntity<B> For access to request headers and body. The body is converted with HttpMessageReader instances. Supports reactive types. See HttpEntity.@RequestPart For access to a part in a multipart/form-data request.", "chunk_char_count": 428, "chunk_word_count": 57, "chunk_token_count": 107.0}, {"page_number": 1133, "sentence_chunk": "Supports reactive types. See Multipart Content and Multipart Data.java.util. Map, org.springframework.ui. Model, and org.springframework.ui. ModelMa p. For access to the model that is used in HTML controllers and is exposed to templates as part of view rendering.@ModelAttribute For access to an existing attribute in the model (instantiated if not present) with data binding and validation applied. See @ModelAttribute as well as Model and DataBinder. Note that use of @ModelAttribute is optional\u2009\u2014\u2009for example, to set its attributes. See \u201cAny other argument\u201d later in this table.", "chunk_char_count": 581, "chunk_word_count": 84, "chunk_token_count": 145.25}, {"page_number": 1133, "sentence_chunk": "Errors, BindingResult For access to errors from validation and data binding for a command object, i.e. a @ModelAttribute argument. An Errors, or BindingResult argument must be declared immediately after the validated method argument. SessionStatus + class-level @SessionAttributes For marking form processing complete, which triggers cleanup of session attributes declared through a class-level @SessionAttributes annotation. See @SessionAttributes for more details. UriComponentsBuilder For preparing a URL relative to the current request\u2019s host, port, scheme, and context path. See URI Links.@SessionAttribute For access to any session attribute\u2009\u2014\u2009in contrast to model attributes stored in the session as a result of a class-level @SessionAttributes declaration. See @SessionAttribute for more details.1133", "chunk_char_count": 808, "chunk_word_count": 105, "chunk_token_count": 202.0}, {"page_number": 1134, "sentence_chunk": "Controller method argument Description @RequestAttribute For access to request attributes. See @RequestAttribute for more details. Any other argument If a method argument is not matched to any of the above, it is, by default, resolved as a @RequestParam if it is a simple type, as determined by BeanUtils#isSimpleProperty, or as a @ModelAttribute, otherwise. Return Values Web MVC The following table shows the supported controller method return values. Note that reactive types from libraries such as Reactor, RxJava, or other are generally supported for all return values. Controller method return value Description @ResponseBody The return value is encoded through HttpMessageWriter instances and written to the response. See @ResponseBody. HttpEntity<B>, ResponseEntity<B> The return value specifies the full response, including HTTP headers, and the body is encoded through HttpMessageWriter instances and written to the response. See ResponseEntity. HttpHeaders For returning a response with headers and no body.", "chunk_char_count": 1018, "chunk_word_count": 144, "chunk_token_count": 254.5}, {"page_number": 1134, "sentence_chunk": "ErrorResponse To render an RFC 7807 error response with details in the body, see Error Responses ProblemDetail To render an RFC 7807 error response with details in the body, see Error Responses String A view name to be resolved with ViewResolver instances and used together with the implicit model\u2009\u2014\u2009determined through command objects and @ModelAttribute methods. The handler method can also programmatically enrich the model by declaring a Model argument (described earlier). View A View instance to use for rendering together with the implicit model\u2009\u2014\u2009determined through command objects and @ModelAttribute methods. The handler method can also programmatically enrich the model by declaring a Model argument (described earlier).java.util. Map, org.springframework.ui. Model Attributes to be added to the implicit model, with the view name implicitly determined based on the request path.@ModelAttribute An attribute to be added to the model, with the view name implicitly determined based on the request path. Note that @ModelAttribute is optional. See \u201cAny other return value\u201d later in this table.", "chunk_char_count": 1100, "chunk_word_count": 161, "chunk_token_count": 275.0}, {"page_number": 1135, "sentence_chunk": "Controller method return value Description Rendering An API for model and view rendering scenarios.void A method with a void, possibly asynchronous (for example, Mono<Void>), return type (or a null return value) is considered to have fully handled the response if it also has a ServerHttpResponse, a ServerWebExchange argument, or an @ResponseStatus annotation. The same is also true if the controller has made a positive ETag or lastModified timestamp check. //TODO: See Controllers for details. If none of the above is true, a void return type can also indicate \u201cno response body\u201d for REST controllers or default view name selection for HTML controllers. Flux<ServerSentEvent>, Observable<ServerSentEvent>, or other reactive type Emit server-sent events. The ServerSentEvent wrapper can be omitted when only data needs to be written (however, text/event-stream must be requested or declared in the mapping through the produces attribute). Other return values If a return value remains unresolved in any other way, it is treated as a model attribute, unless it is a simple type as determined by BeanUtils#isSimpleProperty, in which case it remains unresolved. Type Conversion Web MVC Some annotated controller method arguments that represent String-based request input (for example, @RequestParam, @RequestHeader, @PathVariable, @MatrixVariable, and @CookieValue) can require type conversion if the argument is declared as something other than String. For such cases, type conversion is automatically applied based on the configured converters.", "chunk_char_count": 1545, "chunk_word_count": 223, "chunk_token_count": 386.25}, {"page_number": 1135, "sentence_chunk": "By default, simple types (such as int, long, Date, and others) are supported. Type conversion can be customized through a WebDataBinder (see DataBinder) or by registering Formatters with the FormattingConversionService (see Spring Field Formatting). A practical issue in type conversion is the treatment of an empty String source value. Such a value is treated as missing if it becomes null as a result of type conversion. This can be the case for Long, UUID, and other target types. If you want to allow null to be injected, either use the required flag on the argument annotation, or declare the argument as @Nullable. Matrix Variables Web MVC RFC 3986 discusses name-value pairs in path segments. In Spring WebFlux, we refer to those as \u201cmatrix variables\u201d based on an \u201cold post\u201d by Tim Berners-Lee, but they can be also be referred to as URI path parameters.1135", "chunk_char_count": 865, "chunk_word_count": 144, "chunk_token_count": 216.25}, {"page_number": 1136, "sentence_chunk": "Matrix variables can appear in any path segment, with each variable separated by a semicolon and multiple values separated by commas\u2009\u2014\u2009for example, \"/cars;color=red,green;year=2012\". Multiple values can also be specified through repeated variable names\u2009\u2014\u2009for example, \"color=red;color=green;color=blue\". Unlike Spring MVC, in WebFlux, the presence or absence of matrix variables in a URL does not affect request mappings. In other words, you are not required to use a URI variable to mask variable content. That said, if you want to access matrix variables from a controller method, you need to add a URI variable to the path segment where matrix variables are expected. The following example shows how to do so: Java // GET /pets/42;q=11;r=22 @GetMapping(\"/pets/{petId}\") public void findPet(@PathVariable String petId, @MatrixVariable int q) { \u00a0  // petId == 42 \u00a0  // q == 11 } Kotlin // GET /pets/42;q=11;r=22 @GetMapping(\"/pets/{petId}\") fun findPet(@PathVariable petId: String, @MatrixVariable q: Int) { \u00a0  // petId == 42 \u00a0  // q == 11 } Given that all path segments can contain matrix variables, you may sometimes need to disambiguate which path variable the matrix variable is expected to be in, as the following example shows: Java // GET /owners/42;q=11/pets/21;q=22 @GetMapping(\"/owners/{ownerId}/pets/{petId}\") public void findPet( \u00a0    @MatrixVariable(name=\"q\", pathVar=\"ownerId\") int q1, \u00a0    @MatrixVariable(name=\"q\", pathVar=\"petId\") int q2) { \u00a0  // q1 == 11 \u00a0  // q2 == 22 } 1136", "chunk_char_count": 1495, "chunk_word_count": 231, "chunk_token_count": 373.75}, {"page_number": 1137, "sentence_chunk": "Kotlin @GetMapping(\"/owners/{ownerId}/pets/{petId}\") fun findPet( \u00a0    @MatrixVariable(name = \"q\", pathVar = \"ownerId\") q1: Int, \u00a0    @MatrixVariable(name = \"q\", pathVar = \"petId\") q2: Int) { \u00a0  // q1 == 11 \u00a0  // q2 == 22 } You can define a matrix variable may be defined as optional and specify a default value as the following example shows: Java // GET /pets/42 @GetMapping(\"/pets/{petId}\") public void findPet(@MatrixVariable(required=false, defaultValue=\"1\") int q) { \u00a0  // q == 1 } Kotlin // GET /pets/42 @GetMapping(\"/pets/{petId}\") fun findPet(@MatrixVariable(required = false, defaultValue = \"1\") q: Int) { \u00a0  // q == 1 } To get all matrix variables, use a MultiValueMap, as the following example shows: 1137", "chunk_char_count": 717, "chunk_word_count": 118, "chunk_token_count": 179.25}, {"page_number": 1138, "sentence_chunk": "Java // GET /owners/42;q=11;r=12/pets/21;q=22;s=23 @GetMapping(\"/owners/{ownerId}/pets/{petId}\") public void findPet( \u00a0    @MatrixVariable MultiValueMap<String, String> matrixVars, \u00a0    @MatrixVariable(pathVar=\"petId\") MultiValueMap<String, String> petMatrixVars) { \u00a0  // matrixVars: [\"q\" : [11,22], \"r\" : 12, \"s\" : 23] \u00a0  // petMatrixVars: [\"q\" : 22, \"s\" : 23] } Kotlin // GET /owners/42;q=11;r=12/pets/21;q=22;s=23 @GetMapping(\"/owners/{ownerId}/pets/{petId}\") fun findPet( \u00a0    @MatrixVariable matrixVars: MultiValueMap<String, String>, \u00a0    @MatrixVariable(pathVar=\"petId\") petMatrixVars: MultiValueMap<String, String>) { \u00a0  // matrixVars: [\"q\" : [11,22], \"r\" : 12, \"s\" : 23] \u00a0  // petMatrixVars: [\"q\" : 22, \"s\" : 23] } @RequestParam Web MVC You can use the @RequestParam annotation to bind query parameters to a method argument in a controller. The following code snippet shows the usage: 1138", "chunk_char_count": 898, "chunk_word_count": 125, "chunk_token_count": 224.5}, {"page_number": 1139, "sentence_chunk": "Java @Controller @RequestMapping(\"/pets\") public class EditPetForm { \u00a0  // ... \u00a0  @GetMapping \u00a0  public String setupForm(@RequestParam(\"petId\") int petId, Model model) { \u2460 \u00a0    Pet pet = this.clinic.loadPet(petId); \u00a0    model.addAttribute(\"pet\", pet); \u00a0    return \"petForm\"; \u00a0  } \u00a0  // ... } \u2460 Using @RequestParam. Kotlin import org.springframework.ui.set @Controller @RequestMapping(\"/pets\") class EditPetForm { \u00a0  // ... \u00a0  @GetMapping \u00a0  fun setupForm(@RequestParam(\"petId\") petId: Int, model: Model): String { \u2460 \u00a0    val pet = clinic.loadPet(petId) \u00a0    model[\"pet\"] = pet \u00a0    return \"petForm\" \u00a0  } \u00a0  // ... } \u2460 Using @RequestParam.\uf0eb The Servlet API \u201crequest parameter\u201d concept conflates query parameters, form data, and multiparts into one. However, in WebFlux, each is accessed individually through ServerWebExchange. While @RequestParam binds to query parameters only, you can use data binding to apply query parameters, form data, and multiparts to a command object. Method parameters that use the @RequestParam annotation are required by default, but you can specify that a method parameter is optional by setting the required flag of a @RequestParam to false 1139", "chunk_char_count": 1175, "chunk_word_count": 194, "chunk_token_count": 293.75}, {"page_number": 1140, "sentence_chunk": "or by declaring the argument with a java.util. Optional wrapper. Type conversion is applied automatically if the target method parameter type is not String. See Type Conversion. When a @RequestParam annotation is declared on a Map<String, String> or MultiValueMap<String, String> argument, the map is populated with all query parameters. Note that use of @RequestParam is optional\u2009\u2014\u2009for example, to set its attributes. By default, any argument that is a simple value type (as determined by BeanUtils#isSimpleProperty) and is not resolved by any other argument resolver is treated as if it were annotated with @RequestParam.@RequestHeader Web MVC You can use the @RequestHeader annotation to bind a request header to a method argument in a controller. The following example shows a request with headers: Host          localhost:8080 Accept         text/html,application/xhtml+xml,application/xml;q=0.9 Accept-Language     fr,en-gb;q=0.7,en;q=0.3 Accept-Encoding     gzip,deflate Accept-Charset     ISO-8859-1,utf-8;q=0.7,*;q=0.7 Keep-Alive       300 The following example gets the value of the Accept-Encoding and Keep-Alive headers: Java @GetMapping(\"/demo\") public void handle( \u00a0    @RequestHeader(\"Accept-Encoding\") String encoding, \u2460 \u00a0    @RequestHeader(\"Keep-Alive\") long keepAlive) { \u2461 \u00a0  //... } \u2460 Get the value of the Accept-Encoding header.\u2461 Get the value of the Keep-Alive header.", "chunk_char_count": 1389, "chunk_word_count": 221, "chunk_token_count": 347.25}, {"page_number": 1141, "sentence_chunk": "Kotlin @GetMapping(\"/demo\") fun handle( \u00a0    @RequestHeader(\"Accept-Encoding\") encoding: String, \u2460 \u00a0    @RequestHeader(\"Keep-Alive\") keepAlive: Long) { \u2461 \u00a0  //... } \u2460 Get the value of the Accept-Encoding header.\u2461 Get the value of the Keep-Alive header. Type conversion is applied automatically if the target method parameter type is not String. See Type Conversion. When a @RequestHeader annotation is used on a Map<String, String>, MultiValueMap<String, String>, or HttpHeaders argument, the map is populated with all header values.\uf0eb Built-in support is available for converting a comma-separated string into an array or collection of strings or other types known to the type conversion system. For example, a method parameter annotated with @RequestHeader(\"Accept\") may be of type String but also of String[] or List<String>.@CookieValue Web MVC You can use the @CookieValue annotation to bind the value of an HTTP cookie to a method argument in a controller. The following example shows a request with a cookie: JSESSIONID=415A4AC178C59DACE0B2C9CA727CDD84 The following code sample demonstrates how to get the cookie value: Java @GetMapping(\"/demo\") public void handle(@CookieValue(\"JSESSIONID\") String cookie) { \u2460 \u00a0  //... } \u2460 Get the cookie value.1141", "chunk_char_count": 1256, "chunk_word_count": 186, "chunk_token_count": 314.0}, {"page_number": 1142, "sentence_chunk": "Kotlin @GetMapping(\"/demo\") fun handle(@CookieValue(\"JSESSIONID\") cookie: String) { \u2460 \u00a0  //... } \u2460 Get the cookie value. Type conversion is applied automatically if the target method parameter type is not String. See Type Conversion.@ModelAttribute Web MVC You can use the @ModelAttribute annotation on a method argument to access an attribute from the model or have it instantiated if not present. The model attribute is also overlaid with the values of query parameters and form fields whose names match to field names. This is referred to as data binding, and it saves you from having to deal with parsing and converting individual query parameters and form fields. The following example binds an instance of Pet: Java @PostMapping(\"/owners/{ownerId}/pets/{petId}/edit\") public String processSubmit(@ModelAttribute Pet pet) { } \u2460 \u2460 Bind an instance of Pet. Kotlin @PostMapping(\"/owners/{ownerId}/pets/{petId}/edit\") fun processSubmit(@ModelAttribute pet: Pet): String { } \u2460 \u2460 Bind an instance of Pet. The Pet instance in the preceding example is resolved as follows: \u2022 From the model if already added through Model. \u2022From the HTTP session through @SessionAttributes. \u2022", "chunk_char_count": 1171, "chunk_word_count": 173, "chunk_token_count": 292.75}, {"page_number": 1142, "sentence_chunk": "From the invocation of a default constructor. \u2022From the invocation of a \u201cprimary constructor\u201d with arguments that match query parameters or form fields. Argument names are determined through JavaBeans @ConstructorProperties or through runtime-retained parameter names in the bytecode. After the model attribute instance is obtained, data binding is applied. The WebExchangeDataBinder class matches names of query parameters and form fields to field names on the target Object. Matching fields are populated after type conversion is applied where necessary. For more on data binding (and validation), see Validation. For more on customizing data binding, see DataBinder.1142", "chunk_char_count": 673, "chunk_word_count": 95, "chunk_token_count": 168.25}, {"page_number": 1143, "sentence_chunk": "Data binding can result in errors. By default, a WebExchangeBindException is raised, but, to check for such errors in the controller method, you can add a BindingResult argument immediately next to the @ModelAttribute, as the following example shows: Java @PostMapping(\"/owners/{ownerId}/pets/{petId}/edit\") public String processSubmit(@ModelAttribute(\"pet\") Pet pet, BindingResult result) { \u2460 \u00a0  if (result.hasErrors()) { \u00a0    return \"petForm\"; \u00a0  } \u00a0  // ... } \u2460 Adding a BindingResult. Kotlin @PostMapping(\"/owners/{ownerId}/pets/{petId}/edit\") fun processSubmit(@ModelAttribute(\"pet\") pet: Pet, result: BindingResult): String { \u2460 \u00a0  if (result.hasErrors()) { \u00a0    return \"petForm\" \u00a0  } \u00a0  // ... } \u2460 Adding a BindingResult. You can automatically apply validation after data binding by adding the jakarta.validation. Valid annotation or Spring\u2019s @Validated annotation (see also Bean Validation and Spring validation). The following example uses the @Valid annotation: Java @PostMapping(\"/owners/{ownerId}/pets/{petId}/edit\") public String processSubmit(@Valid @ModelAttribute(\"pet\") Pet pet, BindingResult result) { \u2460 \u00a0  if (result.hasErrors()) { \u00a0    return \"petForm\"; \u00a0  } \u00a0  // ... } \u2460 Using @Valid on a model attribute argument.1143", "chunk_char_count": 1239, "chunk_word_count": 177, "chunk_token_count": 309.75}, {"page_number": 1144, "sentence_chunk": "Kotlin @PostMapping(\"/owners/{ownerId}/pets/{petId}/edit\") fun processSubmit(@Valid @ModelAttribute(\"pet\") pet: Pet, result: BindingResult): String { \u2460 \u00a0  if (result.hasErrors()) { \u00a0    return \"petForm\" \u00a0  } \u00a0  // ... } \u2460 Using @Valid on a model attribute argument. Spring WebFlux, unlike Spring MVC, supports reactive types in the model\u2009\u2014\u2009for example, Mono<Account> or io.reactivex. Single<Account>. You can declare a @ModelAttribute argument with or without a reactive type wrapper, and it will be resolved accordingly, to the actual value if necessary. However, note that, to use a BindingResult argument, you must declare the @ModelAttribute argument before it without a reactive type wrapper, as shown earlier. Alternatively, you can handle any errors through the reactive type, as the following example shows: Java @PostMapping(\"/owners/{ownerId}/pets/{petId}/edit\") public Mono<String> processSubmit(@Valid @ModelAttribute(\"pet\") Mono<Pet> petMono) { \u00a0  return petMono \u00a0    .flatMap(pet -> { \u00a0      // ... \u00a0    }) \u00a0    .onErrorResume(ex -> { \u00a0      // ... \u00a0    }); } Kotlin @PostMapping(\"/owners/{ownerId}/pets/{petId}/edit\") fun processSubmit(@Valid @ModelAttribute(\"pet\") petMono: Mono<Pet>): Mono<String> { \u00a0  return petMono \u00a0      .flatMap { pet -> \u00a0        // ... \u00a0      } \u00a0      .onErrorResume{ ex -> \u00a0        // ... \u00a0      } } Note that use of @ModelAttribute is optional\u2009\u2014\u2009for example, to set its attributes. By default, any argument that is not a simple value type( as determined by BeanUtils#isSimpleProperty) and is not resolved by any other argument resolver is treated as if it were annotated with @ModelAttribute.1144", "chunk_char_count": 1638, "chunk_word_count": 285, "chunk_token_count": 409.5}, {"page_number": 1145, "sentence_chunk": "@SessionAttributes Web MVC @SessionAttributes is used to store model attributes in the WebSession between requests. It is a type- level annotation that declares session attributes used by a specific controller. This typically lists the names of model attributes or types of model attributes that should be transparently stored in the session for subsequent requests to access. Consider the following example: Java @Controller @SessionAttributes(\"pet\") \u2460 public class EditPetForm { \u00a0  // ... } \u2460 Using the @SessionAttributes annotation. Kotlin @Controller @SessionAttributes(\"pet\") \u2460 class EditPetForm { \u00a0  // ... } \u2460 Using the @SessionAttributes annotation. On the first request, when a model attribute with the name, pet, is added to the model, it is automatically promoted to and saved in the WebSession. It remains there until another controller method uses a SessionStatus method argument to clear the storage, as the following example shows: 1145", "chunk_char_count": 951, "chunk_word_count": 144, "chunk_token_count": 237.75}, {"page_number": 1146, "sentence_chunk": "Java @Controller @SessionAttributes(\"pet\") \u2460 public class EditPetForm { \u00a0  // ... \u00a0  @PostMapping(\"/pets/{id}\") \u00a0  public String handle(Pet pet, BindingResult errors, SessionStatus status) { \u2461 \u00a0    if (errors.hasErrors()) { \u00a0      // ... \u00a0    } \u00a0      status.setComplete(); \u00a0      // ... \u00a0    } \u00a0  } } \u2460 Using the @SessionAttributes annotation.\u2461 Using a SessionStatus variable. Kotlin @Controller @SessionAttributes(\"pet\") \u2460 class EditPetForm { \u00a0  // ... \u00a0  @PostMapping(\"/pets/{id}\") \u00a0  fun handle(pet: Pet, errors: BindingResult, status: SessionStatus): String { \u2461 \u00a0    if (errors.hasErrors()) { \u00a0      // ... \u00a0    } \u00a0    status.setComplete() \u00a0    // ... \u00a0  } } \u2460 Using the @SessionAttributes annotation.\u2461 Using a SessionStatus variable.@SessionAttribute Web MVC If you need access to pre-existing session attributes that are managed globally (that is, outside the controller\u2009\u2014\u2009for example, by a filter) and may or may not be present, you can use the @SessionAttribute annotation on a method parameter, as the following example shows: 1146", "chunk_char_count": 1041, "chunk_word_count": 196, "chunk_token_count": 260.25}, {"page_number": 1147, "sentence_chunk": "Java @GetMapping(\"/\") public String handle(@SessionAttribute User user) { \u2460 \u00a0  // ... } \u2460 Using @SessionAttribute. Kotlin @GetMapping(\"/\") fun handle(@SessionAttribute user: User): String { \u2460 \u00a0  // ... } \u2460 Using @SessionAttribute. For use cases that require adding or removing session attributes, consider injecting WebSession into the controller method. For temporary storage of model attributes in the session as part of a controller workflow, consider using SessionAttributes, as described in @SessionAttributes.@RequestAttribute Web MVC Similarly to @SessionAttribute, you can use the @RequestAttribute annotation to access pre-existing request attributes created earlier (for example, by a WebFilter), as the following example shows: Java @GetMapping(\"/\") public String handle(@RequestAttribute Client client) { \u2460 \u00a0  // ... } \u2460 Using @RequestAttribute. Kotlin @GetMapping(\"/\") fun handle(@RequestAttribute client: Client): String { \u2460 \u00a0  // ... } \u2460 Using @RequestAttribute.1147", "chunk_char_count": 981, "chunk_word_count": 135, "chunk_token_count": 245.25}, {"page_number": 1148, "sentence_chunk": "Multipart Content Web MVC As explained in Multipart Data, ServerWebExchange provides access to multipart content. The best way to handle a file upload form (for example, from a browser) in a controller is through data binding to a command object, as the following example shows: Java class MyForm { \u00a0  private String name; \u00a0  private MultipartFile file; \u00a0  // ... } @Controller public class FileUploadController { \u00a0  @PostMapping(\"/form\") \u00a0  public String handleFormUpload(MyForm form, BindingResult errors) { \u00a0    // ... \u00a0  } } Kotlin class MyForm( \u00a0    val name: String, \u00a0    val file: MultipartFile) @Controller class FileUploadController { \u00a0  @PostMapping(\"/form\") \u00a0  fun handleFormUpload(form: MyForm, errors: BindingResult): String { \u00a0    // ... \u00a0  } } You can also submit multipart requests from non-browser clients in a RESTful service scenario. The following example uses a file along with JSON: 1148", "chunk_char_count": 909, "chunk_word_count": 158, "chunk_token_count": 227.25}, {"page_number": 1149, "sentence_chunk": "POST /someUrl Content-Type: multipart/mixed --edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp Content-Disposition: form-data; name=\"meta-data\" Content-Type: application/json; charset=UTF-8 Content-Transfer-Encoding: 8bit { \u00a0  \"name\": \"value\" } --edt7Tfrdusa7r3lNQc79vXuhIIMlatb7PQg7Vp Content-Disposition: form-data; name=\"file-data\"; filename=\"file.properties\" Content-Type: text/xml Content-Transfer-Encoding: 8bit ... File Data ... You can access individual parts with @RequestPart, as the following example shows: Java @PostMapping(\"/\") public String handle(@RequestPart(\"meta-data\") Part metadata, \u2460 \u00a0    @RequestPart(\"file-data\") FilePart file) { \u2461 \u00a0  // ... } \u2460 Using @RequestPart to get the metadata.\u2461 Using @RequestPart to get the file. Kotlin @PostMapping(\"/\") fun handle(@RequestPart(\"meta-data\") Part metadata, \u2460 \u00a0    @RequestPart(\"file-data\") FilePart file): String { \u2461 \u00a0  // ... } \u2460 Using @RequestPart to get the metadata.\u2461 Using @RequestPart to get the file. To deserialize the raw part content (for example, to JSON\u2009\u2014\u2009similar to @RequestBody), you can declare a concrete target Object, instead of Part, as the following example shows: 1149", "chunk_char_count": 1146, "chunk_word_count": 142, "chunk_token_count": 286.5}, {"page_number": 1150, "sentence_chunk": "Java @PostMapping(\"/\") public String handle(@RequestPart(\"meta-data\") MetaData metadata) { \u2460 \u00a0  // ... } \u2460 Using @RequestPart to get the metadata. Kotlin @PostMapping(\"/\") fun handle(@RequestPart(\"meta-data\") metadata: MetaData): String { \u2460 \u00a0  // ... } \u2460 Using @RequestPart to get the metadata. You can use @RequestPart in combination with jakarta.validation. Valid or Spring\u2019s @Validated annotation, which causes Standard Bean Validation to be applied. Validation errors lead to a WebExchangeBindException that results in a 400 (BAD_REQUEST) response. The exception contains a BindingResult with the error details and can also be handled in the controller method by declaring the argument with an async wrapper and then using error related operators: Java @PostMapping(\"/\") public String handle(@Valid @RequestPart(\"meta-data\") Mono<MetaData> metadata) { \u00a0  // use one of the onError* operators... } Kotlin @PostMapping(\"/\") fun handle(@Valid @RequestPart(\"meta-data\") metadata: MetaData): String { \u00a0  // ... } To access all multipart data as a MultiValueMap, you can use @RequestBody, as the following example shows: Java @PostMapping(\"/\") public String handle(@RequestBody Mono<MultiValueMap<String, Part>> parts) { \u2460 \u00a0  // ... } \u2460 Using @RequestBody.1150", "chunk_char_count": 1258, "chunk_word_count": 176, "chunk_token_count": 314.5}, {"page_number": 1151, "sentence_chunk": "Kotlin @PostMapping(\"/\") fun handle(@RequestBody parts: MultiValueMap<String, Part>): String { \u2460 \u00a0  // ... } \u2460 Using @RequestBody. PartEvent To access multipart data sequentially, in a streaming fashion, you can use @RequestBody with Flux<PartEvent> (or Flow<PartEvent> in Kotlin). Each part in a multipart HTTP message will produce at least one PartEvent containing both headers and a buffer with the contents of the part. \u2022Form fields will produce a single FormPartEvent, containing the value of the field. \u2022File uploads will produce one or more FilePartEvent objects, containing the filename used when uploading. If the file is large enough to be split across multiple buffers, the first FilePartEvent will be followed by subsequent events. For example: Java @PostMapping(\"/\") public void handle(@RequestBody Flux<PartEvent> allPartsEvents) { \u2460 \u00a0  allPartsEvents.windowUntil(PartEvent::isLast) \u2461 \u00a0      .concatMap(p -> p.switchOnFirst((signal, partEvents) -> { \u2462 \u00a0        if (signal.hasValue()) { \u00a0          PartEvent event = signal.get(); \u00a0          if (event instanceof FormPartEvent formEvent) { \u2463 \u00a0            String value = formEvent.value(); \u00a0            // handle form field \u00a0          } \u00a0          else if (event instanceof FilePartEvent fileEvent) { \u2464 \u00a0            String filename = fileEvent.filename(); \u00a0            Flux<DataBuffer> contents = partEvents.map(PartEvent::content); \u2465 \u00a0            // handle file upload \u00a0          } \u00a0          else { \u00a0            return Mono.error(new RuntimeException(\"Unexpected event: \" + event)); \u00a0          } \u00a0        } \u00a0        else { \u00a0          return partEvents; // either complete or error signal \u00a0        } \u00a0      })); } 1151", "chunk_char_count": 1680, "chunk_word_count": 400, "chunk_token_count": 420.0}, {"page_number": 1152, "sentence_chunk": "\u2460 Using @RequestBody.\u2461 The final PartEvent for a particular part will have isLast() set to true, and can be followed by additional events belonging to subsequent parts. This makes the isLast property suitable as a predicate for the Flux::windowUntil operator, to split events from all parts into windows that each belong to a single part.\u2462 The Flux::switchOnFirst operator allows you to see whether you are handling a form field or file upload.\u2463 Handling the form field.\u2464 Handling the file upload.\u2465 The body contents must be completely consumed, relayed, or released to avoid memory leaks. Kotlin \u00a0  @PostMapping(\"/\") \u00a0  fun handle(@RequestBody allPartsEvents: Flux<PartEvent>) = { \u2460 \u00a0   allPartsEvents.windowUntil(PartEvent::isLast) \u2461 \u00a0     .concatMap { \u00a0       it.switchOnFirst { signal, partEvents -> \u2462 \u00a0         if (signal.hasValue()) { \u00a0           val event = signal.get() \u00a0           if (event is FormPartEvent) { \u2463 \u00a0             val value: String = event.value(); \u00a0             // handle form field \u00a0           } else if (event is FilePartEvent) { \u2464 \u00a0             val filename: String = event.filename(); \u00a0             val contents: Flux<DataBuffer> = partEvents.map(PartEvent::content); \u2465 \u00a0             // handle file upload \u00a0           } else { \u00a0             return Mono.error(RuntimeException(\"Unexpected event: \" + event)); \u00a0           } \u00a0         } else { \u00a0           return partEvents; // either complete or error signal \u00a0         } \u00a0       } \u00a0     } } \u2460 Using @RequestBody.\u2461 The final PartEvent for a particular part will have isLast() set to true, and can be followed by additional events belonging to subsequent parts. This makes the isLast property suitable as a predicate for the Flux::windowUntil operator, to split events from all parts into windows that each belong to a single part.", "chunk_char_count": 1804, "chunk_word_count": 440, "chunk_token_count": 451.0}, {"page_number": 1153, "sentence_chunk": "\u2463 Handling the form field.\u2464 Handling the file upload.\u2465 The body contents must be completely consumed, relayed, or released to avoid memory leaks. Received part events can also be relayed to another service by using the WebClient. See Multipart Data.@RequestBody Web MVC You can use the @RequestBody annotation to have the request body read and deserialized into an Object through an HttpMessageReader. The following example uses a @RequestBody argument: Java @PostMapping(\"/accounts\") public void handle(@RequestBody Account account) { \u00a0  // ... } Kotlin @PostMapping(\"/accounts\") fun handle(@RequestBody account: Account) { \u00a0  // ... } Unlike Spring MVC, in WebFlux, the @RequestBody method argument supports reactive types and fully non-blocking reading and (client-to-server) streaming. Java @PostMapping(\"/accounts\") public void handle(@RequestBody Mono<Account> account) { \u00a0  // ... } Kotlin @PostMapping(\"/accounts\") fun handle(@RequestBody accounts: Flow<Account>) { \u00a0  // ... } You can use the HTTP message codecs option of the WebFlux Config to configure or customize message readers.1153", "chunk_char_count": 1097, "chunk_word_count": 156, "chunk_token_count": 274.25}, {"page_number": 1154, "sentence_chunk": "You can use @RequestBody in combination with jakarta.validation. Valid or Spring\u2019s @Validated annotation, which causes Standard Bean Validation to be applied. Validation errors cause a WebExchangeBindException, which results in a 400 (BAD_REQUEST) response. The exception contains a BindingResult with error details and can be handled in the controller method by declaring the argument with an async wrapper and then using error related operators: Java @PostMapping(\"/accounts\") public void handle(@Valid @RequestBody Mono<Account> account) { \u00a0  // use one of the onError* operators... } Kotlin @PostMapping(\"/accounts\") fun handle(@Valid @RequestBody account: Mono<Account>) { \u00a0  // ... } HttpEntity Web MVC HttpEntity is more or less identical to using @RequestBody but is based on a container object that exposes request headers and the body. The following example uses an HttpEntity: Java @PostMapping(\"/accounts\") public void handle(HttpEntity<Account> entity) { \u00a0  // ... } Kotlin @PostMapping(\"/accounts\") fun handle(entity: HttpEntity<Account>) { \u00a0  // ... } @ResponseBody Web MVC You can use the @ResponseBody annotation on a method to have the return serialized to the response body through an HttpMessageWriter. The following example shows how to do so: 1154", "chunk_char_count": 1269, "chunk_word_count": 183, "chunk_token_count": 317.25}, {"page_number": 1155, "sentence_chunk": "Java @GetMapping(\"/accounts/{id}\") @ResponseBody public Account handle() { \u00a0  // ... } Kotlin @GetMapping(\"/accounts/{id}\") @ResponseBody fun handle(): Account { \u00a0  // ... } @ResponseBody is also supported at the class level, in which case it is inherited by all controller methods. This is the effect of @RestController, which is nothing more than a meta-annotation marked with @Controller and @ResponseBody.@ResponseBody supports reactive types, which means you can return Reactor or RxJava types and have the asynchronous values they produce rendered to the response. For additional details, see Streaming and JSON rendering. You can combine @ResponseBody methods with JSON serialization views. See Jackson JSON for details. You can use the HTTP message codecs option of the WebFlux Config to configure or customize message writing. ResponseEntity Web MVC ResponseEntity is like @ResponseBody but with status and headers. For example: Java @GetMapping(\"/something\") public ResponseEntity<String> handle() { \u00a0  String body = ... ; \u00a0  String etag = ... ; \u00a0  return ResponseEntity.ok().eTag(etag).body(body); } 1155", "chunk_char_count": 1115, "chunk_word_count": 163, "chunk_token_count": 278.75}, {"page_number": 1156, "sentence_chunk": "Kotlin @GetMapping(\"/something\") fun handle(): ResponseEntity<String> { \u00a0  val body: String = ... \u00a0  val etag: String = ... \u00a0  return ResponseEntity.ok().eTag(etag).build(body) } WebFlux supports using a single value reactive type to produce the ResponseEntity asynchronously, and/or single and multi-value reactive types for the body. This allows a variety of async responses with ResponseEntity as follows: \u2022 ResponseEntity<Mono<T>> or ResponseEntity<Flux<T>> make the response status and headers known immediately while the body is provided asynchronously at a later point. Use Mono if the body consists of 0..1 values or Flux if it can produce multiple values. \u2022Mono<ResponseEntity<T>> provides all three\u2009\u2014\u2009response status, headers, and body, asynchronously at a later point. This allows the response status and headers to vary depending on the outcome of asynchronous request handling. \u2022Mono<ResponseEntity<Mono<T>>> or Mono<ResponseEntity<Flux<T>>> are yet another possible, albeit less common alternative. They provide the response status and headers asynchronously first and then the response body, also asynchronously, second. Jackson JSON Spring offers support for the Jackson JSON library. JSON Views Web MVC Spring WebFlux provides built-in support for Jackson\u2019s Serialization Views, which allows rendering only a subset of all fields in an Object. To use it with @ResponseBody or ResponseEntity controller methods, you can use Jackson\u2019s @JsonView annotation to activate a serialization view class, as the following example shows: 1156", "chunk_char_count": 1547, "chunk_word_count": 217, "chunk_token_count": 386.75}, {"page_number": 1157, "sentence_chunk": "Java @RestController public class UserController { \u00a0  @GetMapping(\"/user\") \u00a0  @JsonView(User. WithoutPasswordView.class) \u00a0  public User getUser() { \u00a0    return new User(\"eric\", \"7!jd#h23\"); \u00a0  } } public class User { \u00a0  public interface WithoutPasswordView {}; \u00a0  public interface WithPasswordView extends WithoutPasswordView {}; \u00a0  private String username; \u00a0  private String password; \u00a0  public User() { \u00a0  } \u00a0  public User(String username, String password) { \u00a0    this.username = username; \u00a0    this.password = password; \u00a0  } \u00a0  @JsonView(WithoutPasswordView.class) \u00a0  public String getUsername() { \u00a0    return this.username; \u00a0  } \u00a0  @JsonView(WithPasswordView.class) \u00a0  public String getPassword() { \u00a0    return this.password; \u00a0  } } 1157", "chunk_char_count": 741, "chunk_word_count": 130, "chunk_token_count": 185.25}, {"page_number": 1158, "sentence_chunk": "Kotlin @RestController class UserController { \u00a0  @GetMapping(\"/user\") \u00a0  @JsonView(User. WithoutPasswordView::class) \u00a0  fun getUser(): User { \u00a0    return User(\"eric\", \"7!jd#h23\") \u00a0  } } class User( \u00a0    @JsonView(WithoutPasswordView::class) val username: String, \u00a0    @JsonView(WithPasswordView::class) val password: String ) { \u00a0  interface WithoutPasswordView \u00a0  interface WithPasswordView : WithoutPasswordView } \uf05a @JsonView allows an array of view classes but you can only specify only one per controller method. Use a composite interface if you need to activate multiple views. Model Web MVC You can use the @ModelAttribute annotation: \u2022 On a method argument in @RequestMapping methods to create or access an Object from the model and to bind it to the request through a WebDataBinder. \u2022As a method-level annotation in @Controller or @ControllerAdvice classes, helping to initialize the model prior to any @RequestMapping method invocation. \u2022On a @RequestMapping method to mark its return value as a model attribute. This section discusses @ModelAttribute methods, or the second item from the preceding list. A controller can have any number of @ModelAttribute methods. All such methods are invoked before @RequestMapping methods in the same controller. A @ModelAttribute method can also be shared across controllers through @ControllerAdvice.", "chunk_char_count": 1347, "chunk_word_count": 203, "chunk_token_count": 336.75}, {"page_number": 1158, "sentence_chunk": "See the section on Controller Advice for more details.@ModelAttribute methods have flexible method signatures. They support many of the same arguments as @RequestMapping methods (except for @ModelAttribute itself and anything related to the request body). The following example uses a @ModelAttribute method: 1158", "chunk_char_count": 313, "chunk_word_count": 43, "chunk_token_count": 78.25}, {"page_number": 1159, "sentence_chunk": "Java @ModelAttribute public void populateModel(@RequestParam String number, Model model) { \u00a0  model.addAttribute(accountRepository.findAccount(number)); \u00a0  // add more ... } Kotlin @ModelAttribute fun populateModel(@RequestParam number: String, model: Model) { \u00a0  model.addAttribute(accountRepository.findAccount(number)) \u00a0  // add more ... } The following example adds one attribute only: Java @ModelAttribute public Account addAccount(@RequestParam String number) { \u00a0  return accountRepository.findAccount(number); } Kotlin @ModelAttribute fun addAccount(@RequestParam number: String): Account { \u00a0  return accountRepository.findAccount(number); } \uf05a When a name is not explicitly specified, a default name is chosen based on the type, as explained in the javadoc for Conventions. You can always assign an explicit name by using the overloaded addAttribute method or through the name attribute on @ModelAttribute (for a return value). Spring WebFlux, unlike Spring MVC, explicitly supports reactive types in the model (for example, Mono<Account> or io.reactivex. Single<Account>). Such asynchronous model attributes can be transparently resolved (and the model updated) to their actual values at the time of @RequestMapping invocation, provided a @ModelAttribute argument is declared without a wrapper, as the following example shows: 1159", "chunk_char_count": 1339, "chunk_word_count": 175, "chunk_token_count": 334.75}, {"page_number": 1160, "sentence_chunk": "Java @ModelAttribute public void addAccount(@RequestParam String number) { \u00a0  Mono<Account> accountMono = accountRepository.findAccount(number); \u00a0  model.addAttribute(\"account\", accountMono); } @PostMapping(\"/accounts\") public String handle(@ModelAttribute Account account, BindingResult errors) { \u00a0  // ... } Kotlin import org.springframework.ui.set @ModelAttribute fun addAccount(@RequestParam number: String) { \u00a0  val accountMono: Mono<Account> = accountRepository.findAccount(number) \u00a0  model[\"account\"] = accountMono } @PostMapping(\"/accounts\") fun handle(@ModelAttribute account: Account, errors: BindingResult): String { \u00a0  // ... } In addition, any model attributes that have a reactive type wrapper are resolved to their actual values (and the model updated) just prior to view rendering. You can also use @ModelAttribute as a method-level annotation on @RequestMapping methods, in which case the return value of the @RequestMapping method is interpreted as a model attribute. This is typically not required, as it is the default behavior in HTML controllers, unless the return value is a String that would otherwise be interpreted as a view name.@ModelAttribute can also help to customize the model attribute name, as the following example shows: Java @GetMapping(\"/accounts/{id}\") @ModelAttribute(\"myAccount\") public Account handle() { \u00a0  // ... \u00a0  return account; } 1160", "chunk_char_count": 1382, "chunk_word_count": 184, "chunk_token_count": 345.5}, {"page_number": 1161, "sentence_chunk": "Kotlin @GetMapping(\"/accounts/{id}\") @ModelAttribute(\"myAccount\") fun handle(): Account { \u00a0  // ... \u00a0  return account } DataBinder Web MVC @Controller or @ControllerAdvice classes can have @InitBinder methods, to initialize instances of WebDataBinder. Those, in turn, are used to: \u2022 Bind request parameters (that is, form data or query) to a model object. \u2022Convert String-based request values (such as request parameters, path variables, headers, cookies, and others) to the target type of controller method arguments. \u2022Format model object values as String values when rendering HTML forms.@InitBinder methods can register controller-specific java.beans. PropertyEditor or Spring Converter and Formatter components. In addition, you can use the WebFlux Java configuration to register Converter and Formatter types in a globally shared FormattingConversionService.@InitBinder methods support many of the same arguments that @RequestMapping methods do, except for @ModelAttribute (command object) arguments. Typically, they are declared with a WebDataBinder argument, for registrations, and a void return value. The following example uses the @InitBinder annotation: Java @Controller public class FormController { \u00a0  @InitBinder \u2460 \u00a0  public void initBinder(WebDataBinder binder) { \u00a0    SimpleDateFormat dateFormat = new SimpleDateFormat(\"yyyy-MM-dd\"); \u00a0    dateFormat.setLenient(false); \u00a0    binder.registerCustomEditor(Date.class, new CustomDateEditor(dateFormat, false)); \u00a0  } \u00a0  // ... } \u2460 Using the @InitBinder annotation.", "chunk_char_count": 1524, "chunk_word_count": 208, "chunk_token_count": 381.0}, {"page_number": 1162, "sentence_chunk": "Kotlin @Controller class FormController { \u00a0  @InitBinder \u2460 \u00a0  fun initBinder(binder: WebDataBinder) { \u00a0    val dateFormat = SimpleDateFormat(\"yyyy-MM-dd\") \u00a0    dateFormat.isLenient = false \u00a0    binder.registerCustomEditor(Date::class.java, CustomDateEditor(dateFormat, false)) \u00a0  } \u00a0  // ... } Alternatively, when using a Formatter-based setup through a shared FormattingConversionService, you could re-use the same approach and register controller-specific Formatter instances, as the following example shows: Java @Controller public class FormController { \u00a0  @InitBinder \u00a0  protected void initBinder(WebDataBinder binder) { \u00a0    binder.addCustomFormatter(new DateFormatter(\"yyyy-MM-dd\")); \u2460 \u00a0  } \u00a0  // ... } \u2460 Adding a custom formatter (a DateFormatter, in this case). Kotlin @Controller class FormController { \u00a0  @InitBinder \u00a0  fun initBinder(binder: WebDataBinder) { \u00a0    binder.addCustomFormatter(DateFormatter(\"yyyy-MM-dd\")) \u2460 \u00a0  } \u00a0  // ... } \u2460 Adding a custom formatter (a DateFormatter, in this case).1162", "chunk_char_count": 1014, "chunk_word_count": 150, "chunk_token_count": 253.5}, {"page_number": 1163, "sentence_chunk": "Model Design Web MVC In the context of web applications, data binding involves the binding of HTTP request parameters (that is, form data or query parameters) to properties in a model object and its nested objects. Only public properties following the JavaBeans naming conventions are exposed for data binding \u2014 for example, public String getFirstName() and public void setFirstName(String) methods for a firstName property.\uf0eb The model object, and its nested object graph, is also sometimes referred to as a command object, form-backing object, or POJO (Plain Old Java Object). By default, Spring permits binding to all public properties in the model object graph. This means you need to carefully consider what public properties the model has, since a client could target any public property path, even some that are not expected to be targeted for a given use case. For example, given an HTTP form data endpoint, a malicious client could supply values for properties that exist in the model object graph but are not part of the HTML form presented in the browser. This could lead to data being set on the model object and any of its nested objects, that is not expected to be updated. The recommended approach is to use a dedicated model object that exposes only properties that are relevant for the form submission. For example, on a form for changing a user\u2019s email address, the model object should declare a minimum set of properties such as in the following ChangeEmailForm.public class ChangeEmailForm { \u00a0  private String oldEmailAddress; \u00a0  private String newEmailAddress; \u00a0  public void setOldEmailAddress(String oldEmailAddress) { \u00a0    this.oldEmailAddress = oldEmailAddress; \u00a0  } \u00a0  public String getOldEmailAddress() { \u00a0    return this.oldEmailAddress; \u00a0  } \u00a0  public void setNewEmailAddress(String newEmailAddress) { \u00a0    this.newEmailAddress = newEmailAddress; \u00a0  } \u00a0  public String getNewEmailAddress() { \u00a0    return this.newEmailAddress; \u00a0  } } 1163", "chunk_char_count": 1965, "chunk_word_count": 325, "chunk_token_count": 491.25}, {"page_number": 1164, "sentence_chunk": "If you cannot or do not want to use a dedicated model object for each data binding use case, you must limit the properties that are allowed for data binding. Ideally, you can achieve this by registering allowed field patterns via the setAllowedFields() method on WebDataBinder. For example, to register allowed field patterns in your application, you can implement an @InitBinder method in a @Controller or @ControllerAdvice component as shown below: @Controller public class ChangeEmailController { \u00a0  @InitBinder \u00a0  void initBinder(WebDataBinder binder) { \u00a0    binder.setAllowedFields(\"oldEmailAddress\", \"newEmailAddress\"); \u00a0  } \u00a0  // @RequestMapping methods, etc. }In addition to registering allowed patterns, it is also possible to register disallowed field patterns via the setDisallowedFields() method in DataBinder and its subclasses. Please note, however, that an \"allow list\" is safer than a \"deny list\". Consequently, setAllowedFields() should be favored over setDisallowedFields(). Note that matching against allowed field patterns is case-sensitive; whereas, matching against disallowed field patterns is case-insensitive. In addition, a field matching a disallowed pattern will not be accepted even if it also happens to match a pattern in the allowed list.\uf071 It is extremely important to properly configure allowed and disallowed field patterns when exposing your domain model directly for data binding purposes. Otherwise, it is a big security risk.", "chunk_char_count": 1463, "chunk_word_count": 215, "chunk_token_count": 365.75}, {"page_number": 1164, "sentence_chunk": "Furthermore, it is strongly recommended that you do not use types from your domain model such as JPA or Hibernate entities as the model object in data binding scenarios. Exceptions Web MVC @Controller and @ControllerAdvice classes can have @ExceptionHandler methods to handle exceptions from controller methods. The following example includes such a handler method: 1164", "chunk_char_count": 370, "chunk_word_count": 55, "chunk_token_count": 92.5}, {"page_number": 1165, "sentence_chunk": "Java @Controller public class SimpleController { \u00a0  // ... \u00a0  @ExceptionHandler \u2460 \u00a0  public ResponseEntity<String> handle(IOException ex) { \u00a0    // ... \u00a0  } } \u2460 Declaring an @ExceptionHandler. Kotlin @Controller class SimpleController { \u00a0  // ... \u00a0  @ExceptionHandler \u2460 \u00a0  fun handle(ex: IOException): ResponseEntity<String> { \u00a0    // ... \u00a0  } } \u2460 Declaring an @ExceptionHandler. The exception can match against a top-level exception being propagated (that is, a direct IOException being thrown) or against the immediate cause within a top-level wrapper exception (for example, an IOException wrapped inside an IllegalStateException). For matching exception types, preferably declare the target exception as a method argument, as shown in the preceding example. Alternatively, the annotation declaration can narrow the exception types to match. We generally recommend being as specific as possible in the argument signature and to declare your primary root exception mappings on a @ControllerAdvice prioritized with a corresponding order. See the MVC section for details.\uf05a An @ExceptionHandler method in WebFlux supports the same method arguments and return values as a @RequestMapping method, with the exception of request body- and @ModelAttribute-related method arguments. Support for @ExceptionHandler methods in Spring WebFlux is provided by the HandlerAdapter for @RequestMapping methods. See DispatcherHandler for more detail.", "chunk_char_count": 1433, "chunk_word_count": 215, "chunk_token_count": 358.25}, {"page_number": 1166, "sentence_chunk": "@ExceptionHandler methods support the same method arguments as @RequestMapping methods, except the request body might have been consumed already. Return Values Web MVC @ExceptionHandler methods support the same return values as @RequestMapping methods. Controller Advice Web MVC Typically, the @ExceptionHandler, @InitBinder, and @ModelAttribute methods apply within the @Controller class (or class hierarchy) in which they are declared. If you want such methods to apply more globally (across controllers), you can declare them in a class annotated with @ControllerAdvice or @RestControllerAdvice.@ControllerAdvice is annotated with @Component, which means that such classes can be registered as Spring beans through component scanning.@RestControllerAdvice is a composed annotation that is annotated with both @ControllerAdvice and @ResponseBody, which essentially means @ExceptionHandler methods are rendered to the response body through message conversion (versus view resolution or template rendering). On startup, the infrastructure classes for @RequestMapping and @ExceptionHandler methods detect Spring beans annotated with @ControllerAdvice and then apply their methods at runtime. Global @ExceptionHandler methods (from a @ControllerAdvice) are applied after local ones (from the @Controller). By contrast, global @ModelAttribute and @InitBinder methods are applied before local ones. By default, @ControllerAdvice methods apply to every request (that is, all controllers), but you can narrow that down to a subset of controllers by using attributes on the annotation, as the following example shows: Java // Target all Controllers annotated with @RestController @ControllerAdvice(annotations = RestController.class) public class ExampleAdvice1 {} // Target all Controllers within specific packages @ControllerAdvice(\"org.example.controllers\") public class ExampleAdvice2 {} // Target all Controllers assignable to specific classes @ControllerAdvice(assignableTypes = {ControllerInterface.class, AbstractController.class}) public class ExampleAdvice3 {} 1166", "chunk_char_count": 2068, "chunk_word_count": 257, "chunk_token_count": 517.0}, {"page_number": 1167, "sentence_chunk": "Kotlin // Target all Controllers annotated with @RestController @ControllerAdvice(annotations = [RestController::class]) public class ExampleAdvice1 {} // Target all Controllers within specific packages @ControllerAdvice(\"org.example.controllers\") public class ExampleAdvice2 {} // Target all Controllers assignable to specific classes @ControllerAdvice(assignableTypes = [ControllerInterface::class, AbstractController::class]) public class ExampleAdvice3 {} The selectors in the preceding example are evaluated at runtime and may negatively impact performance if used extensively. See the @ControllerAdvice javadoc for more details.6.1.5. Functional Endpoints Web MVC Spring WebFlux includes WebFlux.fn, a lightweight functional programming model in which functions are used to route and handle requests and contracts are designed for immutability. It is an alternative to the annotation-based programming model but otherwise runs on the same Reactive Core foundation. Overview Web MVC In WebFlux.fn, an HTTP request is handled with a HandlerFunction: a function that takes ServerRequest and returns a delayed ServerResponse (i.e. Mono<ServerResponse>). Both the request and the response object have immutable contracts that offer JDK 8-friendly access to the HTTP request and response. HandlerFunction is the equivalent of the body of a @RequestMapping method in the annotation-based programming model. Incoming requests are routed to a handler function with a RouterFunction: a function that takes ServerRequest and returns a delayed HandlerFunction (i.e. Mono<HandlerFunction>). When the router function matches, a handler function is returned; otherwise an empty Mono.", "chunk_char_count": 1674, "chunk_word_count": 214, "chunk_token_count": 418.5}, {"page_number": 1167, "sentence_chunk": "RouterFunction is the equivalent of a @RequestMapping annotation, but with the major difference that router functions provide not just data, but also behavior. RouterFunctions.route() provides a router builder that facilitates the creation of routers, as the following example shows: 1167", "chunk_char_count": 288, "chunk_word_count": 40, "chunk_token_count": 72.0}, {"page_number": 1168, "sentence_chunk": "Java import static org.springframework.http. MediaType. APPLICATION_JSON; import static org.springframework.web.reactive.function.server. RequestPredicates.*;import static org.springframework.web.reactive.function.server. RouterFunctions.route; PersonRepository repository = ... PersonHandler handler = new PersonHandler(repository); RouterFunction<ServerResponse> route = route() \u2460 \u00a0  . GET(\"/person/{id}\", accept(APPLICATION_JSON), handler::getPerson) \u00a0  . GET(\"/person\", accept(APPLICATION_JSON), handler::listPeople) \u00a0  . POST(\"/person\", handler::createPerson) \u00a0  .build(); public class PersonHandler { \u00a0  // ... \u00a0  public Mono<ServerResponse> listPeople(ServerRequest request) { \u00a0    // ... \u00a0  } \u00a0  public Mono<ServerResponse> createPerson(ServerRequest request) { \u00a0    // ... \u00a0  } \u00a0  public Mono<ServerResponse> getPerson(ServerRequest request) { \u00a0    // ... \u00a0  } } \u2460 Create router using route().1168", "chunk_char_count": 906, "chunk_word_count": 109, "chunk_token_count": 226.5}, {"page_number": 1169, "sentence_chunk": "Kotlin val repository: PersonRepository = ... val handler = PersonHandler(repository) val route = coRouter { \u2460 \u00a0  accept(APPLICATION_JSON).nest { \u00a0    GET(\"/person/{id}\", handler::getPerson) \u00a0    GET(\"/person\", handler::listPeople) \u00a0  } \u00a0  POST(\"/person\", handler::createPerson) } class PersonHandler(private val repository: PersonRepository) { \u00a0  // ... \u00a0  suspend fun listPeople(request: ServerRequest): ServerResponse { \u00a0    // ... \u00a0  } \u00a0  suspend fun createPerson(request: ServerRequest): ServerResponse { \u00a0    // ... \u00a0  } \u00a0  suspend fun getPerson(request: ServerRequest): ServerResponse { \u00a0    // ... \u00a0  } } \u2460 Create router using Coroutines router DSL, a Reactive alternative is also available via router { }. One way to run a RouterFunction is to turn it into an HttpHandler and install it through one of the built-in server adapters: \u2022 RouterFunctions.toHttpHandler(RouterFunction) \u2022 RouterFunctions.toHttpHandler(RouterFunction, HandlerStrategies) Most applications can run through the WebFlux Java configuration, see Running a Server. HandlerFunction Web MVC ServerRequest and ServerResponse are immutable interfaces that offer JDK 8-friendly access to the HTTP request and response. Both request and response provide Reactive Streams back pressure against the body streams. The request body is represented with a Reactor Flux or Mono. The response body is represented with any Reactive Streams Publisher, including Flux and Mono. For more on that, see Reactive Libraries.1169", "chunk_char_count": 1485, "chunk_word_count": 225, "chunk_token_count": 371.25}, {"page_number": 1170, "sentence_chunk": "ServerRequest ServerRequest provides access to the HTTP method, URI, headers, and query parameters, while access to the body is provided through the body methods. The following example extracts the request body to a Mono<String>: Java Mono<String> string = request.bodyToMono(String.class); Kotlin val string = request.awaitBody<String>() The following example extracts the body to a Flux<Person> (or a Flow<Person> in Kotlin), where Person objects are decoded from some serialized form, such as JSON or XML: Java Flux<Person> people = request.bodyToFlux(Person.class); Kotlin val people = request.bodyToFlow<Person>() The preceding examples are shortcuts that use the more general ServerRequest.body(BodyExtractor), which accepts the BodyExtractor functional strategy interface. The utility class BodyExtractors provides access to a number of instances. For example, the preceding examples can also be written as follows: Java Mono<String> string = request.body(BodyExtractors.toMono(String.class)); Flux<Person> people = request.body(BodyExtractors.toFlux(Person.class)); Kotlin \u00a0  val string = request.body(BodyExtractors.toMono(String::class.java)).awaitSingle() \u00a0  val people = request.body(BodyExtractors.toFlux(Person::class.java)).asFlow() The following example shows how to access form data: Java Mono<MultiValueMap<String, String>> map = request.formData(); 1170", "chunk_char_count": 1372, "chunk_word_count": 160, "chunk_token_count": 343.0}, {"page_number": 1171, "sentence_chunk": "Kotlin val map = request.awaitFormData() The following example shows how to access multipart data as a map: Java Mono<MultiValueMap<String, Part>> map = request.multipartData(); Kotlin val map = request.awaitMultipartData() The following example shows how to access multipart data, one at a time, in streaming fashion: Java Flux<PartEvent> allPartEvents = request.bodyToFlux(PartEvent.class); allPartsEvents.windowUntil(PartEvent::isLast) \u00a0   .concatMap(p -> p.switchOnFirst((signal, partEvents) -> { \u00a0     if (signal.hasValue()) { \u00a0       PartEvent event = signal.get(); \u00a0       if (event instanceof FormPartEvent formEvent) { \u00a0         String value = formEvent.value(); \u00a0         // handle form field \u00a0       } \u00a0       else if (event instanceof FilePartEvent fileEvent) { \u00a0         String filename = fileEvent.filename(); \u00a0         Flux<DataBuffer> contents = partEvents.map(PartEvent::content); \u00a0         // handle file upload \u00a0       } \u00a0       else { \u00a0         return Mono.error(new RuntimeException(\"Unexpected event: \" + event)); \u00a0       } \u00a0     } \u00a0     else { \u00a0       return partEvents; // either complete or error signal \u00a0     } \u00a0   })); 1171", "chunk_char_count": 1150, "chunk_word_count": 258, "chunk_token_count": 287.5}, {"page_number": 1172, "sentence_chunk": "Kotlin val parts = request.bodyToFlux<PartEvent>() allPartsEvents.windowUntil(PartEvent::isLast) \u00a0  .concatMap { \u00a0    it.switchOnFirst { signal, partEvents -> \u00a0      if (signal.hasValue()) { \u00a0        val event = signal.get() \u00a0        if (event is FormPartEvent) { \u00a0          val value: String = event.value(); \u00a0          // handle form field \u00a0        } else if (event is FilePartEvent) { \u00a0          val filename: String = event.filename(); \u00a0          val contents: Flux<DataBuffer> = partEvents.map(PartEvent::content); \u00a0          // handle file upload \u00a0        } else { \u00a0          return Mono.error(RuntimeException(\"Unexpected event: \" + event)); \u00a0        } \u00a0      } else { \u00a0        return partEvents; // either complete or error signal \u00a0      } \u00a0    } \u00a0  } } Note that the body contents of the PartEvent objects must be completely consumed, relayed, or released to avoid memory leaks. ServerResponse ServerResponse provides access to the HTTP response and, since it is immutable, you can use a build method to create it. You can use the builder to set the response status, to add response headers, or to provide a body. The following example creates a 200 (OK) response with JSON content: Java Mono<Person> person = ... ServerResponse.ok().contentType(MediaType. APPLICATION_JSON).body(person, Person.class); Kotlin val person: Person = ... ServerResponse.ok().contentType(MediaType. APPLICATION_JSON).bodyValue(person) The following example shows how to build a 201 (CREATED) response with a Location header and no body: 1172", "chunk_char_count": 1529, "chunk_word_count": 325, "chunk_token_count": 382.25}, {"page_number": 1173, "sentence_chunk": "Java URI location = ... ServerResponse.created(location).build(); Kotlin val location: URI = ... ServerResponse.created(location).build() Depending on the codec used, it is possible to pass hint parameters to customize how the body is serialized or deserialized. For example, to specify a Jackson JSON view: Java ServerResponse.ok().hint(Jackson2CodecSupport. JSON_VIEW_HINT, MyJacksonView.class).body(...); Kotlin ServerResponse.ok().hint(Jackson2CodecSupport. JSON_VIEW_HINT, MyJacksonView::class.java).body(...) Handler Classes We can write a handler function as a lambda, as the following example shows: Java HandlerFunction<ServerResponse> helloWorld = \u00a0 request -> ServerResponse.ok().bodyValue(\"Hello World\"); Kotlin val helloWorld = HandlerFunction<ServerResponse> { ServerResponse.ok().bodyValue(\"Hello World\") } That is convenient, but in an application we need multiple functions, and multiple inline lambda\u2019s can get messy. Therefore, it is useful to group related handler functions together into a handler class, which has a similar role as @Controller in an annotation-based application. For example, the following class exposes a reactive Person repository: 1173", "chunk_char_count": 1177, "chunk_word_count": 138, "chunk_token_count": 294.25}, {"page_number": 1174, "sentence_chunk": "Java import static org.springframework.http. MediaType. APPLICATION_JSON; import static org.springframework.web.reactive.function.server. ServerResponse.ok; public class PersonHandler { \u00a0  private final PersonRepository repository; \u00a0  public PersonHandler(PersonRepository repository) { \u00a0    this.repository = repository; \u00a0  } \u00a0  public Mono<ServerResponse> listPeople(ServerRequest request) { \u2460 \u00a0    Flux<Person> people = repository.allPeople(); \u00a0    return ok().contentType(APPLICATION_JSON).body(people, Person.class); \u00a0  } \u00a0  public Mono<ServerResponse> createPerson(ServerRequest request) { \u2461 \u00a0    Mono<Person> person = request.bodyToMono(Person.class); \u00a0    return ok().build(repository.savePerson(person)); \u00a0  } \u00a0  public Mono<ServerResponse> getPerson(ServerRequest request) { \u2462 \u00a0    int personId = Integer.valueOf(request.pathVariable(\"id\")); \u00a0    return repository.getPerson(personId) \u00a0      .flatMap(person -> ok().contentType(APPLICATION_JSON).bodyValue(person)) \u00a0      .switchIfEmpty(ServerResponse.notFound().build()); \u00a0  } } \u2460 listPeople is a handler function that returns all Person objects found in the repository as JSON.\u2461 createPerson is a handler function that stores a new Person contained in the request body. Note that PersonRepository.savePerson(Person) returns Mono<Void>: an empty Mono that emits a completion signal when the person has been read from the request and stored. So we use the build(Publisher<Void>) method to send a response when that completion signal is received (that is, when the Person has been saved).\u2462 getPerson is a handler function that returns a single person, identified by the id path variable. We retrieve that Person from the repository and create a JSON response, if it is found. If it is not found, we use switchIfEmpty(Mono<T>) to return a 404 Not Found response.1174", "chunk_char_count": 1824, "chunk_word_count": 256, "chunk_token_count": 456.0}, {"page_number": 1175, "sentence_chunk": "Kotlin class PersonHandler(private val repository: PersonRepository) { \u00a0  suspend fun listPeople(request: ServerRequest): ServerResponse { \u2460 \u00a0    val people: Flow<Person> = repository.allPeople() \u00a0    return ok().contentType(APPLICATION_JSON).bodyAndAwait(people); \u00a0  } \u00a0  suspend fun createPerson(request: ServerRequest): ServerResponse { \u2461 \u00a0    val person = request.awaitBody<Person>() \u00a0    repository.savePerson(person) \u00a0    return ok().buildAndAwait() \u00a0  } \u00a0  suspend fun getPerson(request: ServerRequest): ServerResponse { \u2462 \u00a0    val personId = request.pathVariable(\"id\").toInt() \u00a0    return repository.getPerson(personId)?.let { ok().contentType(APPLICATION_JSON).bodyValueAndAwait(it) } \u00a0        ?:ServerResponse.notFound().buildAndAwait() \u00a0  } } \u2460 listPeople is a handler function that returns all Person objects found in the repository as JSON.\u2461 createPerson is a handler function that stores a new Person contained in the request body. Note that PersonRepository.savePerson(Person) is a suspending function with no return type.\u2462 getPerson is a handler function that returns a single person, identified by the id path variable. We retrieve that Person from the repository and create a JSON response, if it is found. If it is not found, we return a 404 Not Found response. Validation A functional endpoint can use Spring\u2019s validation facilities to apply validation to the request body. For example, given a custom Spring Validator implementation for a Person: 1175", "chunk_char_count": 1472, "chunk_word_count": 219, "chunk_token_count": 368.0}, {"page_number": 1176, "sentence_chunk": "Java public class PersonHandler { \u00a0  private final Validator validator = new PersonValidator(); \u2460 \u00a0  // ... \u00a0  public Mono<ServerResponse> createPerson(ServerRequest request) { \u00a0    Mono<Person> person = request.bodyToMono(Person.class).doOnNext(this::validate); \u2461 \u00a0    return ok().build(repository.savePerson(person)); \u00a0  } \u00a0  private void validate(Person person) { \u00a0    Errors errors = new BeanPropertyBindingResult(person, \"person\"); \u00a0    validator.validate(person, errors); \u00a0    if (errors.hasErrors()) { \u00a0      throw new ServerWebInputException(errors.toString()); \u2462 \u00a0    } \u00a0  } } \u2460 Create Validator instance.\u2461 Apply validation.\u2462 Raise exception for a 400 response.1176", "chunk_char_count": 674, "chunk_word_count": 105, "chunk_token_count": 168.5}, {"page_number": 1177, "sentence_chunk": "Kotlin class PersonHandler(private val repository: PersonRepository) { \u00a0  private val validator = PersonValidator() \u2460 \u00a0  // ... \u00a0  suspend fun createPerson(request: ServerRequest): ServerResponse { \u00a0    val person = request.awaitBody<Person>() \u00a0    validate(person) \u2461 \u00a0    repository.savePerson(person) \u00a0    return ok().buildAndAwait() \u00a0  } \u00a0  private fun validate(person: Person) { \u00a0    val errors: Errors = BeanPropertyBindingResult(person, \"person\"); \u00a0    validator.validate(person, errors); \u00a0    if (errors.hasErrors()) { \u00a0      throw ServerWebInputException(errors.toString()) \u2462 \u00a0    } \u00a0  } } \u2460 Create Validator instance.\u2461 Apply validation.\u2462 Raise exception for a 400 response. Handlers can also use the standard bean validation API (JSR-303) by creating and injecting a global Validator instance based on LocalValidatorFactoryBean. See Spring Validation. RouterFunction Web MVC Router functions are used to route the requests to the corresponding HandlerFunction. Typically, you do not write router functions yourself, but rather use a method on the RouterFunctions utility class to create one. RouterFunctions.route() (no parameters) provides you with a fluent builder for creating a router function, whereas RouterFunctions.route(RequestPredicate, HandlerFunction) offers a direct way to create a router. Generally, it is recommended to use the route() builder, as it provides convenient short-cuts for typical mapping scenarios without requiring hard-to-discover static imports. For instance, the router function builder offers the method GET(String, HandlerFunction) to create a mapping for GET requests; and POST(String, HandlerFunction) for POSTs.", "chunk_char_count": 1659, "chunk_word_count": 246, "chunk_token_count": 414.75}, {"page_number": 1177, "sentence_chunk": "Besides HTTP method-based mapping, the route builder offers a way to introduce additional predicates when mapping to requests. For each HTTP method there is an overloaded variant that takes a RequestPredicate as a parameter, though which additional constraints can be expressed.1177", "chunk_char_count": 282, "chunk_word_count": 41, "chunk_token_count": 70.5}, {"page_number": 1178, "sentence_chunk": "Predicates You can write your own RequestPredicate, but the RequestPredicates utility class offers commonly used implementations, based on the request path, HTTP method, content-type, and so on. The following example uses a request predicate to create a constraint based on the Accept header: Java RouterFunction<ServerResponse> route = RouterFunctions.route() \u00a0  . GET(\"/hello-world\", accept(MediaType. TEXT_PLAIN), \u00a0    request -> ServerResponse.ok().bodyValue(\"Hello World\")).build(); Kotlin val route = coRouter { \u00a0  GET(\"/hello-world\", accept(TEXT_PLAIN)) { \u00a0    ServerResponse.ok().bodyValueAndAwait(\"Hello World\") \u00a0  } } You can compose multiple request predicates together by using: \u2022 RequestPredicate.and(RequestPredicate)\u2009\u2014\u2009both must match. \u2022RequestPredicate.or(RequestPredicate)\u2009\u2014\u2009either can match. Many of the predicates from RequestPredicates are composed. For example, RequestPredicates. GET(String) is composed from RequestPredicates.method(HttpMethod) and RequestPredicates.path(String). The example shown above also uses two request predicates, as the builder uses RequestPredicates. GET internally, and composes that with the accept predicate. Routes Router functions are evaluated in order: if the first route does not match, the second is evaluated, and so on.", "chunk_char_count": 1280, "chunk_word_count": 161, "chunk_token_count": 320.0}, {"page_number": 1178, "sentence_chunk": "Therefore, it makes sense to declare more specific routes before general ones. This is also important when registering router functions as Spring beans, as will be described later. Note that this behavior is different from the annotation-based programming model, where the \"most specific\" controller method is picked automatically. When using the router function builder, all defined routes are composed into one RouterFunction that is returned from build(). There are also other ways to compose multiple router functions together: \u2022 add(RouterFunction) on the RouterFunctions.route() builder \u2022 RouterFunction.and(RouterFunction) \u2022 RouterFunction.andRoute(RequestPredicate, HandlerFunction)\u2009\u2014\u2009shortcut for RouterFunction.and() with nested RouterFunctions.route(). The following example shows the composition of four routes: 1178", "chunk_char_count": 828, "chunk_word_count": 104, "chunk_token_count": 207.0}, {"page_number": 1179, "sentence_chunk": "Java import static org.springframework.http. MediaType. APPLICATION_JSON; import static org.springframework.web.reactive.function.server. RequestPredicates.*;PersonRepository repository = ... PersonHandler handler = new PersonHandler(repository); RouterFunction<ServerResponse> otherRoute = ... RouterFunction<ServerResponse> route = route() \u00a0  . GET(\"/person/{id}\", accept(APPLICATION_JSON), handler::getPerson) \u2460 \u00a0  . GET(\"/person\", accept(APPLICATION_JSON), handler::listPeople) \u2461 \u00a0  . POST(\"/person\", handler::createPerson) \u2462 \u00a0  .add(otherRoute) \u2463 \u00a0  .build(); \u2460 GET /person/{id} with an Accept header that matches JSON is routed to PersonHandler.getPerson \u2461 GET /person with an Accept header that matches JSON is routed to PersonHandler.listPeople \u2462 POST /person with no additional predicates is mapped to PersonHandler.createPerson, and \u2463 otherRoute is a router function that is created elsewhere, and added to the route built. Kotlin import org.springframework.http. MediaType. APPLICATION_JSON val repository: PersonRepository = ... val handler = PersonHandler(repository); val otherRoute: RouterFunction<ServerResponse> = coRouter { } val route = coRouter { \u00a0  GET(\"/person/{id}\", accept(APPLICATION_JSON), handler::getPerson) \u2460 \u00a0  GET(\"/person\", accept(APPLICATION_JSON), handler::listPeople) \u2461 \u00a0  POST(\"/person\", handler::createPerson) \u2462 }.and(otherRoute) \u2463 \u2460 GET /person/{id} with an Accept header that matches JSON is routed to PersonHandler.getPerson \u2461 GET /person with an Accept header that matches JSON is routed to PersonHandler.listPeople \u2462 POST /person with no additional predicates is mapped to PersonHandler.createPerson, and \u2463 otherRoute is a router function that is created elsewhere, and added to the route built. Nested Routes It is common for a group of router functions to have a shared predicate, for instance a shared path. In the example above, the shared predicate would be a path predicate that matches /person, used by three of the routes.", "chunk_char_count": 1972, "chunk_word_count": 252, "chunk_token_count": 493.0}, {"page_number": 1179, "sentence_chunk": "When using annotations, you would remove this duplication by using a type- level @RequestMapping annotation that maps to /person. In WebFlux.fn, path predicates can be 1179", "chunk_char_count": 172, "chunk_word_count": 26, "chunk_token_count": 43.0}, {"page_number": 1180, "sentence_chunk": "shared through the path method on the router function builder. For instance, the last few lines of the example above can be improved in the following way by using nested routes: Java RouterFunction<ServerResponse> route = route() \u00a0  .path(\"/person\", builder -> builder \u2460 \u00a0    . GET(\"/{id}\", accept(APPLICATION_JSON), handler::getPerson) \u00a0    . GET(accept(APPLICATION_JSON), handler::listPeople) \u00a0    . POST(handler::createPerson)) \u00a0  .build(); \u2460 Note that second parameter of path is a consumer that takes the router builder. Kotlin val route = coRouter { \u00a0  \"/person\".nest { \u00a0    GET(\"/{id}\", accept(APPLICATION_JSON), handler::getPerson) \u00a0    GET(accept(APPLICATION_JSON), handler::listPeople) \u00a0    POST(handler::createPerson) \u00a0  } } Though path-based nesting is the most common, you can nest on any kind of predicate by using the nest method on the builder. The above still contains some duplication in the form of the shared Accept-header predicate. We can further improve by using the nest method together with accept: Java RouterFunction<ServerResponse> route = route() \u00a0  .path(\"/person\", b1 -> b1 \u00a0    .nest(accept(APPLICATION_JSON), b2 -> b2 \u00a0      . GET(\"/{id}\", handler::getPerson) \u00a0      . GET(handler::listPeople)) \u00a0    . POST(handler::createPerson)) \u00a0  .build(); Kotlin val route = coRouter { \u00a0  \"/person\".nest { \u00a0    accept(APPLICATION_JSON).nest { \u00a0      GET(\"/{id}\", handler::getPerson) \u00a0      GET(handler::listPeople) \u00a0      POST(handler::createPerson) \u00a0    } \u00a0  } } 1180", "chunk_char_count": 1489, "chunk_word_count": 256, "chunk_token_count": 372.25}, {"page_number": 1181, "sentence_chunk": "Running a Server Web MVC How do you run a router function in an HTTP server?A simple option is to convert a router function to an HttpHandler by using one of the following: \u2022 RouterFunctions.toHttpHandler(RouterFunction) \u2022 RouterFunctions.toHttpHandler(RouterFunction, HandlerStrategies) You can then use the returned HttpHandler with a number of server adapters by following HttpHandler for server-specific instructions. A more typical option, also used by Spring Boot, is to run with a DispatcherHandler-based setup through the WebFlux Config, which uses Spring configuration to declare the components required to process requests. The WebFlux Java configuration declares the following infrastructure components to support functional endpoints: \u2022 RouterFunctionMapping: Detects one or more RouterFunction<?> beans in the Spring configuration, orders them, combines them through RouterFunction.andOther, and routes requests to the resulting composed RouterFunction. \u2022HandlerFunctionAdapter: Simple adapter that lets DispatcherHandler invoke a HandlerFunction that was mapped to a request. \u2022ServerResponseResultHandler: Handles the result from the invocation of a HandlerFunction by invoking the writeTo method of the ServerResponse. The preceding components let functional endpoints fit within the DispatcherHandler request processing lifecycle and also (potentially) run side by side with annotated controllers, if any are declared. It is also how functional endpoints are enabled by the Spring Boot WebFlux starter. The following example shows a WebFlux Java configuration (see DispatcherHandler for how to run it): 1181", "chunk_char_count": 1623, "chunk_word_count": 218, "chunk_token_count": 405.75}, {"page_number": 1182, "sentence_chunk": "Java @Configuration @EnableWebFlux public class WebConfig implements WebFluxConfigurer { \u00a0  @Bean \u00a0  public RouterFunction<?> routerFunctionA() { \u00a0    // ... \u00a0  } \u00a0  @Bean \u00a0  public RouterFunction<?> routerFunctionB() { \u00a0    // ... \u00a0  } \u00a0  // ... \u00a0  @Override \u00a0  public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) { \u00a0    // configure message conversion... \u00a0  } \u00a0  @Override \u00a0  public void addCorsMappings(CorsRegistry registry) { \u00a0    // configure CORS... \u00a0  } \u00a0  @Override \u00a0  public void configureViewResolvers(ViewResolverRegistry registry) { \u00a0    // configure view resolution for HTML rendering... \u00a0  } } 1182", "chunk_char_count": 634, "chunk_word_count": 116, "chunk_token_count": 158.5}, {"page_number": 1183, "sentence_chunk": "Kotlin @Configuration @EnableWebFlux class WebConfig : WebFluxConfigurer { \u00a0  @Bean \u00a0  fun routerFunctionA(): RouterFunction<*> { \u00a0    // ... \u00a0  } \u00a0  @Bean \u00a0  fun routerFunctionB(): RouterFunction<*> { \u00a0    // ... \u00a0  } \u00a0  // ... \u00a0  override fun configureHttpMessageCodecs(configurer: ServerCodecConfigurer) { \u00a0    // configure message conversion... \u00a0  } \u00a0  override fun addCorsMappings(registry: CorsRegistry) { \u00a0    // configure CORS... \u00a0  } \u00a0  override fun configureViewResolvers(registry: ViewResolverRegistry) { \u00a0    // configure view resolution for HTML rendering... \u00a0  } } Filtering Handler Functions Web MVC You can filter handler functions by using the before, after, or filter methods on the routing function builder. With annotations, you can achieve similar functionality by using @ControllerAdvice, a ServletFilter, or both. The filter will apply to all routes that are built by the builder. This means that filters defined in nested routes do not apply to \"top-level\" routes. For instance, consider the following example: 1183", "chunk_char_count": 1039, "chunk_word_count": 176, "chunk_token_count": 259.75}, {"page_number": 1184, "sentence_chunk": "Java RouterFunction<ServerResponse> route = route() \u00a0  .path(\"/person\", b1 -> b1 \u00a0    .nest(accept(APPLICATION_JSON), b2 -> b2 \u00a0      . GET(\"/{id}\", handler::getPerson) \u00a0      . GET(handler::listPeople) \u00a0      .before(request -> ServerRequest.from(request) \u2460 \u00a0        .header(\"X-RequestHeader\", \"Value\") \u00a0        .build())) \u00a0    . POST(handler::createPerson)) \u00a0  .after((request, response) -> logResponse(response)) \u2461 \u00a0  .build(); \u2460 The before filter that adds a custom request header is only applied to the two GET routes.\u2461 The after filter that logs the response is applied to all routes, including the nested ones. Kotlin val route = router { \u00a0  \"/person\".nest { \u00a0    GET(\"/{id}\", handler::getPerson) \u00a0    GET(\"\", handler::listPeople) \u00a0    before { \u2460 \u00a0      ServerRequest.from(it) \u00a0          .header(\"X-RequestHeader\", \"Value\").build() \u00a0    } \u00a0    POST(handler::createPerson) \u00a0    after { _, response -> \u2461 \u00a0      logResponse(response) \u00a0    } \u00a0  } } \u2460 The before filter that adds a custom request header is only applied to the two GET routes.\u2461 The after filter that logs the response is applied to all routes, including the nested ones. The filter method on the router builder takes a HandlerFilterFunction: a function that takes a ServerRequest and HandlerFunction and returns a ServerResponse. The handler function parameter represents the next element in the chain. This is typically the handler that is routed to, but it can also be another filter if multiple are applied. Now we can add a simple security filter to our route, assuming that we have a SecurityManager that can determine whether a particular path is allowed. The following example shows how to do so: 1184", "chunk_char_count": 1676, "chunk_word_count": 321, "chunk_token_count": 419.0}, {"page_number": 1185, "sentence_chunk": "Java SecurityManager securityManager = ... RouterFunction<ServerResponse> route = route() \u00a0  .path(\"/person\", b1 -> b1 \u00a0    .nest(accept(APPLICATION_JSON), b2 -> b2 \u00a0      . GET(\"/{id}\", handler::getPerson) \u00a0      . GET(handler::listPeople)) \u00a0    . POST(handler::createPerson)) \u00a0  .filter((request, next) -> { \u00a0    if (securityManager.allowAccessTo(request.path())) { \u00a0      return next.handle(request); \u00a0    } \u00a0    else { \u00a0      return ServerResponse.status(UNAUTHORIZED).build(); \u00a0    } \u00a0  }) \u00a0  .build(); Kotlin val securityManager: SecurityManager = ... val route = router { \u00a0    (\"/person\" and accept(APPLICATION_JSON)).nest { \u00a0      GET(\"/{id}\", handler::getPerson) \u00a0      GET(\"\", handler::listPeople) \u00a0      POST(handler::createPerson) \u00a0      filter { request, next -> \u00a0        if (securityManager.allowAccessTo(request.path())) { \u00a0          next(request) \u00a0        } \u00a0        else { \u00a0          status(UNAUTHORIZED).build(); \u00a0        } \u00a0      } \u00a0    } \u00a0  } The preceding example demonstrates that invoking the next.handle(ServerRequest) is optional. We only let the handler function be run when access is allowed. Besides using the filter method on the router function builder, it is possible to apply a filter to an existing router function via RouterFunction.filter(HandlerFilterFunction).\uf05a CORS support for functional endpoints is provided through a dedicated CorsWebFilter.1185", "chunk_char_count": 1387, "chunk_word_count": 283, "chunk_token_count": 346.75}, {"page_number": 1186, "sentence_chunk": "6.1.6. URI Links Web MVC This section describes various options available in the Spring Framework to prepare URIs. UriComponents Spring MVC and Spring WebFlux UriComponentsBuilder helps to build URI\u2019s from URI templates with variables, as the following example shows: Java UriComponents uriComponents = UriComponentsBuilder \u00a0    .fromUriString(\"https://example.com/hotels/{hotel}\") \u2460 \u00a0    .queryParam(\"q\", \"{q}\") \u2461 \u00a0    .encode() \u2462 \u00a0    .build(); \u2463 URI uri = uriComponents.expand(\"Westin\", \"123\").toUri(); \u2464 \u2460 Static factory method with a URI template.\u2461 Add or replace URI components.\u2462 Request to have the URI template and URI variables encoded.\u2463 Build a UriComponents.\u2464 Expand variables and obtain the URI. Kotlin val uriComponents = UriComponentsBuilder \u00a0    .fromUriString(\"https://example.com/hotels/{hotel}\") \u2460 \u00a0    .queryParam(\"q\", \"{q}\") \u2461 \u00a0    .encode() \u2462 \u00a0    .build() \u2463 val uri = uriComponents.expand(\"Westin\", \"123\").toUri() \u2464 \u2460 Static factory method with a URI template.\u2461 Add or replace URI components.\u2462 Request to have the URI template and URI variables encoded.", "chunk_char_count": 1075, "chunk_word_count": 166, "chunk_token_count": 268.75}, {"page_number": 1186, "sentence_chunk": "\u2463 Build a UriComponents.\u2464 Expand variables and obtain the URI. The preceding example can be consolidated into one chain and shortened with buildAndExpand, as the following example shows: 1186", "chunk_char_count": 191, "chunk_word_count": 29, "chunk_token_count": 47.75}, {"page_number": 1187, "sentence_chunk": "Java URI uri = UriComponentsBuilder \u00a0    .fromUriString(\"https://example.com/hotels/{hotel}\") \u00a0    .queryParam(\"q\", \"{q}\") \u00a0    .encode() \u00a0    .buildAndExpand(\"Westin\", \"123\") \u00a0    .toUri(); Kotlin val uri = UriComponentsBuilder \u00a0    .fromUriString(\"https://example.com/hotels/{hotel}\") \u00a0    .queryParam(\"q\", \"{q}\") \u00a0    .encode() \u00a0    .buildAndExpand(\"Westin\", \"123\") \u00a0    .toUri() You can shorten it further by going directly to a URI (which implies encoding), as the following example shows: Java URI uri = UriComponentsBuilder \u00a0    .fromUriString(\"https://example.com/hotels/{hotel}\") \u00a0    .queryParam(\"q\", \"{q}\") \u00a0    .build(\"Westin\", \"123\"); Kotlin val uri = UriComponentsBuilder \u00a0    .fromUriString(\"https://example.com/hotels/{hotel}\") \u00a0    .queryParam(\"q\", \"{q}\") \u00a0    .build(\"Westin\", \"123\") You can shorten it further still with a full URI template, as the following example shows: Java URI uri = UriComponentsBuilder \u00a0    .fromUriString(\"https://example.com/hotels/{hotel}?q={q}\") \u00a0    .build(\"Westin\", \"123\"); 1187", "chunk_char_count": 1027, "chunk_word_count": 160, "chunk_token_count": 256.75}, {"page_number": 1188, "sentence_chunk": "Kotlin val uri = UriComponentsBuilder \u00a0    .fromUriString(\"https://example.com/hotels/{hotel}?q={q}\") \u00a0    .build(\"Westin\", \"123\") UriBuilder Spring MVC and Spring WebFlux UriComponentsBuilder implements UriBuilder. You can create a UriBuilder, in turn, with a UriBuilderFactory. Together, UriBuilderFactory and UriBuilder provide a pluggable mechanism to build URIs from URI templates, based on shared configuration, such as a base URL, encoding preferences, and other details. You can configure RestTemplate and WebClient with a UriBuilderFactory to customize the preparation of URIs. DefaultUriBuilderFactory is a default implementation of UriBuilderFactory that uses UriComponentsBuilder internally and exposes shared configuration options. The following example shows how to configure a RestTemplate: Java // import org.springframework.web.util. DefaultUriBuilderFactory. EncodingMode; String baseUrl = \"https://example.org\"; DefaultUriBuilderFactory factory = new DefaultUriBuilderFactory(baseUrl); factory.setEncodingMode(EncodingMode. TEMPLATE_AND_VALUES); RestTemplate restTemplate = new RestTemplate(); restTemplate.setUriTemplateHandler(factory); Kotlin // import org.springframework.web.util. DefaultUriBuilderFactory.", "chunk_char_count": 1230, "chunk_word_count": 131, "chunk_token_count": 307.5}, {"page_number": 1188, "sentence_chunk": "EncodingMode val baseUrl = \"https://example.org\" val factory = DefaultUriBuilderFactory(baseUrl) factory.encodingMode = EncodingMode. TEMPLATE_AND_VALUES val restTemplate = RestTemplate() restTemplate.uriTemplateHandler = factory The following example configures a WebClient: 1188", "chunk_char_count": 280, "chunk_word_count": 27, "chunk_token_count": 70.0}, {"page_number": 1189, "sentence_chunk": "Java // import org.springframework.web.util. DefaultUriBuilderFactory. EncodingMode; String baseUrl = \"https://example.org\"; DefaultUriBuilderFactory factory = new DefaultUriBuilderFactory(baseUrl); factory.setEncodingMode(EncodingMode. TEMPLATE_AND_VALUES); WebClient client = WebClient.builder().uriBuilderFactory(factory).build(); Kotlin // import org.springframework.web.util. DefaultUriBuilderFactory. EncodingMode val baseUrl = \"https://example.org\" val factory = DefaultUriBuilderFactory(baseUrl) factory.encodingMode = EncodingMode. TEMPLATE_AND_VALUES val client = WebClient.builder().uriBuilderFactory(factory).build() In addition, you can also use DefaultUriBuilderFactory directly. It is similar to using UriComponentsBuilder but, instead of static factory methods, it is an actual instance that holds configuration and preferences, as the following example shows: Java String baseUrl = \"https://example.com\"; DefaultUriBuilderFactory uriBuilderFactory = new DefaultUriBuilderFactory(baseUrl); URI uri = uriBuilderFactory.uriString(\"/hotels/{hotel}\") \u00a0    .queryParam(\"q\", \"{q}\") \u00a0    .build(\"Westin\", \"123\"); Kotlin val baseUrl = \"https://example.com\" val uriBuilderFactory = DefaultUriBuilderFactory(baseUrl) val uri = uriBuilderFactory.uriString(\"/hotels/{hotel}\") \u00a0    .queryParam(\"q\", \"{q}\") \u00a0    .build(\"Westin\", \"123\") URI Encoding Spring MVC and Spring WebFlux UriComponentsBuilder exposes encoding options at two levels: \u2022 UriComponentsBuilder#encode(): Pre-encodes the URI template first and then strictly encodes 1189", "chunk_char_count": 1540, "chunk_word_count": 155, "chunk_token_count": 385.0}, {"page_number": 1190, "sentence_chunk": "URI variables when expanded. \u2022UriComponents#encode(): Encodes URI components after URI variables are expanded. Both options replace non-ASCII and illegal characters with escaped octets. However, the first option also replaces characters with reserved meaning that appear in URI variables.\uf0eb Consider \";\", which is legal in a path but has reserved meaning. The first option replaces \";\" with \"%3B\" in URI variables but not in the URI template. By contrast, the second option never replaces \";\", since it is a legal character in a path. For most cases, the first option is likely to give the expected result, because it treats URI variables as opaque data to be fully encoded, while the second option is useful if URI variables do intentionally contain reserved characters. The second option is also useful when not expanding URI variables at all since that will also encode anything that incidentally looks like a URI variable. The following example uses the first option: Java URI uri = UriComponentsBuilder.fromPath(\"/hotel list/{city}\") \u00a0    .queryParam(\"q\", \"{q}\") \u00a0    .encode() \u00a0    .buildAndExpand(\"New York\", \"foo+bar\") \u00a0    .toUri(); // Result is \"/hotel%20list/New%20York?q=foo%2Bbar\" Kotlin val uri = UriComponentsBuilder.fromPath(\"/hotel list/{city}\") \u00a0    .queryParam(\"q\", \"{q}\") \u00a0    .encode() \u00a0    .buildAndExpand(\"New York\", \"foo+bar\") \u00a0    .toUri() // Result is \"/hotel%20list/New%20York?q=foo%2Bbar\" You can shorten the preceding example by going directly to the URI (which implies encoding), as the following example shows: Java URI uri = UriComponentsBuilder.fromPath(\"/hotel list/{city}\") \u00a0    .queryParam(\"q\", \"{q}\") \u00a0    .build(\"New York\", \"foo+bar\"); 1190", "chunk_char_count": 1677, "chunk_word_count": 261, "chunk_token_count": 419.25}, {"page_number": 1191, "sentence_chunk": "Kotlin val uri = UriComponentsBuilder.fromPath(\"/hotel list/{city}\") \u00a0    .queryParam(\"q\", \"{q}\") \u00a0    .build(\"New York\", \"foo+bar\") You can shorten it further still with a full URI template, as the following example shows: Java URI uri = UriComponentsBuilder.fromUriString(\"/hotel list/{city}?q={q}\") \u00a0    .build(\"New York\", \"foo+bar\"); Kotlin val uri = UriComponentsBuilder.fromUriString(\"/hotel list/{city}?q={q}\") \u00a0    .build(\"New York\", \"foo+bar\") The WebClient and the RestTemplate expand and encode URI templates internally through the UriBuilderFactory strategy. Both can be configured with a custom strategy, as the following example shows: Java String baseUrl = \"https://example.com\"; DefaultUriBuilderFactory factory = new DefaultUriBuilderFactory(baseUrl) factory.setEncodingMode(EncodingMode. TEMPLATE_AND_VALUES); // Customize the RestTemplate.. RestTemplate restTemplate = new RestTemplate(); restTemplate.setUriTemplateHandler(factory); // Customize the WebClient.. WebClient client = WebClient.builder().uriBuilderFactory(factory).build(); 1191", "chunk_char_count": 1061, "chunk_word_count": 120, "chunk_token_count": 265.25}, {"page_number": 1192, "sentence_chunk": "Kotlin val baseUrl = \"https://example.com\" val factory = DefaultUriBuilderFactory(baseUrl).apply { \u00a0  encodingMode = EncodingMode. TEMPLATE_AND_VALUES } // Customize the RestTemplate.. val restTemplate = RestTemplate().apply { \u00a0  uriTemplateHandler = factory } // Customize the WebClient.. val client = WebClient.builder().uriBuilderFactory(factory).build() The DefaultUriBuilderFactory implementation uses UriComponentsBuilder internally to expand and encode URI templates. As a factory, it provides a single place to configure the approach to encoding, based on one of the below encoding modes: \u2022 TEMPLATE_AND_VALUES: Uses UriComponentsBuilder#encode(), corresponding to the first option in the earlier list, to pre-encode the URI template and strictly encode URI variables when expanded. \u2022VALUES_ONLY: Does not encode the URI template and, instead, applies strict encoding to URI variables through UriUtils#encodeUriVariables prior to expanding them into the template. \u2022URI_COMPONENT: Uses UriComponents#encode(), corresponding to the second option in the earlier list, to encode URI component value after URI variables are expanded. \u2022NONE: No encoding is applied. The RestTemplate is set to EncodingMode. URI_COMPONENT for historic reasons and for backwards compatibility. The WebClient relies on the default value in DefaultUriBuilderFactory, which was changed from EncodingMode. URI_COMPONENT in 5.0.x to EncodingMode.", "chunk_char_count": 1424, "chunk_word_count": 183, "chunk_token_count": 356.0}, {"page_number": 1192, "sentence_chunk": "TEMPLATE_AND_VALUES in 5.1.6.1.7. CORS Web MVC Spring WebFlux lets you handle CORS (Cross-Origin Resource Sharing). This section describes how to do so. Introduction Web MVC For security reasons, browsers prohibit AJAX calls to resources outside the current origin. For example, you could have your bank account in one tab and evil.com in another. Scripts from evil.com should not be able to make AJAX requests to your bank API with your credentials\u2009\u2014\u2009for example, withdrawing money from your account!Cross-Origin Resource Sharing (CORS) is a W3C specification implemented by most browsers that 1192", "chunk_char_count": 599, "chunk_word_count": 90, "chunk_token_count": 149.75}, {"page_number": 1193, "sentence_chunk": "lets you specify what kind of cross-domain requests are authorized, rather than using less secure and less powerful workarounds based on IFRAME or JSONP. Processing Web MVC The CORS specification distinguishes between preflight, simple, and actual requests. To learn how CORS works, you can read this article, among many others, or see the specification for more details. Spring WebFlux HandlerMapping implementations provide built-in support for CORS. After successfully mapping a request to a handler, a HandlerMapping checks the CORS configuration for the given request and handler and takes further actions. Preflight requests are handled directly, while simple and actual CORS requests are intercepted, validated, and have the required CORS response headers set. In order to enable cross-origin requests (that is, the Origin header is present and differs from the host of the request), you need to have some explicitly declared CORS configuration. If no matching CORS configuration is found, preflight requests are rejected. No CORS headers are added to the responses of simple and actual CORS requests and, consequently, browsers reject them. Each HandlerMapping can be configured individually with URL pattern-based CorsConfiguration mappings.", "chunk_char_count": 1250, "chunk_word_count": 183, "chunk_token_count": 312.5}, {"page_number": 1193, "sentence_chunk": "In most cases, applications use the WebFlux Java configuration to declare such mappings, which results in a single, global map passed to all HandlerMapping implementations. You can combine global CORS configuration at the HandlerMapping level with more fine-grained, handler-level CORS configuration. For example, annotated controllers can use class- or method- level @CrossOrigin annotations (other handlers can implement CorsConfigurationSource). The rules for combining global and local configuration are generally additive\u2009\u2014\u2009for example, all global and all local origins. For those attributes where only a single value can be accepted, such as allowCredentials and maxAge, the local overrides the global value. See CorsConfiguration#combine(CorsConfiguration) for more details.\uf0eb To learn more from the source or to make advanced customizations, see: \u2022 CorsConfiguration \u2022 CorsProcessor and DefaultCorsProcessor \u2022 AbstractHandlerMapping @CrossOrigin Web MVC The @CrossOrigin annotation enables cross-origin requests on annotated controller methods, as the following example shows: 1193", "chunk_char_count": 1088, "chunk_word_count": 142, "chunk_token_count": 272.0}, {"page_number": 1194, "sentence_chunk": "Java @RestController @RequestMapping(\"/account\") public class AccountController { \u00a0  @CrossOrigin \u00a0  @GetMapping(\"/{id}\") \u00a0  public Mono<Account> retrieve(@PathVariable Long id) { \u00a0    // ... \u00a0  } \u00a0  @DeleteMapping(\"/{id}\") \u00a0  public Mono<Void> remove(@PathVariable Long id) { \u00a0    // ... \u00a0  } } Kotlin @RestController @RequestMapping(\"/account\") class AccountController { \u00a0  @CrossOrigin \u00a0  @GetMapping(\"/{id}\") \u00a0  suspend fun retrieve(@PathVariable id: Long): Account { \u00a0    // ... \u00a0  } \u00a0  @DeleteMapping(\"/{id}\") \u00a0  suspend fun remove(@PathVariable id: Long) { \u00a0    // ... \u00a0  } } By default, @CrossOrigin allows: \u2022 All origins. \u2022All headers. \u2022All HTTP methods to which the controller method is mapped.allowCredentials is not enabled by default, since that establishes a trust level that exposes sensitive user-specific information (such as cookies and CSRF tokens) and should be used only where appropriate. When it is enabled either allowOrigins must be set to one or more specific domain (but not the special value \"*\") or alternatively the allowOriginPatterns property may be used to match to a dynamic set of origins.maxAge is set to 30 minutes.1194", "chunk_char_count": 1156, "chunk_word_count": 192, "chunk_token_count": 289.0}, {"page_number": 1195, "sentence_chunk": "@CrossOrigin is supported at the class level, too, and inherited by all methods. The following example specifies a certain domain and sets maxAge to an hour: Java @CrossOrigin(origins = \"https://domain2.com\", maxAge = 3600) @RestController @RequestMapping(\"/account\") public class AccountController { \u00a0  @GetMapping(\"/{id}\") \u00a0  public Mono<Account> retrieve(@PathVariable Long id) { \u00a0    // ... \u00a0  } \u00a0  @DeleteMapping(\"/{id}\") \u00a0  public Mono<Void> remove(@PathVariable Long id) { \u00a0    // ... \u00a0  } } Kotlin @CrossOrigin(\"https://domain2.com\", maxAge = 3600) @RestController @RequestMapping(\"/account\") class AccountController { \u00a0  @GetMapping(\"/{id}\") \u00a0  suspend fun retrieve(@PathVariable id: Long): Account { \u00a0    // ... \u00a0  } \u00a0  @DeleteMapping(\"/{id}\") \u00a0  suspend fun remove(@PathVariable id: Long) { \u00a0    // ... \u00a0  } } You can use @CrossOrigin at both the class and the method level, as the following example shows: 1195", "chunk_char_count": 922, "chunk_word_count": 150, "chunk_token_count": 230.5}, {"page_number": 1196, "sentence_chunk": "Java @CrossOrigin(maxAge = 3600) \u2460 @RestController @RequestMapping(\"/account\") public class AccountController { \u00a0  @CrossOrigin(\"https://domain2.com\") \u2461 \u00a0  @GetMapping(\"/{id}\") \u00a0  public Mono<Account> retrieve(@PathVariable Long id) { \u00a0    // ... \u00a0  } \u00a0  @DeleteMapping(\"/{id}\") \u00a0  public Mono<Void> remove(@PathVariable Long id) { \u00a0    // ... \u00a0  } } \u2460 Using @CrossOrigin at the class level.\u2461 Using @CrossOrigin at the method level. Kotlin @CrossOrigin(maxAge = 3600) \u2460 @RestController @RequestMapping(\"/account\") class AccountController { \u00a0  @CrossOrigin(\"https://domain2.com\") \u2461 \u00a0  @GetMapping(\"/{id}\") \u00a0  suspend fun retrieve(@PathVariable id: Long): Account { \u00a0    // ... \u00a0  } \u00a0  @DeleteMapping(\"/{id}\") \u00a0  suspend fun remove(@PathVariable id: Long) { \u00a0    // ... \u00a0  } } \u2460 Using @CrossOrigin at the class level.\u2461 Using @CrossOrigin at the method level. Global Configuration Web MVC In addition to fine-grained, controller method-level configuration, you probably want to define some global CORS configuration, too. You can set URL-based CorsConfiguration mappings 1196", "chunk_char_count": 1072, "chunk_word_count": 166, "chunk_token_count": 268.0}, {"page_number": 1197, "sentence_chunk": "individually on any HandlerMapping. Most applications, however, use the WebFlux Java configuration to do that. By default global configuration enables the following: \u2022 All origins. \u2022All headers. \u2022GET, HEAD, and POST methods.allowedCredentials is not enabled by default, since that establishes a trust level that exposes sensitive user-specific information( such as cookies and CSRF tokens) and should be used only where appropriate. When it is enabled either allowOrigins must be set to one or more specific domain (but not the special value \"*\") or alternatively the allowOriginPatterns property may be used to match to a dynamic set of origins.maxAge is set to 30 minutes. To enable CORS in the WebFlux Java configuration, you can use the CorsRegistry callback, as the following example shows: Java @Configuration @EnableWebFlux public class WebConfig implements WebFluxConfigurer { \u00a0  @Override \u00a0  public void addCorsMappings(CorsRegistry registry) { \u00a0    registry.addMapping(\"/api/**\") \u00a0      .allowedOrigins(\"https://domain2.com\") \u00a0      .allowedMethods(\"PUT\", \"DELETE\") \u00a0      .allowedHeaders(\"header1\", \"header2\", \"header3\") \u00a0      .exposedHeaders(\"header1\", \"header2\") \u00a0      .allowCredentials(true).maxAge(3600); \u00a0    // Add more mappings... \u00a0  } } 1197", "chunk_char_count": 1262, "chunk_word_count": 198, "chunk_token_count": 315.5}, {"page_number": 1198, "sentence_chunk": "Kotlin @Configuration @EnableWebFlux class WebConfig : WebFluxConfigurer { \u00a0  override fun addCorsMappings(registry: CorsRegistry) { \u00a0    registry.addMapping(\"/api/**\") \u00a0        .allowedOrigins(\"https://domain2.com\") \u00a0        .allowedMethods(\"PUT\", \"DELETE\") \u00a0        .allowedHeaders(\"header1\", \"header2\", \"header3\") \u00a0        .exposedHeaders(\"header1\", \"header2\") \u00a0        .allowCredentials(true).maxAge(3600) \u00a0    // Add more mappings... \u00a0  } } CORS WebFilter Web MVC You can apply CORS support through the built-in CorsWebFilter, which is a good fit with functional endpoints.\uf05a If you try to use the CorsFilter with Spring Security, keep in mind that Spring Security has built-in support for CORS. To configure the filter, you can declare a CorsWebFilter bean and pass a CorsConfigurationSource to its constructor, as the following example shows: 1198", "chunk_char_count": 853, "chunk_word_count": 146, "chunk_token_count": 213.25}, {"page_number": 1199, "sentence_chunk": "Java @Bean CorsWebFilter corsFilter() { \u00a0  CorsConfiguration config = new CorsConfiguration(); \u00a0  // Possibly... \u00a0  // config.applyPermitDefaultValues() \u00a0  config.setAllowCredentials(true); \u00a0  config.addAllowedOrigin(\"https://domain1.com\"); \u00a0  config.addAllowedHeader(\"*\"); \u00a0  config.addAllowedMethod(\"*\"); \u00a0  UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(); \u00a0  source.registerCorsConfiguration(\"/**\", config); \u00a0  return new CorsWebFilter(source); } Kotlin @Bean fun corsFilter(): CorsWebFilter { \u00a0  val config = CorsConfiguration() \u00a0  // Possibly... \u00a0  // config.applyPermitDefaultValues() \u00a0  config.allowCredentials = true \u00a0  config.addAllowedOrigin(\"https://domain1.com\") \u00a0  config.addAllowedHeader(\"*\") \u00a0  config.addAllowedMethod(\"*\") \u00a0  val source = UrlBasedCorsConfigurationSource().apply { \u00a0    registerCorsConfiguration(\"/**\", config) \u00a0  } \u00a0  return CorsWebFilter(source) } 6.1.8. Error Responses Web MVC A common requirement for REST services is to include details in the body of error responses. The Spring Framework supports the \"Problem Details for HTTP APIs\" specification, RFC 7807. The following are the main abstractions for this support: 1199", "chunk_char_count": 1190, "chunk_word_count": 148, "chunk_token_count": 297.5}, {"page_number": 1200, "sentence_chunk": "\u2022 ProblemDetail\u2009\u2014\u2009representation for an RFC 7807 problem detail; a simple container for both standard fields defined in the spec, and for non-standard ones. \u2022ErrorResponse\u2009\u2014\u2009contract to expose HTTP error response details including HTTP status, response headers, and a body in the format of RFC 7807; this allows exceptions to encapsulate and expose the details of how they map to an HTTP response. All Spring WebFlux exceptions implement this. \u2022ErrorResponseException\u2009\u2014\u2009basic ErrorResponse implementation that others can use as a convenient base class. \u2022ResponseEntityExceptionHandler\u2009\u2014\u2009convenient base class for an @ControllerAdvice that handles all Spring WebFlux exceptions, and any ErrorResponseException, and renders an error response with a body. Render Web MVC You can return ProblemDetail or ErrorResponse from any @ExceptionHandler or from any @RequestMapping method to render an RFC 7807 response. This is processed as follows: \u2022 The status property of ProblemDetail determines the HTTP status. \u2022The instance property of ProblemDetail is set from the current URL path, if not already set. \u2022For content negotiation, the Jackson HttpMessageConverter prefers \"application/problem+json\" over \"application/json\" when rendering a ProblemDetail, and also falls back on it if no compatible media type is found. To enable RFC 7807 responses for Spring WebFlux exceptions and for any ErrorResponseException, extend ResponseEntityExceptionHandler and declare it as an @ControllerAdvice in Spring configuration.", "chunk_char_count": 1509, "chunk_word_count": 207, "chunk_token_count": 377.25}, {"page_number": 1200, "sentence_chunk": "The handler has an @ExceptionHandler method that handles any ErrorResponse exception, which includes all built-in web exceptions. You can add more exception handling methods, and use a protected method to map any exception to a ProblemDetail. Non-Standard Fields Web MVC You can extend an RFC 7807 response with non-standard fields in one of two ways. One, insert into the \"properties\" Map of ProblemDetail. When using the Jackson library, the Spring Framework registers ProblemDetailJacksonMixin that ensures this \"properties\" Map is unwrapped and rendered as top level JSON properties in the response, and likewise any unknown property during deserialization is inserted into this Map. You can also extend ProblemDetail to add dedicated non-standard properties. The copy constructor in ProblemDetail allows a subclass to make it easy to be created from an existing ProblemDetail. This could be done centrally, e.g. from an @ControllerAdvice such as ResponseEntityExceptionHandler that re-creates the ProblemDetail of an exception into a subclass with the additional non-standard fields.1200", "chunk_char_count": 1092, "chunk_word_count": 158, "chunk_token_count": 273.0}, {"page_number": 1201, "sentence_chunk": "Internationalization Web MVC It is a common requirement to internationalize error response details, and good practice to customize the problem details for Spring WebFlux exceptions. This is supported as follows: \u2022 Each ErrorResponse exposes a message code and arguments to resolve the \"detail\" field through a MessageSource. The actual message code value is parameterized with placeholders, e.g. \"HTTP method {0} not supported\" to be expanded from the arguments. \u2022Each ErrorResponse also exposes a message code to resolve the \"title\" field. \u2022ResponseEntityExceptionHandler uses the message code and arguments to resolve the \"detail\" and the \"title\" fields. By default, the message code for the \"detail\" field is \"problemDetail.\"+ the fully qualified exception class name. Some exceptions may expose additional message codes in which case a suffix is added to the default message code. The table below lists message arguments and codes for Spring WebFlux exceptions: Exception Message Code Message Code Arguments UnsupportedMediaTypeSt atusException (default) {0} the media type that is not supported, {1} list of supported media types UnsupportedMediaTypeSt atusException (default) + \".parseError\" MissingRequestValueExc eption (default) {0} a label for the value (e.g. \"request header\", \"cookie value\", \u2026), {1} the value name UnsatisfiedRequestPara meterException (default) {0} the list of parameter conditions WebExchangeBindExcepti on (default) {0} the list of global errors, {1} the list of field errors. Message codes and arguments for each error within the BindingResult are also resolved via MessageSource.", "chunk_char_count": 1613, "chunk_word_count": 229, "chunk_token_count": 403.25}, {"page_number": 1201, "sentence_chunk": "NotAcceptableStatusExc eption (default) {0} list of supported media types NotAcceptableStatusExc eption (default) + \".parseError\" ServerErrorException (default) {0} the failure reason provided to the class constructor MethodNotAllowedExcept ion (default) {0} the current HTTP method, {1} the list of supported HTTP methods By default, the message code for the \"title\" field is \"problemDetail.title.\"+ the fully qualified exception class name.1201", "chunk_char_count": 446, "chunk_word_count": 57, "chunk_token_count": 111.5}, {"page_number": 1202, "sentence_chunk": "Client Handling Web MVC A client application can catch WebClientResponseException, when using the WebClient, or RestClientResponseException when using the RestTemplate, and use their getResponseBodyAs methods to decode the error response body to any target type such as ProblemDetail, or a subclass of ProblemDetail.6.1.9. Web Security Web MVC The Spring Security project provides support for protecting web applications from malicious exploits. See the Spring Security reference documentation, including: \u2022 WebFlux Security \u2022 WebFlux Testing Support \u2022 CSRF protection \u2022 Security Response Headers 6.1.10. HTTP Caching Web MVC HTTP caching can significantly improve the performance of a web application. HTTP caching revolves around the Cache-Control response header and subsequent conditional request headers, such as Last-Modified and ETag. Cache-Control advises private (for example, browser) and public (for example, proxy) caches how to cache and re-use responses. An ETag header is used to make a conditional request that may result in a 304 (NOT_MODIFIED) without a body, if the content has not changed. ETag can be seen as a more sophisticated successor to the Last-Modified header. This section describes the HTTP caching related options available in Spring WebFlux.", "chunk_char_count": 1274, "chunk_word_count": 184, "chunk_token_count": 318.5}, {"page_number": 1202, "sentence_chunk": "CacheControl Web MVC CacheControl provides support for configuring settings related to the Cache-Control header and is accepted as an argument in a number of places: \u2022 Controllers \u2022 Static Resources While RFC 7234 describes all possible directives for the Cache-Control response header, the CacheControl type takes a use case-oriented approach that focuses on the common scenarios, as the following example shows: 1202", "chunk_char_count": 418, "chunk_word_count": 62, "chunk_token_count": 104.5}, {"page_number": 1203, "sentence_chunk": "Java // Cache for an hour - \"Cache-Control: max-age=3600\" CacheControl ccCacheOneHour = CacheControl.maxAge(1, TimeUnit. HOURS); // Prevent caching - \"Cache-Control: no-store\" CacheControl ccNoStore = CacheControl.noStore(); // Cache for ten days in public and private caches, // public caches should not transform the response // \"Cache-Control: max-age=864000, public, no-transform\" CacheControl ccCustom = CacheControl.maxAge(10, TimeUnit. DAYS).noTransform().cachePublic(); Kotlin // Cache for an hour - \"Cache-Control: max-age=3600\" val ccCacheOneHour = CacheControl.maxAge(1, TimeUnit. HOURS) // Prevent caching - \"Cache-Control: no-store\" val ccNoStore = CacheControl.noStore() // Cache for ten days in public and private caches, // public caches should not transform the response // \"Cache-Control: max-age=864000, public, no-transform\" val ccCustom = CacheControl.maxAge(10, TimeUnit. DAYS).noTransform().cachePublic() Controllers Web MVC Controllers can add explicit support for HTTP caching. We recommend doing so, since the lastModified or ETag value for a resource needs to be calculated before it can be compared against conditional request headers. A controller can add an ETag and Cache-Control settings to a ResponseEntity, as the following example shows: 1203", "chunk_char_count": 1277, "chunk_word_count": 163, "chunk_token_count": 319.25}, {"page_number": 1204, "sentence_chunk": "Java @GetMapping(\"/book/{id}\") public ResponseEntity<Book> showBook(@PathVariable Long id) { \u00a0  Book book = findBook(id); \u00a0  String version = book.getVersion(); \u00a0  return ResponseEntity \u00a0      .ok() \u00a0      .cacheControl(CacheControl.maxAge(30, TimeUnit. DAYS)) \u00a0      .eTag(version) // lastModified is also available \u00a0      .body(book); } Kotlin @GetMapping(\"/book/{id}\") fun showBook(@PathVariable id: Long): ResponseEntity<Book> { \u00a0  val book = findBook(id) \u00a0  val version = book.getVersion() \u00a0  return ResponseEntity \u00a0      .ok() \u00a0      .cacheControl(CacheControl.maxAge(30, TimeUnit. DAYS)) \u00a0      .eTag(version) // lastModified is also available \u00a0      .body(book) } The preceding example sends a 304 (NOT_MODIFIED) response with an empty body if the comparison to the conditional request headers indicates the content has not changed. Otherwise, the ETag and Cache-Control headers are added to the response. You can also make the check against conditional request headers in the controller, as the following example shows: 1204", "chunk_char_count": 1033, "chunk_word_count": 176, "chunk_token_count": 258.25}, {"page_number": 1205, "sentence_chunk": "Java @RequestMapping public String myHandleMethod(ServerWebExchange exchange, Model model) { \u00a0  long eTag = ... \u2460 \u00a0  if (exchange.checkNotModified(eTag)) { \u00a0    return null; \u2461 \u00a0  } \u00a0  model.addAttribute(...); \u2462 \u00a0  return \"myViewName\"; } \u2460 Application-specific calculation.\u2461 Response has been set to 304 (NOT_MODIFIED). No further processing.\u2462 Continue with request processing. Kotlin @RequestMapping fun myHandleMethod(exchange: ServerWebExchange, model: Model): String? {\u00a0  val eTag: Long = ... \u2460 \u00a0  if (exchange.checkNotModified(eTag)) { \u00a0    return null\u2461 \u00a0  } \u00a0  model.addAttribute(...) \u2462 \u00a0  return \"myViewName\" } \u2460 Application-specific calculation.\u2461 Response has been set to 304 (NOT_MODIFIED). No further processing.\u2462 Continue with request processing. There are three variants for checking conditional requests against eTag values, lastModified values, or both.", "chunk_char_count": 866, "chunk_word_count": 128, "chunk_token_count": 216.5}, {"page_number": 1205, "sentence_chunk": "For conditional GET and HEAD requests, you can set the response to 304 (NOT_MODIFIED). For conditional POST, PUT, and DELETE, you can instead set the response to 412 (PRECONDITION_FAILED) to prevent concurrent modification. Static Resources Web MVC You should serve static resources with a Cache-Control and conditional response headers for optimal performance. See the section on configuring Static Resources.1205", "chunk_char_count": 414, "chunk_word_count": 59, "chunk_token_count": 103.5}, {"page_number": 1206, "sentence_chunk": "6.1.11. View Technologies Web MVC The use of view technologies in Spring WebFlux is pluggable. Whether you decide to use Thymeleaf, FreeMarker, or some other view technology is primarily a matter of a configuration change. This chapter covers the view technologies integrated with Spring WebFlux. We assume you are already familiar with View Resolution. Thymeleaf Web MVC Thymeleaf is a modern server-side Java template engine that emphasizes natural HTML templates that can be previewed in a browser by double-clicking, which is very helpful for independent work on UI templates (for example, by a designer) without the need for a running server. Thymeleaf offers an extensive set of features, and it is actively developed and maintained. For a more complete introduction, see the Thymeleaf project home page. The Thymeleaf integration with Spring WebFlux is managed by the Thymeleaf project. The configuration involves a few bean declarations, such as SpringResourceTemplateResolver, SpringWebFluxTemplateEngine, and ThymeleafReactiveViewResolver.", "chunk_char_count": 1049, "chunk_word_count": 151, "chunk_token_count": 262.25}, {"page_number": 1206, "sentence_chunk": "For more details, see Thymeleaf+Spring and the WebFlux integration announcement. FreeMarker Web MVC Apache FreeMarker is a template engine for generating any kind of text output from HTML to email and others. The Spring Framework has built-in integration for using Spring WebFlux with FreeMarker templates. View Configuration Web MVC The following example shows how to configure FreeMarker as a view technology: 1206", "chunk_char_count": 416, "chunk_word_count": 62, "chunk_token_count": 104.0}, {"page_number": 1207, "sentence_chunk": "Java @Configuration @EnableWebFlux public class WebConfig implements WebFluxConfigurer { \u00a0  @Override \u00a0  public void configureViewResolvers(ViewResolverRegistry registry) { \u00a0    registry.freeMarker(); \u00a0  } \u00a0  // Configure FreeMarker... \u00a0  @Bean \u00a0  public FreeMarkerConfigurer freeMarkerConfigurer() { \u00a0    FreeMarkerConfigurer configurer = new FreeMarkerConfigurer(); \u00a0    configurer.setTemplateLoaderPath(\"classpath:/templates/freemarker\"); \u00a0    return configurer; \u00a0  } } Kotlin @Configuration @EnableWebFlux class WebConfig : WebFluxConfigurer { \u00a0  override fun configureViewResolvers(registry: ViewResolverRegistry) { \u00a0    registry.freeMarker() \u00a0  } \u00a0  // Configure FreeMarker... \u00a0  @Bean \u00a0  fun freeMarkerConfigurer() = FreeMarkerConfigurer().apply { \u00a0    setTemplateLoaderPath(\"classpath:/templates/freemarker\") \u00a0  } } Your templates need to be stored in the directory specified by the FreeMarkerConfigurer, shown in the preceding example. Given the preceding configuration, if your controller returns the view name, welcome, the resolver looks for the classpath:/templates/freemarker/welcome.ftl template. FreeMarker Configuration Web MVC You can pass FreeMarker 'Settings' and 'SharedVariables' directly to the FreeMarker Configuration object (which is managed by Spring) by setting the appropriate bean properties on the FreeMarkerConfigurer bean. The freemarkerSettings property requires a java.util. Properties object, 1207", "chunk_char_count": 1433, "chunk_word_count": 190, "chunk_token_count": 358.25}, {"page_number": 1208, "sentence_chunk": "and the freemarkerVariables property requires a java.util. Map. The following example shows how to use a FreeMarkerConfigurer: Java @Configuration @EnableWebFlux public class WebConfig implements WebFluxConfigurer { \u00a0  // ... \u00a0  @Bean \u00a0  public FreeMarkerConfigurer freeMarkerConfigurer() { \u00a0    Map<String, Object> variables = new HashMap<>(); \u00a0    variables.put(\"xml_escape\", new XmlEscape()); \u00a0    FreeMarkerConfigurer configurer = new FreeMarkerConfigurer(); \u00a0    configurer.setTemplateLoaderPath(\"classpath:/templates\"); \u00a0    configurer.setFreemarkerVariables(variables); \u00a0    return configurer; \u00a0  } } Kotlin @Configuration @EnableWebFlux class WebConfig : WebFluxConfigurer { \u00a0  // ... \u00a0  @Bean \u00a0  fun freeMarkerConfigurer() = FreeMarkerConfigurer().apply { \u00a0    setTemplateLoaderPath(\"classpath:/templates\") \u00a0    setFreemarkerVariables(mapOf(\"xml_escape\" to XmlEscape())) \u00a0  } } See the FreeMarker documentation for details of settings and variables as they apply to the Configuration object. Form Handling Web MVC Spring provides a tag library for use in JSPs that contains, among others, a <spring:bind/> element. This element primarily lets forms display values from form-backing objects and show the results of failed validations from a Validator in the web or business tier. Spring also has support for the same functionality in FreeMarker, with additional convenience macros for generating form input elements themselves.1208", "chunk_char_count": 1439, "chunk_word_count": 206, "chunk_token_count": 359.75}, {"page_number": 1209, "sentence_chunk": "The Bind Macros Web MVC A standard set of macros are maintained within the spring-webflux.jar file for FreeMarker, so they are always available to a suitably configured application. Some of the macros defined in the Spring templating libraries are considered internal (private), but no such scoping exists in the macro definitions, making all macros visible to calling code and user templates. The following sections concentrate only on the macros you need to directly call from within your templates. If you wish to view the macro code directly, the file is called spring.ftl and is in the org.springframework.web.reactive.result.view.freemarker package. For additional details on binding support, see Simple Binding for Spring MVC. Form Macros For details on Spring\u2019s form macro support for FreeMarker templates, consult the following sections of the Spring MVC documentation. \u2022Input Macros \u2022 Input Fields \u2022 Selection Fields \u2022 HTML Escaping Script Views Web MVC The Spring Framework has a built-in integration for using Spring WebFlux with any templating library that can run on top of the JSR-223 Java scripting engine. The following table shows the templating libraries that we have tested on different script engines: Scripting Library Scripting Engine Handlebars Nashorn Mustache Nashorn React Nashorn EJS Nashorn ERB JRuby String templates Jython Kotlin Script templating Kotlin \uf0eb The basic rule for integrating any other script engine is that it must implement the ScriptEngine and Invocable interfaces.1209", "chunk_char_count": 1515, "chunk_word_count": 228, "chunk_token_count": 378.75}, {"page_number": 1210, "sentence_chunk": "Requirements Web MVC You need to have the script engine on your classpath, the details of which vary by script engine: \u2022 The Nashorn JavaScript engine is provided with Java 8+. Using the latest update release available is highly recommended. \u2022JRuby should be added as a dependency for Ruby support. \u2022Jython should be added as a dependency for Python support. \u2022org.jetbrains.kotlin:kotlin-script-util dependency and a META- INF/services/javax.script. ScriptEngineFactory file containing a org.jetbrains.kotlin.script.jsr223. KotlinJsr223JvmLocalScriptEngineFactory line should be added for Kotlin script support. See this example for more detail. You need to have the script templating library. One way to do that for JavaScript is through WebJars. Script Templates Web MVC You can declare a ScriptTemplateConfigurer bean to specify the script engine to use, the script files to load, what function to call to render templates, and so on.", "chunk_char_count": 937, "chunk_word_count": 136, "chunk_token_count": 234.25}, {"page_number": 1210, "sentence_chunk": "The following example uses Mustache templates and the Nashorn JavaScript engine: Java @Configuration @EnableWebFlux public class WebConfig implements WebFluxConfigurer { \u00a0  @Override \u00a0  public void configureViewResolvers(ViewResolverRegistry registry) { \u00a0    registry.scriptTemplate(); \u00a0  } \u00a0  @Bean \u00a0  public ScriptTemplateConfigurer configurer() { \u00a0    ScriptTemplateConfigurer configurer = new ScriptTemplateConfigurer(); \u00a0    configurer.setEngineName(\"nashorn\"); \u00a0    configurer.setScripts(\"mustache.js\"); \u00a0    configurer.setRenderObject(\"Mustache\"); \u00a0    configurer.setRenderFunction(\"render\"); \u00a0    return configurer; \u00a0  } } 1210", "chunk_char_count": 635, "chunk_word_count": 87, "chunk_token_count": 158.75}, {"page_number": 1211, "sentence_chunk": "Kotlin @Configuration @EnableWebFlux class WebConfig : WebFluxConfigurer { \u00a0  override fun configureViewResolvers(registry: ViewResolverRegistry) { \u00a0    registry.scriptTemplate() \u00a0  } \u00a0  @Bean \u00a0  fun configurer() = ScriptTemplateConfigurer().apply { \u00a0    engineName = \"nashorn\" \u00a0    setScripts(\"mustache.js\") \u00a0    renderObject = \"Mustache\" \u00a0    renderFunction = \"render\" \u00a0  } } The render function is called with the following parameters: \u2022 String template: The template content \u2022 Map model: The view model \u2022 RenderingContext renderingContext: The RenderingContext that gives access to the application context, the locale, the template loader, and the URL (since 5.0) Mustache.render() is natively compatible with this signature, so you can call it directly. If your templating technology requires some customization, you can provide a script that implements a custom render function. For example, Handlerbars needs to compile templates before using them and requires a polyfill in order to emulate some browser facilities not available in the server-side script engine. The following example shows how to set a custom render function: 1211", "chunk_char_count": 1140, "chunk_word_count": 177, "chunk_token_count": 285.0}, {"page_number": 1212, "sentence_chunk": "Java @Configuration @EnableWebFlux public class WebConfig implements WebFluxConfigurer { \u00a0  @Override \u00a0  public void configureViewResolvers(ViewResolverRegistry registry) { \u00a0    registry.scriptTemplate(); \u00a0  } \u00a0  @Bean \u00a0  public ScriptTemplateConfigurer configurer() { \u00a0    ScriptTemplateConfigurer configurer = new ScriptTemplateConfigurer(); \u00a0    configurer.setEngineName(\"nashorn\"); \u00a0    configurer.setScripts(\"polyfill.js\", \"handlebars.js\", \"render.js\"); \u00a0    configurer.setRenderFunction(\"render\"); \u00a0    configurer.setSharedEngine(false); \u00a0    return configurer; \u00a0  } } Kotlin @Configuration @EnableWebFlux class WebConfig : WebFluxConfigurer { \u00a0  override fun configureViewResolvers(registry: ViewResolverRegistry) { \u00a0    registry.scriptTemplate() \u00a0  } \u00a0  @Bean \u00a0  fun configurer() = ScriptTemplateConfigurer().apply { \u00a0    engineName = \"nashorn\" \u00a0    setScripts(\"polyfill.js\", \"handlebars.js\", \"render.js\") \u00a0    renderFunction = \"render\" \u00a0    isSharedEngine = false \u00a0  } } \uf05a Setting the sharedEngine property to false is required when using non-thread-safe script engines with templating libraries not designed for concurrency, such as Handlebars or React running on Nashorn. In that case, Java SE 8 update 60 is required, due to this bug, but it is generally recommended to use a recent Java SE patch release in any case.polyfill.js defines only the window object needed by Handlebars to run properly, as the following snippet shows: 1212", "chunk_char_count": 1446, "chunk_word_count": 218, "chunk_token_count": 361.5}, {"page_number": 1213, "sentence_chunk": "var window = {}; This basic render.js implementation compiles the template before using it. A production ready implementation should also store and reused cached templates or pre-compiled templates. This can be done on the script side, as well as any customization you need (managing template engine configuration for example). The following example shows how compile a template: function render(template, model) { \u00a0  var compiledTemplate = Handlebars.compile(template); \u00a0  return compiledTemplate(model); } Check out the Spring Framework unit tests, Java, and resources, for more configuration examples. JSON and XML Web MVC For Content Negotiation purposes, it is useful to be able to alternate between rendering a model with an HTML template or as other formats (such as JSON or XML), depending on the content type requested by the client. To support doing so, Spring WebFlux provides the HttpMessageWriterView, which you can use to plug in any of the available Codecs from spring-web, such as Jackson2JsonEncoder, Jackson2SmileEncoder, or Jaxb2XmlEncoder. Unlike other view technologies, HttpMessageWriterView does not require a ViewResolver but is instead configured as a default view. You can configure one or more such default views, wrapping different HttpMessageWriter instances or Encoder instances. The one that matches the requested content type is used at runtime. In most cases, a model contains multiple attributes.", "chunk_char_count": 1430, "chunk_word_count": 212, "chunk_token_count": 357.5}, {"page_number": 1213, "sentence_chunk": "To determine which one to serialize, you can configure HttpMessageWriterView with the name of the model attribute to use for rendering. If the model contains only one attribute, that one is used.6.1.12. WebFlux Config Web MVC The WebFlux Java configuration declares the components that are required to process requests with annotated controllers or functional endpoints, and it offers an API to customize the configuration. That means you do not need to understand the underlying beans created by the Java configuration. However, if you want to understand them, you can see them in WebFluxConfigurationSupport or read more about what they are in Special Bean Types. For more advanced customizations, not available in the configuration API, you can gain full control over the configuration through the Advanced Configuration Mode.1213", "chunk_char_count": 833, "chunk_word_count": 127, "chunk_token_count": 208.25}, {"page_number": 1214, "sentence_chunk": "Enabling WebFlux Config Web MVC You can use the @EnableWebFlux annotation in your Java config, as the following example shows: Java @Configuration @EnableWebFlux public class WebConfig { } Kotlin @Configuration @EnableWebFlux class WebConfig The preceding example registers a number of Spring WebFlux infrastructure beans and adapts to dependencies available on the classpath\u2009\u2014\u2009for JSON, XML, and others. WebFlux config API Web MVC In your Java configuration, you can implement the WebFluxConfigurer interface, as the following example shows: Java @Configuration @EnableWebFlux public class WebConfig implements WebFluxConfigurer { \u00a0  // Implement configuration methods... } Kotlin @Configuration @EnableWebFlux class WebConfig : WebFluxConfigurer { \u00a0  // Implement configuration methods... } 1214", "chunk_char_count": 797, "chunk_word_count": 108, "chunk_token_count": 199.25}, {"page_number": 1215, "sentence_chunk": "Conversion, formatting Web MVC By default, formatters for various number and date types are installed, along with support for customization via @NumberFormat and @DateTimeFormat on fields. To register custom formatters and converters in Java config, use the following: Java @Configuration @EnableWebFlux public class WebConfig implements WebFluxConfigurer { \u00a0  @Override \u00a0  public void addFormatters(FormatterRegistry registry) { \u00a0    // ... \u00a0  } } Kotlin @Configuration @EnableWebFlux class WebConfig : WebFluxConfigurer { \u00a0  override fun addFormatters(registry: FormatterRegistry) { \u00a0    // ... \u00a0  } } By default Spring WebFlux considers the request Locale when parsing and formatting date values. This works for forms where dates are represented as Strings with \"input\" form fields. For \"date\" and \"time\" form fields, however, browsers use a fixed format defined in the HTML spec. For such cases date and time formatting can be customized as follows: 1215", "chunk_char_count": 958, "chunk_word_count": 150, "chunk_token_count": 239.5}, {"page_number": 1216, "sentence_chunk": "Java @Configuration @EnableWebFlux public class WebConfig implements WebFluxConfigurer { \u00a0  @Override \u00a0  public void addFormatters(FormatterRegistry registry) { \u00a0    DateTimeFormatterRegistrar registrar = new DateTimeFormatterRegistrar(); \u00a0    registrar.setUseIsoFormat(true); \u00a0    registrar.registerFormatters(registry); \u00a0  } } Kotlin @Configuration @EnableWebFlux class WebConfig : WebFluxConfigurer { \u00a0  override fun addFormatters(registry: FormatterRegistry) { \u00a0    val registrar = DateTimeFormatterRegistrar() \u00a0    registrar.setUseIsoFormat(true) \u00a0    registrar.registerFormatters(registry) \u00a0  } } \uf05a See FormatterRegistrar SPI and the FormattingConversionServiceFactoryBean for more information on when to use FormatterRegistrar implementations. Validation Web MVC By default, if Bean Validation is present on the classpath (for example, the Hibernate Validator), the LocalValidatorFactoryBean is registered as a global validator for use with @Valid and @Validated on @Controller method arguments. In your Java configuration, you can customize the global Validator instance, as the following example shows: 1216", "chunk_char_count": 1116, "chunk_word_count": 148, "chunk_token_count": 279.0}, {"page_number": 1217, "sentence_chunk": "Java @Configuration @EnableWebFlux public class WebConfig implements WebFluxConfigurer { \u00a0  @Override \u00a0  public Validator getValidator() { \u00a0    // ... \u00a0  } } Kotlin @Configuration @EnableWebFlux class WebConfig : WebFluxConfigurer { \u00a0  override fun getValidator(): Validator { \u00a0    // ... \u00a0  } } Note that you can also register Validator implementations locally, as the following example shows: Java @Controller public class MyController { \u00a0  @InitBinder \u00a0  protected void initBinder(WebDataBinder binder) { \u00a0    binder.addValidators(new FooValidator()); \u00a0  } } 1217", "chunk_char_count": 566, "chunk_word_count": 94, "chunk_token_count": 141.5}, {"page_number": 1218, "sentence_chunk": "Kotlin @Controller class MyController { \u00a0  @InitBinder \u00a0  protected fun initBinder(binder: WebDataBinder) { \u00a0    binder.addValidators(FooValidator()) \u00a0  } } \uf0eb If you need to have a LocalValidatorFactoryBean injected somewhere, create a bean and mark it with @Primary in order to avoid conflict with the one declared in the MVC config. Content Type Resolvers Web MVC You can configure how Spring WebFlux determines the requested media types for @Controller instances from the request. By default, only the Accept header is checked, but you can also enable a query parameter-based strategy. The following example shows how to customize the requested content type resolution: Java @Configuration @EnableWebFlux public class WebConfig implements WebFluxConfigurer { \u00a0  @Override \u00a0  public void configureContentTypeResolver(RequestedContentTypeResolverBuilder builder) { \u00a0    // ... \u00a0  } } Kotlin @Configuration @EnableWebFlux class WebConfig : WebFluxConfigurer { \u00a0  override fun configureContentTypeResolver(builder: RequestedContentTypeResolverBuilder) { \u00a0    // ... \u00a0  } } 1218", "chunk_char_count": 1076, "chunk_word_count": 161, "chunk_token_count": 269.0}, {"page_number": 1219, "sentence_chunk": "HTTP message codecs Web MVC The following example shows how to customize how the request and response body are read and written: Java @Configuration @EnableWebFlux public class WebConfig implements WebFluxConfigurer { \u00a0  @Override \u00a0  public void configureHttpMessageCodecs(ServerCodecConfigurer configurer) { \u00a0    configurer.defaultCodecs().maxInMemorySize(512 * 1024); \u00a0  } } Kotlin @Configuration @EnableWebFlux class WebConfig : WebFluxConfigurer { \u00a0  override fun configureHttpMessageCodecs(configurer: ServerCodecConfigurer) { \u00a0    // ... \u00a0  } } ServerCodecConfigurer provides a set of default readers and writers. You can use it to add more readers and writers, customize the default ones, or replace the default ones completely. For Jackson JSON and XML, consider using Jackson2ObjectMapperBuilder, which customizes Jackson\u2019s default properties with the following ones: \u2022 DeserializationFeature. FAIL_ON_UNKNOWN_PROPERTIES is disabled. \u2022MapperFeature. DEFAULT_VIEW_INCLUSION is disabled. It also automatically registers the following well-known modules if they are detected on the classpath: \u2022 jackson-datatype-joda: Support for Joda-Time types. \u2022jackson-datatype-jsr310: Support for Java 8 Date and Time API types. \u2022jackson-datatype-jdk8: Support for other Java 8 types, such as Optional. \u2022jackson-module-kotlin: Support for Kotlin classes and data classes.", "chunk_char_count": 1365, "chunk_word_count": 181, "chunk_token_count": 341.25}, {"page_number": 1220, "sentence_chunk": "View Resolvers Web MVC The following example shows how to configure view resolution: Java @Configuration @EnableWebFlux public class WebConfig implements WebFluxConfigurer { \u00a0  @Override \u00a0  public void configureViewResolvers(ViewResolverRegistry registry) { \u00a0    // ... \u00a0  } } Kotlin @Configuration @EnableWebFlux class WebConfig : WebFluxConfigurer { \u00a0  override fun configureViewResolvers(registry: ViewResolverRegistry) { \u00a0    // ... \u00a0  } } The ViewResolverRegistry has shortcuts for view technologies with which the Spring Framework integrates. The following example uses FreeMarker (which also requires configuring the underlying FreeMarker view technology): 1220", "chunk_char_count": 668, "chunk_word_count": 95, "chunk_token_count": 167.0}, {"page_number": 1221, "sentence_chunk": "Java @Configuration @EnableWebFlux public class WebConfig implements WebFluxConfigurer { \u00a0  @Override \u00a0  public void configureViewResolvers(ViewResolverRegistry registry) { \u00a0    registry.freeMarker(); \u00a0  } \u00a0  // Configure Freemarker... \u00a0  @Bean \u00a0  public FreeMarkerConfigurer freeMarkerConfigurer() { \u00a0    FreeMarkerConfigurer configurer = new FreeMarkerConfigurer(); \u00a0    configurer.setTemplateLoaderPath(\"classpath:/templates\"); \u00a0    return configurer; \u00a0  } } Kotlin @Configuration @EnableWebFlux class WebConfig : WebFluxConfigurer { \u00a0  override fun configureViewResolvers(registry: ViewResolverRegistry) { \u00a0    registry.freeMarker() \u00a0  } \u00a0  // Configure Freemarker... \u00a0  @Bean \u00a0  fun freeMarkerConfigurer() = FreeMarkerConfigurer().apply { \u00a0    setTemplateLoaderPath(\"classpath:/templates\") \u00a0  } } You can also plug in any ViewResolver implementation, as the following example shows: 1221", "chunk_char_count": 892, "chunk_word_count": 126, "chunk_token_count": 223.0}, {"page_number": 1222, "sentence_chunk": "Java @Configuration @EnableWebFlux public class WebConfig implements WebFluxConfigurer { \u00a0  @Override \u00a0  public void configureViewResolvers(ViewResolverRegistry registry) { \u00a0    ViewResolver resolver = ... ; \u00a0    registry.viewResolver(resolver); \u00a0  } } Kotlin @Configuration @EnableWebFlux class WebConfig : WebFluxConfigurer { \u00a0  override fun configureViewResolvers(registry: ViewResolverRegistry) { \u00a0    val resolver: ViewResolver = ... \u00a0    registry.viewResolver(resolver \u00a0  } } To support Content Negotiation and rendering other formats through view resolution (besides HTML), you can configure one or more default views based on the HttpMessageWriterView implementation, which accepts any of the available Codecs from spring-web. The following example shows how to do so: Java @Configuration @EnableWebFlux public class WebConfig implements WebFluxConfigurer { \u00a0  @Override \u00a0  public void configureViewResolvers(ViewResolverRegistry registry) { \u00a0    registry.freeMarker(); \u00a0    Jackson2JsonEncoder encoder = new Jackson2JsonEncoder(); \u00a0    registry.defaultViews(new HttpMessageWriterView(encoder)); \u00a0  } \u00a0  // ... } 1222", "chunk_char_count": 1125, "chunk_word_count": 161, "chunk_token_count": 281.25}, {"page_number": 1223, "sentence_chunk": "Kotlin @Configuration @EnableWebFlux class WebConfig : WebFluxConfigurer { \u00a0  override fun configureViewResolvers(registry: ViewResolverRegistry) { \u00a0    registry.freeMarker() \u00a0    val encoder = Jackson2JsonEncoder() \u00a0    registry.defaultViews(HttpMessageWriterView(encoder)) \u00a0  } \u00a0  // ... } See View Technologies for more on the view technologies that are integrated with Spring WebFlux. Static Resources Web MVC This option provides a convenient way to serve static resources from a list of Resource-based locations. In the next example, given a request that starts with /resources, the relative path is used to find and serve static resources relative to /static on the classpath. Resources are served with a one-year future expiration to ensure maximum use of the browser cache and a reduction in HTTP requests made by the browser. The Last-Modified header is also evaluated and, if present, a 304 status code is returned. The following list shows the example: Java @Configuration @EnableWebFlux public class WebConfig implements WebFluxConfigurer { \u00a0  @Override \u00a0  public void addResourceHandlers(ResourceHandlerRegistry registry) { \u00a0    registry.addResourceHandler(\"/resources/**\") \u00a0        .addResourceLocations(\"/public\", \"classpath:/static/\") \u00a0        .setCacheControl(CacheControl.maxAge(365, TimeUnit. DAYS)); \u00a0  } } 1223", "chunk_char_count": 1332, "chunk_word_count": 201, "chunk_token_count": 333.0}, {"page_number": 1224, "sentence_chunk": "Kotlin @Configuration @EnableWebFlux class WebConfig : WebFluxConfigurer { \u00a0  override fun addResourceHandlers(registry: ResourceHandlerRegistry) { \u00a0    registry.addResourceHandler(\"/resources/**\") \u00a0        .addResourceLocations(\"/public\", \"classpath:/static/\") \u00a0        .setCacheControl(CacheControl.maxAge(365, TimeUnit. DAYS)) \u00a0  } } The resource handler also supports a chain of ResourceResolver implementations and ResourceTransformer implementations, which can be used to create a toolchain for working with optimized resources. You can use the VersionResourceResolver for versioned resource URLs based on an MD5 hash computed from the content, a fixed application version, or other information. A ContentVersionStrategy (MD5 hash) is a good choice with some notable exceptions (such as JavaScript resources used with a module loader). The following example shows how to use VersionResourceResolver in your Java configuration: Java @Configuration @EnableWebFlux public class WebConfig implements WebFluxConfigurer { \u00a0  @Override \u00a0  public void addResourceHandlers(ResourceHandlerRegistry registry) { \u00a0    registry.addResourceHandler(\"/resources/**\") \u00a0        .addResourceLocations(\"/public/\") \u00a0        .resourceChain(true) \u00a0        .addResolver(new VersionResourceResolver().addContentVersionStrategy(\"/**\")); \u00a0  } } 1224", "chunk_char_count": 1327, "chunk_word_count": 186, "chunk_token_count": 331.75}, {"page_number": 1225, "sentence_chunk": "Kotlin @Configuration @EnableWebFlux class WebConfig : WebFluxConfigurer { \u00a0  override fun addResourceHandlers(registry: ResourceHandlerRegistry) { \u00a0    registry.addResourceHandler(\"/resources/**\") \u00a0        .addResourceLocations(\"/public/\") \u00a0        .resourceChain(true) \u00a0 .addResolver(VersionResourceResolver().addContentVersionStrategy(\"/**\")) \u00a0  } } You can use ResourceUrlProvider to rewrite URLs and apply the full chain of resolvers and transformers (for example, to insert versions). The WebFlux configuration provides a ResourceUrlProvider so that it can be injected into others. Unlike Spring MVC, at present, in WebFlux, there is no way to transparently rewrite static resource URLs, since there are no view technologies that can make use of a non-blocking chain of resolvers and transformers. When serving only local resources, the workaround is to use ResourceUrlProvider directly (for example, through a custom element) and block. Note that, when using both EncodedResourceResolver (for example, Gzip, Brotli encoded) and VersionedResourceResolver, they must be registered in that order, to ensure content-based versions are always computed reliably based on the unencoded file. For WebJars, versioned URLs like /webjars/jquery/1.2.0/jquery.min.js are the recommended and most efficient way to use them. The related resource location is configured out of the box with Spring Boot (or can be configured manually via ResourceHandlerRegistry) and does not require to add the org.webjars:webjars-locator-core dependency. Version-less URLs like /webjars/jquery/jquery.min.js are supported through the WebJarsResourceResolver which is automatically registered when the org.webjars:webjars-locator- core library is present on the classpath, at the cost of a classpath scanning that could slow down application startup. The resolver can re-write URLs to include the version of the jar and can also match against incoming URLs without versions\u2009\u2014\u2009for example, from /webjars/jquery/jquery.min.js to /webjars/jquery/1.2.0/jquery.min.js.\uf0eb The Java configuration based on ResourceHandlerRegistry provides further options for fine-grained control, e.g. last-modified behavior and optimized resource resolution.", "chunk_char_count": 2208, "chunk_word_count": 293, "chunk_token_count": 552.0}, {"page_number": 1226, "sentence_chunk": "You can customize options related to path matching. For details on the individual options, see the PathMatchConfigurer javadoc. The following example shows how to use PathMatchConfigurer: Java @Configuration @EnableWebFlux public class WebConfig implements WebFluxConfigurer { \u00a0  @Override \u00a0  public void configurePathMatch(PathMatchConfigurer configurer) { \u00a0    configurer \u00a0      .setUseCaseSensitiveMatch(true) \u00a0      .addPathPrefix(\"/api\", HandlerTypePredicate.forAnnotation(RestController.class)); \u00a0  } } Kotlin @Configuration @EnableWebFlux class WebConfig : WebFluxConfigurer { \u00a0  @Override \u00a0  fun configurePathMatch(configurer: PathMatchConfigurer) { \u00a0    configurer \u00a0      .setUseCaseSensitiveMatch(true) \u00a0      .addPathPrefix(\"/api\", HandlerTypePredicate.forAnnotation(RestController::class.java)) \u00a0  } } \uf0eb Spring WebFlux relies on a parsed representation of the request path called RequestPath for access to decoded path segment values, with semicolon content removed (that is, path or matrix variables). That means, unlike in Spring MVC, you need not indicate whether to decode the request path nor whether to remove semicolon content for path matching purposes. Spring WebFlux also does not support suffix pattern matching, unlike in Spring MVC, where we are also recommend moving away from reliance on it. WebSocketService The WebFlux Java config declares of a WebSocketHandlerAdapter bean which provides support for the invocation of WebSocket handlers. That means all that remains to do in order to handle a WebSocket handshake request is to map a WebSocketHandler to a URL via SimpleUrlHandlerMapping. In some cases it may be necessary to create the WebSocketHandlerAdapter bean with a provided 1226", "chunk_char_count": 1715, "chunk_word_count": 251, "chunk_token_count": 428.75}, {"page_number": 1227, "sentence_chunk": "WebSocketService service which allows configuring WebSocket server properties. For example: Java @Configuration @EnableWebFlux public class WebConfig implements WebFluxConfigurer { \u00a0  @Override \u00a0  public WebSocketService getWebSocketService() { \u00a0    TomcatRequestUpgradeStrategy strategy = new TomcatRequestUpgradeStrategy(); \u00a0    strategy.setMaxSessionIdleTimeout(0L); \u00a0    return new HandshakeWebSocketService(strategy); \u00a0  } } Kotlin @Configuration @EnableWebFlux class WebConfig : WebFluxConfigurer { \u00a0  @Override \u00a0  fun webSocketService(): WebSocketService { \u00a0    val strategy = TomcatRequestUpgradeStrategy().apply { \u00a0      setMaxSessionIdleTimeout(0L) \u00a0    } \u00a0    return HandshakeWebSocketService(strategy) \u00a0  } } Advanced Configuration Mode Web MVC @EnableWebFlux imports DelegatingWebFluxConfiguration that: \u2022 Provides default Spring configuration for WebFlux applications \u2022 detects and delegates to WebFluxConfigurer implementations to customize that configuration. For advanced mode, you can remove @EnableWebFlux and extend directly from DelegatingWebFluxConfiguration instead of implementing WebFluxConfigurer, as the following example shows: 1227", "chunk_char_count": 1160, "chunk_word_count": 151, "chunk_token_count": 290.0}, {"page_number": 1228, "sentence_chunk": "Java @Configuration public class WebConfig extends DelegatingWebFluxConfiguration { \u00a0  // ... } Kotlin @Configuration class WebConfig : DelegatingWebFluxConfiguration { \u00a0  // ... } You can keep existing methods in WebConfig, but you can now also override bean declarations from the base class and still have any number of other WebMvcConfigurer implementations on the classpath.6.1.13. HTTP/2 Web MVC HTTP/2 is supported with Reactor Netty, Tomcat, Jetty, and Undertow. However, there are considerations related to server configuration. For more details, see the HTTP/2 wiki page.6.2. WebClient Spring WebFlux includes a client to perform HTTP requests with. WebClient has a functional, fluent API based on Reactor, see Reactive Libraries, which enables declarative composition of asynchronous logic without the need to deal with threads or concurrency. It is fully non-blocking, it supports streaming, and relies on the same codecs that are also used to encode and decode request and response content on the server side. WebClient needs an HTTP client library to perform requests with.", "chunk_char_count": 1086, "chunk_word_count": 163, "chunk_token_count": 271.5}, {"page_number": 1228, "sentence_chunk": "There is built-in support for the following: \u2022 Reactor Netty \u2022 JDK HttpClient \u2022 Jetty Reactive HttpClient \u2022 Apache HttpComponents \u2022 Others can be plugged via ClientHttpConnector.6.2.1. Configuration The simplest way to create a WebClient is through one of the static factory methods: 1228", "chunk_char_count": 288, "chunk_word_count": 44, "chunk_token_count": 72.0}, {"page_number": 1229, "sentence_chunk": "\u2022 WebClient.create() \u2022 WebClient.create(String baseUrl) You can also use WebClient.builder() with further options: \u2022 uriBuilderFactory: Customized UriBuilderFactory to use as a base URL. \u2022defaultUriVariables: default values to use when expanding URI templates. \u2022defaultHeader: Headers for every request. \u2022defaultCookie: Cookies for every request. \u2022defaultRequest: Consumer to customize every request. \u2022filter: Client filter for every request. \u2022exchangeStrategies: HTTP message reader/writer customizations. \u2022clientConnector: HTTP client library settings. For example: Java WebClient client = WebClient.builder() \u00a0    .codecs(configurer -> ... ) \u00a0    .build(); Kotlin val webClient = WebClient.builder() \u00a0    .codecs { configurer -> ... } \u00a0    .build() Once built, a WebClient is immutable. However, you can clone it and build a modified copy as follows: Java WebClient client1 = WebClient.builder() \u00a0    .filter(filterA).filter(filterB).build(); WebClient client2 = client1.mutate() \u00a0    .filter(filterC).filter(filterD).build(); // client1 has filterA, filterB // client2 has filterA, filterB, filterC, filterD 1229", "chunk_char_count": 1116, "chunk_word_count": 154, "chunk_token_count": 279.0}, {"page_number": 1230, "sentence_chunk": "Kotlin val client1 = WebClient.builder() \u00a0    .filter(filterA).filter(filterB).build() val client2 = client1.mutate() \u00a0    .filter(filterC).filter(filterD).build() // client1 has filterA, filterB // client2 has filterA, filterB, filterC, filterD MaxInMemorySize Codecs have limits for buffering data in memory to avoid application memory issues. By default those are set to 256KB. If that\u2019s not enough you\u2019ll get the following error: org.springframework.core.io.buffer. DataBufferLimitException: Exceeded limit on max bytes to buffer To change the limit for default codecs, use the following: Java WebClient webClient = WebClient.builder() \u00a0    .codecs(configurer -> configurer.defaultCodecs().maxInMemorySize(2 * 1024 * 1024)) \u00a0    .build(); Kotlin val webClient = WebClient.builder() \u00a0    .codecs { configurer -> configurer.defaultCodecs().maxInMemorySize(2 * 1024 * 1024) } \u00a0    .build() Reactor Netty To customize Reactor Netty settings, provide a pre-configured HttpClient: Java HttpClient httpClient = HttpClient.create().secure(sslSpec -> ...); WebClient webClient = WebClient.builder() \u00a0    .clientConnector(new ReactorClientHttpConnector(httpClient)) \u00a0    .build(); 1230", "chunk_char_count": 1179, "chunk_word_count": 159, "chunk_token_count": 294.75}, {"page_number": 1231, "sentence_chunk": "Kotlin val httpClient = HttpClient.create().secure { ... } val webClient = WebClient.builder() \u00a0  .clientConnector(ReactorClientHttpConnector(httpClient)) \u00a0  .build() Resources By default, HttpClient participates in the global Reactor Netty resources held in reactor.netty.http. HttpResources, including event loop threads and a connection pool. This is the recommended mode, since fixed, shared resources are preferred for event loop concurrency. In this mode global resources remain active until the process exits. If the server is timed with the process, there is typically no need for an explicit shutdown. However, if the server can start or stop in-process (for example, a Spring MVC application deployed as a WAR), you can declare a Spring-managed bean of type ReactorResourceFactory with globalResources=true (the default) to ensure that the Reactor Netty global resources are shut down when the Spring ApplicationContext is closed, as the following example shows: Java @Bean public ReactorResourceFactory reactorResourceFactory() { \u00a0  return new ReactorResourceFactory(); } Kotlin @Bean fun reactorResourceFactory() = ReactorResourceFactory() You can also choose not to participate in the global Reactor Netty resources. However, in this mode, the burden is on you to ensure that all Reactor Netty client and server instances use shared resources, as the following example shows: 1231", "chunk_char_count": 1393, "chunk_word_count": 197, "chunk_token_count": 348.25}, {"page_number": 1232, "sentence_chunk": "Java @Bean public ReactorResourceFactory resourceFactory() { \u00a0  ReactorResourceFactory factory = new ReactorResourceFactory(); \u00a0  factory.setUseGlobalResources(false); \u2460 \u00a0  return factory; } @Bean public WebClient webClient() { \u00a0  Function<HttpClient, HttpClient> mapper = client -> { \u00a0    // Further customizations... \u00a0  }; \u00a0  ClientHttpConnector connector = \u00a0      new ReactorClientHttpConnector(resourceFactory(), mapper); \u2461 \u00a0  return WebClient.builder().clientConnector(connector).build(); \u2462 } \u2460 Create resources independent of global ones.\u2461 Use the ReactorClientHttpConnector constructor with resource factory.\u2462 Plug the connector into the WebClient. Builder. Kotlin @Bean fun resourceFactory() = ReactorResourceFactory().apply { \u00a0  isUseGlobalResources = false \u2460 } @Bean fun webClient(): WebClient { \u00a0  val mapper: (HttpClient) -> HttpClient = { \u00a0    // Further customizations... \u00a0  } \u00a0  val connector = ReactorClientHttpConnector(resourceFactory(), mapper) \u2461 \u00a0  return WebClient.builder().clientConnector(connector).build() \u2462 } \u2460 Create resources independent of global ones.\u2461 Use the ReactorClientHttpConnector constructor with resource factory.\u2462 Plug the connector into the WebClient. Builder.1232", "chunk_char_count": 1205, "chunk_word_count": 161, "chunk_token_count": 301.25}, {"page_number": 1233, "sentence_chunk": "Timeouts To configure a connection timeout: Java import io.netty.channel. ChannelOption; HttpClient httpClient = HttpClient.create() \u00a0    .option(ChannelOption. CONNECT_TIMEOUT_MILLIS, 10000); WebClient webClient = WebClient.builder() \u00a0    .clientConnector(new ReactorClientHttpConnector(httpClient)) \u00a0    .build(); Kotlin import io.netty.channel. ChannelOption val httpClient = HttpClient.create() \u00a0    .option(ChannelOption. CONNECT_TIMEOUT_MILLIS, 10000); val webClient = WebClient.builder() \u00a0    .clientConnector(new ReactorClientHttpConnector(httpClient)) \u00a0    .build(); To configure a read or write timeout: Java import io.netty.handler.timeout. ReadTimeoutHandler; import io.netty.handler.timeout. WriteTimeoutHandler; HttpClient httpClient = HttpClient.create() \u00a0    .doOnConnected(conn -> conn \u00a0        .addHandlerLast(new ReadTimeoutHandler(10)) \u00a0        .addHandlerLast(new WriteTimeoutHandler(10))); // Create WebClient... 1233", "chunk_char_count": 939, "chunk_word_count": 115, "chunk_token_count": 234.75}, {"page_number": 1234, "sentence_chunk": "Kotlin import io.netty.handler.timeout. ReadTimeoutHandler import io.netty.handler.timeout. WriteTimeoutHandler val httpClient = HttpClient.create() \u00a0    .doOnConnected { conn -> conn \u00a0        .addHandlerLast(new ReadTimeoutHandler(10)) \u00a0        .addHandlerLast(new WriteTimeoutHandler(10)) \u00a0    } // Create WebClient... To configure a response timeout for all requests: Java HttpClient httpClient = HttpClient.create() \u00a0    .responseTimeout(Duration.ofSeconds(2)); // Create WebClient... Kotlin val httpClient = HttpClient.create() \u00a0    .responseTimeout(Duration.ofSeconds(2)); // Create WebClient... To configure a response timeout for a specific request: Java WebClient.create().get() \u00a0    .uri(\"https://example.org/path\") \u00a0    .httpRequest(httpRequest -> { \u00a0      HttpClientRequest reactorRequest = httpRequest.getNativeRequest(); \u00a0      reactorRequest.responseTimeout(Duration.ofSeconds(2)); \u00a0    }) \u00a0    .retrieve() \u00a0    .bodyToMono(String.class); 1234", "chunk_char_count": 958, "chunk_word_count": 138, "chunk_token_count": 239.5}, {"page_number": 1235, "sentence_chunk": "Kotlin WebClient.create().get() \u00a0    .uri(\"https://example.org/path\") \u00a0    .httpRequest { httpRequest: ClientHttpRequest -> \u00a0      val reactorRequest = httpRequest.getNativeRequest<HttpClientRequest>() \u00a0      reactorRequest.responseTimeout(Duration.ofSeconds(2)) \u00a0    } \u00a0    .retrieve() \u00a0    .bodyToMono(String::class.java) JDK HttpClient The following example shows how to customize the JDK HttpClient: Java HttpClient httpClient = HttpClient.newBuilder() \u00a0  .followRedirects(Redirect. NORMAL) \u00a0  .connectTimeout(Duration.ofSeconds(20)) \u00a0  .build(); ClientHttpConnector connector = \u00a0    new JdkClientHttpConnector(httpClient, new DefaultDataBufferFactory()); WebClient webClient = WebClient.builder().clientConnector(connector).build(); Kotlin val httpClient = HttpClient.newBuilder() \u00a0  .followRedirects(Redirect. NORMAL) \u00a0  .connectTimeout(Duration.ofSeconds(20)) \u00a0  .build() val connector = JdkClientHttpConnector(httpClient, DefaultDataBufferFactory()) val webClient = WebClient.builder().clientConnector(connector).build() Jetty The following example shows how to customize Jetty HttpClient settings: 1235", "chunk_char_count": 1111, "chunk_word_count": 126, "chunk_token_count": 277.75}, {"page_number": 1236, "sentence_chunk": "Java HttpClient httpClient = new HttpClient(); httpClient.setCookieStore(...); WebClient webClient = WebClient.builder() \u00a0    .clientConnector(new JettyClientHttpConnector(httpClient)) \u00a0    .build(); Kotlin val httpClient = HttpClient() httpClient.cookieStore = ... val webClient = WebClient.builder() \u00a0    .clientConnector(new JettyClientHttpConnector(httpClient)) \u00a0    .build(); By default, HttpClient creates its own resources (Executor, ByteBufferPool, Scheduler), which remain active until the process exits or stop() is called. You can share resources between multiple instances of the Jetty client (and server) and ensure that the resources are shut down when the Spring ApplicationContext is closed by declaring a Spring- managed bean of type JettyResourceFactory, as the following example shows: Java @Bean public JettyResourceFactory resourceFactory() { \u00a0  return new JettyResourceFactory(); } @Bean public WebClient webClient() { \u00a0  HttpClient httpClient = new HttpClient(); \u00a0  // Further customizations... \u00a0  ClientHttpConnector connector = \u00a0      new JettyClientHttpConnector(httpClient, resourceFactory()); \u2460 \u00a0  return WebClient.builder().clientConnector(connector).build(); \u2461 } \u2460 Use the JettyClientHttpConnector constructor with resource factory.\u2461 Plug the connector into the WebClient. Builder.1236", "chunk_char_count": 1315, "chunk_word_count": 172, "chunk_token_count": 328.75}, {"page_number": 1237, "sentence_chunk": "Kotlin @Bean fun resourceFactory() = JettyResourceFactory() @Bean fun webClient(): WebClient { \u00a0  val httpClient = HttpClient() \u00a0  // Further customizations... \u00a0  val connector = JettyClientHttpConnector(httpClient, resourceFactory()) \u2460 \u00a0  return WebClient.builder().clientConnector(connector).build() \u2461 } \u2460 Use the JettyClientHttpConnector constructor with resource factory.\u2461 Plug the connector into the WebClient. Builder. HttpComponents The following example shows how to customize Apache HttpComponents HttpClient settings: Java HttpAsyncClientBuilder clientBuilder = HttpAsyncClients.custom(); clientBuilder.setDefaultRequestConfig(...); CloseableHttpAsyncClient client = clientBuilder.build(); ClientHttpConnector connector = new HttpComponentsClientHttpConnector(client); WebClient webClient = WebClient.builder().clientConnector(connector).build(); Kotlin val client = HttpAsyncClients.custom().apply { \u00a0  setDefaultRequestConfig(...) }.build() val connector = HttpComponentsClientHttpConnector(client) val webClient = WebClient.builder().clientConnector(connector).build() 6.2.2.retrieve() The retrieve() method can be used to declare how to extract the response. For example: 1237", "chunk_char_count": 1190, "chunk_word_count": 117, "chunk_token_count": 297.5}, {"page_number": 1238, "sentence_chunk": "Java WebClient client = WebClient.create(\"https://example.org\"); Mono<ResponseEntity<Person>> result = client.get() \u00a0    .uri(\"/persons/{id}\", id).accept(MediaType. APPLICATION_JSON) \u00a0    .retrieve() \u00a0    .toEntity(Person.class); Kotlin val client = WebClient.create(\"https://example.org\") val result = client.get() \u00a0    .uri(\"/persons/{id}\", id).accept(MediaType. APPLICATION_JSON) \u00a0    .retrieve() \u00a0    .toEntity<Person>().awaitSingle() Or to get only the body: Java WebClient client = WebClient.create(\"https://example.org\"); Mono<Person> result = client.get() \u00a0    .uri(\"/persons/{id}\", id).accept(MediaType. APPLICATION_JSON) \u00a0    .retrieve() \u00a0    .bodyToMono(Person.class); Kotlin val client = WebClient.create(\"https://example.org\") val result = client.get() \u00a0    .uri(\"/persons/{id}\", id).accept(MediaType. APPLICATION_JSON) \u00a0    .retrieve() \u00a0    .awaitBody<Person>() To get a stream of decoded objects: Java Flux<Quote> result = client.get() \u00a0    .uri(\"/quotes\").accept(MediaType. TEXT_EVENT_STREAM) \u00a0    .retrieve() \u00a0    .bodyToFlux(Quote.class); 1238", "chunk_char_count": 1061, "chunk_word_count": 139, "chunk_token_count": 265.25}, {"page_number": 1239, "sentence_chunk": "Kotlin val result = client.get() \u00a0    .uri(\"/quotes\").accept(MediaType. TEXT_EVENT_STREAM) \u00a0    .retrieve() \u00a0    .bodyToFlow<Quote>() By default, 4xx or 5xx responses result in an WebClientResponseException, including sub-classes for specific HTTP status codes. To customize the handling of error responses, use onStatus handlers as follows: Java Mono<Person> result = client.get() \u00a0    .uri(\"/persons/{id}\", id).accept(MediaType. APPLICATION_JSON) \u00a0    .retrieve() \u00a0    .onStatus(HttpStatus::is4xxClientError, response -> ...) \u00a0    .onStatus(HttpStatus::is5xxServerError, response -> ...) \u00a0    .bodyToMono(Person.class); Kotlin val result = client.get() \u00a0    .uri(\"/persons/{id}\", id).accept(MediaType. APPLICATION_JSON) \u00a0    .retrieve() \u00a0    .onStatus(HttpStatus::is4xxClientError) { ... } \u00a0    .onStatus(HttpStatus::is5xxServerError) { ... } \u00a0    .awaitBody<Person>() 6.2.3. Exchange The exchangeToMono() and exchangeToFlux() methods (or awaitExchange { } and exchangeToFlow { } in Kotlin) are useful for more advanced cases that require more control, such as to decode the response differently depending on the response status: 1239", "chunk_char_count": 1136, "chunk_word_count": 166, "chunk_token_count": 284.0}, {"page_number": 1240, "sentence_chunk": "Java Mono<Person> entityMono = client.get() \u00a0    .uri(\"/persons/1\") \u00a0    .accept(MediaType. APPLICATION_JSON) \u00a0    .exchangeToMono(response -> { \u00a0      if (response.statusCode().equals(HttpStatus. OK)) { \u00a0        return response.bodyToMono(Person.class); \u00a0      } \u00a0      else { \u00a0        // Turn to error \u00a0        return response.createError(); \u00a0      } \u00a0    }); Kotlin val entity = client.get() \u00a0 .uri(\"/persons/1\") \u00a0 .accept(MediaType. APPLICATION_JSON) \u00a0 .awaitExchange { \u00a0    if (response.statusCode() == HttpStatus. OK) { \u00a0      return response.awaitBody<Person>() \u00a0    } \u00a0    else { \u00a0      throw response.createExceptionAndAwait() \u00a0    } \u00a0 } When using the above, after the returned Mono or Flux completes, the response body is checked and if not consumed it is released to prevent memory and connection leaks. Therefore the response cannot be decoded further downstream. It is up to the provided function to declare how to decode the response if needed.6.2.4. Request Body The request body can be encoded from any asynchronous type handled by ReactiveAdapterRegistry, like Mono or Kotlin Coroutines Deferred as the following example shows: Java Mono<Person> personMono = ... ; Mono<Void> result = client.post() \u00a0    .uri(\"/persons/{id}\", id) \u00a0    .contentType(MediaType. APPLICATION_JSON) \u00a0    .body(personMono, Person.class) \u00a0    .retrieve() \u00a0    .bodyToMono(Void.class); 1240", "chunk_char_count": 1383, "chunk_word_count": 267, "chunk_token_count": 345.75}, {"page_number": 1241, "sentence_chunk": "Kotlin val personDeferred: Deferred<Person> = ... client.post() \u00a0    .uri(\"/persons/{id}\", id) \u00a0    .contentType(MediaType. APPLICATION_JSON) \u00a0    .body<Person>(personDeferred) \u00a0    .retrieve() \u00a0    .awaitBody<Unit>() You can also have a stream of objects be encoded, as the following example shows: Java Flux<Person> personFlux = ... ; Mono<Void> result = client.post() \u00a0    .uri(\"/persons/{id}\", id) \u00a0    .contentType(MediaType. APPLICATION_STREAM_JSON) \u00a0    .body(personFlux, Person.class) \u00a0    .retrieve() \u00a0    .bodyToMono(Void.class); Kotlin val people: Flow<Person> = ... client.post() \u00a0    .uri(\"/persons/{id}\", id) \u00a0    .contentType(MediaType. APPLICATION_JSON) \u00a0    .body(people) \u00a0    .retrieve() \u00a0    .awaitBody<Unit>() Alternatively, if you have the actual value, you can use the bodyValue shortcut method, as the following example shows: Java Person person = ... ; Mono<Void> result = client.post() \u00a0    .uri(\"/persons/{id}\", id) \u00a0    .contentType(MediaType. APPLICATION_JSON) \u00a0    .bodyValue(person) \u00a0    .retrieve() \u00a0    .bodyToMono(Void.class); 1241", "chunk_char_count": 1064, "chunk_word_count": 178, "chunk_token_count": 266.0}, {"page_number": 1242, "sentence_chunk": "Kotlin val person: Person = ... client.post() \u00a0    .uri(\"/persons/{id}\", id) \u00a0    .contentType(MediaType. APPLICATION_JSON) \u00a0    .bodyValue(person) \u00a0    .retrieve() \u00a0    .awaitBody<Unit>() Form Data To send form data, you can provide a MultiValueMap<String, String> as the body. Note that the content is automatically set to application/x-www-form-urlencoded by the FormHttpMessageWriter. The following example shows how to use MultiValueMap<String, String>: Java MultiValueMap<String, String> formData = ... ; Mono<Void> result = client.post() \u00a0    .uri(\"/path\", id) \u00a0    .bodyValue(formData) \u00a0    .retrieve() \u00a0    .bodyToMono(Void.class); Kotlin val formData: MultiValueMap<String, String> = ... client.post() \u00a0    .uri(\"/path\", id) \u00a0    .bodyValue(formData) \u00a0    .retrieve() \u00a0    .awaitBody<Unit>() You can also supply form data in-line by using BodyInserters, as the following example shows: Java import static org.springframework.web.reactive.function. BodyInserters.*;Mono<Void> result = client.post() \u00a0    .uri(\"/path\", id) \u00a0    .body(fromFormData(\"k1\", \"v1\").with(\"k2\", \"v2\")) \u00a0    .retrieve() \u00a0    .bodyToMono(Void.class); 1242", "chunk_char_count": 1136, "chunk_word_count": 178, "chunk_token_count": 284.0}, {"page_number": 1243, "sentence_chunk": "Kotlin import org.springframework.web.reactive.function. BodyInserters.*client.post() \u00a0    .uri(\"/path\", id) \u00a0    .body(fromFormData(\"k1\", \"v1\").with(\"k2\", \"v2\")) \u00a0    .retrieve() \u00a0    .awaitBody<Unit>() Multipart Data To send multipart data, you need to provide a MultiValueMap<String, ?> whose values are either Object instances that represent part content or HttpEntity instances that represent the content and headers for a part. MultipartBodyBuilder provides a convenient API to prepare a multipart request. The following example shows how to create a MultiValueMap<String, ?>: Java MultipartBodyBuilder builder = new MultipartBodyBuilder(); builder.part(\"fieldPart\", \"fieldValue\"); builder.part(\"filePart1\", new FileSystemResource(\"...logo.png\")); builder.part(\"jsonPart\", new Person(\"Jason\")); builder.part(\"myPart\", part); // Part from a server request MultiValueMap<String, HttpEntity<?>> parts = builder.build(); Kotlin val builder = MultipartBodyBuilder().apply { \u00a0  part(\"fieldPart\", \"fieldValue\") \u00a0  part(\"filePart1\", new FileSystemResource(\"...logo.png\")) \u00a0  part(\"jsonPart\", new Person(\"Jason\")) \u00a0  part(\"myPart\", part) // Part from a server request } val parts = builder.build() In most cases, you do not have to specify the Content-Type for each part. The content type is determined automatically based on the HttpMessageWriter chosen to serialize it or, in the case of a Resource, based on the file extension. If necessary, you can explicitly provide the MediaType to use for each part through one of the overloaded builder part methods.", "chunk_char_count": 1555, "chunk_word_count": 205, "chunk_token_count": 388.75}, {"page_number": 1243, "sentence_chunk": "Once a MultiValueMap is prepared, the easiest way to pass it to the WebClient is through the body method, as the following example shows: 1243", "chunk_char_count": 142, "chunk_word_count": 25, "chunk_token_count": 35.5}, {"page_number": 1244, "sentence_chunk": "Java MultipartBodyBuilder builder = ...; Mono<Void> result = client.post() \u00a0    .uri(\"/path\", id) \u00a0    .body(builder.build()) \u00a0    .retrieve() \u00a0    .bodyToMono(Void.class); Kotlin val builder: MultipartBodyBuilder = ... client.post() \u00a0    .uri(\"/path\", id) \u00a0    .body(builder.build()) \u00a0    .retrieve() \u00a0    .awaitBody<Unit>() If the MultiValueMap contains at least one non-String value, which could also represent regular form data (that is, application/x-www-form-urlencoded), you need not set the Content-Type to multipart/form-data. This is always the case when using MultipartBodyBuilder, which ensures an HttpEntity wrapper. As an alternative to MultipartBodyBuilder, you can also provide multipart content, inline-style, through the built-in BodyInserters, as the following example shows: Java import static org.springframework.web.reactive.function. BodyInserters.*;Mono<Void> result = client.post() \u00a0    .uri(\"/path\", id) \u00a0    .body(fromMultipartData(\"fieldPart\", \"value\").with(\"filePart\", resource)) \u00a0    .retrieve() \u00a0    .bodyToMono(Void.class); Kotlin import org.springframework.web.reactive.function. BodyInserters.*client.post() \u00a0    .uri(\"/path\", id) \u00a0    .body(fromMultipartData(\"fieldPart\", \"value\").with(\"filePart\", resource)) \u00a0    .retrieve() \u00a0    .awaitBody<Unit>() 1244", "chunk_char_count": 1289, "chunk_word_count": 178, "chunk_token_count": 322.25}, {"page_number": 1245, "sentence_chunk": "PartEvent To stream multipart data sequentially, you can provide multipart content through PartEvent objects. \u2022Form fields can be created via FormPartEvent::create. \u2022File uploads can be created via FilePartEvent::create. You can concatenate the streams returned from methods via Flux::concat, and create a request for the WebClient. For instance, this sample will POST a multipart form containing a form field and a file. Java Resource resource = ... Mono<String> result = webClient \u00a0  .post() \u00a0  .uri(\"https://example.com\") \u00a0  .body(Flux.concat( \u00a0      FormPartEvent.create(\"field\", \"field value\"), \u00a0      FilePartEvent.create(\"file\", resource) \u00a0  ), PartEvent.class) \u00a0  .retrieve() \u00a0  .bodyToMono(String.class); Kotlin var resource: Resource = ... var result: Mono<String> = webClient \u00a0  .post() \u00a0  .uri(\"https://example.com\") \u00a0  .body( \u00a0    Flux.concat( \u00a0      FormPartEvent.create(\"field\", \"field value\"), \u00a0      FilePartEvent.create(\"file\", resource) \u00a0    ) \u00a0  ) \u00a0  .retrieve() \u00a0  .bodyToMono() On the server side, PartEvent objects that are received via @RequestBody or ServerRequest::bodyToFlux(PartEvent.class) can be relayed to another service via the WebClient.6.2.5. Filters You can register a client filter (ExchangeFilterFunction) through the WebClient. Builder in order to intercept and modify requests, as the following example shows: 1245", "chunk_char_count": 1354, "chunk_word_count": 209, "chunk_token_count": 338.5}, {"page_number": 1246, "sentence_chunk": "Java WebClient client = WebClient.builder() \u00a0    .filter((request, next) -> { \u00a0      ClientRequest filtered = ClientRequest.from(request) \u00a0          .header(\"foo\", \"bar\") \u00a0          .build(); \u00a0      return next.exchange(filtered); \u00a0    }) \u00a0    .build(); Kotlin val client = WebClient.builder() \u00a0    .filter { request, next -> \u00a0      val filtered = ClientRequest.from(request) \u00a0          .header(\"foo\", \"bar\") \u00a0          .build() \u00a0      next.exchange(filtered) \u00a0    } \u00a0    .build() This can be used for cross-cutting concerns, such as authentication. The following example uses a filter for basic authentication through a static factory method: Java import static org.springframework.web.reactive.function.client. ExchangeFilterFunctions.basicAuthenti cation; WebClient client = WebClient.builder() \u00a0    .filter(basicAuthentication(\"user\", \"password\")) \u00a0    .build(); Kotlin import org.springframework.web.reactive.function.client. ExchangeFilterFunctions.basicAuthenti cation val client = WebClient.builder() \u00a0    .filter(basicAuthentication(\"user\", \"password\")) \u00a0    .build() 1246", "chunk_char_count": 1081, "chunk_word_count": 194, "chunk_token_count": 270.25}, {"page_number": 1247, "sentence_chunk": "Filters can be added or removed by mutating an existing WebClient instance, resulting in a new WebClient instance that does not affect the original one. For example: Java import static org.springframework.web.reactive.function.client. ExchangeFilterFunctions.basicAuthenti cation; WebClient client = webClient.mutate() \u00a0    .filters(filterList -> { \u00a0      filterList.add(0, basicAuthentication(\"user\", \"password\")); \u00a0    }) \u00a0    .build(); Kotlin val client = webClient.mutate() \u00a0    .filters { it.add(0, basicAuthentication(\"user\", \"password\")) } \u00a0    .build() WebClient is a thin facade around the chain of filters followed by an ExchangeFunction. It provides a workflow to make requests, to encode to and from higher level objects, and it helps to ensure that response content is always consumed. When filters handle the response in some way, extra care must be taken to always consume its content or to otherwise propagate it downstream to the WebClient which will ensure the same. Below is a filter that handles the UNAUTHORIZED status code but ensures that any response content, whether expected or not, is released: Java public ExchangeFilterFunction renewTokenFilter() { \u00a0  return (request, next) -> next.exchange(request).flatMap(response -> { \u00a0    if (response.statusCode().value() == HttpStatus. UNAUTHORIZED.value()) { \u00a0      return response.releaseBody() \u00a0          .then(renewToken()) \u00a0          .flatMap(token -> { \u00a0            ClientRequest newRequest = ClientRequest.from(request).build(); \u00a0            return next.exchange(newRequest); \u00a0          }); \u00a0    } else { \u00a0      return Mono.just(response); \u00a0    } \u00a0  }); } 1247", "chunk_char_count": 1637, "chunk_word_count": 299, "chunk_token_count": 409.25}, {"page_number": 1248, "sentence_chunk": "Kotlin fun renewTokenFilter(): ExchangeFilterFunction? {\u00a0  return ExchangeFilterFunction { request: ClientRequest?,next: ExchangeFunction -> \u00a0    next.exchange(request!!).flatMap { response: ClientResponse -> \u00a0      if (response.statusCode().value() == HttpStatus. UNAUTHORIZED.value()) { \u00a0        return@flatMap response.releaseBody() \u00a0            .then(renewToken()) \u00a0            .flatMap { token: String? -> \u00a0              val newRequest = ClientRequest.from(request).build() \u00a0              next.exchange(newRequest) \u00a0            } \u00a0      } else { \u00a0        return@flatMap Mono.just(response) \u00a0      } \u00a0    } \u00a0  } } 6.2.6. Attributes You can add attributes to a request. This is convenient if you want to pass information through the filter chain and influence the behavior of filters for a given request. For example: Java WebClient client = WebClient.builder() \u00a0    .filter((request, next) -> { \u00a0      Optional<Object> usr = request.attribute(\"myAttribute\"); \u00a0      // ... \u00a0    }) \u00a0    .build(); client.get().uri(\"https://example.org/\") \u00a0    .attribute(\"myAttribute\", \"...\") \u00a0    .retrieve() \u00a0    .bodyToMono(Void.class); \u00a0  } 1248", "chunk_char_count": 1135, "chunk_word_count": 251, "chunk_token_count": 283.75}, {"page_number": 1249, "sentence_chunk": "Kotlin val client = WebClient.builder() \u00a0    .filter { request, _ -> \u00a0      val usr = request.attributes()[\"myAttribute\"]; \u00a0      // ... \u00a0    } \u00a0    .build() \u00a0  client.get().uri(\"https://example.org/\") \u00a0      .attribute(\"myAttribute\", \"...\") \u00a0      .retrieve() \u00a0      .awaitBody<Unit>() Note that you can configure a defaultRequest callback globally at the WebClient. Builder level which lets you insert attributes into all requests, which could be used for example in a Spring MVC application to populate request attributes based on ThreadLocal data.6.2.7. Context Attributes provide a convenient way to pass information to the filter chain but they only influence the current request. If you want to pass information that propagates to additional requests that are nested, e.g. via flatMap, or executed after, e.g. via concatMap, then you\u2019ll need to use the Reactor Context. The Reactor Context needs to be populated at the end of a reactive chain in order to apply to all operations. For example: Java WebClient client = WebClient.builder() \u00a0    .filter((request, next) -> \u00a0        Mono.deferContextual(contextView -> { \u00a0          String value = contextView.get(\"foo\"); \u00a0          // ... \u00a0        })) \u00a0    .build(); client.get().uri(\"https://example.org/\") \u00a0    .retrieve() \u00a0    .bodyToMono(String.class) \u00a0    .flatMap(body -> { \u00a0        // perform nested request (context propagates automatically)... \u00a0    }) \u00a0    .contextWrite(context -> context.put(\"foo\", ...)); 6.2.8. Synchronous Use WebClient can be used in synchronous style by blocking at the end for the result: 1249", "chunk_char_count": 1578, "chunk_word_count": 310, "chunk_token_count": 394.5}, {"page_number": 1250, "sentence_chunk": "Java Person person = client.get().uri(\"/person/{id}\", i).retrieve() \u00a0  .bodyToMono(Person.class) \u00a0  .block(); List<Person> persons = client.get().uri(\"/persons\").retrieve() \u00a0  .bodyToFlux(Person.class) \u00a0  .collectList() \u00a0  .block(); Kotlin val person = runBlocking { \u00a0  client.get().uri(\"/person/{id}\", i).retrieve() \u00a0      .awaitBody<Person>() } val persons = runBlocking { \u00a0  client.get().uri(\"/persons\").retrieve() \u00a0      .bodyToFlow<Person>() \u00a0      .toList() } However if multiple calls need to be made, it\u2019s more efficient to avoid blocking on each response individually, and instead wait for the combined result: Java Mono<Person> personMono = client.get().uri(\"/person/{id}\", personId) \u00a0    .retrieve().bodyToMono(Person.class); Mono<List<Hobby>> hobbiesMono = client.get().uri(\"/person/{id}/hobbies\", personId) \u00a0    .retrieve().bodyToFlux(Hobby.class).collectList(); Map<String, Object> data = Mono.zip(personMono, hobbiesMono, (person, hobbies) -> { \u00a0      Map<String, String> map = new LinkedHashMap<>(); \u00a0      map.put(\"person\", person); \u00a0      map.put(\"hobbies\", hobbies); \u00a0      return map; \u00a0    }) \u00a0    .block(); 1250", "chunk_char_count": 1132, "chunk_word_count": 169, "chunk_token_count": 283.0}, {"page_number": 1251, "sentence_chunk": "Kotlin val data = runBlocking { \u00a0    val personDeferred = async { \u00a0      client.get().uri(\"/person/{id}\", personId) \u00a0          .retrieve().awaitBody<Person>() \u00a0    } \u00a0    val hobbiesDeferred = async { \u00a0      client.get().uri(\"/person/{id}/hobbies\", personId) \u00a0          .retrieve().bodyToFlow<Hobby>().toList() \u00a0    } \u00a0    mapOf(\"person\" to personDeferred.await(), \"hobbies\" to hobbiesDeferred.await()) \u00a0  } The above is merely one example. There are lots of other patterns and operators for putting together a reactive pipeline that makes many remote calls, potentially some nested, inter- dependent, without ever blocking until the end.\uf05a With Flux or Mono, you should never have to block in a Spring MVC or Spring WebFlux controller. Simply return the resulting reactive type from the controller method. The same principle apply to Kotlin Coroutines and Spring WebFlux, just use suspending function or return Flow in your controller method .6.2.9. Testing To test code that uses the WebClient, you can use a mock web server, such as the OkHttp MockWebServer. To see an example of its use, check out WebClientIntegrationTests in the Spring Framework test suite or the static-server sample in the OkHttp repository.6.3. HTTP Interface Client The Spring Frameworks lets you define an HTTP service as a Java interface with HTTP exchange methods.", "chunk_char_count": 1343, "chunk_word_count": 235, "chunk_token_count": 335.75}, {"page_number": 1251, "sentence_chunk": "You can then generate a proxy that implements this interface and performs the exchanges. This helps to simplify HTTP remote access and provides additional flexibility for to choose an API style such as synchronous or reactive. See REST Endpoints for details.6.4. WebSockets Same as in the Servlet stack This part of the reference documentation covers support for reactive-stack WebSocket messaging.= Introduction to WebSocket 1251", "chunk_char_count": 430, "chunk_word_count": 64, "chunk_token_count": 107.5}, {"page_number": 1252, "sentence_chunk": "The WebSocket protocol, RFC 6455, provides a standardized way to establish a full-duplex, two-way communication channel between client and server over a single TCP connection. It is a different TCP protocol from HTTP but is designed to work over HTTP, using ports 80 and 443 and allowing re- use of existing firewall rules. A WebSocket interaction begins with an HTTP request that uses the HTTP Upgrade header to upgrade or, in this case, to switch to the WebSocket protocol. The following example shows such an interaction: GET /spring-websocket-portfolio/portfolio HTTP/1.1 Host: localhost:8080 Upgrade: websocket \u2460 Connection: Upgrade \u2461 Sec-WebSocket-Key: Uc9l9TMkWGbHFD2qnFHltg== Sec-WebSocket-Protocol: v10.stomp, v11.stomp Sec-WebSocket-Version: 13 Origin: http://localhost:8080 \u2460 The Upgrade header.\u2461 Using the Upgrade connection. Instead of the usual 200 status code, a server with WebSocket support returns output similar to the following: HTTP/1.1 101 Switching Protocols \u2460 Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: 1qVdfYHU9hPOl4JYYNXF623Gzn0= Sec-WebSocket-Protocol: v10.stomp \u2460 Protocol switch After a successful handshake, the TCP socket underlying the HTTP upgrade request remains open for both the client and the server to continue to send and receive messages. A complete introduction of how WebSockets work is beyond the scope of this document. See RFC 6455, the WebSocket chapter of HTML5, or any of the many introductions and tutorials on the Web. Note that, if a WebSocket server is running behind a web server (e.g. nginx), you likely need to configure it to pass WebSocket upgrade requests on to the WebSocket server. Likewise, if the application runs in a cloud environment, check the instructions of the cloud provider related to WebSocket support.", "chunk_char_count": 1792, "chunk_word_count": 259, "chunk_token_count": 448.0}, {"page_number": 1252, "sentence_chunk": "== HTTP Versus WebSocket Even though WebSocket is designed to be HTTP-compatible and starts with an HTTP request, it is important to understand that the two protocols lead to very different architectures and application programming models.1252", "chunk_char_count": 243, "chunk_word_count": 36, "chunk_token_count": 60.75}, {"page_number": 1253, "sentence_chunk": "In HTTP and REST, an application is modeled as many URLs. To interact with the application, clients access those URLs, request-response style. Servers route requests to the appropriate handler based on the HTTP URL, method, and headers. By contrast, in WebSockets, there is usually only one URL for the initial connect. Subsequently, all application messages flow on that same TCP connection. This points to an entirely different asynchronous, event-driven, messaging architecture. WebSocket is also a low-level transport protocol, which, unlike HTTP, does not prescribe any semantics to the content of messages. That means that there is no way to route or process a message unless the client and the server agree on message semantics. WebSocket clients and servers can negotiate the use of a higher-level, messaging protocol (for example, STOMP), through the Sec-WebSocket-Protocol header on the HTTP handshake request. In the absence of that, they need to come up with their own conventions.", "chunk_char_count": 993, "chunk_word_count": 153, "chunk_token_count": 248.25}, {"page_number": 1253, "sentence_chunk": "== When to Use WebSockets WebSockets can make a web page be dynamic and interactive. However, in many cases, a combination of Ajax and HTTP streaming or long polling can provide a simple and effective solution. For example, news, mail, and social feeds need to update dynamically, but it may be perfectly okay to do so every few minutes. Collaboration, games, and financial apps, on the other hand, need to be much closer to real-time. Latency alone is not a deciding factor. If the volume of messages is relatively low (for example, monitoring network failures) HTTP streaming or polling can provide an effective solution. It is the combination of low latency, high frequency, and high volume that make the best case for the use of WebSocket. Keep in mind also that over the Internet, restrictive proxies that are outside of your control may preclude WebSocket interactions, either because they are not configured to pass on the Upgrade header or because they close long-lived connections that appear idle. This means that the use of WebSocket for internal applications within the firewall is a more straightforward decision than it is for public facing applications.6.4.1.", "chunk_char_count": 1174, "chunk_word_count": 192, "chunk_token_count": 293.5}, {"page_number": 1253, "sentence_chunk": "WebSocket API Same as in the Servlet stack The Spring Framework provides a WebSocket API that you can use to write client- and server-side applications that handle WebSocket messages. Server Same as in the Servlet stack To create a WebSocket server, you can first create a WebSocketHandler. The following example shows how to do so: 1253", "chunk_char_count": 337, "chunk_word_count": 56, "chunk_token_count": 84.25}, {"page_number": 1254, "sentence_chunk": "Java import org.springframework.web.reactive.socket. WebSocketHandler; import org.springframework.web.reactive.socket. WebSocketSession; public class MyWebSocketHandler implements WebSocketHandler { \u00a0  @Override \u00a0  public Mono<Void> handle(WebSocketSession session) { \u00a0    // ... \u00a0  } } Kotlin import org.springframework.web.reactive.socket. WebSocketHandler import org.springframework.web.reactive.socket. WebSocketSession class MyWebSocketHandler : WebSocketHandler { \u00a0  override fun handle(session: WebSocketSession): Mono<Void> { \u00a0    // ... \u00a0  } } Then you can map it to a URL: Java @Configuration class WebConfig { \u00a0  @Bean \u00a0  public HandlerMapping handlerMapping() { \u00a0    Map<String, WebSocketHandler> map = new HashMap<>(); \u00a0    map.put(\"/path\", new MyWebSocketHandler()); \u00a0    int order = -1; // before annotated controllers \u00a0    return new SimpleUrlHandlerMapping(map, order); \u00a0  } } 1254", "chunk_char_count": 898, "chunk_word_count": 127, "chunk_token_count": 224.5}, {"page_number": 1255, "sentence_chunk": "Kotlin @Configuration class WebConfig { \u00a0  @Bean \u00a0  fun handlerMapping(): HandlerMapping { \u00a0    val map = mapOf(\"/path\" to MyWebSocketHandler()) \u00a0    val order = -1 // before annotated controllers \u00a0    return SimpleUrlHandlerMapping(map, order) \u00a0  } } If using the WebFlux Config there is nothing further to do, or otherwise if not using the WebFlux config you\u2019ll need to declare a WebSocketHandlerAdapter as shown below: Java @Configuration class WebConfig { \u00a0  // ... \u00a0  @Bean \u00a0  public WebSocketHandlerAdapter handlerAdapter() { \u00a0    return new WebSocketHandlerAdapter(); \u00a0  } } Kotlin @Configuration class WebConfig { \u00a0  // ... \u00a0  @Bean \u00a0  fun handlerAdapter() = WebSocketHandlerAdapter() } WebSocketHandler The handle method of WebSocketHandler takes WebSocketSession and returns Mono<Void> to indicate when application handling of the session is complete. The session is handled through two streams, one for inbound and one for outbound messages. The following table describes the two methods that handle the streams: 1255", "chunk_char_count": 1028, "chunk_word_count": 171, "chunk_token_count": 257.0}, {"page_number": 1256, "sentence_chunk": "WebSocketSession method Description Flux<WebSocketMessage> receive() Provides access to the inbound message stream and completes when the connection is closed. Mono<Void> send(Publisher<WebSocketMessage>) Takes a source for outgoing messages, writes the messages, and returns a Mono<Void> that completes when the source completes and writing is done. A WebSocketHandler must compose the inbound and outbound streams into a unified flow and return a Mono<Void> that reflects the completion of that flow. Depending on application requirements, the unified flow completes when: \u2022 Either the inbound or the outbound message stream completes. \u2022The inbound stream completes (that is, the connection closed), while the outbound stream is infinite. \u2022At a chosen point, through the close method of WebSocketSession. When inbound and outbound message streams are composed together, there is no need to check if the connection is open, since Reactive Streams signals end activity. The inbound stream receives a completion or error signal, and the outbound stream receives a cancellation signal. The most basic implementation of a handler is one that handles the inbound stream. The following example shows such an implementation: Java class ExampleHandler implements WebSocketHandler { \u00a0  @Override \u00a0  public Mono<Void> handle(WebSocketSession session) { \u00a0    return session.receive()      \u2460 \u00a0        .doOnNext(message -> { \u00a0          // ...         \u2461 \u00a0        }) \u00a0        .concatMap(message -> { \u00a0          // ...         \u2462 \u00a0        }) \u00a0        .then();          \u2463 \u00a0  } } \u2460 Access the stream of inbound messages.", "chunk_char_count": 1602, "chunk_word_count": 316, "chunk_token_count": 400.5}, {"page_number": 1256, "sentence_chunk": "\u2461 Do something with each message.\u2462 Perform nested asynchronous operations that use the message content.\u2463 Return a Mono<Void> that completes when receiving completes.1256", "chunk_char_count": 169, "chunk_word_count": 23, "chunk_token_count": 42.25}, {"page_number": 1257, "sentence_chunk": "Kotlin class ExampleHandler : WebSocketHandler { \u00a0  override fun handle(session: WebSocketSession): Mono<Void> { \u00a0    return session.receive()      \u2460 \u00a0        .doOnNext { \u00a0          // ...         \u2461 \u00a0        } \u00a0        .concatMap { \u00a0          // ...         \u2462 \u00a0        } \u00a0        .then()           \u2463 \u00a0  } } \u2460 Access the stream of inbound messages.\u2461 Do something with each message.\u2462 Perform nested asynchronous operations that use the message content.\u2463 Return a Mono<Void> that completes when receiving completes.\uf0eb For nested, asynchronous operations, you may need to call message.retain() on underlying servers that use pooled data buffers (for example, Netty). Otherwise, the data buffer may be released before you have had a chance to read the data. For more background, see Data Buffers and Codecs. The following implementation combines the inbound and outbound streams: Java class ExampleHandler implements WebSocketHandler { \u00a0  @Override \u00a0  public Mono<Void> handle(WebSocketSession session) { \u00a0    Flux<WebSocketMessage> output = session.receive()        \u2460 \u00a0        .doOnNext(message -> { \u00a0          // ... \u00a0        }) \u00a0        .concatMap(message -> { \u00a0          // ... \u00a0        }) \u00a0        .map(value -> session.textMessage(\"Echo \" + value));  \u2461 \u00a0    return session.send(output);                  \u2462 \u00a0  } } \u2460 Handle the inbound message stream.1257", "chunk_char_count": 1353, "chunk_word_count": 360, "chunk_token_count": 338.25}, {"page_number": 1258, "sentence_chunk": "\u2461 Create the outbound message, producing a combined flow.\u2462 Return a Mono<Void> that does not complete while we continue to receive. Kotlin class ExampleHandler : WebSocketHandler { \u00a0  override fun handle(session: WebSocketSession): Mono<Void> { \u00a0    val output = session.receive()           \u2460 \u00a0        .doOnNext { \u00a0          // ... \u00a0        } \u00a0        .concatMap { \u00a0          // ... \u00a0        } \u00a0        .map { session.textMessage(\"Echo $it\") }  \u2461 \u00a0    return session.send(output)             \u2462 \u00a0  } } \u2460 Handle the inbound message stream.\u2461 Create the outbound message, producing a combined flow.\u2462 Return a Mono<Void> that does not complete while we continue to receive. Inbound and outbound streams can be independent and be joined only for completion, as the following example shows: 1258", "chunk_char_count": 788, "chunk_word_count": 199, "chunk_token_count": 197.0}, {"page_number": 1259, "sentence_chunk": "Java class ExampleHandler implements WebSocketHandler { \u00a0  @Override \u00a0  public Mono<Void> handle(WebSocketSession session) { \u00a0    Mono<Void> input = session.receive()                \u2460 \u00a0        .doOnNext(message -> { \u00a0          // ... \u00a0        }) \u00a0        .concatMap(message -> { \u00a0          // ... \u00a0        }) \u00a0        .then(); \u00a0    Flux<String> source = ... ; \u00a0    Mono<Void> output = session.send(source.map(session::textMessage)); \u2461 \u00a0    return Mono.zip(input, output).then();               \u2462 \u00a0  } } \u2460 Handle inbound message stream.\u2461 Send outgoing messages.\u2462 Join the streams and return a Mono<Void> that completes when either stream ends. Kotlin class ExampleHandler : WebSocketHandler { \u00a0  override fun handle(session: WebSocketSession): Mono<Void> { \u00a0    val input = session.receive()                  \u2460 \u00a0        .doOnNext { \u00a0          // ... \u00a0        } \u00a0        .concatMap { \u00a0          // ... \u00a0        } \u00a0        .then() \u00a0    val source: Flux<String> = ... \u00a0    val output = session.send(source.map(session::textMessage))   \u2461 \u00a0    return Mono.zip(input, output).then()              \u2462 \u00a0  } } \u2460 Handle inbound message stream.1259", "chunk_char_count": 1133, "chunk_word_count": 339, "chunk_token_count": 283.25}, {"page_number": 1260, "sentence_chunk": "\u2461 Send outgoing messages.\u2462 Join the streams and return a Mono<Void> that completes when either stream ends. DataBuffer DataBuffer is the representation for a byte buffer in WebFlux. The Spring Core part of the reference has more on that in the section on Data Buffers and Codecs. The key point to understand is that on some servers like Netty, byte buffers are pooled and reference counted, and must be released when consumed to avoid memory leaks. When running on Netty, applications must use DataBufferUtils.retain(dataBuffer) if they wish to hold on input data buffers in order to ensure they are not released, and subsequently use DataBufferUtils.release(dataBuffer) when the buffers are consumed. Handshake Same as in the Servlet stack WebSocketHandlerAdapter delegates to a WebSocketService. By default, that is an instance of HandshakeWebSocketService, which performs basic checks on the WebSocket request and then uses RequestUpgradeStrategy for the server in use. Currently, there is built-in support for Reactor Netty, Tomcat, Jetty, and Undertow. HandshakeWebSocketService exposes a sessionAttributePredicate property that allows setting a Predicate<String> to extract attributes from the WebSession and insert them into the attributes of the WebSocketSession.", "chunk_char_count": 1271, "chunk_word_count": 184, "chunk_token_count": 317.75}, {"page_number": 1260, "sentence_chunk": "Server Configuration Same as in the Servlet stack The RequestUpgradeStrategy for each server exposes configuration specific to the underlying WebSocket server engine. When using the WebFlux Java config you can customize such properties as shown in the corresponding section of the WebFlux Config, or otherwise if not using the WebFlux config, use the below: 1260", "chunk_char_count": 362, "chunk_word_count": 55, "chunk_token_count": 90.5}, {"page_number": 1261, "sentence_chunk": "Java @Configuration class WebConfig { \u00a0  @Bean \u00a0  public WebSocketHandlerAdapter handlerAdapter() { \u00a0    return new WebSocketHandlerAdapter(webSocketService()); \u00a0  } \u00a0  @Bean \u00a0  public WebSocketService webSocketService() { \u00a0    TomcatRequestUpgradeStrategy strategy = new TomcatRequestUpgradeStrategy(); \u00a0    strategy.setMaxSessionIdleTimeout(0L); \u00a0    return new HandshakeWebSocketService(strategy); \u00a0  } } Kotlin @Configuration class WebConfig { \u00a0  @Bean \u00a0  fun handlerAdapter() = \u00a0      WebSocketHandlerAdapter(webSocketService()) \u00a0  @Bean \u00a0  fun webSocketService(): WebSocketService { \u00a0    val strategy = TomcatRequestUpgradeStrategy().apply { \u00a0      setMaxSessionIdleTimeout(0L) \u00a0    } \u00a0    return HandshakeWebSocketService(strategy) \u00a0  } } Check the upgrade strategy for your server to see what options are available. Currently, only Tomcat and Jetty expose such options. CORS Same as in the Servlet stack The easiest way to configure CORS and restrict access to a WebSocket endpoint is to have your WebSocketHandler implement CorsConfigurationSource and return a CorsConfiguration with allowed origins, headers, and other details. If you cannot do that, you can also set the corsConfigurations property on the SimpleUrlHandler to specify CORS settings by URL pattern. If both are specified, they are combined by using the combine method on CorsConfiguration.1261", "chunk_char_count": 1369, "chunk_word_count": 213, "chunk_token_count": 342.25}, {"page_number": 1262, "sentence_chunk": "Client Spring WebFlux provides a WebSocketClient abstraction with implementations for Reactor Netty, Tomcat, Jetty, Undertow, and standard Java (that is, JSR-356).\uf05a The Tomcat client is effectively an extension of the standard Java one with some extra functionality in the WebSocketSession handling to take advantage of the Tomcat-specific API to suspend receiving messages for back pressure. To start a WebSocket session, you can create an instance of the client and use its execute methods: Java WebSocketClient client = new ReactorNettyWebSocketClient(); URI url = new URI(\"ws://localhost:8080/path\"); client.execute(url, session -> \u00a0    session.receive() \u00a0        .doOnNext(System.out::println) \u00a0        .then()); Kotlin val client = ReactorNettyWebSocketClient() \u00a0    val url = URI(\"ws://localhost:8080/path\") \u00a0    client.execute(url) { session -> \u00a0      session.receive() \u00a0          .doOnNext(::println) \u00a0      .then() \u00a0    } Some clients, such as Jetty, implement Lifecycle and need to be stopped and started before you can use them. All clients have constructor options related to configuration of the underlying WebSocket client.6.5. Testing Same in Spring MVC The spring-test module provides mock implementations of ServerHttpRequest, ServerHttpResponse, and ServerWebExchange. See Spring Web Reactive for a discussion of mock objects. WebTestClient builds on these mock request and response objects to provide support for testing WebFlux applications without an HTTP server. You can use the WebTestClient for end-to-end integration tests, too.1262", "chunk_char_count": 1558, "chunk_word_count": 249, "chunk_token_count": 389.5}, {"page_number": 1263, "sentence_chunk": "6.6. RSocket This section describes Spring Framework\u2019s support for the RSocket protocol.6.6.1. Overview RSocket is an application protocol for multiplexed, duplex communication over TCP, WebSocket, and other byte stream transports, using one of the following interaction models: \u2022 Request-Response\u2009\u2014\u2009send one message and receive one back. \u2022Request-Stream\u2009\u2014\u2009send one message and receive a stream of messages back. \u2022Channel\u2009\u2014\u2009send streams of messages in both directions. \u2022Fire-and-Forget\u2009\u2014\u2009send a one-way message. Once the initial connection is made, the \"client\" vs \"server\" distinction is lost as both sides become symmetrical and each side can initiate one of the above interactions. This is why in the protocol calls the participating sides \"requester\" and \"responder\" while the above interactions are called \"request streams\" or simply \"requests\". These are the key features and benefits of the RSocket protocol: \u2022 Reactive Streams semantics across network boundary\u2009\u2014\u2009for streaming requests such as Request-Stream and Channel, back pressure signals travel between requester and responder, allowing a requester to slow down a responder at the source, hence reducing reliance on network layer congestion control, and the need for buffering at the network level or at any level. \u2022", "chunk_char_count": 1280, "chunk_word_count": 184, "chunk_token_count": 320.0}, {"page_number": 1263, "sentence_chunk": "Request throttling\u2009\u2014\u2009this feature is named \"Leasing\" after the LEASE frame that can be sent from each end to limit the total number of requests allowed by other end for a given time. Leases are renewed periodically. \u2022Session resumption\u2009\u2014\u2009this is designed for loss of connectivity and requires some state to be maintained. The state management is transparent for applications, and works well in combination with back pressure which can stop a producer when possible and reduce the amount of state required. \u2022Fragmentation and re-assembly of large messages. \u2022Keepalive (heartbeats). RSocket has implementations in multiple languages. The Java library is built on Project Reactor, and Reactor Netty for the transport. That means signals from Reactive Streams Publishers in your application propagate transparently through RSocket across the network. The Protocol One of the benefits of RSocket is that it has well defined behavior on the wire and an easy to read specification along with some protocol extensions.", "chunk_char_count": 1010, "chunk_word_count": 154, "chunk_token_count": 252.5}, {"page_number": 1263, "sentence_chunk": "Therefore it is a good idea to read the spec, independent of language implementations and higher level framework APIs. This section provides a succinct overview to establish some context.1263", "chunk_char_count": 191, "chunk_word_count": 29, "chunk_token_count": 47.75}, {"page_number": 1264, "sentence_chunk": "Connecting Initially a client connects to a server via some low level streaming transport such as TCP or WebSocket and sends a SETUP frame to the server to set parameters for the connection. The server may reject the SETUP frame, but generally after it is sent (for the client) and received (for the server), both sides can begin to make requests, unless SETUP indicates use of leasing semantics to limit the number of requests, in which case both sides must wait for a LEASE frame from the other end to permit making requests. Making Requests Once a connection is established, both sides may initiate a request through one of the frames REQUEST_RESPONSE, REQUEST_STREAM, REQUEST_CHANNEL, or REQUEST_FNF. Each of those frames carries one message from the requester to the responder. The responder may then return PAYLOAD frames with response messages, and in the case of REQUEST_CHANNEL the requester may also send PAYLOAD frames with more request messages. When a request involves a stream of messages such as Request-Stream and Channel, the responder must respect demand signals from the requester. Demand is expressed as a number of messages. Initial demand is specified in REQUEST_STREAM and REQUEST_CHANNEL frames. Subsequent demand is signaled via REQUEST_N frames. Each side may also send metadata notifications, via the METADATA_PUSH frame, that do not pertain to any individual request but rather to the connection as a whole.", "chunk_char_count": 1435, "chunk_word_count": 229, "chunk_token_count": 358.75}, {"page_number": 1264, "sentence_chunk": "Message Format RSocket messages contain data and metadata. Metadata can be used to send a route, a security token, etc. Data and metadata can be formatted differently. Mime types for each are declared in the SETUP frame and apply to all requests on a given connection. While all messages can have metadata, typically metadata such as a route are per-request and therefore only included in the first message on a request, i.e. with one of the frames REQUEST_RESPONSE, REQUEST_STREAM, REQUEST_CHANNEL, or REQUEST_FNF. Protocol extensions define common metadata formats for use in applications: \u2022 Composite Metadata-- multiple, independently formatted metadata entries. \u2022Routing\u2009\u2014\u2009the route for a request. Java Implementation The Java implementation for RSocket is built on Project Reactor. The transports for TCP and WebSocket are built on Reactor Netty. As a Reactive Streams library, Reactor simplifies the job of implementing the protocol.", "chunk_char_count": 940, "chunk_word_count": 141, "chunk_token_count": 235.0}, {"page_number": 1264, "sentence_chunk": "For applications it is a natural fit to use Flux and Mono with declarative operators and transparent back pressure support. The API in RSocket Java is intentionally minimal and basic. It focuses on protocol features and leaves the application programming model (e.g. RPC codegen vs other) as a higher level, 1264", "chunk_char_count": 312, "chunk_word_count": 51, "chunk_token_count": 78.0}, {"page_number": 1265, "sentence_chunk": "independent concern. The main contract io.rsocket. RSocket models the four request interaction types with Mono representing a promise for a single message, Flux a stream of messages, and io.rsocket. Payload the actual message with access to data and metadata as byte buffers. The RSocket contract is used symmetrically. For requesting, the application is given an RSocket to perform requests with. For responding, the application implements RSocket to handle requests. This is not meant to be a thorough introduction. For the most part, Spring applications will not have to use its API directly. However it may be important to see or experiment with RSocket independent of Spring.", "chunk_char_count": 680, "chunk_word_count": 106, "chunk_token_count": 170.0}, {"page_number": 1265, "sentence_chunk": "The RSocket Java repository contains a number of sample apps that demonstrate its API and protocol features. Spring Support The spring-messaging module contains the following: \u2022 RSocketRequester\u2009\u2014\u2009fluent API to make requests through an io.rsocket. RSocket with data and metadata encoding/decoding. \u2022Annotated Responders\u2009\u2014\u2009@MessageMapping annotated handler methods for responding. The spring-web module contains Encoder and Decoder implementations such as Jackson CBOR/JSON, and Protobuf that RSocket applications will likely need. It also contains the PathPatternParser that can be plugged in for efficient route matching. Spring Boot 2.2 supports standing up an RSocket server over TCP or WebSocket, including the option to expose RSocket over WebSocket in a WebFlux server. There is also client support and auto-configuration for an RSocketRequester. Builder and RSocketStrategies. See the RSocket section in the Spring Boot reference for more details.", "chunk_char_count": 954, "chunk_word_count": 131, "chunk_token_count": 238.5}, {"page_number": 1265, "sentence_chunk": "Spring Security 5.2 provides RSocket support. Spring Integration 5.2 provides inbound and outbound gateways to interact with RSocket clients and servers. See the Spring Integration Reference Manual for more details. Spring Cloud Gateway supports RSocket connections.6.6.2. RSocketRequester RSocketRequester provides a fluent API to perform RSocket requests, accepting and returning objects for data and metadata instead of low level data buffers. It can be used symmetrically, to make requests from clients and to make requests from servers. Client Requester To obtain an RSocketRequester on the client side is to connect to a server which involves sending an RSocket SETUP frame with connection settings. RSocketRequester provides a builder that helps to prepare an io.rsocket.core. RSocketConnector including connection settings for the SETUP frame.", "chunk_char_count": 851, "chunk_word_count": 120, "chunk_token_count": 212.75}, {"page_number": 1266, "sentence_chunk": "Java RSocketRequester requester = RSocketRequester.builder().tcp(\"localhost\", 7000); URI url = URI.create(\"https://example.org:8080/rsocket\"); RSocketRequester requester = RSocketRequester.builder().webSocket(url); Kotlin val requester = RSocketRequester.builder().tcp(\"localhost\", 7000) URI url = URI.create(\"https://example.org:8080/rsocket\"); val requester = RSocketRequester.builder().webSocket(url) The above does not connect immediately. When requests are made, a shared connection is established transparently and used. Connection Setup RSocketRequester. Builder provides the following to customize the initial SETUP frame: \u2022 dataMimeType(MimeType)\u2009\u2014\u2009set the mime type for data on the connection. \u2022metadataMimeType(MimeType)\u2009\u2014\u2009set the mime type for metadata on the connection. \u2022setupData(Object)\u2009\u2014\u2009data to include in the SETUP. \u2022setupRoute(String, Object\u2026)\u2009\u2014\u2009route in the metadata to include in the SETUP. \u2022setupMetadata(Object, MimeType)\u2009\u2014\u2009other metadata to include in the SETUP. For data, the default mime type is derived from the first configured Decoder. For metadata, the default mime type is composite metadata which allows multiple metadata value and mime type pairs per request.", "chunk_char_count": 1193, "chunk_word_count": 135, "chunk_token_count": 298.25}, {"page_number": 1266, "sentence_chunk": "Typically both don\u2019t need to be changed. Data and metadata in the SETUP frame is optional. On the server side, @ConnectMapping methods can be used to handle the start of a connection and the content of the SETUP frame. Metadata may be used for connection level security. Strategies RSocketRequester. Builder accepts RSocketStrategies to configure the requester. You\u2019ll need to use this to provide encoders and decoders for (de)-serialization of data and metadata values. By default only the basic codecs from spring-core for String, byte[], and ByteBuffer are registered. Adding spring-web provides access to more that can be registered as follows: 1266", "chunk_char_count": 653, "chunk_word_count": 101, "chunk_token_count": 163.25}, {"page_number": 1267, "sentence_chunk": "Java RSocketStrategies strategies = RSocketStrategies.builder() \u00a0  .encoders(encoders -> encoders.add(new Jackson2CborEncoder())) \u00a0  .decoders(decoders -> decoders.add(new Jackson2CborDecoder())) \u00a0  .build(); RSocketRequester requester = RSocketRequester.builder() \u00a0  .rsocketStrategies(strategies) \u00a0  .tcp(\"localhost\", 7000); Kotlin val strategies = RSocketStrategies.builder() \u00a0    .encoders { it.add(Jackson2CborEncoder()) } \u00a0    .decoders { it.add(Jackson2CborDecoder()) } \u00a0    .build() val requester = RSocketRequester.builder() \u00a0    .rsocketStrategies(strategies) \u00a0    .tcp(\"localhost\", 7000) RSocketStrategies is designed for re-use. In some scenarios, e.g. client and server in the same application, it may be preferable to declare it in Spring configuration. Client Responders RSocketRequester. Builder can be used to configure responders to requests from the server. You can use annotated handlers for client-side responding based on the same infrastructure that\u2019s used on a server, but registered programmatically as follows: Java RSocketStrategies strategies = RSocketStrategies.builder() \u00a0  .routeMatcher(new PathPatternRouteMatcher()) \u2460 \u00a0  .build(); SocketAcceptor responder = \u00a0  RSocketMessageHandler.responder(strategies, new ClientHandler()); \u2461 RSocketRequester requester = RSocketRequester.builder() \u00a0  .rsocketConnector(connector -> connector.acceptor(responder)) \u2462 \u00a0  .tcp(\"localhost\", 7000); \u2460 Use PathPatternRouteMatcher, if spring-web is present, for efficient route matching.\u2461 Create a responder from a class with @MessageMapping and/or @ConnectMapping methods.\u2462 Register the responder.1267", "chunk_char_count": 1614, "chunk_word_count": 197, "chunk_token_count": 403.5}, {"page_number": 1268, "sentence_chunk": "Kotlin val strategies = RSocketStrategies.builder() \u00a0    .routeMatcher(PathPatternRouteMatcher()) \u2460 \u00a0    .build() val responder = \u00a0  RSocketMessageHandler.responder(strategies, new ClientHandler()); \u2461 val requester = RSocketRequester.builder() \u00a0    .rsocketConnector { it.acceptor(responder) } \u2462 \u00a0    .tcp(\"localhost\", 7000) \u2460 Use PathPatternRouteMatcher, if spring-web is present, for efficient route matching.\u2461 Create a responder from a class with @MessageMapping and/or @ConnectMapping methods.\u2462 Register the responder. Note the above is only a shortcut designed for programmatic registration of client responders. For alternative scenarios, where client responders are in Spring configuration, you can still declare RSocketMessageHandler as a Spring bean and then apply as follows: Java ApplicationContext context = ... ; RSocketMessageHandler handler = context.getBean(RSocketMessageHandler.class); RSocketRequester requester = RSocketRequester.builder() \u00a0  .rsocketConnector(connector -> connector.acceptor(handler.responder())) \u00a0  .tcp(\"localhost\", 7000); Kotlin import org.springframework.beans.factory.getBean val context: ApplicationContext = ... val handler = context.getBean<RSocketMessageHandler>() val requester = RSocketRequester.builder() \u00a0    .rsocketConnector { it.acceptor(handler.responder()) } \u00a0    .tcp(\"localhost\", 7000) For the above you may also need to use setHandlerPredicate in RSocketMessageHandler to switch to a different strategy for detecting client responders, e.g. based on a custom annotation such as @RSocketClientResponder vs the default @Controller. This is necessary in scenarios with client and server, or multiple clients in the same application. See also Annotated Responders, for more on the programming model.1268", "chunk_char_count": 1758, "chunk_word_count": 221, "chunk_token_count": 439.5}, {"page_number": 1269, "sentence_chunk": "Advanced RSocketRequesterBuilder provides a callback to expose the underlying io.rsocket.core. RSocketConnector for further configuration options for keepalive intervals, session resumption, interceptors, and more. You can configure options at that level as follows: Java RSocketRequester requester = RSocketRequester.builder() \u00a0  .rsocketConnector(connector -> { \u00a0    // ... \u00a0  }) \u00a0  .tcp(\"localhost\", 7000); Kotlin val requester = RSocketRequester.builder() \u00a0    .rsocketConnector { \u00a0      //... \u00a0    } \u00a0    .tcp(\"localhost\", 7000) Server Requester To make requests from a server to connected clients is a matter of obtaining the requester for the connected client from the server. In Annotated Responders, @ConnectMapping and @MessageMapping methods support an RSocketRequester argument. Use it to access the requester for the connection. Keep in mind that @ConnectMapping methods are essentially handlers of the SETUP frame which must be handled before requests can begin. Therefore, requests at the very start must be decoupled from handling. For example: Java @ConnectMapping Mono<Void> handle(RSocketRequester requester) { \u00a0  requester.route(\"status\").data(\"5\") \u00a0    .retrieveFlux(StatusReport.class) \u00a0    .subscribe(bar -> { \u2460 \u00a0      // ... \u00a0    }); \u00a0  return ... \u2461 } \u2460 Start the request asynchronously, independent from handling.\u2461 Perform handling and return completion Mono<Void>.1269", "chunk_char_count": 1394, "chunk_word_count": 218, "chunk_token_count": 348.5}, {"page_number": 1270, "sentence_chunk": "Kotlin @ConnectMapping suspend fun handle(requester: RSocketRequester) { \u00a0  GlobalScope.launch { \u00a0    requester.route(\"status\").data(\"5\").retrieveFlow<StatusReport>().collect { \u2460 \u00a0      // ... \u00a0    } \u00a0  } \u00a0  /// ... \u2461 } \u2460 Start the request asynchronously, independent from handling.\u2461 Perform handling in the suspending function. Requests Once you have a client or server requester, you can make requests as follows: Java ViewBox viewBox = ... ; Flux<AirportLocation> locations = requester.route(\"locate.radars.within\") \u2460 \u00a0    .data(viewBox) \u2461 \u00a0    .retrieveFlux(AirportLocation.class); \u2462 \u2460 Specify a route to include in the metadata of the request message.\u2461 Provide data for the request message.\u2462 Declare the expected response. Kotlin val viewBox: ViewBox = ... val locations = requester.route(\"locate.radars.within\") \u2460 \u00a0    .data(viewBox) \u2461 \u00a0    .retrieveFlow<AirportLocation>() \u2462 \u2460 Specify a route to include in the metadata of the request message.\u2461 Provide data for the request message.\u2462 Declare the expected response. The interaction type is determined implicitly from the cardinality of the input and output. The above example is a Request-Stream because one value is sent and a stream of values is received.", "chunk_char_count": 1213, "chunk_word_count": 193, "chunk_token_count": 303.25}, {"page_number": 1270, "sentence_chunk": "For the most part you don\u2019t need to think about this as long as the choice of input and output matches an RSocket interaction type and the types of input and output expected by the responder. The only example of an invalid combination is many-to-one.1270", "chunk_char_count": 254, "chunk_word_count": 45, "chunk_token_count": 63.5}, {"page_number": 1271, "sentence_chunk": "The data(Object) method also accepts any Reactive Streams Publisher, including Flux and Mono, as well as any other producer of value(s) that is registered in the ReactiveAdapterRegistry. For a multi- value Publisher such as Flux which produces the same types of values, consider using one of the overloaded data methods to avoid having type checks and Encoder lookup on every element: data(Object producer, Class<?> elementClass); data(Object producer, ParameterizedTypeReference<?> elementTypeRef); The data(Object) step is optional. Skip it for requests that don\u2019t send data: Java Mono<AirportLocation> location = requester.route(\"find.radar. EWR\")) \u00a0  .retrieveMono(AirportLocation.class); Kotlin import org.springframework.messaging.rsocket.retrieveAndAwait val location = requester.route(\"find.radar. EWR\") \u00a0  .retrieveAndAwait<AirportLocation>() Extra metadata values can be added if using composite metadata (the default) and if the values are supported by a registered Encoder. For example: Java String securityToken = ... ; ViewBox viewBox = ... ; MimeType mimeType = MimeType.valueOf(\"message/x.rsocket.authentication.bearer.v0\"); Flux<AirportLocation> locations = requester.route(\"locate.radars.within\") \u00a0    .metadata(securityToken, mimeType) \u00a0    .data(viewBox) \u00a0    .retrieveFlux(AirportLocation.class); 1271", "chunk_char_count": 1322, "chunk_word_count": 162, "chunk_token_count": 330.5}, {"page_number": 1272, "sentence_chunk": "Kotlin import org.springframework.messaging.rsocket.retrieveFlow val requester: RSocketRequester = ... val securityToken: String = ... val viewBox: ViewBox = ... val mimeType = MimeType.valueOf(\"message/x.rsocket.authentication.bearer.v0\") val locations = requester.route(\"locate.radars.within\") \u00a0    .metadata(securityToken, mimeType) \u00a0    .data(viewBox) \u00a0    .retrieveFlow<AirportLocation>() For Fire-and-Forget use the send() method that returns Mono<Void>. Note that the Mono indicates only that the message was successfully sent, and not that it was handled. For Metadata-Push use the sendMetadata() method with a Mono<Void> return value.6.6.3. Annotated Responders RSocket responders can be implemented as @MessageMapping and @ConnectMapping methods.@MessageMapping methods handle individual requests while @ConnectMapping methods handle connection-level events (setup and metadata push). Annotated responders are supported symmetrically, for responding from the server side and for responding from the client side. Server Responders To use annotated responders on the server side, add RSocketMessageHandler to your Spring configuration to detect @Controller beans with @MessageMapping and @ConnectMapping methods: Java @Configuration static class ServerConfig { \u00a0  @Bean \u00a0  public RSocketMessageHandler rsocketMessageHandler() { \u00a0    RSocketMessageHandler handler = new RSocketMessageHandler(); \u00a0    handler.routeMatcher(new PathPatternRouteMatcher()); \u00a0    return handler; \u00a0  } } 1272", "chunk_char_count": 1492, "chunk_word_count": 190, "chunk_token_count": 373.0}, {"page_number": 1273, "sentence_chunk": "Kotlin @Configuration class ServerConfig { \u00a0  @Bean \u00a0  fun rsocketMessageHandler() = RSocketMessageHandler().apply { \u00a0    routeMatcher = PathPatternRouteMatcher() \u00a0  } } Then start an RSocket server through the Java RSocket API and plug the RSocketMessageHandler for the responder as follows: Java ApplicationContext context = ... ; RSocketMessageHandler handler = context.getBean(RSocketMessageHandler.class); CloseableChannel server = \u00a0  RSocketServer.create(handler.responder()) \u00a0    .bind(TcpServerTransport.create(\"localhost\", 7000)) \u00a0    .block(); Kotlin import org.springframework.beans.factory.getBean val context: ApplicationContext = ... val handler = context.getBean<RSocketMessageHandler>() val server = RSocketServer.create(handler.responder()) \u00a0    .bind(TcpServerTransport.create(\"localhost\", 7000)) \u00a0    .awaitSingle() RSocketMessageHandler supports composite and routing metadata by default. You can set its MetadataExtractor if you need to switch to a different mime type or register additional metadata mime types. You\u2019ll need to set the Encoder and Decoder instances required for metadata and data formats to support. You\u2019ll likely need the spring-web module for codec implementations. By default SimpleRouteMatcher is used for matching routes via AntPathMatcher. We recommend plugging in the PathPatternRouteMatcher from spring-web for efficient route matching. RSocket routes can be hierarchical but are not URL paths. Both route matchers are configured to use \".\"as separator by default and there is no URL decoding as with HTTP URLs. RSocketMessageHandler can be configured via RSocketStrategies which may be useful if you need to share configuration between a client and a server in the same process: 1273", "chunk_char_count": 1730, "chunk_word_count": 234, "chunk_token_count": 432.5}, {"page_number": 1274, "sentence_chunk": "Java @Configuration static class ServerConfig { \u00a0  @Bean \u00a0  public RSocketMessageHandler rsocketMessageHandler() { \u00a0    RSocketMessageHandler handler = new RSocketMessageHandler(); \u00a0    handler.setRSocketStrategies(rsocketStrategies()); \u00a0    return handler; \u00a0  } \u00a0  @Bean \u00a0  public RSocketStrategies rsocketStrategies() { \u00a0    return RSocketStrategies.builder() \u00a0      .encoders(encoders -> encoders.add(new Jackson2CborEncoder())) \u00a0      .decoders(decoders -> decoders.add(new Jackson2CborDecoder())) \u00a0      .routeMatcher(new PathPatternRouteMatcher()) \u00a0      .build(); \u00a0  } } Kotlin @Configuration class ServerConfig { \u00a0  @Bean \u00a0  fun rsocketMessageHandler() = RSocketMessageHandler().apply { \u00a0    rSocketStrategies = rsocketStrategies() \u00a0  } \u00a0  @Bean \u00a0  fun rsocketStrategies() = RSocketStrategies.builder() \u00a0      .encoders { it.add(Jackson2CborEncoder()) } \u00a0      .decoders { it.add(Jackson2CborDecoder()) } \u00a0      .routeMatcher(PathPatternRouteMatcher()) \u00a0      .build() } Client Responders Annotated responders on the client side need to be configured in the RSocketRequester. Builder. For details, see Client Responders.@MessageMapping Once server or client responder configuration is in place, @MessageMapping methods can be used as follows: 1274", "chunk_char_count": 1255, "chunk_word_count": 199, "chunk_token_count": 313.75}, {"page_number": 1275, "sentence_chunk": "Java @Controller public class RadarsController { \u00a0  @MessageMapping(\"locate.radars.within\") \u00a0  public Flux<AirportLocation> radars(MapRequest request) { \u00a0    // ... \u00a0  } } Kotlin @Controller class RadarsController { \u00a0  @MessageMapping(\"locate.radars.within\") \u00a0  fun radars(request: MapRequest): Flow<AirportLocation> { \u00a0    // ... \u00a0  } } The above @MessageMapping method responds to a Request-Stream interaction having the route \"locate.radars.within\". It supports a flexible method signature with the option to use the following method arguments: Method Argument Description @Payload The payload of the request. This can be a concrete value of asynchronous types like Mono or Flux. Note: Use of the annotation is optional. A method argument that is not a simple type and is not any of the other supported arguments, is assumed to be the expected payload. RSocketRequester Requester for making requests to the remote end.@DestinationVariable Value extracted from the route based on variables in the mapping pattern, e.g. @MessageMapping(\"find.radar.{id}\").@Header Metadata value registered for extraction as described in MetadataExtractor.@Headers Map<String, Object> All metadata values registered for extraction as described in MetadataExtractor. The return value is expected to be one or more Objects to be serialized as response payloads.", "chunk_char_count": 1342, "chunk_word_count": 194, "chunk_token_count": 335.5}, {"page_number": 1275, "sentence_chunk": "That can be asynchronous types like Mono or Flux, a concrete value, or either void or a no-value asynchronous type such as Mono<Void>. The RSocket interaction type that an @MessageMapping method supports is determined from the 1275", "chunk_char_count": 231, "chunk_word_count": 37, "chunk_token_count": 57.75}, {"page_number": 1276, "sentence_chunk": "cardinality of the input (i.e. @Payload argument) and of the output, where cardinality means the following: Cardinali ty Description 1 Either an explicit value, or a single-value asynchronous type such as Mono<T>. Many A multi-value asynchronous type such as Flux<T>.0 For input this means the method does not have an @Payload argument. For output this is void or a no-value asynchronous type such as Mono<Void>. The table below shows all input and output cardinality combinations and the corresponding interaction type(s): Input Cardinality Output Cardinality Interaction Types 0, 1 0 Fire-and-Forget, Request-Response 0, 1 1 Request-Response 0, 1 Many Request-Stream Many 0, 1, Many Request-Channel @ConnectMapping @ConnectMapping handles the SETUP frame at the start of an RSocket connection, and any subsequent metadata push notifications through the METADATA_PUSH frame, i.e. metadataPush(Payload) in io.rsocket. RSocket.@ConnectMapping methods support the same arguments as @MessageMapping but based on metadata and data from the SETUP and METADATA_PUSH frames.@ConnectMapping can have a pattern to narrow handling to specific connections that have a route in the metadata, or if no patterns are declared then all connections match.@ConnectMapping methods cannot return data and must be declared with void or Mono<Void> as the return value. If handling returns an error for a new connection then the connection is rejected.", "chunk_char_count": 1429, "chunk_word_count": 208, "chunk_token_count": 357.25}, {"page_number": 1276, "sentence_chunk": "Handling must not be held up to make requests to the RSocketRequester for the connection. See Server Requester for details.6.6.4. MetadataExtractor Responders must interpret metadata. Composite metadata allows independently formatted metadata values (e.g. for routing, security, tracing) each with its own mime type. Applications need a way to configure metadata mime types to support, and a way to access extracted values. MetadataExtractor is a contract to take serialized metadata and return decoded name-value pairs that can then be accessed like headers by name, for example via @Header in annotated handler methods.1276", "chunk_char_count": 625, "chunk_word_count": 91, "chunk_token_count": 156.25}, {"page_number": 1277, "sentence_chunk": "DefaultMetadataExtractor can be given Decoder instances to decode metadata. Out of the box it has built-in support for \"message/x.rsocket.routing.v0\" which it decodes to String and saves under the \"route\" key. For any other mime type you\u2019ll need to provide a Decoder and register the mime type as follows: Java DefaultMetadataExtractor extractor = new DefaultMetadataExtractor(metadataDecoders); extractor.metadataToExtract(fooMimeType, Foo.class, \"foo\"); Kotlin import org.springframework.messaging.rsocket.metadataToExtract val extractor = DefaultMetadataExtractor(metadataDecoders) extractor.metadataToExtract<Foo>(fooMimeType, \"foo\") Composite metadata works well to combine independent metadata values. However the requester might not support composite metadata, or may choose not to use it. For this, DefaultMetadataExtractor may needs custom logic to map the decoded value to the output map. Here is an example where JSON is used for metadata: Java DefaultMetadataExtractor extractor = new DefaultMetadataExtractor(metadataDecoders); extractor.metadataToExtract( \u00a0  MimeType.valueOf(\"application/vnd.myapp.metadata+json\"), \u00a0  new ParameterizedTypeReference<Map<String,String>>() {}, \u00a0  (jsonMap, outputMap) -> { \u00a0    outputMap.putAll(jsonMap); \u00a0  }); Kotlin import org.springframework.messaging.rsocket.metadataToExtract val extractor = DefaultMetadataExtractor(metadataDecoders) extractor.metadataToExtract<Map<String, String>>(MimeType.valueOf(\"application/vnd.myapp.metadata+json\")) { jsonMap, outputMap -> \u00a0  outputMap.putAll(jsonMap) } When configuring MetadataExtractor through RSocketStrategies, you can let RSocketStrategies. Builder create the extractor with the configured decoders, and simply use a callback to customize registrations as follows: 1277", "chunk_char_count": 1769, "chunk_word_count": 190, "chunk_token_count": 442.25}, {"page_number": 1278, "sentence_chunk": "Java RSocketStrategies strategies = RSocketStrategies.builder() \u00a0  .metadataExtractorRegistry(registry -> { \u00a0    registry.metadataToExtract(fooMimeType, Foo.class, \"foo\"); \u00a0    // ... \u00a0  }) \u00a0  .build(); Kotlin import org.springframework.messaging.rsocket.metadataToExtract val strategies = RSocketStrategies.builder() \u00a0    .metadataExtractorRegistry { registry: MetadataExtractorRegistry -> \u00a0      registry.metadataToExtract<Foo>(fooMimeType, \"foo\") \u00a0      // ... \u00a0    } \u00a0    .build() 6.6.5. RSocket Interface The Spring Framework lets you define an RSocket service as a Java interface with annotated methods for RSocket exchanges. You can then generate a proxy that implements this interface and performs the exchanges. This helps to simplify RSocket remote access by wrapping the use of the underlying RSocketRequester. One, declare an interface with @RSocketExchange methods: interface RadarService { \u00a0  @RSocketExchange(\"radars\") \u00a0  Flux<AirportLocation> getRadars(@Payload MapRequest request); \u00a0  // more RSocket exchange methods... } Two, create a proxy that will perform the declared RSocket exchanges: RSocketRequester requester = ... ; RSocketServiceProxyFactory factory = RSocketServiceProxyFactory.builder(requester).build(); RepositoryService service = factory.createClient(RadarService.class); 1278", "chunk_char_count": 1311, "chunk_word_count": 174, "chunk_token_count": 327.75}, {"page_number": 1279, "sentence_chunk": "Method Parameters Annotated, RSocket exchange methods support flexible method signatures with the following method parameters: Method argument Description @DestinationVariable Add a route variable to pass to RSocketRequester along with the route from the @RSocketExchange annotation in order to expand template placeholders in the route. This variable can be a String or any Object, which is then formatted via toString().@Payload Set the input payload(s) for the request. This can be a concrete value, or any producer of values that can be adapted to a Reactive Streams Publisher via ReactiveAdapterRegistry Object, if followed by MimeType The value for a metadata entry in the input payload. This can be any Object as long as the next argument is the metadata entry MimeType. The value can be a concrete value or any producer of a single value that can be adapted to a Reactive Streams Publisher via ReactiveAdapterRegistry. MimeType The MimeType for a metadata entry. The preceding method argument is expected to be the metadata value. Return Values Annotated, RSocket exchange methods support return values that are concrete value(s), or any producer of value(s) that can be adapted to a Reactive Streams Publisher via ReactiveAdapterRegistry.6.7.", "chunk_char_count": 1251, "chunk_word_count": 191, "chunk_token_count": 312.75}, {"page_number": 1279, "sentence_chunk": "Reactive Libraries spring-webflux depends on reactor-core and uses it internally to compose asynchronous logic and to provide Reactive Streams support. Generally, WebFlux APIs return Flux or Mono (since those are used internally) and leniently accept any Reactive Streams Publisher implementation as input. The use of Flux versus Mono is important, because it helps to express cardinality\u2009\u2014\u2009for example, whether a single or multiple asynchronous values are expected, and that can be essential for making decisions (for example, when encoding or decoding HTTP messages). For annotated controllers, WebFlux transparently adapts to the reactive library chosen by the application. This is done with the help of the ReactiveAdapterRegistry, which provides pluggable support for reactive library and other asynchronous types. The registry has built-in support for RxJava 3, Kotlin coroutines and SmallRye Mutiny, but you can register others, too. For functional APIs (such as Functional Endpoints, the WebClient, and others), the general rules for WebFlux APIs apply\u2009\u2014\u2009Flux and Mono as return values and a Reactive Streams Publisher as input. When a Publisher, whether custom or from another reactive library, is provided, it can be treated only as a stream with unknown semantics (0.. N). If, however, the semantics are known, you can wrap it with Flux or Mono.from(Publisher) instead of passing the raw Publisher.1279", "chunk_char_count": 1413, "chunk_word_count": 210, "chunk_token_count": 353.25}, {"page_number": 1280, "sentence_chunk": "For example, given a Publisher that is not a Mono, the Jackson JSON message writer expects multiple values. If the media type implies an infinite stream (for example, application/json+stream), values are written and flushed individually. Otherwise, values are buffered into a list and rendered as a JSON array.1280", "chunk_char_count": 314, "chunk_word_count": 48, "chunk_token_count": 78.5}, {"page_number": 1281, "sentence_chunk": "Chapter 7. Integration This part of the reference documentation covers Spring Framework\u2019s integration with a number of technologies.7.1. REST Clients The Spring Framework provides the following choices for making calls to REST endpoints: \u2022 WebClient - non-blocking, reactive client w fluent API. \u2022RestTemplate - synchronous client with template method API. \u2022HTTP Interface - annotated interface with generated, dynamic proxy implementation.7.1.1. WebClient WebClient is a non-blocking, reactive client to perform HTTP requests. It was introduced in 5.0 and offers an alternative to the RestTemplate, with support for synchronous, asynchronous, and streaming scenarios. WebClient supports the following: \u2022 Non-blocking I/O. \u2022 Reactive Streams back pressure. \u2022", "chunk_char_count": 758, "chunk_word_count": 104, "chunk_token_count": 189.5}, {"page_number": 1281, "sentence_chunk": "High concurrency with fewer hardware resources. \u2022Functional-style, fluent API that takes advantage of Java 8 lambdas. \u2022Synchronous and asynchronous interactions. \u2022Streaming up to or streaming down from a server. See WebClient for more details.7.1.2. RestTemplate The RestTemplate provides a higher level API over HTTP client libraries. It makes it easy to invoke REST endpoints in a single line. It exposes the following groups of overloaded methods: \uf05a RestTemplate is in maintenance mode, with only requests for minor changes and bugs to be accepted. Please, consider using the WebClient instead.", "chunk_char_count": 597, "chunk_word_count": 89, "chunk_token_count": 149.25}, {"page_number": 1281, "sentence_chunk": "Table 27. RestTemplate methods Method group Description getForObject Retrieves a representation via GET.getForEntity Retrieves a ResponseEntity (that is, status, headers, and body) by using GET.1281", "chunk_char_count": 198, "chunk_word_count": 25, "chunk_token_count": 49.5}, {"page_number": 1282, "sentence_chunk": "Method group Description headForHeaders Retrieves all headers for a resource by using HEAD.postForLocation Creates a new resource by using POST and returns the Location header from the response.postForObject Creates a new resource by using POST and returns the representation from the response.postForEntity Creates a new resource by using POST and returns the representation from the response.put Creates or updates a resource by using PUT.patchForObject Updates a resource by using PATCH and returns the representation from the response. Note that the JDK HttpURLConnection does not support PATCH, but Apache HttpComponents and others do.delete Deletes the resources at the specified URI by using DELETE.optionsForAllow Retrieves allowed HTTP methods for a resource by using ALLOW.exchange More generalized (and less opinionated) version of the preceding methods that provides extra flexibility when needed.", "chunk_char_count": 909, "chunk_word_count": 128, "chunk_token_count": 227.25}, {"page_number": 1282, "sentence_chunk": "It accepts a RequestEntity (including HTTP method, URL, headers, and body as input) and returns a ResponseEntity. These methods allow the use of ParameterizedTypeReference instead of Class to specify a response type with generics.execute The most generalized way to perform a request, with full control over request preparation and response extraction through callback interfaces. Initialization The default constructor uses java.net. HttpURLConnection to perform requests. You can switch to a different HTTP library with an implementation of ClientHttpRequestFactory. There is built-in support for the following: \u2022 Apache HttpComponents \u2022 Netty \u2022 OkHttp For example, to switch to Apache HttpComponents, you can use the following: RestTemplate template = new RestTemplate(new HttpComponentsClientHttpRequestFactory()); Each ClientHttpRequestFactory exposes configuration options specific to the underlying HTTP client library\u2009\u2014\u2009for example, for credentials, connection pooling, and other details.1282", "chunk_char_count": 1000, "chunk_word_count": 129, "chunk_token_count": 250.0}, {"page_number": 1283, "sentence_chunk": "\uf0eb Note that the java.net implementation for HTTP requests can raise an exception when accessing the status of a response that represents an error (such as 401). If this is an issue, switch to another HTTP client library. URIs Many of the RestTemplate methods accept a URI template and URI template variables, either as a String variable argument, or as Map<String,String>. The following example uses a String variable argument: String result = restTemplate.getForObject( \u00a0    \"https://example.com/hotels/{hotel}/bookings/{booking}\", String.class, \"42\", \"21\"); The following example uses a Map<String, String>: Map<String, String> vars = Collections.singletonMap(\"hotel\", \"42\"); String result = restTemplate.getForObject( \u00a0    \"https://example.com/hotels/{hotel}/rooms/{hotel}\", String.class, vars); Keep in mind URI templates are automatically encoded, as the following example shows: restTemplate.getForObject(\"https://example.com/hotel list\", String.class); // Results in request to \"https://example.com/hotel%20list\" You can use the uriTemplateHandler property of RestTemplate to customize how URIs are encoded. Alternatively, you can prepare a java.net. URI and pass it into one of the RestTemplate methods that accepts a URI. For more details on working with and encoding URIs, see URI Links. Headers You can use the exchange() methods to specify request headers, as the following example shows: 1283", "chunk_char_count": 1405, "chunk_word_count": 190, "chunk_token_count": 351.25}, {"page_number": 1284, "sentence_chunk": "String uriTemplate = \"https://example.com/hotels/{hotel}\"; URI uri = UriComponentsBuilder.fromUriString(uriTemplate).build(42); RequestEntity<Void> requestEntity = RequestEntity.get(uri) \u00a0    .header(\"MyRequestHeader\", \"MyValue\") \u00a0    .build(); ResponseEntity<String> response = template.exchange(requestEntity, String.class); String responseHeader = response.getHeaders().getFirst(\"MyResponseHeader\"); String body = response.getBody(); You can obtain response headers through many RestTemplate method variants that return ResponseEntity. Body Objects passed into and returned from RestTemplate methods are converted to and from raw content with the help of an HttpMessageConverter. On a POST, an input object is serialized to the request body, as the following example shows: URI location = template.postForLocation(\"https://example.com/people\", person); You need not explicitly set the Content-Type header of the request. In most cases, you can find a compatible message converter based on the source Object type, and the chosen message converter sets the content type accordingly. If necessary, you can use the exchange methods to explicitly provide the Content-Type request header, and that, in turn, influences what message converter is selected. On a GET, the body of the response is deserialized to an output Object, as the following example shows: Person person = restTemplate.getForObject(\"https://example.com/people/{id}\", Person.class, 42); The Accept header of the request does not need to be explicitly set. In most cases, a compatible message converter can be found based on the expected response type, which then helps to populate the Accept header. If necessary, you can use the exchange methods to provide the Accept header explicitly. By default, RestTemplate registers all built-in message converters, depending on classpath checks that help to determine what optional conversion libraries are present. You can also set the message converters to use explicitly.", "chunk_char_count": 1980, "chunk_word_count": 263, "chunk_token_count": 495.0}, {"page_number": 1285, "sentence_chunk": "Message Conversion WebFlux The spring-web module contains the HttpMessageConverter contract for reading and writing the body of HTTP requests and responses through InputStream and OutputStream. HttpMessageConverter instances are used on the client side (for example, in the RestTemplate) and on the server side (for example, in Spring MVC REST controllers). Concrete implementations for the main media (MIME) types are provided in the framework and are, by default, registered with the RestTemplate on the client side and with RequestMappingHandlerAdapter on the server side (see Configuring Message Converters). The implementations of HttpMessageConverter are described in the following sections. For all converters, a default media type is used, but you can override it by setting the supportedMediaTypes bean property. The following table describes each implementation: Table 28. HttpMessageConverter Implementations MessageConverter Description StringHttpMessageConve rter An HttpMessageConverter implementation that can read and write String instances from the HTTP request and response. By default, this converter supports all text media types (text/*) and writes with a Content-Type of text/plain. FormHttpMessageConvert er An HttpMessageConverter implementation that can read and write form data from the HTTP request and response. By default, this converter reads and writes the application/x-www-form-urlencoded media type.", "chunk_char_count": 1433, "chunk_word_count": 192, "chunk_token_count": 358.25}, {"page_number": 1285, "sentence_chunk": "Form data is read from and written into a MultiValueMap<String, String>. The converter can also write (but not read) multipart data read from a MultiValueMap<String, Object>. By default, multipart/form-data is supported. As of Spring Framework 5.2, additional multipart subtypes can be supported for writing form data. Consult the javadoc for FormHttpMessageConverter for further details. ByteArrayHttpMessageCo nverter An HttpMessageConverter implementation that can read and write byte arrays from the HTTP request and response. By default, this converter supports all media types (*/*) and writes with a Content-Type of application/octet-stream. You can override this by setting the supportedMediaTypes property and overriding getContentType(byte[]). MarshallingHttpMessage Converter An HttpMessageConverter implementation that can read and write XML by using Spring\u2019s Marshaller and Unmarshaller abstractions from the org.springframework.oxm package. This converter requires a Marshaller and Unmarshaller before it can be used.", "chunk_char_count": 1031, "chunk_word_count": 134, "chunk_token_count": 257.75}, {"page_number": 1285, "sentence_chunk": "You can inject these through constructor or bean properties. By default, this converter supports text/xml and application/xml.1285", "chunk_char_count": 130, "chunk_word_count": 17, "chunk_token_count": 32.5}, {"page_number": 1286, "sentence_chunk": "MessageConverter Description MappingJackson2HttpMes sageConverter An HttpMessageConverter implementation that can read and write JSON by using Jackson\u2019s ObjectMapper. You can customize JSON mapping as needed through the use of Jackson\u2019s provided annotations. When you need further control (for cases where custom JSON serializers/deserializers need to be provided for specific types), you can inject a custom ObjectMapper through the ObjectMapper property. By default, this converter supports application/json. MappingJackson2XmlHttp MessageConverter An HttpMessageConverter implementation that can read and write XML by using Jackson XML extension\u2019s XmlMapper. You can customize XML mapping as needed through the use of JAXB or Jackson\u2019s provided annotations. When you need further control (for cases where custom XML serializers/deserializers need to be provided for specific types), you can inject a custom XmlMapper through the ObjectMapper property. By default, this converter supports application/xml. SourceHttpMessageConve rter An HttpMessageConverter implementation that can read and write javax.xml.transform. Source from the HTTP request and response.", "chunk_char_count": 1162, "chunk_word_count": 150, "chunk_token_count": 290.5}, {"page_number": 1286, "sentence_chunk": "Only DOMSource, SAXSource, and StreamSource are supported. By default, this converter supports text/xml and application/xml. BufferedImageHttpMessa geConverter An HttpMessageConverter implementation that can read and write java.awt.image. BufferedImage from the HTTP request and response. This converter reads and writes the media type supported by the Java I/O API. Jackson JSON Views You can specify a Jackson JSON View to serialize only a subset of the object properties, as the following example shows: MappingJacksonValue value = new MappingJacksonValue(new User(\"eric\", \"7!jd#h23\")); value.setSerializationView(User. WithoutPasswordView.class); RequestEntity<MappingJacksonValue> requestEntity = \u00a0  RequestEntity.post(new URI(\"https://example.com/user\")).body(value); ResponseEntity<String> response = template.exchange(requestEntity, String.class); Multipart To send multipart data, you need to provide a MultiValueMap<String, Object> whose values may be an Object for part content, a Resource for a file part, or an HttpEntity for part content with headers. For example: 1286", "chunk_char_count": 1083, "chunk_word_count": 130, "chunk_token_count": 270.75}, {"page_number": 1287, "sentence_chunk": "MultiValueMap<String, Object> parts = new LinkedMultiValueMap<>(); parts.add(\"fieldPart\", \"fieldValue\"); parts.add(\"filePart\", new FileSystemResource(\"...logo.png\")); parts.add(\"jsonPart\", new Person(\"Jason\")); HttpHeaders headers = new HttpHeaders(); headers.setContentType(MediaType. APPLICATION_XML); parts.add(\"xmlPart\", new HttpEntity<>(myBean, headers)); In most cases, you do not have to specify the Content-Type for each part. The content type is determined automatically based on the HttpMessageConverter chosen to serialize it or, in the case of a Resource based on the file extension. If necessary, you can explicitly provide the MediaType with an HttpEntity wrapper. Once the MultiValueMap is ready, you can pass it to the RestTemplate, as show below: MultiValueMap<String, Object> parts = ...; template.postForObject(\"https://example.com/upload\", parts, Void.class); If the MultiValueMap contains at least one non-String value, the Content-Type is set to multipart/form- data by the FormHttpMessageConverter. If the MultiValueMap has String values the Content-Type is defaulted to application/x-www-form-urlencoded. If necessary the Content-Type may also be set explicitly.7.1.3. HTTP Interface The Spring Framework lets you define an HTTP service as a Java interface with annotated methods for HTTP exchanges. You can then generate a proxy that implements this interface and performs the exchanges.", "chunk_char_count": 1412, "chunk_word_count": 175, "chunk_token_count": 353.0}, {"page_number": 1287, "sentence_chunk": "This helps to simplify HTTP remote access which often involves a facade that wraps the details of using the underlying HTTP client. One, declare an interface with @HttpExchange methods: interface RepositoryService { \u00a0  @GetExchange(\"/repos/{owner}/{repo}\") \u00a0  Repository getRepository(@PathVariable String owner, @PathVariable String repo); \u00a0  // more HTTP exchange methods... } Two, create a proxy that will perform the declared HTTP exchanges: 1287", "chunk_char_count": 450, "chunk_word_count": 64, "chunk_token_count": 112.5}, {"page_number": 1288, "sentence_chunk": "WebClient client = WebClient.builder().baseUrl(\"https://api.github.com/\").build(); HttpServiceProxyFactory factory = HttpServiceProxyFactory.builder(WebClientAdapter.forClient(client)).build(); RepositoryService service = factory.createClient(RepositoryService.class); @HttpExchange is supported at the type level where it applies to all methods: @HttpExchange(url = \"/repos/{owner}/{repo}\", accept = \"application/vnd.github.v3+json\") interface RepositoryService { \u00a0  @GetExchange \u00a0  Repository getRepository(@PathVariable String owner, @PathVariable String repo); \u00a0  @PatchExchange(contentType = MediaType. APPLICATION_FORM_URLENCODED_VALUE) \u00a0  void updateRepository(@PathVariable String owner, @PathVariable String repo, \u00a0      @RequestParam String name, @RequestParam String description, @RequestParam String homepage); } Method Parameters Annotated, HTTP exchange methods support flexible method signatures with the following method parameters: Method argument Description URI Dynamically set the URL for the request, overriding the annotation\u2019s url attribute. HttpMethod Dynamically set the HTTP method for the request, overriding the annotation\u2019s method attribute @RequestHeader Add a request header or mutliple headers. The argument may be a Map<String, ?> or MultiValueMap<String, ?> with multiple headers, a Collection<?> of values, or an individual value. Type conversion is supported for non-String values.@PathVariable Add a variable for expand a placeholder in the request URL. The argument may be a Map<String, ?", "chunk_char_count": 1526, "chunk_word_count": 176, "chunk_token_count": 381.5}, {"page_number": 1288, "sentence_chunk": "> with multiple variables, or an individual value. Type conversion is supported for non-String values.@RequestBody Provide the body of the request either as an Object to be serialized, or a Reactive Streams Publisher such as Mono, Flux, or any other async type supported through the configured ReactiveAdapterRegistry.1288", "chunk_char_count": 322, "chunk_word_count": 47, "chunk_token_count": 80.5}, {"page_number": 1289, "sentence_chunk": "Method argument Description @RequestParam Add a request parameter or mutliple parameters. The argument may be a Map<String, ?> or MultiValueMap<String, ?> with multiple parameters, a Collection<?> of values, or an individual value. Type conversion is supported for non-String values. When \"content-type\" is set to \"application/x-www-form- urlencoded\", request parameters are encoded in the request body. Otherwise, they are added as URL query parameters.@RequestPart Add a request part, which may be a String (form field), Resource (file part), Object (entity to be encoded, e.g. as JSON), HttpEntity (part content and headers), a Spring Part, or Reactive Streams Publisher of any of the above.@CookieValue Add a cookie or mutliple cookies.", "chunk_char_count": 740, "chunk_word_count": 107, "chunk_token_count": 185.0}, {"page_number": 1289, "sentence_chunk": "The argument may be a Map<String, ?> or MultiValueMap<String, ?> with multiple cookies, a Collection<?> of values, or an individual value. Type conversion is supported for non-String values. Return Values Annotated, HTTP exchange methods support the following return values: Method return value Description void, Mono<Void> Perform the given request, and release the response content, if any. HttpHeaders, Mono<HttpHeaders> Perform the given request, release the response content, if any, and return the response headers.<T>, Mono<T> Perform the given request and decode the response content to the declared return type.<T>, Flux<T> Perform the given request and decode the response content to a stream of the declared element type. ResponseEntity<Void>, Mono<ResponseEntity<Void>> Perform the given request, and release the response content, if any, and return a ResponseEntity with the status and headers.", "chunk_char_count": 907, "chunk_word_count": 128, "chunk_token_count": 226.75}, {"page_number": 1289, "sentence_chunk": "ResponseEntity<T>, Mono<ResponseEntity<T>> Perform the given request, decode the response content to the declared return type, and return a ResponseEntity with the status, headers, and the decoded body. Mono<ResponseEntity<Flux<T>> Perform the given request, decode the response content to a stream of the declared element type, and return a ResponseEntity with the status, headers, and the decoded response body stream.\uf0eb You can also use any other async or reactive types registered in the ReactiveAdapterRegistry.1289", "chunk_char_count": 519, "chunk_word_count": 72, "chunk_token_count": 129.75}, {"page_number": 1290, "sentence_chunk": "Exception Handling By default, WebClient raises WebClientResponseException for 4xx and 5xx HTTP status codes. To customize this, you can register a response status handler that applies to all responses performed through the client: WebClient webClient = WebClient.builder() \u00a0    .defaultStatusHandler(HttpStatusCode::isError, resp -> ...) \u00a0    .build(); WebClientAdapter clientAdapter = WebClientAdapter.forClient(webClient); HttpServiceProxyFactory factory = HttpServiceProxyFactory \u00a0    .builder(clientAdapter).build(); For more details and options, such as suppressing error status codes, see the Javadoc of defaultStatusHandler in WebClient. Builder.7.2. JMS (Java Message Service) Spring provides a JMS integration framework that simplifies the use of the JMS API in much the same way as Spring\u2019s integration does for the JDBC API. JMS can be roughly divided into two areas of functionality, namely the production and consumption of messages. The JmsTemplate class is used for message production and synchronous message reception. For asynchronous reception similar to Jakarta EE\u2019s message-driven bean style, Spring provides a number of message-listener containers that you can use to create Message-Driven POJOs (MDPs). Spring also provides a declarative way to create message listeners. The org.springframework.jms.core package provides the core functionality for using JMS.", "chunk_char_count": 1381, "chunk_word_count": 188, "chunk_token_count": 345.25}, {"page_number": 1290, "sentence_chunk": "It contains JMS template classes that simplify the use of the JMS by handling the creation and release of resources, much like the JdbcTemplate does for JDBC. The design principle common to Spring template classes is to provide helper methods to perform common operations and, for more sophisticated usage, delegate the essence of the processing task to user-implemented callback interfaces. The JMS template follows the same design. The classes offer various convenience methods for sending messages, consuming messages synchronously, and exposing the JMS session and message producer to the user. The org.springframework.jms.support package provides JMSException translation functionality. The translation converts the checked JMSException hierarchy to a mirrored hierarchy of unchecked exceptions. If any provider-specific subclasses of the checked jakarta.jms. JMSException exist, this exception is wrapped in the unchecked UncategorizedJmsException. The org.springframework.jms.support.converter package provides a MessageConverter abstraction to convert between Java objects and JMS messages. The org.springframework.jms.support.destination package provides various strategies for managing JMS destinations, such as providing a service locator for destinations stored in JNDI.", "chunk_char_count": 1282, "chunk_word_count": 165, "chunk_token_count": 320.5}, {"page_number": 1291, "sentence_chunk": "annotation-driven listener endpoints by using @JmsListener. The org.springframework.jms.config package provides the parser implementation for the jms namespace as well as the java config support to configure listener containers and create listener endpoints. Finally, the org.springframework.jms.connection package provides an implementation of the ConnectionFactory suitable for use in standalone applications. It also contains an implementation of Spring\u2019s PlatformTransactionManager for JMS (the cunningly named JmsTransactionManager). This allows for seamless integration of JMS as a transactional resource into Spring\u2019s transaction management mechanisms.\uf05a As of Spring Framework 5, Spring\u2019s JMS package fully supports JMS 2.0 and requires the JMS 2.0 API to be present at runtime. We recommend the use of a JMS 2.0 compatible provider. If you happen to use an older message broker in your system, you may try upgrading to a JMS 2.0 compatible driver for your existing broker generation. Alternatively, you may also try to run against a JMS 1.1 based driver, simply putting the JMS 2.0 API jar on the classpath but only using JMS 1.1 compatible API against your driver. Spring\u2019s JMS support adheres to JMS 1.1 conventions by default, so with corresponding configuration it does support such a scenario.", "chunk_char_count": 1306, "chunk_word_count": 191, "chunk_token_count": 326.5}, {"page_number": 1291, "sentence_chunk": "However, please consider this for transition scenarios only.7.2.1. Using Spring JMS This section describes how to use Spring\u2019s JMS components. Using JmsTemplate The JmsTemplate class is the central class in the JMS core package. It simplifies the use of JMS, since it handles the creation and release of resources when sending or synchronously receiving messages. Code that uses the JmsTemplate needs only to implement callback interfaces that give them a clearly defined high-level contract. The MessageCreator callback interface creates a message when given a Session provided by the calling code in JmsTemplate. To allow for more complex usage of the JMS API, SessionCallback provides the JMS session, and ProducerCallback exposes a Session and MessageProducer pair. The JMS API exposes two types of send methods, one that takes delivery mode, priority, and time-to- live as Quality of Service (QOS) parameters and one that takes no QOS parameters and uses default values. Since JmsTemplate has many send methods, setting the QOS parameters have been exposed as bean properties to avoid duplication in the number of send methods.", "chunk_char_count": 1132, "chunk_word_count": 175, "chunk_token_count": 283.0}, {"page_number": 1291, "sentence_chunk": "Similarly, the timeout value for synchronous receive calls is set by using the setReceiveTimeout property. Some JMS providers allow the setting of default QOS values administratively through the configuration of the ConnectionFactory. This has the effect that a call to a MessageProducer instance\u2019s send method (send(Destination destination, Message message)) uses different QOS default values 1291", "chunk_char_count": 398, "chunk_word_count": 55, "chunk_token_count": 99.5}, {"page_number": 1292, "sentence_chunk": "than those specified in the JMS specification. In order to provide consistent management of QOS values, the JmsTemplate must, therefore, be specifically enabled to use its own QOS values by setting the boolean property isExplicitQosEnabled to true. For convenience, JmsTemplate also exposes a basic request-reply operation that allows for sending a message and waiting for a reply on a temporary queue that is created as part of the operation.\uf06a Instances of the JmsTemplate class are thread-safe, once configured. This is important, because it means that you can configure a single instance of a JmsTemplate and then safely inject this shared reference into multiple collaborators. To be clear, the JmsTemplate is stateful, in that it maintains a reference to a ConnectionFactory, but this state is not conversational state. As of Spring Framework 4.1, JmsMessagingTemplate is built on top of JmsTemplate and provides an integration with the messaging abstraction\u2009\u2014\u2009that is, org.springframework.messaging. Message. This lets you create the message to send in a generic manner. Connections The JmsTemplate requires a reference to a ConnectionFactory.", "chunk_char_count": 1149, "chunk_word_count": 171, "chunk_token_count": 287.25}, {"page_number": 1292, "sentence_chunk": "The ConnectionFactory is part of the JMS specification and serves as the entry point for working with JMS. It is used by the client application as a factory to create connections with the JMS provider and encapsulates various configuration parameters, many of which are vendor-specific, such as SSL configuration options. When using JMS inside an EJB, the vendor provides implementations of the JMS interfaces so that they can participate in declarative transaction management and perform pooling of connections and sessions. In order to use this implementation, Jakarta EE containers typically require that you declare a JMS connection factory as a resource-ref inside the EJB or servlet deployment descriptors. To ensure the use of these features with the JmsTemplate inside an EJB, the client application should ensure that it references the managed implementation of the ConnectionFactory. Caching Messaging Resources The standard API involves creating many intermediate objects. To send a message, the following 'API' walk is performed: ConnectionFactory->Connection->Session->MessageProducer->send Between the ConnectionFactory and the Send operation, three intermediate objects are created and destroyed. To optimize the resource usage and increase performance, Spring provides two implementations of ConnectionFactory. Using SingleConnectionFactory Spring provides an implementation of the ConnectionFactory interface, SingleConnectionFactory, that returns the same Connection on all createConnection() calls and ignores calls to close(). This is useful for testing and standalone environments so that the same connection can be used for multiple JmsTemplate calls that may span any number of transactions.", "chunk_char_count": 1714, "chunk_word_count": 237, "chunk_token_count": 428.5}, {"page_number": 1293, "sentence_chunk": "Using CachingConnectionFactory The CachingConnectionFactory extends the functionality of SingleConnectionFactory and adds the caching of Session, MessageProducer, and MessageConsumer instances. The initial cache size is set to 1. You can use the sessionCacheSize property to increase the number of cached sessions. Note that the number of actual cached sessions is more than that number, as sessions are cached based on their acknowledgment mode, so there can be up to four cached session instances (one for each acknowledgment mode) when sessionCacheSize is set to one. MessageProducer and MessageConsumer instances are cached within their owning session and also take into account the unique properties of the producers and consumers when caching. MessageProducers are cached based on their destination. MessageConsumers are cached based on a key composed of the destination, selector, noLocal delivery flag, and the durable subscription name (if creating durable consumers).\uf05a MessageProducers and MessageConsumers for temporary queues and topics (TemporaryQueue/TemporaryTopic) will never be cached. Unfortunately, WebLogic JMS happens to implement the temporary queue/topic interfaces on its regular destination implementation, mis-indicating that none of its destinations can be cached. Please use a different connection pool/cache on WebLogic, or customize CachingConnectionFactory for WebLogic purposes.", "chunk_char_count": 1410, "chunk_word_count": 190, "chunk_token_count": 352.5}, {"page_number": 1293, "sentence_chunk": "Destination Management Destinations, as ConnectionFactory instances, are JMS administered objects that you can store and retrieve in JNDI. When configuring a Spring application context, you can use the JNDI JndiObjectFactoryBean factory class or <jee:jndi-lookup> to perform dependency injection on your object\u2019s references to JMS destinations. However, this strategy is often cumbersome if there are a large number of destinations in the application or if there are advanced destination management features unique to the JMS provider. Examples of such advanced destination management include the creation of dynamic destinations or support for a hierarchical namespace of destinations. The JmsTemplate delegates the resolution of a destination name to a JMS destination object that implements the DestinationResolver interface. DynamicDestinationResolver is the default implementation used by JmsTemplate and accommodates resolving dynamic destinations. A JndiDestinationResolver is also provided to act as a service locator for destinations contained in JNDI and optionally falls back to the behavior contained in DynamicDestinationResolver. Quite often, the destinations used in a JMS application are only known at runtime and, therefore, cannot be administratively created when the application is deployed. This is often because there is shared application logic between interacting system components that create destinations at runtime according to a well-known naming convention. Even though the creation of dynamic destinations is not part of the JMS specification, most vendors have provided this functionality.", "chunk_char_count": 1619, "chunk_word_count": 222, "chunk_token_count": 404.75}, {"page_number": 1293, "sentence_chunk": "Dynamic destinations are created with a user-defined name, which differentiates them from temporary destinations, and are often not registered in JNDI. The API used to create dynamic destinations varies from provider to provider since the properties associated with the destination are vendor-specific. However, a simple implementation choice that is sometimes made by vendors is to disregard the warnings in the JMS specification and to use the method TopicSession createTopic(String topicName) or the QueueSession createQueue(String queueName) method to create a new destination with default destination properties. Depending on the vendor implementation, DynamicDestinationResolver can then also create a physical destination instead of only resolving 1293", "chunk_char_count": 759, "chunk_word_count": 103, "chunk_token_count": 189.75}, {"page_number": 1294, "sentence_chunk": "one. The boolean property pubSubDomain is used to configure the JmsTemplate with knowledge of what JMS domain is being used. By default, the value of this property is false, indicating that the point-to- point domain, Queues, is to be used. This property (used by JmsTemplate) determines the behavior of dynamic destination resolution through implementations of the DestinationResolver interface. You can also configure the JmsTemplate with a default destination through the property defaultDestination. The default destination is with send and receive operations that do not refer to a specific destination. Message Listener Containers One of the most common uses of JMS messages in the EJB world is to drive message-driven beans (MDBs). Spring offers a solution to create message-driven POJOs (MDPs) in a way that does not tie a user to an EJB container. (See Asynchronous reception: Message-Driven POJOs for detailed coverage of Spring\u2019s MDP support.)Since Spring Framework 4.1, endpoint methods can be annotated with @JmsListener\u2009\u2014\u2009see Annotation-driven Listener Endpoints for more details.", "chunk_char_count": 1094, "chunk_word_count": 161, "chunk_token_count": 273.5}, {"page_number": 1294, "sentence_chunk": "A message listener container is used to receive messages from a JMS message queue and drive the MessageListener that is injected into it. The listener container is responsible for all threading of message reception and dispatches into the listener for processing. A message listener container is the intermediary between an MDP and a messaging provider and takes care of registering to receive messages, participating in transactions, resource acquisition and release, exception conversion, and so on. This lets you write the (possibly complex) business logic associated with receiving a message (and possibly respond to it), and delegates boilerplate JMS infrastructure concerns to the framework. There are two standard JMS message listener containers packaged with Spring, each with its specialized feature set. \u2022SimpleMessageListenerContainer \u2022 DefaultMessageListenerContainer Using SimpleMessageListenerContainer This message listener container is the simpler of the two standard flavors. It creates a fixed number of JMS sessions and consumers at startup, registers the listener by using the standard JMS MessageConsumer.setMessageListener() method, and leaves it up the JMS provider to perform listener callbacks. This variant does not allow for dynamic adaption to runtime demands or for participation in externally managed transactions. Compatibility-wise, it stays very close to the spirit of the standalone JMS specification, but is generally not compatible with Jakarta EE\u2019s JMS restrictions.1294", "chunk_char_count": 1507, "chunk_word_count": 211, "chunk_token_count": 376.75}, {"page_number": 1295, "sentence_chunk": "\uf05a While SimpleMessageListenerContainer does not allow for participation in externally managed transactions, it does support native JMS transactions. To enable this feature, you can switch the sessionTransacted flag to true or, in the XML namespace, set the acknowledge attribute to transacted. Exceptions thrown from your listener then lead to a rollback, with the message getting redelivered. Alternatively, consider using CLIENT_ACKNOWLEDGE mode, which provides redelivery in case of an exception as well but does not use transacted Session instances and, therefore, does not include any other Session operations (such as sending response messages) in the transaction protocol.\uf06a The default AUTO_ACKNOWLEDGE mode does not provide proper reliability guarantees. Messages can get lost when listener execution fails (since the provider automatically acknowledges each message after listener invocation, with no exceptions to be propagated to the provider) or when the listener container shuts down (you can configure this by setting the acceptMessagesWhileStopping flag). Make sure to use transacted sessions in case of reliability needs (for example, for reliable queue handling and durable topic subscriptions). Using DefaultMessageListenerContainer This message listener container is used in most cases. In contrast to SimpleMessageListenerContainer, this container variant allows for dynamic adaptation to runtime demands and is able to participate in externally managed transactions. Each received message is registered with an XA transaction when configured with a JtaTransactionManager.", "chunk_char_count": 1592, "chunk_word_count": 218, "chunk_token_count": 398.0}, {"page_number": 1295, "sentence_chunk": "As a result, processing may take advantage of XA transaction semantics. This listener container strikes a good balance between low requirements on the JMS provider, advanced functionality (such as participation in externally managed transactions), and compatibility with Jakarta EE environments. You can customize the cache level of the container. Note that, when no caching is enabled, a new connection and a new session is created for each message reception. Combining this with a non- durable subscription with high loads may lead to message loss. Make sure to use a proper cache level in such a case. This container also has recoverable capabilities when the broker goes down. By default, a simple BackOff implementation retries every five seconds. You can specify a custom BackOff implementation for more fine-grained recovery options. See ExponentialBackOff for an example.", "chunk_char_count": 879, "chunk_word_count": 134, "chunk_token_count": 219.75}, {"page_number": 1296, "sentence_chunk": "\uf05a Like its sibling (SimpleMessageListenerContainer), DefaultMessageListenerContainer supports native JMS transactions and allows for customizing the acknowledgment mode. If feasible for your scenario, This is strongly recommended over externally managed transactions\u2009\u2014\u2009that is, if you can live with occasional duplicate messages in case of the JVM dying. Custom duplicate message detection steps in your business logic can cover such situations\u2009\u2014\u2009for example, in the form of a business entity existence check or a protocol table check. Any such arrangements are significantly more efficient than the alternative: wrapping your entire processing with an XA transaction (through configuring your DefaultMessageListenerContainer with an JtaTransactionManager) to cover the reception of the JMS message as well as the execution of the business logic in your message listener (including database operations, etc.).\uf06a The default AUTO_ACKNOWLEDGE mode does not provide proper reliability guarantees. Messages can get lost when listener execution fails (since the provider automatically acknowledges each message after listener invocation, with no exceptions to be propagated to the provider) or when the listener container shuts down (you can configure this by setting the acceptMessagesWhileStopping flag). Make sure to use transacted sessions in case of reliability needs (for example, for reliable queue handling and durable topic subscriptions). Transaction Management Spring provides a JmsTransactionManager that manages transactions for a single JMS ConnectionFactory. This lets JMS applications leverage the managed-transaction features of Spring, as described in Transaction Management section of the Data Access chapter. The JmsTransactionManager performs local resource transactions, binding a JMS Connection/Session pair from the specified ConnectionFactory to the thread.", "chunk_char_count": 1876, "chunk_word_count": 250, "chunk_token_count": 469.0}, {"page_number": 1296, "sentence_chunk": "JmsTemplate automatically detects such transactional resources and operates on them accordingly. In a Jakarta EE environment, the ConnectionFactory pools Connection and Session instances, so those resources are efficiently reused across transactions. In a standalone environment, using Spring\u2019s SingleConnectionFactory result in a shared JMS Connection, with each transaction having its own independent Session. Alternatively, consider the use of a provider-specific pooling adapter, such as ActiveMQ\u2019s PooledConnectionFactory class. You can also use JmsTemplate with the JtaTransactionManager and an XA-capable JMS ConnectionFactory to perform distributed transactions. Note that this requires the use of a JTA transaction manager as well as a properly XA-configured ConnectionFactory. (Check your Jakarta EE server\u2019s or JMS provider\u2019s documentation.)Reusing code across a managed and unmanaged transactional environment can be confusing when using the JMS API to create a Session from a Connection. This is because the JMS API has only one factory method to create a Session, and it requires values for the transaction and acknowledgment modes. In a managed environment, setting these values is the responsibility of the environment\u2019s transactional infrastructure, so these values are ignored by the vendor\u2019s wrapper to the JMS Connection.", "chunk_char_count": 1341, "chunk_word_count": 186, "chunk_token_count": 335.25}, {"page_number": 1296, "sentence_chunk": "When you use the JmsTemplate in an unmanaged environment, you can specify these values through the use of the properties sessionTransacted and sessionAcknowledgeMode. When you 1296", "chunk_char_count": 180, "chunk_word_count": 26, "chunk_token_count": 45.0}, {"page_number": 1297, "sentence_chunk": "use a PlatformTransactionManager with JmsTemplate, the template is always given a transactional JMS Session.7.2.2. Sending a Message The JmsTemplate contains many convenience methods to send a message. Send methods specify the destination by using a jakarta.jms. Destination object, and others specify the destination by using a String in a JNDI lookup. The send method that takes no destination argument uses the default destination. The following example uses the MessageCreator callback to create a text message from the supplied Session object: import jakarta.jms. ConnectionFactory; import jakarta.jms. JMSException; import jakarta.jms. Message; import jakarta.jms.", "chunk_char_count": 670, "chunk_word_count": 91, "chunk_token_count": 167.5}, {"page_number": 1297, "sentence_chunk": "Queue; import jakarta.jms. Session; import org.springframework.jms.core. MessageCreator; import org.springframework.jms.core. JmsTemplate; public class JmsQueueSender { \u00a0  private JmsTemplate jmsTemplate; \u00a0  private Queue queue; \u00a0  public void setConnectionFactory(ConnectionFactory cf) { \u00a0    this.jmsTemplate = new JmsTemplate(cf); \u00a0  } \u00a0  public void setQueue(Queue queue) { \u00a0    this.queue = queue; \u00a0  } \u00a0  public void simpleSend() { \u00a0    this.jmsTemplate.send(this.queue, new MessageCreator() { \u00a0      public Message createMessage(Session session) throws JMSException { \u00a0        return session.createTextMessage(\"hello queue world\"); \u00a0      } \u00a0    }); \u00a0  } } In the preceding example, the JmsTemplate is constructed by passing a reference to a ConnectionFactory. As an alternative, a zero-argument constructor and connectionFactory is provided and can be used for constructing the instance in JavaBean style (using a BeanFactory or plain Java code). Alternatively, consider deriving from Spring\u2019s JmsGatewaySupport convenience base class, which provides pre-built bean properties for JMS configuration.1297", "chunk_char_count": 1111, "chunk_word_count": 174, "chunk_token_count": 277.75}, {"page_number": 1298, "sentence_chunk": "The send(String destinationName, MessageCreator creator) method lets you send a message by using the string name of the destination. If these names are registered in JNDI, you should set the destinationResolver property of the template to an instance of JndiDestinationResolver. If you created the JmsTemplate and specified a default destination, the send(MessageCreator c) sends a message to that destination. Using Message Converters To facilitate the sending of domain model objects, the JmsTemplate has various send methods that take a Java object as an argument for a message\u2019s data content. The overloaded methods convertAndSend() and receiveAndConvert() methods in JmsTemplate delegate the conversion process to an instance of the MessageConverter interface. This interface defines a simple contract to convert between Java objects and JMS messages. The default implementation (SimpleMessageConverter) supports conversion between String and TextMessage, byte[] and BytesMessage, and java.util. Map and MapMessage. By using the converter, you and your application code can focus on the business object that is being sent or received through JMS and not be concerned with the details of how it is represented as a JMS message. The sandbox currently includes a MapMessageConverter, which uses reflection to convert between a JavaBean and a MapMessage.", "chunk_char_count": 1355, "chunk_word_count": 197, "chunk_token_count": 338.75}, {"page_number": 1298, "sentence_chunk": "Other popular implementation choices you might implement yourself are converters that use an existing XML marshalling package (such as JAXB or XStream) to create a TextMessage that represents the object. To accommodate the setting of a message\u2019s properties, headers, and body that can not be generically encapsulated inside a converter class, the MessagePostProcessor interface gives you access to the message after it has been converted but before it is sent. The following example shows how to modify a message header and a property after a java.util. Map is converted to a message: public void sendWithConversion() { \u00a0  Map map = new HashMap(); \u00a0  map.put(\"Name\", \"Mark\"); \u00a0  map.put(\"Age\", new Integer(47)); \u00a0  jmsTemplate.convertAndSend(\"testQueue\", map, new MessagePostProcessor() { \u00a0    public Message postProcessMessage(Message message) throws JMSException { \u00a0      message.setIntProperty(\"AccountID\", 1234); \u00a0      message.setJMSCorrelationID(\"123-00001\"); \u00a0      return message; \u00a0    } \u00a0  }); } This results in a message of the following form: 1298", "chunk_char_count": 1058, "chunk_word_count": 172, "chunk_token_count": 264.5}, {"page_number": 1299, "sentence_chunk": "MapMessage={ \u00a0  Header={ \u00a0    ... standard headers ... \u00a0    CorrelationID={123-00001} \u00a0  } \u00a0  Properties={ \u00a0    AccountID={Integer:1234} \u00a0  } \u00a0  Fields={ \u00a0    Name={String:Mark} \u00a0    Age={Integer:47} \u00a0  } } Using SessionCallback and ProducerCallback While the send operations cover many common usage scenarios, you might sometimes want to perform multiple operations on a JMS Session or MessageProducer. The SessionCallback and ProducerCallback expose the JMS Session and Session / MessageProducer pair, respectively. The execute() methods on JmsTemplate run these callback methods.7.2.3. Receiving a Message This describes how to receive messages with JMS in Spring. Synchronous Reception While JMS is typically associated with asynchronous processing, you can consume messages synchronously. The overloaded receive(..) methods provide this functionality. During a synchronous receive, the calling thread blocks until a message becomes available. This can be a dangerous operation, since the calling thread can potentially be blocked indefinitely. The receiveTimeout property specifies how long the receiver should wait before giving up waiting for a message.", "chunk_char_count": 1160, "chunk_word_count": 178, "chunk_token_count": 290.0}, {"page_number": 1299, "sentence_chunk": "Asynchronous reception: Message-Driven POJOs \uf05a Spring also supports annotated-listener endpoints through the use of the @JmsListener annotation and provides an open infrastructure to register endpoints programmatically. This is, by far, the most convenient way to setup an asynchronous receiver. See Enable Listener Endpoint Annotations for more details. In a fashion similar to a Message-Driven Bean (MDB) in the EJB world, the Message-Driven POJO (MDP) acts as a receiver for JMS messages. The one restriction (but see Using MessageListenerAdapter) on an MDP is that it must implement the jakarta.jms. MessageListener interface. Note that, if your POJO receives messages on multiple threads, it is important to ensure that your implementation is thread-safe.1299", "chunk_char_count": 764, "chunk_word_count": 110, "chunk_token_count": 191.0}, {"page_number": 1300, "sentence_chunk": "The following example shows a simple implementation of an MDP: import jakarta.jms. JMSException; import jakarta.jms. Message; import jakarta.jms. MessageListener; import jakarta.jms. TextMessage; public class ExampleListener implements MessageListener { \u00a0  public void onMessage(Message message) { \u00a0    if (message instanceof TextMessage textMessage) { \u00a0      try { \u00a0        System.out.println(textMessage.getText()); \u00a0      } \u00a0      catch (JMSException ex) { \u00a0        throw new RuntimeException(ex); \u00a0      } \u00a0    } \u00a0    else { \u00a0      throw new IllegalArgumentException(\"Message must be of type TextMessage\"); \u00a0    } \u00a0  } } Once you have implemented your MessageListener, it is time to create a message listener container. The following example shows how to define and configure one of the message listener containers that ships with Spring (in this case, DefaultMessageListenerContainer): <!--this is the Message Driven POJO (MDP) --> <bean id=\"messageListener\" class=\"jmsexample. ExampleListener\"/> <!--and this is the message listener container --> <bean id=\"jmsContainer\" class=\"org.springframework.jms.listener. DefaultMessageListenerContainer\"> \u00a0  <property name=\"connectionFactory\" ref=\"connectionFactory\"/> \u00a0  <property name=\"destination\" ref=\"destination\"/> \u00a0  <property name=\"messageListener\" ref=\"messageListener\"/> </bean> See the Spring javadoc of the various message listener containers (all of which implement MessageListenerContainer) for a full description of the features supported by each implementation.", "chunk_char_count": 1524, "chunk_word_count": 235, "chunk_token_count": 381.0}, {"page_number": 1300, "sentence_chunk": "Using the SessionAwareMessageListener Interface The SessionAwareMessageListener interface is a Spring-specific interface that provides a similar contract to the JMS MessageListener interface but also gives the message-handling method access to the JMS Session from which the Message was received. The following listing shows the definition of 1300", "chunk_char_count": 347, "chunk_word_count": 46, "chunk_token_count": 86.75}, {"page_number": 1301, "sentence_chunk": "the SessionAwareMessageListener interface: package org.springframework.jms.listener; public interface SessionAwareMessageListener { \u00a0  void onMessage(Message message, Session session) throws JMSException; } You can choose to have your MDPs implement this interface (in preference to the standard JMS MessageListener interface) if you want your MDPs to be able to respond to any received messages (by using the Session supplied in the onMessage(Message, Session) method). All of the message listener container implementations that ship with Spring have support for MDPs that implement either the MessageListener or SessionAwareMessageListener interface. Classes that implement the SessionAwareMessageListener come with the caveat that they are then tied to Spring through the interface. The choice of whether or not to use it is left entirely up to you as an application developer or architect. Note that the onMessage(..) method of the SessionAwareMessageListener interface throws JMSException. In contrast to the standard JMS MessageListener interface, when using the SessionAwareMessageListener interface, it is the responsibility of the client code to handle any thrown exceptions. Using MessageListenerAdapter The MessageListenerAdapter class is the final component in Spring\u2019s asynchronous messaging support. In a nutshell, it lets you expose almost any class as an MDP (though there are some constraints). Consider the following interface definition: public interface MessageDelegate { \u00a0  void handleMessage(String message); \u00a0  void handleMessage(Map message); \u00a0  void handleMessage(byte[] message); \u00a0  void handleMessage(Serializable message); } Notice that, although the interface extends neither the MessageListener nor the SessionAwareMessageListener interface, you can still use it as an MDP by using the MessageListenerAdapter class. Notice also how the various message handling methods are strongly typed according to the contents of the various Message types that they can receive and handle.", "chunk_char_count": 2006, "chunk_word_count": 275, "chunk_token_count": 501.5}, {"page_number": 1302, "sentence_chunk": "public class DefaultMessageDelegate implements MessageDelegate { \u00a0  // implementation elided for clarity... } In particular, note how the preceding implementation of the MessageDelegate interface (the DefaultMessageDelegate class) has no JMS dependencies at all. It truly is a POJO that we can make into an MDP through the following configuration: <!--this is the Message Driven POJO (MDP) --> <bean id=\"messageListener\" class=\"org.springframework.jms.listener.adapter. MessageListenerAdapter\"> \u00a0  <constructor-arg> \u00a0    <bean class=\"jmsexample. DefaultMessageDelegate\"/> \u00a0  </constructor-arg> </bean> <!--and this is the message listener container... --> <bean id=\"jmsContainer\" class=\"org.springframework.jms.listener. DefaultMessageListenerContainer\"> \u00a0  <property name=\"connectionFactory\" ref=\"connectionFactory\"/> \u00a0  <property name=\"destination\" ref=\"destination\"/> \u00a0  <property name=\"messageListener\" ref=\"messageListener\"/> </bean> The next example shows another MDP that can handle only receiving JMS TextMessage messages. Notice how the message handling method is actually called receive (the name of the message handling method in a MessageListenerAdapter defaults to handleMessage), but it is configurable (as you can see later in this section). Notice also how the receive(..) method is strongly typed to receive and respond only to JMS TextMessage messages. The following listing shows the definition of the TextMessageDelegate interface: public interface TextMessageDelegate { \u00a0  void receive(TextMessage message); } The following listing shows a class that implements the TextMessageDelegate interface: public class DefaultTextMessageDelegate implements TextMessageDelegate { \u00a0  // implementation elided for clarity... } The configuration of the attendant MessageListenerAdapter would then be as follows: 1302", "chunk_char_count": 1824, "chunk_word_count": 228, "chunk_token_count": 456.0}, {"page_number": 1303, "sentence_chunk": "<bean id=\"messageListener\" class=\"org.springframework.jms.listener.adapter. MessageListenerAdapter\"> \u00a0  <constructor-arg> \u00a0    <bean class=\"jmsexample. DefaultTextMessageDelegate\"/> \u00a0  </constructor-arg> \u00a0  <property name=\"defaultListenerMethod\" value=\"receive\"/> \u00a0  <!--we don't want automatic message context extraction --> \u00a0  <property name=\"messageConverter\"> \u00a0    <null/> \u00a0  </property> </bean> Note that, if the messageListener receives a JMS Message of a type other than TextMessage, an IllegalStateException is thrown (and subsequently swallowed). Another of the capabilities of the MessageListenerAdapter class is the ability to automatically send back a response Message if a handler method returns a non-void value. Consider the following interface and class: public interface ResponsiveTextMessageDelegate { \u00a0  // notice the return type... \u00a0  String receive(TextMessage message); } public class DefaultResponsiveTextMessageDelegate implements ResponsiveTextMessageDelegate { \u00a0  // implementation elided for clarity... } If you use the DefaultResponsiveTextMessageDelegate in conjunction with a MessageListenerAdapter, any non-null value that is returned from the execution of the 'receive(..)' method is (in the default configuration) converted into a TextMessage. The resulting TextMessage is then sent to the Destination (if one exists) defined in the JMS Reply-To property of the original Message or the default Destination set on the MessageListenerAdapter (if one has been configured). If no Destination is found, an InvalidDestinationException is thrown (note that this exception is not swallowed and propagates up the call stack). Processing Messages Within Transactions Invoking a message listener within a transaction requires only reconfiguration of the listener container. You can activate local resource transactions through the sessionTransacted flag on the listener container definition.", "chunk_char_count": 1913, "chunk_word_count": 252, "chunk_token_count": 478.25}, {"page_number": 1303, "sentence_chunk": "Each message listener invocation then operates within an active JMS transaction, with message reception rolled back in case of listener execution failure. Sending a response message (through SessionAwareMessageListener) is part of the same local transaction, but any other resource operations (such as database access) operate independently. This usually 1303", "chunk_char_count": 359, "chunk_word_count": 49, "chunk_token_count": 89.75}, {"page_number": 1304, "sentence_chunk": "requires duplicate message detection in the listener implementation, to cover the case where database processing has committed but message processing failed to commit. Consider the following bean definition: <bean id=\"jmsContainer\" class=\"org.springframework.jms.listener. DefaultMessageListenerContainer\"> \u00a0  <property name=\"connectionFactory\" ref=\"connectionFactory\"/> \u00a0  <property name=\"destination\" ref=\"destination\"/> \u00a0  <property name=\"messageListener\" ref=\"messageListener\"/> \u00a0  <property name=\"sessionTransacted\" value=\"true\"/> </bean> To participate in an externally managed transaction, you need to configure a transaction manager and use a listener container that supports externally managed transactions (typically, DefaultMessageListenerContainer). To configure a message listener container for XA transaction participation, you want to configure a JtaTransactionManager (which, by default, delegates to the Jakarta EE server\u2019s transaction subsystem). Note that the underlying JMS ConnectionFactory needs to be XA-capable and properly registered with your JTA transaction coordinator. (Check your Jakarta EE server\u2019s configuration of JNDI resources.)This lets message reception as well as (for example) database access be part of the same transaction (with unified commit semantics, at the expense of XA transaction log overhead). The following bean definition creates a transaction manager: <bean id=\"transactionManager\" class=\"org.springframework.transaction.jta. JtaTransactionManager\"/> Then we need to add it to our earlier container configuration. The container takes care of the rest.", "chunk_char_count": 1604, "chunk_word_count": 191, "chunk_token_count": 401.0}, {"page_number": 1304, "sentence_chunk": "The following example shows how to do so: <bean id=\"jmsContainer\" class=\"org.springframework.jms.listener. DefaultMessageListenerContainer\"> \u00a0  <property name=\"connectionFactory\" ref=\"connectionFactory\"/> \u00a0  <property name=\"destination\" ref=\"destination\"/> \u00a0  <property name=\"messageListener\" ref=\"messageListener\"/> \u00a0  <property name=\"transactionManager\" ref=\"transactionManager\"/> \u2460 </bean> \u2460 Our transaction manager.7.2.4. Support for JCA Message Endpoints Beginning with version 2.5, Spring also provides support for a JCA-based MessageListener container. The JmsMessageEndpointManager tries to automatically determine the ActivationSpec class name from the provider\u2019s ResourceAdapter class name. Therefore, it is typically possible to provide Spring\u2019s 1304", "chunk_char_count": 761, "chunk_word_count": 81, "chunk_token_count": 190.25}, {"page_number": 1305, "sentence_chunk": "generic JmsActivationSpecConfig, as the following example shows: <bean class=\"org.springframework.jms.listener.endpoint. JmsMessageEndpointManager\"> \u00a0  <property name=\"resourceAdapter\" ref=\"resourceAdapter\"/> \u00a0  <property name=\"activationSpecConfig\"> \u00a0    <bean class=\"org.springframework.jms.listener.endpoint. JmsActivationSpecConfig\"> \u00a0      <property name=\"destinationName\" value=\"myQueue\"/> \u00a0    </bean> \u00a0  </property> \u00a0  <property name=\"messageListener\" ref=\"myMessageListener\"/> </bean> Alternatively, you can set up a JmsMessageEndpointManager with a given ActivationSpec object. The ActivationSpec object may also come from a JNDI lookup (using <jee:jndi-lookup>). The following example shows how to do so: <bean class=\"org.springframework.jms.listener.endpoint. JmsMessageEndpointManager\"> \u00a0  <property name=\"resourceAdapter\" ref=\"resourceAdapter\"/> \u00a0  <property name=\"activationSpec\"> \u00a0    <bean class=\"org.apache.activemq.ra. ActiveMQActivationSpec\"> \u00a0      <property name=\"destination\" value=\"myQueue\"/> \u00a0      <property name=\"destinationType\" value=\"jakarta.jms. Queue\"/> \u00a0    </bean> \u00a0  </property> \u00a0  <property name=\"messageListener\" ref=\"myMessageListener\"/> </bean> Using Spring\u2019s ResourceAdapterFactoryBean, you can configure the target ResourceAdapter locally, as the following example shows: <bean id=\"resourceAdapter\" class=\"org.springframework.jca.support. ResourceAdapterFactoryBean\"> \u00a0  <property name=\"resourceAdapter\"> \u00a0    <bean class=\"org.apache.activemq.ra. ActiveMQResourceAdapter\"> \u00a0      <property name=\"serverUrl\" value=\"tcp://localhost:61616\"/> \u00a0    </bean> \u00a0  </property> \u00a0  <property name=\"workManager\"> \u00a0    <bean class=\"org.springframework.jca.work.", "chunk_char_count": 1688, "chunk_word_count": 190, "chunk_token_count": 422.0}, {"page_number": 1305, "sentence_chunk": "SimpleTaskWorkManager\"/> \u00a0  </property> </bean> The specified WorkManager can also point to an environment-specific thread pool\u2009\u2014\u2009typically through a SimpleTaskWorkManager instance\u2019s asyncTaskExecutor property. Consider defining a shared thread pool for all your ResourceAdapter instances if you happen to use multiple adapters.1305", "chunk_char_count": 332, "chunk_word_count": 40, "chunk_token_count": 83.0}, {"page_number": 1306, "sentence_chunk": "In some environments (such as WebLogic 9 or above), you can instead obtain the entire ResourceAdapter object from JNDI (by using <jee:jndi-lookup>). The Spring-based message listeners can then interact with the server-hosted ResourceAdapter, which also use the server\u2019s built-in WorkManager. See the javadoc for JmsMessageEndpointManager, JmsActivationSpecConfig, and ResourceAdapterFactoryBean for more details. Spring also provides a generic JCA message endpoint manager that is not tied to JMS: org.springframework.jca.endpoint. GenericMessageEndpointManager. This component allows for using any message listener type (such as a JMS MessageListener) and any provider-specific ActivationSpec object. See your JCA provider\u2019s documentation to find out about the actual capabilities of your connector, and see the GenericMessageEndpointManager javadoc for the Spring-specific configuration details.\uf05a JCA-based message endpoint management is very analogous to EJB 2.1 Message- Driven Beans. It uses the same underlying resource provider contract. As with EJB 2.1 MDBs, you can use any message listener interface supported by your JCA provider in the Spring context as well.", "chunk_char_count": 1171, "chunk_word_count": 156, "chunk_token_count": 292.75}, {"page_number": 1306, "sentence_chunk": "Spring nevertheless provides explicit \u201cconvenience\u201d support for JMS, because JMS is the most common endpoint API used with the JCA endpoint management contract.7.2.5. Annotation-driven Listener Endpoints The easiest way to receive a message asynchronously is to use the annotated listener endpoint infrastructure. In a nutshell, it lets you expose a method of a managed bean as a JMS listener endpoint. The following example shows how to use it: @Component public class MyService { \u00a0  @JmsListener(destination = \"myDestination\") \u00a0  public void processOrder(String data) { ... } } The idea of the preceding example is that, whenever a message is available on the jakarta.jms. Destination myDestination, the processOrder method is invoked accordingly (in this case, with the content of the JMS message, similar to what the MessageListenerAdapter provides). The annotated endpoint infrastructure creates a message listener container behind the scenes for each annotated method, by using a JmsListenerContainerFactory. Such a container is not registered against the application context but can be easily located for management purposes by using the JmsListenerEndpointRegistry bean.\uf0eb @JmsListener is a repeatable annotation on Java 8, so you can associate several JMS destinations with the same method by adding additional @JmsListener declarations to it.1306", "chunk_char_count": 1355, "chunk_word_count": 197, "chunk_token_count": 338.75}, {"page_number": 1307, "sentence_chunk": "Enable Listener Endpoint Annotations To enable support for @JmsListener annotations, you can add @EnableJms to one of your @Configuration classes, as the following example shows: @Configuration @EnableJms public class AppConfig { \u00a0  @Bean \u00a0  public DefaultJmsListenerContainerFactory jmsListenerContainerFactory() { \u00a0    DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory(); \u00a0    factory.setConnectionFactory(connectionFactory()); \u00a0    factory.setDestinationResolver(destinationResolver()); \u00a0    factory.setSessionTransacted(true); \u00a0    factory.setConcurrency(\"3-10\"); \u00a0    return factory; \u00a0  } } By default, the infrastructure looks for a bean named jmsListenerContainerFactory as the source for the factory to use to create message listener containers. In this case (and ignoring the JMS infrastructure setup), you can invoke the processOrder method with a core poll size of three threads and a maximum pool size of ten threads. You can customize the listener container factory to use for each annotation or you can configure an explicit default by implementing the JmsListenerConfigurer interface. The default is required only if at least one endpoint is registered without a specific container factory. See the javadoc of classes that implement JmsListenerConfigurer for details and examples. If you prefer XML configuration, you can use the <jms:annotation-driven> element, as the following example shows: <jms:annotation-driven/> <bean id=\"jmsListenerContainerFactory\" \u00a0    class=\"org.springframework.jms.config. DefaultJmsListenerContainerFactory\"> \u00a0  <property name=\"connectionFactory\" ref=\"connectionFactory\"/> \u00a0  <property name=\"destinationResolver\" ref=\"destinationResolver\"/> \u00a0  <property name=\"sessionTransacted\" value=\"true\"/> \u00a0  <property name=\"concurrency\" value=\"3-10\"/> </bean> Programmatic Endpoint Registration JmsListenerEndpoint provides a model of a JMS endpoint and is responsible for configuring the container for that model. The infrastructure lets you programmatically configure endpoints in 1307", "chunk_char_count": 2056, "chunk_word_count": 262, "chunk_token_count": 514.0}, {"page_number": 1308, "sentence_chunk": "addition to the ones that are detected by the JmsListener annotation. The following example shows how to do so: @Configuration @EnableJms public class AppConfig implements JmsListenerConfigurer { \u00a0  @Override \u00a0  public void configureJmsListeners(JmsListenerEndpointRegistrar registrar) { \u00a0    SimpleJmsListenerEndpoint endpoint = new SimpleJmsListenerEndpoint(); \u00a0    endpoint.setId(\"myJmsEndpoint\"); \u00a0    endpoint.setDestination(\"anotherQueue\"); \u00a0    endpoint.setMessageListener(message -> { \u00a0      // processing \u00a0    }); \u00a0    registrar.registerEndpoint(endpoint); \u00a0  } } In the preceding example, we used SimpleJmsListenerEndpoint, which provides the actual MessageListener to invoke. However, you could also build your own endpoint variant to describe a custom invocation mechanism. Note that you could skip the use of @JmsListener altogether and programmatically register only your endpoints through JmsListenerConfigurer. Annotated Endpoint Method Signature So far, we have been injecting a simple String in our endpoint, but it can actually have a very flexible method signature. In the following example, we rewrite it to inject the Order with a custom header: @Component public class MyService { \u00a0  @JmsListener(destination = \"myDestination\") \u00a0  public void processOrder(Order order, @Header(\"order_type\") String orderType) { \u00a0    ... \u00a0  } } The main elements you can inject in JMS listener endpoints are as follows: \u2022 The raw jakarta.jms. Message or any of its subclasses (provided that it matches the incoming message type). \u2022The jakarta.jms. Session for optional access to the native JMS API (for example, for sending a custom reply).1308", "chunk_char_count": 1649, "chunk_word_count": 251, "chunk_token_count": 412.25}, {"page_number": 1309, "sentence_chunk": "\u2022 The org.springframework.messaging. Message that represents the incoming JMS message. Note that this message holds both the custom and the standard headers (as defined by JmsHeaders). \u2022@Header-annotated method arguments to extract a specific header value, including standard JMS headers. \u2022A @Headers-annotated argument that must also be assignable to java.util. Map for getting access to all headers. \u2022A non-annotated element that is not one of the supported types (Message or Session) is considered to be the payload. You can make that explicit by annotating the parameter with @Payload. You can also turn on validation by adding an extra @Valid. The ability to inject Spring\u2019s Message abstraction is particularly useful to benefit from all the information stored in the transport-specific message without relying on transport-specific API.", "chunk_char_count": 842, "chunk_word_count": 124, "chunk_token_count": 210.5}, {"page_number": 1309, "sentence_chunk": "The following example shows how to do so: @JmsListener(destination = \"myDestination\") public void processOrder(Message<Order> order) { ... } Handling of method arguments is provided by DefaultMessageHandlerMethodFactory, which you can further customize to support additional method arguments. You can customize the conversion and validation support there as well. For instance, if we want to make sure our Order is valid before processing it, we can annotate the payload with @Valid and configure the necessary validator, as the following example shows: @Configuration @EnableJms public class AppConfig implements JmsListenerConfigurer { \u00a0  @Override \u00a0  public void configureJmsListeners(JmsListenerEndpointRegistrar registrar) { \u00a0    registrar.setMessageHandlerMethodFactory(myJmsHandlerMethodFactory()); \u00a0  } \u00a0  @Bean \u00a0  public DefaultMessageHandlerMethodFactory myHandlerMethodFactory() { \u00a0    DefaultMessageHandlerMethodFactory factory = new DefaultMessageHandlerMethodFactory(); \u00a0    factory.setValidator(myValidator()); \u00a0    return factory; \u00a0  } } Response Management The existing support in MessageListenerAdapter already lets your method have a non-void return type. When that is the case, the result of the invocation is encapsulated in a jakarta.jms. Message, 1309", "chunk_char_count": 1274, "chunk_word_count": 171, "chunk_token_count": 318.5}, {"page_number": 1310, "sentence_chunk": "sent either in the destination specified in the JMSReplyTo header of the original message or in the default destination configured on the listener. You can now set that default destination by using the @SendTo annotation of the messaging abstraction. Assuming that our processOrder method should now return an OrderStatus, we can write it to automatically send a response, as the following example shows: @JmsListener(destination = \"myDestination\") @SendTo(\"status\") public OrderStatus processOrder(Order order) { \u00a0  // order processing \u00a0  return status; } \uf0eb If you have several @JmsListener-annotated methods, you can also place the @SendTo annotation at the class level to share a default reply destination. If you need to set additional headers in a transport-independent manner, you can return a Message instead, with a method similar to the following: @JmsListener(destination = \"myDestination\") @SendTo(\"status\") public Message<OrderStatus> processOrder(Order order) { \u00a0  // order processing \u00a0  return MessageBuilder \u00a0      .withPayload(status) \u00a0      .setHeader(\"code\", 1234) \u00a0      .build(); } If you need to compute the response destination at runtime, you can encapsulate your response in a JmsResponse instance that also provides the destination to use at runtime. We can rewrite the previous example as follows: @JmsListener(destination = \"myDestination\") public JmsResponse<Message<OrderStatus>> processOrder(Order order) { \u00a0  // order processing \u00a0  Message<OrderStatus> response = MessageBuilder \u00a0      .withPayload(status) \u00a0      .setHeader(\"code\", 1234) \u00a0      .build(); \u00a0  return JmsResponse.forQueue(response, \"status\"); } Finally, if you need to specify some QoS values for the response such as the priority or the time to live, you can configure the JmsListenerContainerFactory accordingly, as the following example 1310", "chunk_char_count": 1840, "chunk_word_count": 286, "chunk_token_count": 460.0}, {"page_number": 1311, "sentence_chunk": "shows: @Configuration @EnableJms public class AppConfig { \u00a0  @Bean \u00a0  public DefaultJmsListenerContainerFactory jmsListenerContainerFactory() { \u00a0    DefaultJmsListenerContainerFactory factory = new DefaultJmsListenerContainerFactory(); \u00a0    factory.setConnectionFactory(connectionFactory()); \u00a0    QosSettings replyQosSettings = new QosSettings(); \u00a0    replyQosSettings.setPriority(2); \u00a0    replyQosSettings.setTimeToLive(10000); \u00a0    factory.setReplyQosSettings(replyQosSettings); \u00a0    return factory; \u00a0  } } 7.2.6. JMS Namespace Support Spring provides an XML namespace for simplifying JMS configuration. To use the JMS namespace elements, you need to reference the JMS schema, as the following example shows: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0    xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0    xmlns:jms=\"http://www.springframework.org/schema/jms\" \u2460 \u00a0    xsi:schemaLocation=\" \u00a0      http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0      http://www.springframework.org/schema/jms https://www.springframework.org/schema/jms/spring-jms.xsd\"> \u00a0  <!--bean definitions here --> </beans> \u2460 Referencing the JMS schema. The namespace consists of three top-level elements: <annotation-driven/>, <listener-container/> and <jca-listener-container/>.<annotation-driven/> enables the use of annotation-driven listener endpoints.<listener-container/> and <jca-listener-container/> define shared listener container configuration and can contain <listener/> child elements. The following example shows a basic configuration for two listeners: 1311", "chunk_char_count": 1668, "chunk_word_count": 186, "chunk_token_count": 417.0}, {"page_number": 1312, "sentence_chunk": "<jms:listener-container> \u00a0  <jms:listener destination=\"queue.orders\" ref=\"orderService\" method=\"placeOrder\"/> \u00a0  <jms:listener destination=\"queue.confirmations\" ref=\"confirmationLogger\" method=\"log\"/> </jms:listener-container> The preceding example is equivalent to creating two distinct listener container bean definitions and two distinct MessageListenerAdapter bean definitions, as shown in Using MessageListenerAdapter. In addition to the attributes shown in the preceding example, the listener element can contain several optional ones. The following table describes all of the available attributes: Table 29. Attributes of the JMS <listener> element Attribute Description id A bean name for the hosting listener container. If not specified, a bean name is automatically generated.destination (required) The destination name for this listener, resolved through the DestinationResolver strategy.ref (required) The bean name of the handler object.method The name of the handler method to invoke. If the ref attribute points to a MessageListener or Spring SessionAwareMessageListener, you can omit this attribute.response- destination The name of the default response destination to which to send response messages.", "chunk_char_count": 1217, "chunk_word_count": 151, "chunk_token_count": 304.25}, {"page_number": 1312, "sentence_chunk": "This is applied in case of a request message that does not carry a JMSReplyTo field. The type of this destination is determined by the listener-container\u2019s response- destination-type attribute. Note that this applies only to a listener method with a return value, for which each result object is converted into a response message.subscription The name of the durable subscription, if any.selector An optional message selector for this listener.concurrency The number of concurrent sessions or consumers to start for this listener. This value can either be a simple number indicating the maximum number (for example, 5) or a range indicating the lower as well as the upper limit (for example, 3-5). Note that a specified minimum is only a hint and might be ignored at runtime. The default is the value provided by the container. The <listener-container/> element also accepts several optional attributes.", "chunk_char_count": 903, "chunk_word_count": 142, "chunk_token_count": 225.75}, {"page_number": 1312, "sentence_chunk": "This allows for customization of the various strategies (for example, taskExecutor and destinationResolver) as well as basic JMS settings and resource references. By using these attributes, you can define highly- customized listener containers while still benefiting from the convenience of the namespace. You can automatically expose such settings as a JmsListenerContainerFactory by specifying the id of 1312", "chunk_char_count": 410, "chunk_word_count": 57, "chunk_token_count": 102.5}, {"page_number": 1313, "sentence_chunk": "the bean to expose through the factory-id attribute, as the following example shows: <jms:listener-container connection-factory=\"myConnectionFactory\" \u00a0    task-executor=\"myTaskExecutor\" \u00a0    destination-resolver=\"myDestinationResolver\" \u00a0    transaction-manager=\"myTransactionManager\" \u00a0    concurrency=\"10\"> \u00a0  <jms:listener destination=\"queue.orders\" ref=\"orderService\" method=\"placeOrder\"/> \u00a0  <jms:listener destination=\"queue.confirmations\" ref=\"confirmationLogger\" method=\"log\"/> </jms:listener-container> The following table describes all available attributes. See the class-level javadoc of the AbstractMessageListenerContainer and its concrete subclasses for more details on the individual properties. The javadoc also provides a discussion of transaction choices and message redelivery scenarios. Table 30. Attributes of the JMS <listener-container> element Attribute Description container- type The type of this listener container. The available options are default, simple, default102, or simple102 (the default option is default).container- class A custom listener container implementation class as a fully qualified class name. The default is Spring\u2019s standard DefaultMessageListenerContainer or SimpleMessageListenerContainer, according to the container-type attribute.factory-id Exposes the settings defined by this element as a JmsListenerContainerFactory with the specified id so that they can be reused with other endpoints.connection- factory A reference to the JMS ConnectionFactory bean (the default bean name is connectionFactory).", "chunk_char_count": 1551, "chunk_word_count": 181, "chunk_token_count": 387.75}, {"page_number": 1313, "sentence_chunk": "task- executor A reference to the Spring TaskExecutor for the JMS listener invokers.destination- resolver A reference to the DestinationResolver strategy for resolving JMS Destination instances.message- converter A reference to the MessageConverter strategy for converting JMS Messages to listener method arguments. The default is a SimpleMessageConverter.error- handler A reference to an ErrorHandler strategy for handling any uncaught exceptions that may occur during the execution of the MessageListener.destination- type The JMS destination type for this listener: queue, topic, durableTopic, sharedTopic, or sharedDurableTopic. This potentially enables the pubSubDomain, subscriptionDurable and subscriptionShared properties of the container. The default is queue (which disables those three properties).1313", "chunk_char_count": 813, "chunk_word_count": 101, "chunk_token_count": 203.25}, {"page_number": 1314, "sentence_chunk": "Attribute Description response- destination- type The JMS destination type for responses: queue or topic. The default is the value of the destination-type attribute.client-id The JMS client ID for this listener container. You must specify it when you use durable subscriptions.cache The cache level for JMS resources: none, connection, session, consumer, or auto. By default (auto), the cache level is effectively consumer, unless an external transaction manager has been specified\u2009\u2014\u2009in which case, the effective default will be none (assuming Jakarta EE-style transaction management, where the given ConnectionFactory is an XA-aware pool).acknowledge The native JMS acknowledge mode: auto, client, dups-ok, or transacted. A value of transacted activates a locally transacted Session. As an alternative, you can specify the transaction-manager attribute, described later in table. The default is auto.", "chunk_char_count": 901, "chunk_word_count": 126, "chunk_token_count": 225.25}, {"page_number": 1314, "sentence_chunk": "transaction- manager A reference to an external PlatformTransactionManager (typically an XA-based transaction coordinator, such as Spring\u2019s JtaTransactionManager). If not specified, native acknowledging is used (see the acknowledge attribute).concurrency The number of concurrent sessions or consumers to start for each listener. It can either be a simple number indicating the maximum number (for example, 5) or a range indicating the lower as well as the upper limit (for example, 3-5). Note that a specified minimum is just a hint and might be ignored at runtime. The default is 1. You should keep concurrency limited to 1 in case of a topic listener or if queue ordering is important. Consider raising it for general queues.prefetch The maximum number of messages to load into a single session. Note that raising this number might lead to starvation of concurrent consumers.", "chunk_char_count": 878, "chunk_word_count": 136, "chunk_token_count": 219.5}, {"page_number": 1314, "sentence_chunk": "receive- timeout The timeout (in milliseconds) to use for receive calls. The default is 1000 (one second).-1 indicates no timeout.back-off Specifies the BackOff instance to use to compute the interval between recovery attempts. If the BackOffExecution implementation returns BackOffExecution#STOP, the listener container does not further try to recover. The recovery-interval value is ignored when this property is set. The default is a FixedBackOff with an interval of 5000 milliseconds (that is, five seconds).recovery- interval Specifies the interval between recovery attempts, in milliseconds. It offers a convenient way to create a FixedBackOff with the specified interval. For more recovery options, consider specifying a BackOff instance instead.", "chunk_char_count": 753, "chunk_word_count": 105, "chunk_token_count": 188.25}, {"page_number": 1314, "sentence_chunk": "The default is 5000 milliseconds (that is, five seconds).phase The lifecycle phase within which this container should start and stop. The lower the value, the earlier this container starts and the later it stops. The default is Integer. MAX_VALUE, meaning that the container starts as late as possible and stops as soon as possible. Configuring a JCA-based listener container with the jms schema support is very similar, as the following example shows: 1314", "chunk_char_count": 457, "chunk_word_count": 73, "chunk_token_count": 114.25}, {"page_number": 1315, "sentence_chunk": "<jms:jca-listener-container resource-adapter=\"myResourceAdapter\" \u00a0    destination-resolver=\"myDestinationResolver\" \u00a0    transaction-manager=\"myTransactionManager\" \u00a0    concurrency=\"10\"> \u00a0  <jms:listener destination=\"queue.orders\" ref=\"myMessageListener\"/> </jms:jca-listener-container> The following table describes the available configuration options for the JCA variant: Table 31. Attributes of the JMS <jca-listener-container/> element Attribute Description factory-id Exposes the settings defined by this element as a JmsListenerContainerFactory with the specified id so that they can be reused with other endpoints.resource- adapter A reference to the JCA ResourceAdapter bean (the default bean name is resourceAdapter).activation- spec-factory A reference to the JmsActivationSpecFactory. The default is to autodetect the JMS provider and its ActivationSpec class (see DefaultJmsActivationSpecFactory).destination- resolver A reference to the DestinationResolver strategy for resolving JMS Destinations.message- converter A reference to the MessageConverter strategy for converting JMS Messages to listener method arguments. The default is SimpleMessageConverter.destination- type The JMS destination type for this listener: queue, topic, durableTopic, sharedTopic.or sharedDurableTopic.", "chunk_char_count": 1293, "chunk_word_count": 146, "chunk_token_count": 323.25}, {"page_number": 1315, "sentence_chunk": "This potentially enables the pubSubDomain, subscriptionDurable, and subscriptionShared properties of the container. The default is queue (which disables those three properties).response- destination- type The JMS destination type for responses: queue or topic. The default is the value of the destination-type attribute.client-id The JMS client ID for this listener container. It needs to be specified when using durable subscriptions.acknowledge The native JMS acknowledge mode: auto, client, dups-ok, or transacted. A value of transacted activates a locally transacted Session. As an alternative, you can specify the transaction-manager attribute described later. The default is auto.", "chunk_char_count": 686, "chunk_word_count": 92, "chunk_token_count": 171.5}, {"page_number": 1315, "sentence_chunk": "transaction- manager A reference to a Spring JtaTransactionManager or a jakarta.transaction. TransactionManager for kicking off an XA transaction for each incoming message. If not specified, native acknowledging is used (see the acknowledge attribute).1315", "chunk_char_count": 256, "chunk_word_count": 33, "chunk_token_count": 64.0}, {"page_number": 1316, "sentence_chunk": "Attribute Description concurrency The number of concurrent sessions or consumers to start for each listener. It can either be a simple number indicating the maximum number (for example 5) or a range indicating the lower as well as the upper limit (for example, 3-5). Note that a specified minimum is only a hint and is typically ignored at runtime when you use a JCA listener container. The default is 1.prefetch The maximum number of messages to load into a single session. Note that raising this number might lead to starvation of concurrent consumers.7.3. JMX The JMX (Java Management Extensions) support in Spring provides features that let you easily and transparently integrate your Spring application into a JMX infrastructure. JMX?This chapter is not an introduction to JMX.", "chunk_char_count": 782, "chunk_word_count": 126, "chunk_token_count": 195.5}, {"page_number": 1316, "sentence_chunk": "It does not try to explain why you might want to use JMX. If you are new to JMX, see Further Resources at the end of this chapter. Specifically, Spring\u2019s JMX support provides four core features: \u2022 The automatic registration of any Spring bean as a JMX MBean. \u2022A flexible mechanism for controlling the management interface of your beans. \u2022The declarative exposure of MBeans over remote, JSR-160 connectors. \u2022The simple proxying of both local and remote MBean resources. These features are designed to work without coupling your application components to either Spring or JMX interfaces and classes. Indeed, for the most part, your application classes need not be aware of either Spring or JMX in order to take advantage of the Spring JMX features.7.3.1. Exporting Your Beans to JMX The core class in Spring\u2019s JMX framework is the MBeanExporter.", "chunk_char_count": 843, "chunk_word_count": 139, "chunk_token_count": 210.75}, {"page_number": 1316, "sentence_chunk": "This class is responsible for taking your Spring beans and registering them with a JMX MBeanServer. For example, consider the following class: 1316", "chunk_char_count": 147, "chunk_word_count": 23, "chunk_token_count": 36.75}, {"page_number": 1317, "sentence_chunk": "package org.springframework.jmx; public class JmxTestBean implements IJmxTestBean { \u00a0  private String name; \u00a0  private int age; \u00a0  private boolean isSuperman; \u00a0  public int getAge() { \u00a0    return age; \u00a0  } \u00a0  public void setAge(int age) { \u00a0    this.age = age; \u00a0  } \u00a0  public void setName(String name) { \u00a0    this.name = name; \u00a0  } \u00a0  public String getName() { \u00a0    return name; \u00a0  } \u00a0  public int add(int x, int y) { \u00a0    return x + y; \u00a0  } \u00a0  public void dontExposeMe() { \u00a0    throw new RuntimeException(); \u00a0  } } To expose the properties and methods of this bean as attributes and operations of an MBean, you can configure an instance of the MBeanExporter class in your configuration file and pass in the bean, as the following example shows: 1317", "chunk_char_count": 749, "chunk_word_count": 164, "chunk_token_count": 187.25}, {"page_number": 1318, "sentence_chunk": "<beans> \u00a0  <!--this bean must not be lazily initialized if the exporting is to happen --> \u00a0  <bean id=\"exporter\" class=\"org.springframework.jmx.export. MBeanExporter\" lazy- init=\"false\"> \u00a0    <property name=\"beans\"> \u00a0      <map> \u00a0        <entry key=\"bean:name=testBean1\" value-ref=\"testBean\"/> \u00a0      </map> \u00a0    </property> \u00a0  </bean> \u00a0  <bean id=\"testBean\" class=\"org.springframework.jmx. JmxTestBean\"> \u00a0    <property name=\"name\" value=\"TEST\"/> \u00a0    <property name=\"age\" value=\"100\"/> \u00a0  </bean> </beans> The pertinent bean definition from the preceding configuration snippet is the exporter bean. The beans property tells the MBeanExporter exactly which of your beans must be exported to the JMX MBeanServer. In the default configuration, the key of each entry in the beans Map is used as the ObjectName for the bean referenced by the corresponding entry value. You can change this behavior, as described in Controlling ObjectName Instances for Your Beans. With this configuration, the testBean bean is exposed as an MBean under the ObjectName bean:name=testBean1. By default, all public properties of the bean are exposed as attributes and all public methods (except those inherited from the Object class) are exposed as operations.\uf05a MBeanExporter is a Lifecycle bean (see Startup and Shutdown Callbacks).", "chunk_char_count": 1309, "chunk_word_count": 212, "chunk_token_count": 327.25}, {"page_number": 1318, "sentence_chunk": "By default, MBeans are exported as late as possible during the application lifecycle. You can configure the phase at which the export happens or disable automatic registration by setting the autoStartup flag. Creating an MBeanServer The configuration shown in the preceding section assumes that the application is running in an environment that has one (and only one) MBeanServer already running. In this case, Spring tries to locate the running MBeanServer and register your beans with that server (if any). This behavior is useful when your application runs inside a container (such as Tomcat or IBM WebSphere) that has its own MBeanServer. However, this approach is of no use in a standalone environment or when running inside a container that does not provide an MBeanServer. To address this, you can create an MBeanServer instance declaratively by adding an instance of the org.springframework.jmx.support. MBeanServerFactoryBean class to your configuration. You can also ensure that a specific MBeanServer is used by setting the value of the MBeanExporter instance\u2019s server property to the MBeanServer value returned by an MBeanServerFactoryBean, as the following example shows: 1318", "chunk_char_count": 1189, "chunk_word_count": 180, "chunk_token_count": 297.25}, {"page_number": 1319, "sentence_chunk": "<beans> \u00a0  <bean id=\"mbeanServer\" class=\"org.springframework.jmx.support. MBeanServerFactoryBean\"/> \u00a0  <!--\u00a0  this bean needs to be eagerly pre-instantiated in order for the exporting to occur; \u00a0  this means that it must not be marked as lazily initialized \u00a0  --> \u00a0  <bean id=\"exporter\" class=\"org.springframework.jmx.export. MBeanExporter\"> \u00a0    <property name=\"beans\"> \u00a0      <map> \u00a0        <entry key=\"bean:name=testBean1\" value-ref=\"testBean\"/> \u00a0      </map> \u00a0    </property> \u00a0    <property name=\"server\" ref=\"mbeanServer\"/> \u00a0  </bean> \u00a0  <bean id=\"testBean\" class=\"org.springframework.jmx. JmxTestBean\"> \u00a0    <property name=\"name\" value=\"TEST\"/> \u00a0    <property name=\"age\" value=\"100\"/> \u00a0  </bean> </beans> In the preceding example, an instance of MBeanServer is created by the MBeanServerFactoryBean and is supplied to the MBeanExporter through the server property. When you supply your own MBeanServer instance, the MBeanExporter does not try to locate a running MBeanServer and uses the supplied MBeanServer instance. For this to work correctly, you must have a JMX implementation on your classpath. Reusing an Existing MBeanServer If no server is specified, the MBeanExporter tries to automatically detect a running MBeanServer. This works in most environments, where only one MBeanServer instance is used. However, when multiple instances exist, the exporter might pick the wrong server.", "chunk_char_count": 1396, "chunk_word_count": 219, "chunk_token_count": 349.0}, {"page_number": 1319, "sentence_chunk": "In such cases, you should use the MBeanServer agentId to indicate which instance to be used, as the following example shows: 1319", "chunk_char_count": 129, "chunk_word_count": 22, "chunk_token_count": 32.25}, {"page_number": 1320, "sentence_chunk": "<beans> \u00a0  <bean id=\"mbeanServer\" class=\"org.springframework.jmx.support. MBeanServerFactoryBean\"> \u00a0    <!--indicate to first look for a server --> \u00a0    <property name=\"locateExistingServerIfPossible\" value=\"true\"/> \u00a0    <!--search for the MBeanServer instance with the given agentId --> \u00a0    <property name=\"agentId\" value=\"MBeanServer_instance_agentId>\"/> \u00a0  </bean> \u00a0  <bean id=\"exporter\" class=\"org.springframework.jmx.export. MBeanExporter\"> \u00a0    <property name=\"server\" ref=\"mbeanServer\"/> \u00a0    ... \u00a0  </bean> </beans> For platforms or cases where the existing MBeanServer has a dynamic (or unknown) agentId that is retrieved through lookup methods, you should use factory-method, as the following example shows: <beans> \u00a0  <bean id=\"exporter\" class=\"org.springframework.jmx.export. MBeanExporter\"> \u00a0    <property name=\"server\"> \u00a0      <!--Custom MBeanServerLocator --> \u00a0      <bean class=\"platform.package. MBeanServerLocator\" factory- method=\"locateMBeanServer\"/> \u00a0    </property> \u00a0  </bean> \u00a0  <!--other beans here --> </beans> Lazily Initialized MBeans If you configure a bean with an MBeanExporter that is also configured for lazy initialization, the MBeanExporter does not break this contract and avoids instantiating the bean. Instead, it registers a proxy with the MBeanServer and defers obtaining the bean from the container until the first invocation on the proxy occurs.", "chunk_char_count": 1387, "chunk_word_count": 203, "chunk_token_count": 346.75}, {"page_number": 1320, "sentence_chunk": "Automatic Registration of MBeans Any beans that are exported through the MBeanExporter and are already valid MBeans are registered as-is with the MBeanServer without further intervention from Spring. You can cause MBeans to be automatically detected by the MBeanExporter by setting the autodetect property to true, as the following example shows: 1320", "chunk_char_count": 351, "chunk_word_count": 52, "chunk_token_count": 87.75}, {"page_number": 1321, "sentence_chunk": "<bean id=\"exporter\" class=\"org.springframework.jmx.export. MBeanExporter\"> \u00a0  <property name=\"autodetect\" value=\"true\"/> </bean> <bean name=\"spring:mbean=true\" class=\"org.springframework.jmx.export. TestDynamicMBean\"/> In the preceding example, the bean called spring:mbean=true is already a valid JMX MBean and is automatically registered by Spring. By default, a bean that is autodetected for JMX registration has its bean name used as the ObjectName. You can override this behavior, as detailed in Controlling ObjectName Instances for Your Beans. Controlling the Registration Behavior Consider the scenario where a Spring MBeanExporter attempts to register an MBean with an MBeanServer by using the ObjectName bean:name=testBean1. If an MBean instance has already been registered under that same ObjectName, the default behavior is to fail (and throw an InstanceAlreadyExistsException). You can control exactly what happens when an MBean is registered with an MBeanServer. Spring\u2019s JMX support allows for three different registration behaviors to control the registration behavior when the registration process finds that an MBean has already been registered under the same ObjectName. The following table summarizes these registration behaviors: Table 32.", "chunk_char_count": 1259, "chunk_word_count": 165, "chunk_token_count": 314.75}, {"page_number": 1321, "sentence_chunk": "Registration Behaviors Registration behavior Explanation FAIL_ON_EXISTING This is the default registration behavior. If an MBean instance has already been registered under the same ObjectName, the MBean that is being registered is not registered, and an InstanceAlreadyExistsException is thrown. The existing MBean is unaffected. IGNORE_EXISTING If an MBean instance has already been registered under the same ObjectName, the MBean that is being registered is not registered. The existing MBean is unaffected, and no Exception is thrown. This is useful in settings where multiple applications want to share a common MBean in a shared MBeanServer. REPLACE_EXISTING If an MBean instance has already been registered under the same ObjectName, the existing MBean that was previously registered is unregistered, and the new MBean is registered in its place (the new MBean effectively replaces the previous instance). The values in the preceding table are defined as enums on the RegistrationPolicy class. If you want to change the default registration behavior, you need to set the value of the registrationPolicy property on your MBeanExporter definition to one of those values. The following example shows how to change from the default registration behavior to the REPLACE_EXISTING behavior: 1321", "chunk_char_count": 1294, "chunk_word_count": 191, "chunk_token_count": 323.5}, {"page_number": 1322, "sentence_chunk": "<beans> \u00a0  <bean id=\"exporter\" class=\"org.springframework.jmx.export. MBeanExporter\"> \u00a0    <property name=\"beans\"> \u00a0      <map> \u00a0        <entry key=\"bean:name=testBean1\" value-ref=\"testBean\"/> \u00a0      </map> \u00a0    </property> \u00a0    <property name=\"registrationPolicy\" value=\"REPLACE_EXISTING\"/> \u00a0  </bean> \u00a0  <bean id=\"testBean\" class=\"org.springframework.jmx. JmxTestBean\"> \u00a0    <property name=\"name\" value=\"TEST\"/> \u00a0    <property name=\"age\" value=\"100\"/> \u00a0  </bean> </beans> 7.3.2. Controlling the Management Interface of Your Beans In the example in the preceding section, you had little control over the management interface of your bean. All of the public properties and methods of each exported bean were exposed as JMX attributes and operations, respectively. To exercise finer-grained control over exactly which properties and methods of your exported beans are actually exposed as JMX attributes and operations, Spring JMX provides a comprehensive and extensible mechanism for controlling the management interfaces of your beans. Using the MBeanInfoAssembler Interface Behind the scenes, the MBeanExporter delegates to an implementation of the org.springframework.jmx.export.assembler. MBeanInfoAssembler interface, which is responsible for defining the management interface of each bean that is exposed. The default implementation, org.springframework.jmx.export.assembler. SimpleReflectiveMBeanInfoAssembler, defines a management interface that exposes all public properties and methods (as you saw in the examples in the preceding sections).", "chunk_char_count": 1550, "chunk_word_count": 218, "chunk_token_count": 387.5}, {"page_number": 1322, "sentence_chunk": "Spring provides two additional implementations of the MBeanInfoAssembler interface that let you control the generated management interface by using either source-level metadata or any arbitrary interface. Using Source-level Metadata: Java Annotations By using the MetadataMBeanInfoAssembler, you can define the management interfaces for your beans by using source-level metadata. The reading of metadata is encapsulated by the org.springframework.jmx.export.metadata. JmxAttributeSource interface. Spring JMX provides a default implementation that uses Java annotations, namely org.springframework.jmx.export.annotation. AnnotationJmxAttributeSource. You must configure the MetadataMBeanInfoAssembler with an implementation instance of the JmxAttributeSource interface for it to function correctly (there is no default).1322", "chunk_char_count": 824, "chunk_word_count": 94, "chunk_token_count": 206.0}, {"page_number": 1323, "sentence_chunk": "To mark a bean for export to JMX, you should annotate the bean class with the ManagedResource annotation. You must mark each method you wish to expose as an operation with the ManagedOperation annotation and mark each property you wish to expose with the ManagedAttribute annotation. When marking properties, you can omit either the annotation of the getter or the setter to create a write-only or read-only attribute, respectively.\uf05a A ManagedResource-annotated bean must be public, as must the methods exposing an operation or an attribute. The following example shows the annotated version of the JmxTestBean class that we used in Creating an MBeanServer: package org.springframework.jmx; import org.springframework.jmx.export.annotation. ManagedResource; import org.springframework.jmx.export.annotation. ManagedOperation; import org.springframework.jmx.export.annotation. ManagedAttribute; @ManagedResource( \u00a0    objectName=\"bean:name=testBean4\", \u00a0    description=\"My Managed Bean\", \u00a0    log=true, \u00a0    logFile=\"jmx.log\", \u00a0    currencyTimeLimit=15, \u00a0    persistPolicy=\"OnUpdate\", \u00a0    persistPeriod=200, \u00a0    persistLocation=\"foo\", \u00a0    persistName=\"bar\") public class AnnotationTestBean implements IJmxTestBean { \u00a0  private String name; \u00a0  private int age; \u00a0  @ManagedAttribute(description=\"The Age Attribute\", currencyTimeLimit=15) \u00a0  public int getAge() { \u00a0    return age; \u00a0  } \u00a0  public void setAge(int age) { \u00a0    this.age = age; \u00a0  } \u00a0  @ManagedAttribute(description=\"The Name Attribute\", \u00a0      currencyTimeLimit=20, \u00a0      defaultValue=\"bar\", \u00a0      persistPolicy=\"OnUpdate\") \u00a0  public void setName(String name) { \u00a0    this.name = name; \u00a0  } 1323", "chunk_char_count": 1658, "chunk_word_count": 260, "chunk_token_count": 414.5}, {"page_number": 1324, "sentence_chunk": "@ManagedAttribute(defaultValue=\"foo\", persistPeriod=300) \u00a0  public String getName() { \u00a0    return name; \u00a0  } \u00a0  @ManagedOperation(description=\"Add two numbers\") \u00a0  @ManagedOperationParameters({ \u00a0    @ManagedOperationParameter(name = \"x\", description = \"The first number\"), \u00a0    @ManagedOperationParameter(name = \"y\", description = \"The second number\")}) \u00a0  public int add(int x, int y) { \u00a0    return x + y; \u00a0  } \u00a0  public void dontExposeMe() { \u00a0    throw new RuntimeException(); \u00a0  } } In the preceding example, you can see that the JmxTestBean class is marked with the ManagedResource annotation and that this ManagedResource annotation is configured with a set of properties. These properties can be used to configure various aspects of the MBean that is generated by the MBeanExporter and are explained in greater detail later in Source-level Metadata Types. Both the age and name properties are annotated with the ManagedAttribute annotation, but, in the case of the age property, only the getter is marked. This causes both of these properties to be included in the management interface as attributes, but the age attribute is read-only. Finally, the add(int, int) method is marked with the ManagedOperation attribute, whereas the dontExposeMe() method is not. This causes the management interface to contain only one operation (add(int, int)) when you use the MetadataMBeanInfoAssembler. The following configuration shows how you can configure the MBeanExporter to use the MetadataMBeanInfoAssembler: 1324", "chunk_char_count": 1511, "chunk_word_count": 239, "chunk_token_count": 377.75}, {"page_number": 1325, "sentence_chunk": "<beans> \u00a0  <bean id=\"exporter\" class=\"org.springframework.jmx.export. MBeanExporter\"> \u00a0    <property name=\"assembler\" ref=\"assembler\"/> \u00a0    <property name=\"namingStrategy\" ref=\"namingStrategy\"/> \u00a0    <property name=\"autodetect\" value=\"true\"/> \u00a0  </bean> \u00a0  <bean id=\"jmxAttributeSource\" \u00a0 class=\"org.springframework.jmx.export.annotation. AnnotationJmxAttributeSource\"/> \u00a0  <!--will create management interface using annotation metadata --> \u00a0  <bean id=\"assembler\" \u00a0 class=\"org.springframework.jmx.export.assembler. MetadataMBeanInfoAssembler\"> \u00a0    <property name=\"attributeSource\" ref=\"jmxAttributeSource\"/> \u00a0  </bean> \u00a0  <!--will pick up the ObjectName from the annotation --> \u00a0  <bean id=\"namingStrategy\" \u00a0      class=\"org.springframework.jmx.export.naming. MetadataNamingStrategy\"> \u00a0    <property name=\"attributeSource\" ref=\"jmxAttributeSource\"/> \u00a0  </bean> \u00a0  <bean id=\"testBean\" class=\"org.springframework.jmx. AnnotationTestBean\"> \u00a0    <property name=\"name\" value=\"TEST\"/> \u00a0    <property name=\"age\" value=\"100\"/> \u00a0  </bean> </beans> In the preceding example, an MetadataMBeanInfoAssembler bean has been configured with an instance of the AnnotationJmxAttributeSource class and passed to the MBeanExporter through the assembler property. This is all that is required to take advantage of metadata-driven management interfaces for your Spring-exposed MBeans. Source-level Metadata Types The following table describes the source-level metadata types that are available for use in Spring JMX: Table 33.", "chunk_char_count": 1507, "chunk_word_count": 186, "chunk_token_count": 376.75}, {"page_number": 1325, "sentence_chunk": "Source-level metadata types Purpose Annotation Annotation Type Mark all instances of a Class as JMX managed resources.@ManagedResource Class Mark a method as a JMX operation.@ManagedOperation Method 1325", "chunk_char_count": 203, "chunk_word_count": 27, "chunk_token_count": 50.75}, {"page_number": 1326, "sentence_chunk": "Purpose Annotation Annotation Type Mark a getter or setter as one half of a JMX attribute.@ManagedAttribute Method (only getters and setters) Define descriptions for operation parameters.@ManagedOperationParameter and @ManagedOperationParameters Method The following table describes the configuration parameters that are available for use on these source-level metadata types: Table 34. Source-level metadata parameters Parameter Description Applies to ObjectName Used by MetadataNamingStrategy to determine the ObjectName of a managed resource. ManagedResource description Sets the friendly description of the resource, attribute or operation. ManagedResource, ManagedAttribute, ManagedOperation, or ManagedOperationPa rameter currencyTimeLimit Sets the value of the currencyTimeLimit descriptor field. ManagedResource or ManagedAttribute defaultValue Sets the value of the defaultValue descriptor field. ManagedAttribute log Sets the value of the log descriptor field. ManagedResource logFile Sets the value of the logFile descriptor field. ManagedResource persistPolicy Sets the value of the persistPolicy descriptor field.", "chunk_char_count": 1126, "chunk_word_count": 136, "chunk_token_count": 281.5}, {"page_number": 1326, "sentence_chunk": "ManagedResource persistPeriod Sets the value of the persistPeriod descriptor field. ManagedResource persistLocation Sets the value of the persistLocation descriptor field. ManagedResource persistName Sets the value of the persistName descriptor field. ManagedResource name Sets the display name of an operation parameter. ManagedOperationPa rameter index Sets the index of an operation parameter. ManagedOperationPa rameter Using the AutodetectCapableMBeanInfoAssembler Interface To simplify configuration even further, Spring includes the AutodetectCapableMBeanInfoAssembler interface, which extends the MBeanInfoAssembler interface to add support for autodetection of MBean resources. If you configure the MBeanExporter with an instance of AutodetectCapableMBeanInfoAssembler, it is allowed to \u201cvote\u201d on the inclusion of beans for exposure to JMX. The only implementation of the AutodetectCapableMBeanInfo interface is the MetadataMBeanInfoAssembler, which votes to include any bean that is marked with the 1326", "chunk_char_count": 1013, "chunk_word_count": 125, "chunk_token_count": 253.25}, {"page_number": 1327, "sentence_chunk": "ManagedResource attribute. The default approach in this case is to use the bean name as the ObjectName, which results in a configuration similar to the following: <beans> \u00a0  <bean id=\"exporter\" class=\"org.springframework.jmx.export. MBeanExporter\"> \u00a0    <!--notice how no 'beans' are explicitly configured here --> \u00a0    <property name=\"autodetect\" value=\"true\"/> \u00a0    <property name=\"assembler\" ref=\"assembler\"/> \u00a0  </bean> \u00a0  <bean id=\"testBean\" class=\"org.springframework.jmx. JmxTestBean\"> \u00a0    <property name=\"name\" value=\"TEST\"/> \u00a0    <property name=\"age\" value=\"100\"/> \u00a0  </bean> \u00a0  <bean id=\"assembler\" class=\"org.springframework.jmx.export.assembler. MetadataMBeanInfoAssembler\"> \u00a0    <property name=\"attributeSource\"> \u00a0      <bean class=\"org.springframework.jmx.export.annotation. AnnotationJmxAttributeSource\"/> \u00a0    </property> \u00a0  </bean> </beans> Notice that, in the preceding configuration, no beans are passed to the MBeanExporter. However, the JmxTestBean is still registered, since it is marked with the ManagedResource attribute and the MetadataMBeanInfoAssembler detects this and votes to include it. The only problem with this approach is that the name of the JmxTestBean now has business meaning. You can address this issue by changing the default behavior for ObjectName creation as defined in Controlling ObjectName Instances for Your Beans.", "chunk_char_count": 1363, "chunk_word_count": 192, "chunk_token_count": 340.75}, {"page_number": 1327, "sentence_chunk": "Defining Management Interfaces by Using Java Interfaces In addition to the MetadataMBeanInfoAssembler, Spring also includes the InterfaceBasedMBeanInfoAssembler, which lets you constrain the methods and properties that are exposed based on the set of methods defined in a collection of interfaces. Although the standard mechanism for exposing MBeans is to use interfaces and a simple naming scheme, InterfaceBasedMBeanInfoAssembler extends this functionality by removing the need for naming conventions, letting you use more than one interface and removing the need for your beans to implement the MBean interfaces. Consider the following interface, which is used to define a management interface for the JmxTestBean class that we showed earlier: 1327", "chunk_char_count": 751, "chunk_word_count": 107, "chunk_token_count": 187.75}, {"page_number": 1328, "sentence_chunk": "public interface IJmxTestBean { \u00a0  public int add(int x, int y); \u00a0  public long myOperation(); \u00a0  public int getAge(); \u00a0  public void setAge(int age); \u00a0  public void setName(String name); \u00a0  public String getName(); } This interface defines the methods and properties that are exposed as operations and attributes on the JMX MBean. The following code shows how to configure Spring JMX to use this interface as the definition for the management interface: <beans> \u00a0  <bean id=\"exporter\" class=\"org.springframework.jmx.export. MBeanExporter\"> \u00a0    <property name=\"beans\"> \u00a0      <map> \u00a0        <entry key=\"bean:name=testBean5\" value-ref=\"testBean\"/> \u00a0      </map> \u00a0    </property> \u00a0    <property name=\"assembler\"> \u00a0      <bean class=\"org.springframework.jmx.export.assembler. InterfaceBasedMBeanInfoAssembler\"> \u00a0        <property name=\"managedInterfaces\"> \u00a0          <value>org.springframework.jmx. IJmxTestBean</value> \u00a0        </property> \u00a0      </bean> \u00a0    </property> \u00a0  </bean> \u00a0  <bean id=\"testBean\" class=\"org.springframework.jmx. JmxTestBean\"> \u00a0    <property name=\"name\" value=\"TEST\"/> \u00a0    <property name=\"age\" value=\"100\"/> \u00a0  </bean> </beans> In the preceding example, the InterfaceBasedMBeanInfoAssembler is configured to use the IJmxTestBean interface when constructing the management interface for any bean. It is important to understand that beans processed by the InterfaceBasedMBeanInfoAssembler are not required to 1328", "chunk_char_count": 1436, "chunk_word_count": 243, "chunk_token_count": 359.0}, {"page_number": 1329, "sentence_chunk": "implement the interface used to generate the JMX management interface. In the preceding case, the IJmxTestBean interface is used to construct all management interfaces for all beans. In many cases, this is not the desired behavior, and you may want to use different interfaces for different beans. In this case, you can pass InterfaceBasedMBeanInfoAssembler a Properties instance through the interfaceMappings property, where the key of each entry is the bean name and the value of each entry is a comma-separated list of interface names to use for that bean. If no management interface is specified through either the managedInterfaces or interfaceMappings properties, the InterfaceBasedMBeanInfoAssembler reflects on the bean and uses all of the interfaces implemented by that bean to create the management interface. Using MethodNameBasedMBeanInfoAssembler MethodNameBasedMBeanInfoAssembler lets you specify a list of method names that are exposed to JMX as attributes and operations. The following code shows a sample configuration: <bean id=\"exporter\" class=\"org.springframework.jmx.export. MBeanExporter\"> \u00a0  <property name=\"beans\"> \u00a0    <map> \u00a0      <entry key=\"bean:name=testBean5\" value-ref=\"testBean\"/> \u00a0    </map> \u00a0  </property> \u00a0  <property name=\"assembler\"> \u00a0    <bean class=\"org.springframework.jmx.export.assembler. MethodNameBasedMBeanInfoAssembler\"> \u00a0      <property name=\"managedMethods\"> \u00a0        <value>add,myOperation,getName,setName,getAge</value> \u00a0      </property> \u00a0    </bean> \u00a0  </property> </bean> In the preceding example, you can see that the add and myOperation methods are exposed as JMX operations, and getName(), setName(String), and getAge() are exposed as the appropriate half of a JMX attribute. In the preceding code, the method mappings apply to beans that are exposed to JMX.", "chunk_char_count": 1814, "chunk_word_count": 272, "chunk_token_count": 453.5}, {"page_number": 1329, "sentence_chunk": "To control method exposure on a bean-by-bean basis, you can use the methodMappings property of MethodNameMBeanInfoAssembler to map bean names to lists of method names.7.3.3. Controlling ObjectName Instances for Your Beans Behind the scenes, the MBeanExporter delegates to an implementation of the ObjectNamingStrategy to obtain an ObjectName instance for each of the beans it registers. By default, the default implementation, KeyNamingStrategy uses the key of the beans Map as the ObjectName. In addition, the KeyNamingStrategy can map the key of the beans Map to an entry in a Properties file (or files) to resolve the ObjectName. In addition to the KeyNamingStrategy, Spring provides two additional ObjectNamingStrategy implementations: the IdentityNamingStrategy (which builds an ObjectName based on the JVM identity of the bean) and the MetadataNamingStrategy (which uses source-level metadata to obtain the ObjectName).1329", "chunk_char_count": 929, "chunk_word_count": 132, "chunk_token_count": 232.25}, {"page_number": 1330, "sentence_chunk": "Reading ObjectName Instances from Properties You can configure your own KeyNamingStrategy instance and configure it to read ObjectName instances from a Properties instance rather than use a bean key. The KeyNamingStrategy tries to locate an entry in the Properties with a key that corresponds to the bean key. If no entry is found or if the Properties instance is null, the bean key itself is used. The following code shows a sample configuration for the KeyNamingStrategy: <beans> \u00a0  <bean id=\"exporter\" class=\"org.springframework.jmx.export. MBeanExporter\"> \u00a0    <property name=\"beans\"> \u00a0      <map> \u00a0        <entry key=\"testBean\" value-ref=\"testBean\"/> \u00a0      </map> \u00a0    </property> \u00a0    <property name=\"namingStrategy\" ref=\"namingStrategy\"/> \u00a0  </bean> \u00a0  <bean id=\"testBean\" class=\"org.springframework.jmx. JmxTestBean\"> \u00a0    <property name=\"name\" value=\"TEST\"/> \u00a0    <property name=\"age\" value=\"100\"/> \u00a0  </bean> \u00a0  <bean id=\"namingStrategy\" class=\"org.springframework.jmx.export.naming. KeyNamingStrategy\"> \u00a0    <property name=\"mappings\"> \u00a0      <props> \u00a0        <prop key=\"testBean\">bean:name=testBean1</prop> \u00a0      </props> \u00a0    </property> \u00a0    <property name=\"mappingLocations\"> \u00a0      <value>names1.properties,names2.properties</value> \u00a0    </property> \u00a0  </bean> </beans> The preceding example configures an instance of KeyNamingStrategy with a Properties instance that is merged from the Properties instance defined by the mapping property and the properties files located in the paths defined by the mappings property. In this configuration, the testBean bean is given an ObjectName of bean:name=testBean1, since this is the entry in the Properties instance that has a key corresponding to the bean key. If no entry in the Properties instance can be found, the bean key name is used as the ObjectName. Using MetadataNamingStrategy MetadataNamingStrategy uses the objectName property of the ManagedResource attribute on each bean 1330", "chunk_char_count": 1950, "chunk_word_count": 316, "chunk_token_count": 487.5}, {"page_number": 1331, "sentence_chunk": "to create the ObjectName. The following code shows the configuration for the MetadataNamingStrategy: <beans> \u00a0  <bean id=\"exporter\" class=\"org.springframework.jmx.export. MBeanExporter\"> \u00a0    <property name=\"beans\"> \u00a0      <map> \u00a0        <entry key=\"testBean\" value-ref=\"testBean\"/> \u00a0      </map> \u00a0    </property> \u00a0    <property name=\"namingStrategy\" ref=\"namingStrategy\"/> \u00a0  </bean> \u00a0  <bean id=\"testBean\" class=\"org.springframework.jmx. JmxTestBean\"> \u00a0    <property name=\"name\" value=\"TEST\"/> \u00a0    <property name=\"age\" value=\"100\"/> \u00a0  </bean> \u00a0  <bean id=\"namingStrategy\" class=\"org.springframework.jmx.export.naming. MetadataNamingStrategy\"> \u00a0    <property name=\"attributeSource\" ref=\"attributeSource\"/> \u00a0  </bean> \u00a0  <bean id=\"attributeSource\" \u00a0 class=\"org.springframework.jmx.export.annotation. AnnotationJmxAttributeSource\"/> </beans> If no objectName has been provided for the ManagedResource attribute, an ObjectName is created with the following format: [fully-qualified-package-name]:type=[short-classname],name=[bean-name]. For example, the generated ObjectName for the following bean would be com.example:type=MyClass,name=myBean: <bean id=\"myBean\" class=\"com.example. MyClass\"/> Configuring Annotation-based MBean Export If you prefer to use the annotation-based approach to define your management interfaces, a convenience subclass of MBeanExporter is available: AnnotationMBeanExporter. When defining an instance of this subclass, you no longer need the namingStrategy, assembler, and attributeSource configuration, since it always uses standard Java annotation-based metadata (autodetection is always enabled as well). In fact, rather than defining an MBeanExporter bean, an even simpler syntax is supported by the @EnableMBeanExport @Configuration annotation, as the following example shows: 1331", "chunk_char_count": 1815, "chunk_word_count": 229, "chunk_token_count": 453.75}, {"page_number": 1332, "sentence_chunk": "@Configuration @EnableMBeanExport public class AppConfig { } If you prefer XML-based configuration, the <context:mbean-export/> element serves the same purpose and is shown in the following listing: <context:mbean-export/> If necessary, you can provide a reference to a particular MBean server, and the defaultDomain attribute (a property of AnnotationMBeanExporter) accepts an alternate value for the generated MBean ObjectName domains. This is used in place of the fully qualified package name as described in the previous section on MetadataNamingStrategy, as the following example shows: @EnableMBeanExport(server=\"myMBeanServer\", defaultDomain=\"myDomain\") @Configuration ContextConfiguration { } The following example shows the XML equivalent of the preceding annotation-based example: <context:mbean-export server=\"myMBeanServer\" default-domain=\"myDomain\"/> \uf06d Do not use interface-based AOP proxies in combination with autodetection of JMX annotations in your bean classes. Interface-based proxies \u201chide\u201d the target class, which also hides the JMX-managed resource annotations. Hence, you should use target-class proxies in that case (through setting the 'proxy-target-class' flag on <aop:config/>, <tx:annotation-driven/> and so on). Otherwise, your JMX beans might be silently ignored at startup.7.3.4. Using JSR-160 Connectors For remote access, Spring JMX module offers two FactoryBean implementations inside the org.springframework.jmx.support package for creating both server- and client-side connectors. Server-side Connectors To have Spring JMX create, start, and expose a JSR-160 JMXConnectorServer, you can use the following configuration: 1332", "chunk_char_count": 1660, "chunk_word_count": 207, "chunk_token_count": 415.0}, {"page_number": 1333, "sentence_chunk": "<bean id=\"serverConnector\" class=\"org.springframework.jmx.support. ConnectorServerFactoryBean\"/> By default, ConnectorServerFactoryBean creates a JMXConnectorServer bound to service:jmx:jmxmp://localhost:9875. The serverConnector bean thus exposes the local MBeanServer to clients through the JMXMP protocol on localhost, port 9875. Note that the JMXMP protocol is marked as optional by the JSR 160 specification. Currently, the main open-source JMX implementation, MX4J, and the one provided with the JDK do not support JMXMP. To specify another URL and register the JMXConnectorServer itself with the MBeanServer, you can use the serviceUrl and ObjectName properties, respectively, as the following example shows: <bean id=\"serverConnector\" \u00a0    class=\"org.springframework.jmx.support. ConnectorServerFactoryBean\"> \u00a0  <property name=\"objectName\" value=\"connector:name=rmi\"/> \u00a0  <property name=\"serviceUrl\" \u00a0 value=\"service:jmx:rmi://localhost/jndi/rmi://localhost:1099/myconnector\"/> </bean> If the ObjectName property is set, Spring automatically registers your connector with the MBeanServer under that ObjectName. The following example shows the full set of parameters that you can pass to the ConnectorServerFactoryBean when creating a JMXConnector: <bean id=\"serverConnector\" \u00a0    class=\"org.springframework.jmx.support. ConnectorServerFactoryBean\"> \u00a0  <property name=\"objectName\" value=\"connector:name=iiop\"/> \u00a0  <property name=\"serviceUrl\" \u00a0    value=\"service:jmx:iiop://localhost/jndi/iiop://localhost:900/myconnector\"/> \u00a0  <property name=\"threaded\" value=\"true\"/> \u00a0  <property name=\"daemon\" value=\"true\"/> \u00a0  <property name=\"environment\"> \u00a0    <map> \u00a0      <entry key=\"someKey\" value=\"someValue\"/> \u00a0    </map> \u00a0  </property> </bean> Note that, when you use a RMI-based connector, you need the lookup service (tnameserv or rmiregistry) to be started in order for the name registration to complete. Client-side Connectors To create an MBeanServerConnection to a remote JSR-160-enabled MBeanServer, you can use the MBeanServerConnectionFactoryBean, as the following example shows: 1333", "chunk_char_count": 2093, "chunk_word_count": 254, "chunk_token_count": 523.25}, {"page_number": 1334, "sentence_chunk": "<bean id=\"clientConnector\" class=\"org.springframework.jmx.support. MBeanServerConnectionFactoryBean\"> \u00a0  <property name=\"serviceUrl\" value=\"service:jmx:rmi://localhost/jndi/rmi://localhost:1099/jmxrmi\"/> </bean> JMX over Hessian or SOAP JSR-160 permits extensions to the way in which communication is done between the client and the server. The examples shown in the preceding sections use the mandatory RMI-based implementation required by the JSR-160 specification (IIOP and JRMP) and the (optional) JMXMP. By using other providers or JMX implementations (such as MX4J) you can take advantage of protocols such as SOAP or Hessian over simple HTTP or SSL and others, as the following example shows: <bean id=\"serverConnector\" class=\"org.springframework.jmx.support. ConnectorServerFactoryBean\"> \u00a0  <property name=\"objectName\" value=\"connector:name=burlap\"/> \u00a0  <property name=\"serviceUrl\" value=\"service:jmx:burlap://localhost:9874\"/> </bean> In the preceding example, we used MX4J 3.0.0. See the official MX4J documentation for more information.7.3.5. Accessing MBeans through Proxies Spring JMX lets you create proxies that re-route calls to MBeans that are registered in a local or remote MBeanServer. These proxies provide you with a standard Java interface, through which you can interact with your MBeans. The following code shows how to configure a proxy for an MBean running in a local MBeanServer: <bean id=\"proxy\" class=\"org.springframework.jmx.access.", "chunk_char_count": 1463, "chunk_word_count": 181, "chunk_token_count": 365.75}, {"page_number": 1334, "sentence_chunk": "MBeanProxyFactoryBean\"> \u00a0  <property name=\"objectName\" value=\"bean:name=testBean\"/> \u00a0  <property name=\"proxyInterface\" value=\"org.springframework.jmx. IJmxTestBean\"/> </bean> In the preceding example, you can see that a proxy is created for the MBean registered under the ObjectName of bean:name=testBean. The set of interfaces that the proxy implements is controlled by the proxyInterfaces property, and the rules for mapping methods and properties on these interfaces to operations and attributes on the MBean are the same rules used by the InterfaceBasedMBeanInfoAssembler. The MBeanProxyFactoryBean can create a proxy to any MBean that is accessible through an MBeanServerConnection. By default, the local MBeanServer is located and used, but you can override this and provide an MBeanServerConnection that points to a remote MBeanServer to cater for proxies that point to remote MBeans: 1334", "chunk_char_count": 896, "chunk_word_count": 123, "chunk_token_count": 224.0}, {"page_number": 1335, "sentence_chunk": "<bean id=\"clientConnector\" \u00a0    class=\"org.springframework.jmx.support. MBeanServerConnectionFactoryBean\"> \u00a0  <property name=\"serviceUrl\" value=\"service:jmx:rmi://remotehost:9875\"/> </bean> <bean id=\"proxy\" class=\"org.springframework.jmx.access. MBeanProxyFactoryBean\"> \u00a0  <property name=\"objectName\" value=\"bean:name=testBean\"/> \u00a0  <property name=\"proxyInterface\" value=\"org.springframework.jmx. IJmxTestBean\"/> \u00a0  <property name=\"server\" ref=\"clientConnector\"/> </bean> In the preceding example, we create an MBeanServerConnection that points to a remote machine that uses the MBeanServerConnectionFactoryBean. This MBeanServerConnection is then passed to the MBeanProxyFactoryBean through the server property. The proxy that is created forwards all invocations to the MBeanServer through this MBeanServerConnection.7.3.6. Notifications Spring\u2019s JMX offering includes comprehensive support for JMX notifications. Registering Listeners for Notifications Spring\u2019s JMX support makes it easy to register any number of NotificationListeners with any number of MBeans (this includes MBeans exported by Spring\u2019s MBeanExporter and MBeans registered through some other mechanism). For example, consider the scenario where one would like to be informed (through a Notification) each and every time an attribute of a target MBean changes.", "chunk_char_count": 1329, "chunk_word_count": 150, "chunk_token_count": 332.25}, {"page_number": 1336, "sentence_chunk": "package com.example; import javax.management. AttributeChangeNotification; import javax.management. Notification; import javax.management. NotificationFilter; import javax.management. NotificationListener; public class ConsoleLoggingNotificationListener \u00a0    implements NotificationListener, NotificationFilter { \u00a0  public void handleNotification(Notification notification, Object handback) { \u00a0    System.out.println(notification); \u00a0    System.out.println(handback); \u00a0  } \u00a0  public boolean isNotificationEnabled(Notification notification) { \u00a0    return AttributeChangeNotification.class.isAssignableFrom(notification.getClass()); \u00a0  } } The following example adds ConsoleLoggingNotificationListener (defined in the preceding example) to notificationListenerMappings: <beans> \u00a0  <bean id=\"exporter\" class=\"org.springframework.jmx.export. MBeanExporter\"> \u00a0    <property name=\"beans\"> \u00a0      <map> \u00a0        <entry key=\"bean:name=testBean1\" value-ref=\"testBean\"/> \u00a0      </map> \u00a0    </property> \u00a0    <property name=\"notificationListenerMappings\"> \u00a0      <map> \u00a0        <entry key=\"bean:name=testBean1\"> \u00a0          <bean class=\"com.example. ConsoleLoggingNotificationListener\"/> \u00a0        </entry> \u00a0      </map> \u00a0    </property> \u00a0  </bean> \u00a0  <bean id=\"testBean\" class=\"org.springframework.jmx. JmxTestBean\"> \u00a0    <property name=\"name\" value=\"TEST\"/> \u00a0    <property name=\"age\" value=\"100\"/> \u00a0  </bean> </beans> 1336", "chunk_char_count": 1409, "chunk_word_count": 204, "chunk_token_count": 352.25}, {"page_number": 1337, "sentence_chunk": "With the preceding configuration in place, every time a JMX Notification is broadcast from the target MBean (bean:name=testBean1), the ConsoleLoggingNotificationListener bean that was registered as a listener through the notificationListenerMappings property is notified. The ConsoleLoggingNotificationListener bean can then take whatever action it deems appropriate in response to the Notification. You can also use straight bean names as the link between exported beans and listeners, as the following example shows: <beans> \u00a0  <bean id=\"exporter\" class=\"org.springframework.jmx.export. MBeanExporter\"> \u00a0    <property name=\"beans\"> \u00a0      <map> \u00a0        <entry key=\"bean:name=testBean1\" value-ref=\"testBean\"/> \u00a0      </map> \u00a0    </property> \u00a0    <property name=\"notificationListenerMappings\"> \u00a0      <map> \u00a0        <entry key=\"testBean\"> \u00a0          <bean class=\"com.example. ConsoleLoggingNotificationListener\"/> \u00a0        </entry> \u00a0      </map> \u00a0    </property> \u00a0  </bean> \u00a0  <bean id=\"testBean\" class=\"org.springframework.jmx. JmxTestBean\"> \u00a0    <property name=\"name\" value=\"TEST\"/> \u00a0    <property name=\"age\" value=\"100\"/> \u00a0  </bean> </beans> If you want to register a single NotificationListener instance for all of the beans that the enclosing MBeanExporter exports, you can use the special wildcard (*) as the key for an entry in the notificationListenerMappings property map, as the following example shows: <property name=\"notificationListenerMappings\"> \u00a0  <map> \u00a0    <entry key=\"*\"> \u00a0      <bean class=\"com.example. ConsoleLoggingNotificationListener\"/> \u00a0    </entry> \u00a0  </map> </property> If you need to do the inverse (that is, register a number of distinct listeners against an MBean), you must instead use the notificationListeners list property (in preference to the notificationListenerMappings property). This time, instead of configuring a NotificationListener for 1337", "chunk_char_count": 1886, "chunk_word_count": 308, "chunk_token_count": 471.5}, {"page_number": 1338, "sentence_chunk": "a single MBean, we configure NotificationListenerBean instances. A NotificationListenerBean encapsulates a NotificationListener and the ObjectName (or ObjectNames) that it is to be registered against in an MBeanServer. The NotificationListenerBean also encapsulates a number of other properties, such as a NotificationFilter and an arbitrary handback object that can be used in advanced JMX notification scenarios. The configuration when using NotificationListenerBean instances is not wildly different to what was presented previously, as the following example shows: <beans> \u00a0  <bean id=\"exporter\" class=\"org.springframework.jmx.export. MBeanExporter\"> \u00a0    <property name=\"beans\"> \u00a0      <map> \u00a0        <entry key=\"bean:name=testBean1\" value-ref=\"testBean\"/> \u00a0      </map> \u00a0    </property> \u00a0    <property name=\"notificationListeners\"> \u00a0      <list> \u00a0        <bean class=\"org.springframework.jmx.export. NotificationListenerBean\"> \u00a0          <constructor-arg> \u00a0            <bean class=\"com.example. ConsoleLoggingNotificationListener\"/> \u00a0          </constructor-arg> \u00a0          <property name=\"mappedObjectNames\"> \u00a0            <list> \u00a0              <value>bean:name=testBean1</value> \u00a0            </list> \u00a0          </property> \u00a0        </bean> \u00a0      </list> \u00a0    </property> \u00a0  </bean> \u00a0  <bean id=\"testBean\" class=\"org.springframework.jmx. JmxTestBean\"> \u00a0    <property name=\"name\" value=\"TEST\"/> \u00a0    <property name=\"age\" value=\"100\"/> \u00a0  </bean> </beans> The preceding example is equivalent to the first notification example. Assume, then, that we want to be given a handback object every time a Notification is raised and that we also want to filter out extraneous Notifications by supplying a NotificationFilter. The following example accomplishes these goals: 1338", "chunk_char_count": 1773, "chunk_word_count": 338, "chunk_token_count": 443.25}, {"page_number": 1339, "sentence_chunk": "<beans> \u00a0  <bean id=\"exporter\" class=\"org.springframework.jmx.export. MBeanExporter\"> \u00a0    <property name=\"beans\"> \u00a0      <map> \u00a0        <entry key=\"bean:name=testBean1\" value-ref=\"testBean1\"/> \u00a0        <entry key=\"bean:name=testBean2\" value-ref=\"testBean2\"/> \u00a0      </map> \u00a0    </property> \u00a0    <property name=\"notificationListeners\"> \u00a0      <list> \u00a0        <bean class=\"org.springframework.jmx.export. NotificationListenerBean\"> \u00a0          <constructor-arg ref=\"customerNotificationListener\"/> \u00a0          <property name=\"mappedObjectNames\"> \u00a0            <list> \u00a0              <!--handles notifications from two distinct MBeans --> \u00a0              <value>bean:name=testBean1</value> \u00a0              <value>bean:name=testBean2</value> \u00a0            </list> \u00a0          </property> \u00a0          <property name=\"handback\"> \u00a0            <bean class=\"java.lang. String\"> \u00a0              <constructor-arg value=\"This could be anything...\"/> \u00a0            </bean> \u00a0          </property> \u00a0          <property name=\"notificationFilter\" ref=\"customerNotificationListener\"/> \u00a0        </bean> \u00a0      </list> \u00a0    </property> \u00a0  </bean> \u00a0  <!--implements both the NotificationListener and NotificationFilter interfaces --> \u00a0  <bean id=\"customerNotificationListener\" class=\"com.example. ConsoleLoggingNotificationListener\"/> \u00a0  <bean id=\"testBean1\" class=\"org.springframework.jmx. JmxTestBean\"> \u00a0    <property name=\"name\" value=\"TEST\"/> \u00a0    <property name=\"age\" value=\"100\"/> \u00a0  </bean> \u00a0  <bean id=\"testBean2\" class=\"org.springframework.jmx. JmxTestBean\"> \u00a0    <property name=\"name\" value=\"ANOTHER TEST\"/> \u00a0    <property name=\"age\" value=\"200\"/> \u00a0  </bean> </beans> (For a full discussion of what a handback object is and, indeed, what a NotificationFilter is, see the 1339", "chunk_char_count": 1754, "chunk_word_count": 380, "chunk_token_count": 438.5}, {"page_number": 1340, "sentence_chunk": "section of the JMX specification (1.2) entitled 'The JMX Notification Model'.)Publishing Notifications Spring provides support not only for registering to receive Notifications but also for publishing Notifications.\uf05a This section is really only relevant to Spring-managed beans that have been exposed as MBeans through an MBeanExporter. Any existing user-defined MBeans should use the standard JMX APIs for notification publication. The key interface in Spring\u2019s JMX notification publication support is the NotificationPublisher interface (defined in the org.springframework.jmx.export.notification package). Any bean that is going to be exported as an MBean through an MBeanExporter instance can implement the related NotificationPublisherAware interface to gain access to a NotificationPublisher instance. The NotificationPublisherAware interface supplies an instance of a NotificationPublisher to the implementing bean through a simple setter method, which the bean can then use to publish Notifications. As stated in the javadoc of the NotificationPublisher interface, managed beans that publish events through the NotificationPublisher mechanism are not responsible for the state management of notification listeners. Spring\u2019s JMX support takes care of handling all the JMX infrastructure issues. All you need to do, as an application developer, is implement the NotificationPublisherAware interface and start publishing events by using the supplied NotificationPublisher instance.", "chunk_char_count": 1486, "chunk_word_count": 195, "chunk_token_count": 371.5}, {"page_number": 1340, "sentence_chunk": "Note that the NotificationPublisher is set after the managed bean has been registered with an MBeanServer. Using a NotificationPublisher instance is quite straightforward. You create a JMX Notification instance (or an instance of an appropriate Notification subclass), populate the notification with the data pertinent to the event that is to be published, and invoke the sendNotification(Notification) on the NotificationPublisher instance, passing in the Notification. In the following example, exported instances of the JmxTestBean publish a NotificationEvent every time the add(int, int) operation is invoked: 1340", "chunk_char_count": 618, "chunk_word_count": 85, "chunk_token_count": 154.5}, {"page_number": 1341, "sentence_chunk": "package org.springframework.jmx; import org.springframework.jmx.export.notification. NotificationPublisherAware; import org.springframework.jmx.export.notification. NotificationPublisher; import javax.management. Notification; public class JmxTestBean implements IJmxTestBean, NotificationPublisherAware { \u00a0  private String name; \u00a0  private int age; \u00a0  private boolean isSuperman; \u00a0  private NotificationPublisher publisher; \u00a0  // other getters and setters omitted for clarity \u00a0  public int add(int x, int y) { \u00a0    int answer = x + y; \u00a0    this.publisher.sendNotification(new Notification(\"add\", this, 0)); \u00a0    return answer; \u00a0  } \u00a0  public void dontExposeMe() { \u00a0    throw new RuntimeException(); \u00a0  } \u00a0  public void setNotificationPublisher(NotificationPublisher notificationPublisher) { \u00a0    this.publisher = notificationPublisher; \u00a0  } } The NotificationPublisher interface and the machinery to get it all working is one of the nicer features of Spring\u2019s JMX support. It does, however, come with the price tag of coupling your classes to both Spring and JMX. As always, the advice here is to be pragmatic. If you need the functionality offered by the NotificationPublisher and you can accept the coupling to both Spring and JMX, then do so.7.3.7. Further Resources This section contains links to further resources about JMX: \u2022 The JMX homepage at Oracle. \u2022The JMX specification (JSR-000003). \u2022", "chunk_char_count": 1399, "chunk_word_count": 210, "chunk_token_count": 349.75}, {"page_number": 1341, "sentence_chunk": "The JMX Remote API specification (JSR-000160). \u2022The MX4J homepage. (MX4J is an open-source implementation of various JMX specs.)1341", "chunk_char_count": 132, "chunk_word_count": 18, "chunk_token_count": 33.0}, {"page_number": 1342, "sentence_chunk": "7.4. Email This section describes how to send email with the Spring Framework. Library dependencies The following JAR needs to be on the classpath of your application in order to use the Spring Framework\u2019s email library: \u2022 The JavaMail / Jakarta Mail 1.6 library This library is freely available on the web\u2009\u2014\u2009for example, in Maven Central as com.sun.mail:jakarta.mail. Please make sure to use the latest 1.6.x version rather than Jakarta Mail 2.0 (which comes with a different package namespace). The Spring Framework provides a helpful utility library for sending email that shields you from the specifics of the underlying mailing system and is responsible for low-level resource handling on behalf of the client. The org.springframework.mail package is the root level package for the Spring Framework\u2019s email support. The central interface for sending emails is the MailSender interface. A simple value object that encapsulates the properties of a simple mail such as from and to (plus many others) is the SimpleMailMessage class. This package also contains a hierarchy of checked exceptions that provide a higher level of abstraction over the lower level mail system exceptions, with the root exception being MailException. See the javadoc for more information on the rich mail exception hierarchy.", "chunk_char_count": 1302, "chunk_word_count": 202, "chunk_token_count": 325.5}, {"page_number": 1342, "sentence_chunk": "The org.springframework.mail.javamail. JavaMailSender interface adds specialized JavaMail features, such as MIME message support to the MailSender interface (from which it inherits). JavaMailSender also provides a callback interface called org.springframework.mail.javamail. MimeMessagePreparator for preparing a MimeMessage.7.4.1. Usage Assume that we have a business interface called OrderManager, as the following example shows: public interface OrderManager { \u00a0  void placeOrder(Order order); } Further assume that we have a requirement stating that an email message with an order number needs to be generated and sent to a customer who placed the relevant order. Basic MailSender and SimpleMailMessage Usage The following example shows how to use MailSender and SimpleMailMessage to send an email when 1342", "chunk_char_count": 811, "chunk_word_count": 110, "chunk_token_count": 202.75}, {"page_number": 1343, "sentence_chunk": "someone places an order: import org.springframework.mail. MailException; import org.springframework.mail. MailSender; import org.springframework.mail. SimpleMailMessage; public class SimpleOrderManager implements OrderManager { \u00a0  private MailSender mailSender; \u00a0  private SimpleMailMessage templateMessage; \u00a0  public void setMailSender(MailSender mailSender) { \u00a0    this.mailSender = mailSender; \u00a0  } \u00a0  public void setTemplateMessage(SimpleMailMessage templateMessage) { \u00a0    this.templateMessage = templateMessage; \u00a0  } \u00a0  public void placeOrder(Order order) { \u00a0    // Do the business calculations... \u00a0    // Call the collaborators to persist the order... \u00a0    // Create a thread safe \"copy\" of the template message and customize it \u00a0    SimpleMailMessage msg = new SimpleMailMessage(this.templateMessage); \u00a0    msg.setTo(order.getCustomer().getEmailAddress()); \u00a0    msg.setText( \u00a0      \"Dear \" + order.getCustomer().getFirstName() \u00a0        + order.getCustomer().getLastName() \u00a0        + \", thank you for placing order. Your order number is \" \u00a0        + order.getOrderNumber()); \u00a0    try { \u00a0      this.mailSender.send(msg); \u00a0    } \u00a0    catch (MailException ex) { \u00a0      // simply log it and go on... \u00a0      System.err.println(ex.getMessage()); \u00a0    } \u00a0  } } The following example shows the bean definitions for the preceding code: 1343", "chunk_char_count": 1338, "chunk_word_count": 244, "chunk_token_count": 334.5}, {"page_number": 1344, "sentence_chunk": "<bean id=\"mailSender\" class=\"org.springframework.mail.javamail. JavaMailSenderImpl\"> \u00a0  <property name=\"host\" value=\"mail.mycompany.example\"/> </bean> <!--this is a template message that we can pre-load with default state --> <bean id=\"templateMessage\" class=\"org.springframework.mail. SimpleMailMessage\"> \u00a0  <property name=\"from\" value=\"customerservice@mycompany.example\"/> \u00a0  <property name=\"subject\" value=\"Your order\"/> </bean> <bean id=\"orderManager\" class=\"com.mycompany.businessapp.support. SimpleOrderManager\"> \u00a0  <property name=\"mailSender\" ref=\"mailSender\"/> \u00a0  <property name=\"templateMessage\" ref=\"templateMessage\"/> </bean> Using JavaMailSender and MimeMessagePreparator This section describes another implementation of OrderManager that uses the MimeMessagePreparator callback interface. In the following example, the mailSender property is of type JavaMailSender so that we are able to use the JavaMail MimeMessage class: 1344", "chunk_char_count": 941, "chunk_word_count": 94, "chunk_token_count": 235.25}, {"page_number": 1345, "sentence_chunk": "import jakarta.mail. Message; import jakarta.mail. MessagingException; import jakarta.mail.internet. InternetAddress; import jakarta.mail.internet. MimeMessage; import jakarta.mail.internet. MimeMessage; import org.springframework.mail. MailException; import org.springframework.mail.javamail. JavaMailSender; import org.springframework.mail.javamail. MimeMessagePreparator; public class SimpleOrderManager implements OrderManager { \u00a0  private JavaMailSender mailSender; \u00a0  public void setMailSender(JavaMailSender mailSender) { \u00a0    this.mailSender = mailSender; \u00a0  } \u00a0  public void placeOrder(final Order order) { \u00a0    // Do the business calculations... \u00a0    // Call the collaborators to persist the order... \u00a0    MimeMessagePreparator preparator = new MimeMessagePreparator() { \u00a0      public void prepare(MimeMessage mimeMessage) throws Exception { \u00a0        mimeMessage.setRecipient(Message. RecipientType.", "chunk_char_count": 909, "chunk_word_count": 114, "chunk_token_count": 227.25}, {"page_number": 1345, "sentence_chunk": "TO, \u00a0            new InternetAddress(order.getCustomer().getEmailAddress())); \u00a0        mimeMessage.setFrom(new InternetAddress(\"mail@mycompany.example\")); \u00a0        mimeMessage.setText(\"Dear \" + order.getCustomer().getFirstName() + \" \" + \u00a0            order.getCustomer().getLastName() + \", thanks for your order. \"+ \u00a0            \"Your order number is \" + order.getOrderNumber() + \".\");\u00a0      } \u00a0    }; \u00a0    try { \u00a0      this.mailSender.send(preparator); \u00a0    } \u00a0    catch (MailException ex) { \u00a0      // simply log it and go on... \u00a0      System.err.println(ex.getMessage()); \u00a0    } \u00a0  } } \uf05a The mail code is a crosscutting concern and could well be a candidate for refactoring into a custom Spring AOP aspect, which could then be run at appropriate joinpoints on the OrderManager target.1345", "chunk_char_count": 789, "chunk_word_count": 182, "chunk_token_count": 197.25}, {"page_number": 1346, "sentence_chunk": "The Spring Framework\u2019s mail support ships with the standard JavaMail implementation. See the relevant javadoc for more information.7.4.2. Using the JavaMail MimeMessageHelper A class that comes in pretty handy when dealing with JavaMail messages is org.springframework.mail.javamail. MimeMessageHelper, which shields you from having to use the verbose JavaMail API. Using the MimeMessageHelper, it is pretty easy to create a MimeMessage, as the following example shows: // of course you would use DI in any real-world cases JavaMailSenderImpl sender = new JavaMailSenderImpl(); sender.setHost(\"mail.host.com\"); MimeMessage message = sender.createMimeMessage(); MimeMessageHelper helper = new MimeMessageHelper(message); helper.setTo(\"test@host.com\"); helper.setText(\"Thank you for ordering!\");sender.send(message); Sending Attachments and Inline Resources Multipart email messages allow for both attachments and inline resources. Examples of inline resources include an image or a stylesheet that you want to use in your message but that you do not want displayed as an attachment. Attachments The following example shows you how to use the MimeMessageHelper to send an email with a single JPEG image attachment: JavaMailSenderImpl sender = new JavaMailSenderImpl(); sender.setHost(\"mail.host.com\"); MimeMessage message = sender.createMimeMessage(); // use the true flag to indicate you need a multipart message MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setTo(\"test@host.com\"); helper.setText(\"Check out this image!\"); //let's attach the infamous windows Sample file (this time copied to c:/) FileSystemResource file = new FileSystemResource(new File(\"c:/Sample.jpg\")); helper.addAttachment(\"CoolImage.jpg\", file); sender.send(message); 1346", "chunk_char_count": 1771, "chunk_word_count": 214, "chunk_token_count": 442.75}, {"page_number": 1347, "sentence_chunk": "Inline Resources The following example shows you how to use the MimeMessageHelper to send an email with an inline image: JavaMailSenderImpl sender = new JavaMailSenderImpl(); sender.setHost(\"mail.host.com\"); MimeMessage message = sender.createMimeMessage(); // use the true flag to indicate you need a multipart message MimeMessageHelper helper = new MimeMessageHelper(message, true); helper.setTo(\"test@host.com\"); // use the true flag to indicate the text included is HTML helper.setText(\"<html><body><img src='cid:identifier1234'></body></html>\", true); // let's include the infamous windows Sample file (this time copied to c:/) FileSystemResource res = new FileSystemResource(new File(\"c:/Sample.jpg\")); helper.addInline(\"identifier1234\", res); sender.send(message); \uf071 Inline resources are added to the MimeMessage by using the specified Content-ID (identifier1234 in the above example). The order in which you add the text and the resource are very important. Be sure to first add the text and then the resources. If you are doing it the other way around, it does not work. Creating Email Content by Using a Templating Library The code in the examples shown in the previous sections explicitly created the content of the email message, by using methods calls such as message.setText(..). This is fine for simple cases, and it is okay in the context of the aforementioned examples, where the intent was to show you the very basics of the API. In your typical enterprise application, though, developers often do not create the content of email messages by using the previously shown approach for a number of reasons: \u2022 Creating HTML-based email content in Java code is tedious and error prone. \u2022There is no clear separation between display logic and business logic. \u2022Changing the display structure of the email content requires writing Java code, recompiling, redeploying, and so on. Typically, the approach taken to address these issues is to use a template library (such as FreeMarker) to define the display structure of email content.", "chunk_char_count": 2041, "chunk_word_count": 298, "chunk_token_count": 510.25}, {"page_number": 1347, "sentence_chunk": "This leaves your code tasked only with creating the data that is to be rendered in the email template and sending the email. It is definitely a best practice when the content of your email messages becomes even moderately complex, and, with the Spring Framework\u2019s support classes for FreeMarker, it becomes quite easy to do.1347", "chunk_char_count": 328, "chunk_word_count": 55, "chunk_token_count": 82.0}, {"page_number": 1348, "sentence_chunk": "7.5. Task Execution and Scheduling The Spring Framework provides abstractions for the asynchronous execution and scheduling of tasks with the TaskExecutor and TaskScheduler interfaces, respectively. Spring also features implementations of those interfaces that support thread pools or delegation to CommonJ within an application server environment. Ultimately, the use of these implementations behind the common interfaces abstracts away the differences between Java SE 5, Java SE 6, and Jakarta EE environments. Spring also features integration classes to support scheduling with the Timer (part of the JDK since 1.3) and the Quartz Scheduler ( https://www.quartz-scheduler.org/). You can set up both of those schedulers by using a FactoryBean with optional references to Timer or Trigger instances, respectively. Furthermore, a convenience class for both the Quartz Scheduler and the Timer is available that lets you invoke a method of an existing target object (analogous to the normal MethodInvokingFactoryBean operation).7.5.1. The Spring TaskExecutor Abstraction Executors are the JDK name for the concept of thread pools. The \u201cexecutor\u201d naming is due to the fact that there is no guarantee that the underlying implementation is actually a pool.", "chunk_char_count": 1251, "chunk_word_count": 181, "chunk_token_count": 312.75}, {"page_number": 1348, "sentence_chunk": "An executor may be single-threaded or even synchronous. Spring\u2019s abstraction hides implementation details between the Java SE and Jakarta EE environments. Spring\u2019s TaskExecutor interface is identical to the java.util.concurrent. Executor interface. In fact, originally, its primary reason for existence was to abstract away the need for Java 5 when using thread pools. The interface has a single method (execute(Runnable task)) that accepts a task for execution based on the semantics and configuration of the thread pool. The TaskExecutor was originally created to give other Spring components an abstraction for thread pooling where needed. Components such as the ApplicationEventMulticaster, JMS\u2019s AbstractMessageListenerContainer, and Quartz integration all use the TaskExecutor abstraction to pool threads. However, if your beans need thread pooling behavior, you can also use this abstraction for your own needs. TaskExecutor Types Spring includes a number of pre-built implementations of TaskExecutor.", "chunk_char_count": 1008, "chunk_word_count": 140, "chunk_token_count": 252.0}, {"page_number": 1348, "sentence_chunk": "In all likelihood, you should never need to implement your own. The variants that Spring provides are as follows: \u2022 SyncTaskExecutor: This implementation does not run invocations asynchronously. Instead, each invocation takes place in the calling thread. It is primarily used in situations where multi- threading is not necessary, such as in simple test cases. \u2022SimpleAsyncTaskExecutor: This implementation does not reuse any threads. Rather, it starts up a new thread for each invocation. However, it does support a concurrency limit that blocks any invocations that are over the limit until a slot has been freed up. If you are looking for true pooling, see ThreadPoolTaskExecutor, later in this list. \u2022ConcurrentTaskExecutor: This implementation is an adapter for a java.util.concurrent. Executor instance.", "chunk_char_count": 809, "chunk_word_count": 120, "chunk_token_count": 202.25}, {"page_number": 1349, "sentence_chunk": "configuration parameters as bean properties. There is rarely a need to use ConcurrentTaskExecutor directly. However, if the ThreadPoolTaskExecutor is not flexible enough for your needs, ConcurrentTaskExecutor is an alternative. \u2022ThreadPoolTaskExecutor: This implementation is most commonly used. It exposes bean properties for configuring a java.util.concurrent. ThreadPoolExecutor and wraps it in a TaskExecutor. If you need to adapt to a different kind of java.util.concurrent. Executor, we recommend that you use a ConcurrentTaskExecutor instead. \u2022DefaultManagedTaskExecutor: This implementation uses a JNDI-obtained ManagedExecutorService in a JSR-236 compatible runtime environment (such as a Jakarta EE application server), replacing a CommonJ WorkManager for that purpose. Using a TaskExecutor Spring\u2019s TaskExecutor implementations are used as simple JavaBeans.", "chunk_char_count": 868, "chunk_word_count": 109, "chunk_token_count": 217.0}, {"page_number": 1349, "sentence_chunk": "In the following example, we define a bean that uses the ThreadPoolTaskExecutor to asynchronously print out a set of messages: import org.springframework.core.task. TaskExecutor; public class TaskExecutorExample { \u00a0  private class MessagePrinterTask implements Runnable { \u00a0    private String message; \u00a0    public MessagePrinterTask(String message) { \u00a0      this.message = message; \u00a0    } \u00a0    public void run() { \u00a0      System.out.println(message); \u00a0    } \u00a0  } \u00a0  private TaskExecutor taskExecutor; \u00a0  public TaskExecutorExample(TaskExecutor taskExecutor) { \u00a0    this.taskExecutor = taskExecutor; \u00a0  } \u00a0  public void printMessages() { \u00a0    for(int i = 0; i < 25; i++) { \u00a0      taskExecutor.execute(new MessagePrinterTask(\"Message\" + i)); \u00a0    } \u00a0  } } As you can see, rather than retrieving a thread from the pool and executing it yourself, you add your Runnable to the queue. Then the TaskExecutor uses its internal rules to decide when the task 1349", "chunk_char_count": 951, "chunk_word_count": 182, "chunk_token_count": 237.75}, {"page_number": 1350, "sentence_chunk": "gets run. To configure the rules that the TaskExecutor uses, we expose simple bean properties: <bean id=\"taskExecutor\" class=\"org.springframework.scheduling.concurrent. ThreadPoolTaskExecutor\"> \u00a0  <property name=\"corePoolSize\" value=\"5\"/> \u00a0  <property name=\"maxPoolSize\" value=\"10\"/> \u00a0  <property name=\"queueCapacity\" value=\"25\"/> </bean> <bean id=\"taskExecutorExample\" class=\"TaskExecutorExample\"> \u00a0  <constructor-arg ref=\"taskExecutor\"/> </bean> 7.5.2. The Spring TaskScheduler Abstraction In addition to the TaskExecutor abstraction, Spring 3.0 introduced a TaskScheduler with a variety of methods for scheduling tasks to run at some point in the future. The following listing shows the TaskScheduler interface definition: public interface TaskScheduler { \u00a0  ScheduledFuture schedule(Runnable task, Trigger trigger); \u00a0  ScheduledFuture schedule(Runnable task, Instant startTime); \u00a0  ScheduledFuture scheduleAtFixedRate(Runnable task, Instant startTime, Duration period); \u00a0  ScheduledFuture scheduleAtFixedRate(Runnable task, Duration period); \u00a0  ScheduledFuture scheduleWithFixedDelay(Runnable task, Instant startTime, Duration delay); \u00a0  ScheduledFuture scheduleWithFixedDelay(Runnable task, Duration delay); The simplest method is the one named schedule that takes only a Runnable and an Instant. That causes the task to run once after the specified time. All of the other methods are capable of scheduling tasks to run repeatedly. The fixed-rate and fixed-delay methods are for simple, periodic execution, but the method that accepts a Trigger is much more flexible. Trigger Interface The Trigger interface is essentially inspired by JSR-236 which, as of Spring 3.0, was not yet officially implemented. The basic idea of the Trigger is that execution times may be determined based on past execution outcomes or even arbitrary conditions.", "chunk_char_count": 1843, "chunk_word_count": 236, "chunk_token_count": 460.75}, {"page_number": 1350, "sentence_chunk": "If these determinations do take into account the outcome of the preceding execution, that information is available within a TriggerContext. The 1350", "chunk_char_count": 148, "chunk_word_count": 22, "chunk_token_count": 37.0}, {"page_number": 1351, "sentence_chunk": "Trigger interface itself is quite simple, as the following listing shows: public interface Trigger { \u00a0  Date nextExecutionTime(TriggerContext triggerContext); } The TriggerContext is the most important part. It encapsulates all of the relevant data and is open for extension in the future, if necessary. The TriggerContext is an interface (a SimpleTriggerContext implementation is used by default). The following listing shows the available methods for Trigger implementations.public interface TriggerContext { \u00a0  Date lastScheduledExecutionTime(); \u00a0  Date lastActualExecutionTime(); \u00a0  Date lastCompletionTime(); } Trigger Implementations Spring provides two implementations of the Trigger interface. The most interesting one is the CronTrigger. It enables the scheduling of tasks based on cron expressions. For example, the following task is scheduled to run 15 minutes past each hour but only during the 9-to-5 \u201cbusiness hours\u201d on weekdays: scheduler.schedule(task, new CronTrigger(\"0 15 9-17 * * MON-FRI\")); The other implementation is a PeriodicTrigger that accepts a fixed period, an optional initial delay value, and a boolean to indicate whether the period should be interpreted as a fixed-rate or a fixed- delay. Since the TaskScheduler interface already defines methods for scheduling tasks at a fixed rate or with a fixed delay, those methods should be used directly whenever possible. The value of the PeriodicTrigger implementation is that you can use it within components that rely on the Trigger abstraction.", "chunk_char_count": 1523, "chunk_word_count": 222, "chunk_token_count": 380.75}, {"page_number": 1351, "sentence_chunk": "For example, it may be convenient to allow periodic triggers, cron-based triggers, and even custom trigger implementations to be used interchangeably. Such a component could take advantage of dependency injection so that you can configure such Triggers externally and, therefore, easily modify or extend them. TaskScheduler implementations As with Spring\u2019s TaskExecutor abstraction, the primary benefit of the TaskScheduler arrangement is that an application\u2019s scheduling needs are decoupled from the deployment environment. This abstraction level is particularly relevant when deploying to an application server environment where threads should not be created directly by the application itself. For such scenarios, Spring 1351", "chunk_char_count": 728, "chunk_word_count": 100, "chunk_token_count": 182.0}, {"page_number": 1352, "sentence_chunk": "provides a TimerManagerTaskScheduler that delegates to a CommonJ TimerManager on WebLogic or WebSphere as well as a more recent DefaultManagedTaskScheduler that delegates to a JSR-236 ManagedScheduledExecutorService in a Jakarta EE environment. Both are typically configured with a JNDI lookup. Whenever external thread management is not a requirement, a simpler alternative is a local ScheduledExecutorService setup within the application, which can be adapted through Spring\u2019s ConcurrentTaskScheduler. As a convenience, Spring also provides a ThreadPoolTaskScheduler, which internally delegates to a ScheduledExecutorService to provide common bean-style configuration along the lines of ThreadPoolTaskExecutor. These variants work perfectly fine for locally embedded thread pool setups in lenient application server environments, as well\u2009\u2014\u2009in particular on Tomcat and Jetty.7.5.3. Annotation Support for Scheduling and Asynchronous Execution Spring provides annotation support for both task scheduling and asynchronous method execution. Enable Scheduling Annotations To enable support for @Scheduled and @Async annotations, you can add @EnableScheduling and @EnableAsync to one of your @Configuration classes, as the following example shows: @Configuration @EnableAsync @EnableScheduling public class AppConfig { } You can pick and choose the relevant annotations for your application. For example, if you need only support for @Scheduled, you can omit @EnableAsync. For more fine-grained control, you can additionally implement the SchedulingConfigurer interface, the AsyncConfigurer interface, or both.", "chunk_char_count": 1606, "chunk_word_count": 207, "chunk_token_count": 401.5}, {"page_number": 1352, "sentence_chunk": "See the SchedulingConfigurer and AsyncConfigurer javadoc for full details. If you prefer XML configuration, you can use the <task:annotation-driven> element, as the following example shows: <task:annotation-driven executor=\"myExecutor\" scheduler=\"myScheduler\"/> <task:executor id=\"myExecutor\" pool-size=\"5\"/> <task:scheduler id=\"myScheduler\" pool-size=\"10\"/> Note that, with the preceding XML, an executor reference is provided for handling those tasks that correspond to methods with the @Async annotation, and the scheduler reference is provided for managing those methods annotated with @Scheduled.1352", "chunk_char_count": 605, "chunk_word_count": 70, "chunk_token_count": 151.25}, {"page_number": 1353, "sentence_chunk": "\uf05a The default advice mode for processing @Async annotations is proxy which allows for interception of calls through the proxy only. Local calls within the same class cannot get intercepted that way. For a more advanced mode of interception, consider switching to aspectj mode in combination with compile-time or load-time weaving. The @Scheduled annotation You can add the @Scheduled annotation to a method, along with trigger metadata. For example, the following method is invoked every five seconds (5000 milliseconds) with a fixed delay, meaning that the period is measured from the completion time of each preceding invocation.@Scheduled(fixedDelay = 5000) public void doSomething() { \u00a0  // something that should run periodically } \uf05a By default, milliseconds will be used as the time unit for fixed delay, fixed rate, and initial delay values. If you would like to use a different time unit such as seconds or minutes, you can configure this via the timeUnit attribute in @Scheduled. For example, the previous example can also be written as follows.@Scheduled(fixedDelay = 5, timeUnit = TimeUnit. SECONDS) public void doSomething() { \u00a0  // something that should run periodically } If you need a fixed-rate execution, you can use the fixedRate attribute within the annotation.", "chunk_char_count": 1279, "chunk_word_count": 202, "chunk_token_count": 319.75}, {"page_number": 1353, "sentence_chunk": "The following method is invoked every five seconds (measured between the successive start times of each invocation).@Scheduled(fixedRate = 5, timeUnit = TimeUnit. SECONDS) public void doSomething() { \u00a0  // something that should run periodically } For fixed-delay and fixed-rate tasks, you can specify an initial delay by indicating the amount of time to wait before the first execution of the method, as the following fixedRate example shows.@Scheduled(initialDelay = 1000, fixedRate = 5000) public void doSomething() { \u00a0  // something that should run periodically } 1353", "chunk_char_count": 571, "chunk_word_count": 87, "chunk_token_count": 142.75}, {"page_number": 1354, "sentence_chunk": "If simple periodic scheduling is not expressive enough, you can provide a cron expression. The following example runs only on weekdays: @Scheduled(cron=\"*/5 * * * * MON-FRI\") public void doSomething() { \u00a0  // something that should run on weekdays only } \uf0eb You can also use the zone attribute to specify the time zone in which the cron expression is resolved. Notice that the methods to be scheduled must have void returns and must not accept any arguments. If the method needs to interact with other objects from the application context, those would typically have been provided through dependency injection.\uf05a As of Spring Framework 4.3, @Scheduled methods are supported on beans of any scope. Make sure that you are not initializing multiple instances of the same @Scheduled annotation class at runtime, unless you do want to schedule callbacks to each such instance. Related to this, make sure that you do not use @Configurable on bean classes that are annotated with @Scheduled and registered as regular Spring beans with the container. Otherwise, you would get double initialization (once through the container and once through the @Configurable aspect), with the consequence of each @Scheduled method being invoked twice. The @Async annotation You can provide the @Async annotation on a method so that invocation of that method occurs asynchronously. In other words, the caller returns immediately upon invocation, while the actual execution of the method occurs in a task that has been submitted to a Spring TaskExecutor.", "chunk_char_count": 1527, "chunk_word_count": 245, "chunk_token_count": 381.75}, {"page_number": 1354, "sentence_chunk": "In the simplest case, you can apply the annotation to a method that returns void, as the following example shows: @Async void doSomething() { \u00a0  // this will be run asynchronously } Unlike the methods annotated with the @Scheduled annotation, these methods can expect arguments, because they are invoked in the \u201cnormal\u201d way by callers at runtime rather than from a scheduled task being managed by the container. For example, the following code is a legitimate application of the @Async annotation: 1354", "chunk_char_count": 502, "chunk_word_count": 83, "chunk_token_count": 125.5}, {"page_number": 1355, "sentence_chunk": "@Async void doSomething(String s) { \u00a0  // this will be run asynchronously } Even methods that return a value can be invoked asynchronously. However, such methods are required to have a Future-typed return value. This still provides the benefit of asynchronous execution so that the caller can perform other tasks prior to calling get() on that Future. The following example shows how to use @Async on a method that returns a value: @Async Future<String> returnSomething(int i) { \u00a0  // this will be run asynchronously } \uf0eb @Async methods may not only declare a regular java.util.concurrent. Future return type but also Spring\u2019s org.springframework.util.concurrent. ListenableFuture or, as of Spring 4.2, JDK 8\u2019s java.util.concurrent. CompletableFuture, for richer interaction with the asynchronous task and for immediate composition with further processing steps. You can not use @Async in conjunction with lifecycle callbacks such as @PostConstruct. To asynchronously initialize Spring beans, you currently have to use a separate initializing Spring bean that then invokes the @Async annotated method on the target, as the following example shows: 1355", "chunk_char_count": 1151, "chunk_word_count": 173, "chunk_token_count": 287.75}, {"page_number": 1356, "sentence_chunk": "public class SampleBeanImpl implements SampleBean { \u00a0  @Async \u00a0  void doSomething() { \u00a0    // ... \u00a0  } } public class SampleBeanInitializer { \u00a0  private final SampleBean bean; \u00a0  public SampleBeanInitializer(SampleBean bean) { \u00a0    this.bean = bean; \u00a0  } \u00a0  @PostConstruct \u00a0  public void initialize() { \u00a0    bean.doSomething(); \u00a0  } } \uf05a There is no direct XML equivalent for @Async, since such methods should be designed for asynchronous execution in the first place, not externally re-declared to be asynchronous. However, you can manually set up Spring\u2019s AsyncExecutionInterceptor with Spring AOP, in combination with a custom pointcut. Executor Qualification with @Async By default, when specifying @Async on a method, the executor that is used is the one configured when enabling async support, i.e. the \u201cannotation-driven\u201d element if you are using XML or your AsyncConfigurer implementation, if any. However, you can use the value attribute of the @Async annotation when you need to indicate that an executor other than the default should be used when executing a given method. The following example shows how to do so: @Async(\"otherExecutor\") void doSomething(String s) { \u00a0  // this will be run asynchronously by \"otherExecutor\" } In this case, \"otherExecutor\" can be the name of any Executor bean in the Spring container, or it may be the name of a qualifier associated with any Executor (for example, as specified with the <qualifier> element or Spring\u2019s @Qualifier annotation).1356", "chunk_char_count": 1490, "chunk_word_count": 249, "chunk_token_count": 372.5}, {"page_number": 1357, "sentence_chunk": "Exception Management with @Async When an @Async method has a Future-typed return value, it is easy to manage an exception that was thrown during the method execution, as this exception is thrown when calling get on the Future result. With a void return type, however, the exception is uncaught and cannot be transmitted. You can provide an AsyncUncaughtExceptionHandler to handle such exceptions. The following example shows how to do so: public class MyAsyncUncaughtExceptionHandler implements AsyncUncaughtExceptionHandler { \u00a0  @Override \u00a0  public void handleUncaughtException(Throwable ex, Method method, Object... params) { \u00a0    // handle exception \u00a0  } } By default, the exception is merely logged. You can define a custom AsyncUncaughtExceptionHandler by using AsyncConfigurer or the <task:annotation-driven/> XML element.7.5.4. The task Namespace As of version 3.0, Spring includes an XML namespace for configuring TaskExecutor and TaskScheduler instances. It also provides a convenient way to configure tasks to be scheduled with a trigger. The 'scheduler' Element The following element creates a ThreadPoolTaskScheduler instance with the specified thread pool size: <task:scheduler id=\"scheduler\" pool-size=\"10\"/> The value provided for the id attribute is used as the prefix for thread names within the pool. The scheduler element is relatively straightforward.", "chunk_char_count": 1371, "chunk_word_count": 198, "chunk_token_count": 342.75}, {"page_number": 1357, "sentence_chunk": "If you do not provide a pool-size attribute, the default thread pool has only a single thread. There are no other configuration options for the scheduler. The executor Element The following creates a ThreadPoolTaskExecutor instance: <task:executor id=\"executor\" pool-size=\"10\"/> As with the scheduler shown in the previous section, the value provided for the id attribute is used as the prefix for thread names within the pool. As far as the pool size is concerned, the executor 1357", "chunk_char_count": 483, "chunk_word_count": 76, "chunk_token_count": 120.75}, {"page_number": 1358, "sentence_chunk": "element supports more configuration options than the scheduler element. For one thing, the thread pool for a ThreadPoolTaskExecutor is itself more configurable. Rather than only a single size, an executor\u2019s thread pool can have different values for the core and the max size. If you provide a single value, the executor has a fixed-size thread pool (the core and max sizes are the same). However, the executor element\u2019s pool-size attribute also accepts a range in the form of min-max. The following example sets a minimum value of 5 and a maximum value of 25: <task:executor \u00a0    id=\"executorWithPoolSizeRange\" \u00a0    pool-size=\"5-25\" \u00a0    queue-capacity=\"100\"/> In the preceding configuration, a queue-capacity value has also been provided. The configuration of the thread pool should also be considered in light of the executor\u2019s queue capacity. For the full description of the relationship between pool size and queue capacity, see the documentation for ThreadPoolExecutor. The main idea is that, when a task is submitted, the executor first tries to use a free thread if the number of active threads is currently less than the core size. If the core size has been reached, the task is added to the queue, as long as its capacity has not yet been reached.", "chunk_char_count": 1256, "chunk_word_count": 212, "chunk_token_count": 314.0}, {"page_number": 1358, "sentence_chunk": "Only then, if the queue\u2019s capacity has been reached, does the executor create a new thread beyond the core size. If the max size has also been reached, then the executor rejects the task. By default, the queue is unbounded, but this is rarely the desired configuration, because it can lead to OutOfMemoryErrors if enough tasks are added to that queue while all pool threads are busy. Furthermore, if the queue is unbounded, the max size has no effect at all. Since the executor always tries the queue before creating a new thread beyond the core size, a queue must have a finite capacity for the thread pool to grow beyond the core size (this is why a fixed-size pool is the only sensible case when using an unbounded queue). Consider the case, as mentioned above, when a task is rejected. By default, when a task is rejected, a thread pool executor throws a TaskRejectedException. However, the rejection policy is actually configurable. The exception is thrown when using the default rejection policy, which is the AbortPolicy implementation. For applications where some tasks can be skipped under heavy load, you can instead configure either DiscardPolicy or DiscardOldestPolicy.", "chunk_char_count": 1181, "chunk_word_count": 196, "chunk_token_count": 295.25}, {"page_number": 1358, "sentence_chunk": "Another option that works well for applications that need to throttle the submitted tasks under heavy load is the CallerRunsPolicy. Instead of throwing an exception or discarding tasks, that policy forces the thread that is calling the submit method to run the task itself. The idea is that such a caller is busy while running that task and not able to submit other tasks immediately. Therefore, it provides a simple way to throttle the incoming load while maintaining the limits of the thread pool and queue. Typically, this allows the executor to \u201ccatch up\u201d on the tasks it is handling and thereby frees up some capacity on the queue, in the pool, or both. You can choose any of these options from an enumeration of values available for the rejection-policy attribute on the executor element. The following example shows an executor element with a number of attributes to specify various behaviors: 1358", "chunk_char_count": 905, "chunk_word_count": 152, "chunk_token_count": 226.25}, {"page_number": 1359, "sentence_chunk": "<task:executor \u00a0    id=\"executorWithCallerRunsPolicy\" \u00a0    pool-size=\"5-25\" \u00a0    queue-capacity=\"100\" \u00a0    rejection-policy=\"CALLER_RUNS\"/> Finally, the keep-alive setting determines the time limit (in seconds) for which threads may remain idle before being stopped. If there are more than the core number of threads currently in the pool, after waiting this amount of time without processing a task, excess threads get stopped. A time value of zero causes excess threads to stop immediately after executing a task without remaining follow-up work in the task queue. The following example sets the keep-alive value to two minutes: <task:executor \u00a0    id=\"executorWithKeepAlive\" \u00a0    pool-size=\"5-25\" \u00a0    keep-alive=\"120\"/> The 'scheduled-tasks' Element The most powerful feature of Spring\u2019s task namespace is the support for configuring tasks to be scheduled within a Spring Application Context. This follows an approach similar to other \u201cmethod- invokers\u201d in Spring, such as that provided by the JMS namespace for configuring message-driven POJOs. Basically, a ref attribute can point to any Spring-managed object, and the method attribute provides the name of a method to be invoked on that object. The following listing shows a simple example: <task:scheduled-tasks scheduler=\"myScheduler\"> \u00a0  <task:scheduled ref=\"beanA\" method=\"methodA\" fixed-delay=\"5000\"/> </task:scheduled-tasks> <task:scheduler id=\"myScheduler\" pool-size=\"10\"/> The scheduler is referenced by the outer element, and each individual task includes the configuration of its trigger metadata. In the preceding example, that metadata defines a periodic trigger with a fixed delay indicating the number of milliseconds to wait after each task execution has completed. Another option is fixed-rate, indicating how often the method should be run regardless of how long any previous execution takes. Additionally, for both fixed-delay and fixed- rate tasks, you can specify an 'initial-delay' parameter, indicating the number of milliseconds to wait before the first execution of the method.", "chunk_char_count": 2058, "chunk_word_count": 304, "chunk_token_count": 514.5}, {"page_number": 1359, "sentence_chunk": "For more control, you can instead provide a cron attribute to provide a cron expression. The following example shows these other options: 1359", "chunk_char_count": 142, "chunk_word_count": 23, "chunk_token_count": 35.5}, {"page_number": 1360, "sentence_chunk": "<task:scheduled-tasks scheduler=\"myScheduler\"> \u00a0  <task:scheduled ref=\"beanA\" method=\"methodA\" fixed-delay=\"5000\" initial- delay=\"1000\"/> \u00a0  <task:scheduled ref=\"beanB\" method=\"methodB\" fixed-rate=\"5000\"/> \u00a0  <task:scheduled ref=\"beanC\" method=\"methodC\" cron=\"*/5 * * * * MON-FRI\"/> </task:scheduled-tasks> <task:scheduler id=\"myScheduler\" pool-size=\"10\"/> 7.5.5. Cron Expressions All Spring cron expressions have to conform to the same format, whether you are using them in @Scheduled annotations, task:scheduled-tasks elements, or someplace else. A well-formed cron expression, such as * * * * * *, consists of six space-separated time and date fields, each with its own range of valid values: \u00a0\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 second (0-59) \u00a0\u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 minute (0 - 59) \u00a0\u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 hour (0 - 23) \u00a0\u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 day of the month (1 - 31) \u00a0\u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 month (1 - 12) (or JAN-DEC) \u00a0\u2502 \u2502 \u2502 \u2502 \u2502 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500 day of the week (0 - 7) \u00a0\u2502 \u2502 \u2502 \u2502 \u2502 \u2502     (0 or 7 is Sunday, or MON-SUN) \u00a0\u2502 \u2502 \u2502 \u2502 \u2502 \u2502 \u00a0* * * * * * There are some rules that apply: \u2022 A field may be an asterisk (*), which always stands for \u201cfirst-last\u201d. For the day-of-the-month or day-of-the-week fields, a question mark (?)may be used instead of an asterisk. \u2022Commas (,) are used to separate items of a list. \u2022Two numbers separated with a hyphen (-) express a range of numbers. The specified range is inclusive. \u2022Following a range (or *) with / specifies the interval of the number\u2019s value through the range. \u2022English names can also be used for the month and day-of-week fields.", "chunk_char_count": 1549, "chunk_word_count": 257, "chunk_token_count": 387.25}, {"page_number": 1360, "sentence_chunk": "Use the first three letters of the particular day or month (case does not matter). \u2022The day-of-month and day-of-week fields can contain a L character, which has a different meaning \u25e6 In the day-of-month field, L stands for the last day of the month. If followed by a negative offset (that is, L-n), it means nth-to-last day of the month.\u25e6 In the day-of-week field, L stands for the last day of the week. If prefixed by a number or three-letter name (dL or DDDL), it means the last day of week (d or DDD) in the month. \u2022The day-of-month field can be nW, which stands for the nearest weekday to day of the month n. If n falls on Saturday, this yields the Friday before it. If n falls on Sunday, this yields the Monday 1360", "chunk_char_count": 720, "chunk_word_count": 136, "chunk_token_count": 180.0}, {"page_number": 1361, "sentence_chunk": "after, which also happens if n is 1 and falls on a Saturday (that is: 1W stands for the first weekday of the month). \u2022If the day-of-month field is LW, it means the last weekday of the month. \u2022The day-of-week field can be d#n (or DDD#n), which stands for the nth day of week d (or DDD) in the month. Here are some examples: Cron Expression Meaning 0 0 * * * * top of every hour of every day */10 * * * * * every ten seconds 0 0 8-10 * * * 8, 9 and 10 o\u2019clock of every day 0 0 6,19 * * * 6:00 AM and 7:00 PM every day 0 0/30 8-10 * * * 8:00, 8:30, 9:00, 9:30, 10:00 and 10:30 every day 0 0 9-17 * * MON-FRI on the hour nine-to-five weekdays 0 0 0 25 DEC ?every Christmas Day at midnight 0 0 0 L * * last day of the month at midnight 0 0 0 L-3 * * third-to-last day of the month at midnight 0 0 0 * * 5L last Friday of the month at midnight 0 0 0 * * THUL last Thursday of the month at midnight 0 0 0 1W * * first weekday of the month at midnight 0 0 0 LW * * last weekday of the month at midnight 0 0 0 ? *5#2 the second Friday in the month at midnight 0 0 0 ? *MON#1 the first Monday in the month at midnight Macros Expressions such as 0 0 * * * * are hard for humans to parse and are, therefore, hard to fix in case of bugs. To improve readability, Spring supports the following macros, which represent commonly used sequences. You can use these macros instead of the six-digit value, thus: @Scheduled(cron = \"@hourly\"). Macro Meaning @yearly (or @annually) once a year (0 0 0 1 1 *) @monthly once a month (0 0 0 1 * *) @weekly once a week (0 0 0 * * 0) @daily (or @midnight) once a day (0 0 0 * * *), or @hourly once an hour, (0 0 * * * *) 1361", "chunk_char_count": 1645, "chunk_word_count": 367, "chunk_token_count": 411.25}, {"page_number": 1362, "sentence_chunk": "7.5.6. Using the Quartz Scheduler Quartz uses Trigger, Job, and JobDetail objects to realize scheduling of all kinds of jobs. For the basic concepts behind Quartz, see https://www.quartz-scheduler.org/. For convenience purposes, Spring offers a couple of classes that simplify using Quartz within Spring-based applications. Using the JobDetailFactoryBean Quartz JobDetail objects contain all the information needed to run a job. Spring provides a JobDetailFactoryBean, which provides bean-style properties for XML configuration purposes. Consider the following example: <bean name=\"exampleJob\" class=\"org.springframework.scheduling.quartz. JobDetailFactoryBean\"> \u00a0  <property name=\"jobClass\" value=\"example. ExampleJob\"/> \u00a0  <property name=\"jobDataAsMap\"> \u00a0    <map> \u00a0      <entry key=\"timeout\" value=\"5\"/> \u00a0    </map> \u00a0  </property> </bean> The job detail configuration has all the information it needs to run the job (ExampleJob). The timeout is specified in the job data map. The job data map is available through the JobExecutionContext (passed to you at execution time), but the JobDetail also gets its properties from the job data mapped to properties of the job instance.", "chunk_char_count": 1178, "chunk_word_count": 169, "chunk_token_count": 294.5}, {"page_number": 1362, "sentence_chunk": "So, in the following example, the ExampleJob contains a bean property named timeout, and the JobDetail has it applied automatically: package example; public class ExampleJob extends QuartzJobBean { \u00a0  private int timeout; \u00a0  /** \u00a0  * Setter called after the ExampleJob is instantiated \u00a0  * with the value from the JobDetailFactoryBean (5) \u00a0  */ \u00a0  public void setTimeout(int timeout) { \u00a0    this.timeout = timeout; \u00a0  } \u00a0  protected void executeInternal(JobExecutionContext ctx) throws JobExecutionException { \u00a0    // do the actual work \u00a0  } } 1362", "chunk_char_count": 548, "chunk_word_count": 99, "chunk_token_count": 137.0}, {"page_number": 1363, "sentence_chunk": "All additional properties from the job data map are available to you as well.\uf05a By using the name and group properties, you can modify the name and the group of the job, respectively. By default, the name of the job matches the bean name of the JobDetailFactoryBean (exampleJob in the preceding example above). Using the MethodInvokingJobDetailFactoryBean Often you merely need to invoke a method on a specific object. By using the MethodInvokingJobDetailFactoryBean, you can do exactly this, as the following example shows: <bean id=\"jobDetail\" class=\"org.springframework.scheduling.quartz. MethodInvokingJobDetailFactoryBean\"> \u00a0  <property name=\"targetObject\" ref=\"exampleBusinessObject\"/> \u00a0  <property name=\"targetMethod\" value=\"doIt\"/> </bean> The preceding example results in the doIt method being called on the exampleBusinessObject method, as the following example shows: public class ExampleBusinessObject { \u00a0  // properties and collaborators \u00a0  public void doIt() { \u00a0    // do the actual work \u00a0  } } <bean id=\"exampleBusinessObject\" class=\"examples. ExampleBusinessObject\"/> By using the MethodInvokingJobDetailFactoryBean, you need not create one-line jobs that merely invoke a method. You need only create the actual business object and wire up the detail object. By default, Quartz Jobs are stateless, resulting in the possibility of jobs interfering with each other. If you specify two triggers for the same JobDetail, it is possible that, before the first job has finished, the second one starts.", "chunk_char_count": 1509, "chunk_word_count": 217, "chunk_token_count": 377.25}, {"page_number": 1363, "sentence_chunk": "If JobDetail classes implement the Stateful interface, this does not happen. The second job does not start before the first one has finished. To make jobs resulting from the MethodInvokingJobDetailFactoryBean be non-concurrent, set the concurrent flag to false, as the following example shows: 1363", "chunk_char_count": 298, "chunk_word_count": 44, "chunk_token_count": 74.5}, {"page_number": 1364, "sentence_chunk": "<bean id=\"jobDetail\" class=\"org.springframework.scheduling.quartz. MethodInvokingJobDetailFactoryBean\"> \u00a0  <property name=\"targetObject\" ref=\"exampleBusinessObject\"/> \u00a0  <property name=\"targetMethod\" value=\"doIt\"/> \u00a0  <property name=\"concurrent\" value=\"false\"/> </bean> \uf05a By default, jobs will run in a concurrent fashion. Wiring up Jobs by Using Triggers and SchedulerFactoryBean We have created job details and jobs. We have also reviewed the convenience bean that lets you invoke a method on a specific object. Of course, we still need to schedule the jobs themselves. This is done by using triggers and a SchedulerFactoryBean. Several triggers are available within Quartz, and Spring offers two Quartz FactoryBean implementations with convenient defaults: CronTriggerFactoryBean and SimpleTriggerFactoryBean. Triggers need to be scheduled. Spring offers a SchedulerFactoryBean that exposes triggers to be set as properties. SchedulerFactoryBean schedules the actual jobs with those triggers.", "chunk_char_count": 995, "chunk_word_count": 125, "chunk_token_count": 248.75}, {"page_number": 1364, "sentence_chunk": "The following listing uses both a SimpleTriggerFactoryBean and a CronTriggerFactoryBean: <bean id=\"simpleTrigger\" class=\"org.springframework.scheduling.quartz. SimpleTriggerFactoryBean\"> \u00a0  <!--see the example of method invoking job above --> \u00a0  <property name=\"jobDetail\" ref=\"jobDetail\"/> \u00a0  <!--10 seconds --> \u00a0  <property name=\"startDelay\" value=\"10000\"/> \u00a0  <!--repeat every 50 seconds --> \u00a0  <property name=\"repeatInterval\" value=\"50000\"/> </bean> <bean id=\"cronTrigger\" class=\"org.springframework.scheduling.quartz. CronTriggerFactoryBean\"> \u00a0  <property name=\"jobDetail\" ref=\"exampleJob\"/> \u00a0  <!--run every morning at 6 AM --> \u00a0  <property name=\"cronExpression\" value=\"0 0 6 * * ?\"/> </bean> The preceding example sets up two triggers, one running every 50 seconds with a starting delay of 10 seconds and one running every morning at 6 AM. To finalize everything, we need to set up the SchedulerFactoryBean, as the following example shows: 1364", "chunk_char_count": 951, "chunk_word_count": 125, "chunk_token_count": 237.75}, {"page_number": 1365, "sentence_chunk": "<bean class=\"org.springframework.scheduling.quartz. SchedulerFactoryBean\"> \u00a0  <property name=\"triggers\"> \u00a0    <list> \u00a0      <ref bean=\"cronTrigger\"/> \u00a0      <ref bean=\"simpleTrigger\"/> \u00a0    </list> \u00a0  </property> </bean> More properties are available for the SchedulerFactoryBean, such as the calendars used by the job details, properties to customize Quartz with, and a Spring-provided JDBC DataSource. See the SchedulerFactoryBean javadoc for more information.\uf05a SchedulerFactoryBean also recognizes a quartz.properties file in the classpath, based on Quartz property keys, as with regular Quartz configuration. Please note that many SchedulerFactoryBean settings interact with common Quartz settings in the properties file; it is therefore not recommended to specify values at both levels. For example, do not set an \"org.quartz.jobStore.class\" property if you mean to rely on a Spring-provided DataSource, or specify an org.springframework.scheduling.quartz. LocalDataSourceJobStore variant which is a full-fledged replacement for the standard org.quartz.impl.jdbcjobstore. JobStoreTX.7.6. Cache Abstraction Since version 3.1, the Spring Framework provides support for transparently adding caching to an existing Spring application.", "chunk_char_count": 1235, "chunk_word_count": 167, "chunk_token_count": 308.75}, {"page_number": 1365, "sentence_chunk": "Similar to the transaction support, the caching abstraction allows consistent use of various caching solutions with minimal impact on the code. In Spring Framework 4.1, the cache abstraction was significantly extended with support for JSR-107 annotations and more customization options.7.6.1. Understanding the Cache Abstraction 1365", "chunk_char_count": 333, "chunk_word_count": 45, "chunk_token_count": 83.25}, {"page_number": 1366, "sentence_chunk": "Cache vs Buffer The terms, \u201cbuffer\u201d and \u201ccache,\u201d tend to be used interchangeably. Note, however, that they represent different things. Traditionally, a buffer is used as an intermediate temporary store for data between a fast and a slow entity. As one party would have to wait for the other (which affects performance), the buffer alleviates this by allowing entire blocks of data to move at once rather than in small chunks. The data is written and read only once from the buffer. Furthermore, the buffers are visible to at least one party that is aware of it. A cache, on the other hand, is, by definition, hidden, and neither party is aware that caching occurs. It also improves performance but does so by letting the same data be read multiple times in a fast fashion. You can find a further explanation of the differences between a buffer and a cache here. At its core, the cache abstraction applies caching to Java methods, thus reducing the number of executions based on the information available in the cache.", "chunk_char_count": 1017, "chunk_word_count": 176, "chunk_token_count": 254.25}, {"page_number": 1366, "sentence_chunk": "That is, each time a targeted method is invoked, the abstraction applies a caching behavior that checks whether the method has been already invoked for the given arguments. If it has been invoked, the cached result is returned without having to invoke the actual method. If the method has not been invoked, then it is invoked, and the result is cached and returned to the user so that, the next time the method is invoked, the cached result is returned. This way, expensive methods (whether CPU- or IO-bound) can be invoked only once for a given set of parameters and the result reused without having to actually invoke the method again. The caching logic is applied transparently without any interference to the invoker.\uf06a This approach works only for methods that are guaranteed to return the same output (result) for a given input (or arguments) no matter how many times they are invoked. The caching abstraction provides other cache-related operations, such as the ability to update the content of the cache or to remove one or all entries. These are useful if the cache deals with data that can change during the course of the application. As with other services in the Spring Framework, the caching service is an abstraction (not a cache implementation) and requires the use of actual storage to store the cache data\u2009\u2014\u2009that is, the abstraction frees you from having to write the caching logic but does not provide the actual data store. This abstraction is materialized by the org.springframework.cache.", "chunk_char_count": 1508, "chunk_word_count": 252, "chunk_token_count": 377.0}, {"page_number": 1366, "sentence_chunk": "Cache and org.springframework.cache. CacheManager interfaces. Spring provides a few implementations of that abstraction: JDK java.util.concurrent. ConcurrentMap based caches, Gemfire cache, Caffeine, and JSR-107 compliant caches (such as Ehcache 3.x). See Plugging-in Different Back-end Caches for more information on plugging in other cache stores and providers.\uf06a The caching abstraction has no special handling for multi-threaded and multi- process environments, as such features are handled by the cache implementation.1366", "chunk_char_count": 526, "chunk_word_count": 67, "chunk_token_count": 131.5}, {"page_number": 1367, "sentence_chunk": "If you have a multi-process environment (that is, an application deployed on several nodes), you need to configure your cache provider accordingly. Depending on your use cases, a copy of the same data on several nodes can be enough. However, if you change the data during the course of the application, you may need to enable other propagation mechanisms. Caching a particular item is a direct equivalent of the typical get-if-not-found-then-proceed-and-put- eventually code blocks found with programmatic cache interaction. No locks are applied, and several threads may try to load the same item concurrently. The same applies to eviction. If several threads are trying to update or evict data concurrently, you may use stale data. Certain cache providers offer advanced features in that area. See the documentation of your cache provider for more details. To use the cache abstraction, you need to take care of two aspects: \u2022 Caching declaration: Identify the methods that need to be cached and their policies. \u2022", "chunk_char_count": 1014, "chunk_word_count": 162, "chunk_token_count": 253.5}, {"page_number": 1367, "sentence_chunk": "Cache configuration: The backing cache where the data is stored and from which it is read.7.6.2. Declarative Annotation-based Caching For caching declaration, Spring\u2019s caching abstraction provides a set of Java annotations: \u2022 @Cacheable: Triggers cache population. \u2022@CacheEvict: Triggers cache eviction. \u2022@CachePut: Updates the cache without interfering with the method execution. \u2022@Caching: Regroups multiple cache operations to be applied on a method. \u2022@CacheConfig: Shares some common cache-related settings at class-level. The @Cacheable Annotation As the name implies, you can use @Cacheable to demarcate methods that are cacheable\u2009\u2014\u2009that is, methods for which the result is stored in the cache so that, on subsequent invocations (with the same arguments), the value in the cache is returned without having to actually invoke the method. In its simplest form, the annotation declaration requires the name of the cache associated with the annotated method, as the following example shows: @Cacheable(\"books\") public Book findBook(ISBN isbn) {...} In the preceding snippet, the findBook method is associated with the cache named books. Each time the method is called, the cache is checked to see whether the invocation has already been run and does not have to be repeated.", "chunk_char_count": 1276, "chunk_word_count": 189, "chunk_token_count": 319.0}, {"page_number": 1367, "sentence_chunk": "While in most cases, only one cache is declared, the annotation lets multiple names be specified so that more than one cache is being used. In this case, each of the caches is checked before invoking the method\u2009\u2014\u2009if at least one cache is hit, the associated value is returned.1367", "chunk_char_count": 280, "chunk_word_count": 49, "chunk_token_count": 70.0}, {"page_number": 1368, "sentence_chunk": "\uf05a All the other caches that do not contain the value are also updated, even though the cached method was not actually invoked. The following example uses @Cacheable on the findBook method with multiple caches: @Cacheable({\"books\", \"isbns\"}) public Book findBook(ISBN isbn) {...} Default Key Generation Since caches are essentially key-value stores, each invocation of a cached method needs to be translated into a suitable key for cache access. The caching abstraction uses a simple KeyGenerator based on the following algorithm: \u2022 If no params are given, return SimpleKey. EMPTY. \u2022If only one param is given, return that instance. \u2022If more than one param is given, return a SimpleKey that contains all parameters. This approach works well for most use-cases, as long as parameters have natural keys and implement valid hashCode() and equals() methods. If that is not the case, you need to change the strategy. To provide a different default key generator, you need to implement the org.springframework.cache.interceptor. KeyGenerator interface.", "chunk_char_count": 1045, "chunk_word_count": 160, "chunk_token_count": 261.25}, {"page_number": 1368, "sentence_chunk": "\uf05a The default key generation strategy changed with the release of Spring 4.0. Earlier versions of Spring used a key generation strategy that, for multiple key parameters, considered only the hashCode() of parameters and not equals(). This could cause unexpected key collisions (see SPR-10237 for background). The new SimpleKeyGenerator uses a compound key for such scenarios. If you want to keep using the previous key strategy, you can configure the deprecated org.springframework.cache.interceptor. DefaultKeyGenerator class or create a custom hash-based KeyGenerator implementation. Custom Key Generation Declaration Since caching is generic, the target methods are quite likely to have various signatures that cannot be readily mapped on top of the cache structure. This tends to become obvious when the target method has multiple arguments out of which only some are suitable for caching (while the rest are used only by the method logic). Consider the following example: @Cacheable(\"books\") public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed) At first glance, while the two boolean arguments influence the way the book is found, they are no 1368", "chunk_char_count": 1176, "chunk_word_count": 173, "chunk_token_count": 294.0}, {"page_number": 1369, "sentence_chunk": "use for the cache. Furthermore, what if only one of the two is important while the other is not?For such cases, the @Cacheable annotation lets you specify how the key is generated through its key attribute. You can use SpEL to pick the arguments of interest (or their nested properties), perform operations, or even invoke arbitrary methods without having to write any code or implement any interface. This is the recommended approach over the default generator, since methods tend to be quite different in signatures as the code base grows. While the default strategy might work for some methods, it rarely works for all methods. The following examples use various SpEL declarations (if you are not familiar with SpEL, do yourself a favor and read Spring Expression Language): @Cacheable(cacheNames=\"books\", key=\"#isbn\") public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed) @Cacheable(cacheNames=\"books\", key=\"#isbn.rawNumber\") public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed) @Cacheable(cacheNames=\"books\", key=\"T(someType).hash(#isbn)\") public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed) The preceding snippets show how easy it is to select a certain argument, one of its properties, or even an arbitrary (static) method. If the algorithm responsible for generating the key is too specific or if it needs to be shared, you can define a custom keyGenerator on the operation. To do so, specify the name of the KeyGenerator bean implementation to use, as the following example shows: @Cacheable(cacheNames=\"books\", keyGenerator=\"myKeyGenerator\") public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed) \uf05a The key and keyGenerator parameters are mutually exclusive and an operation that specifies both results in an exception. Default Cache Resolution The caching abstraction uses a simple CacheResolver that retrieves the caches defined at the operation level by using the configured CacheManager.", "chunk_char_count": 1995, "chunk_word_count": 279, "chunk_token_count": 498.75}, {"page_number": 1369, "sentence_chunk": "To provide a different default cache resolver, you need to implement the org.springframework.cache.interceptor. CacheResolver interface. Custom Cache Resolution The default cache resolution fits well for applications that work with a single CacheManager and have no complex cache resolution requirements. For applications that work with several cache managers, you can set the cacheManager to use for 1369", "chunk_char_count": 405, "chunk_word_count": 56, "chunk_token_count": 101.25}, {"page_number": 1370, "sentence_chunk": "each operation, as the following example shows: @Cacheable(cacheNames=\"books\", cacheManager=\"anotherCacheManager\") \u2460 public Book findBook(ISBN isbn) {...} \u2460 Specifying anotherCacheManager. You can also replace the CacheResolver entirely in a fashion similar to that of replacing key generation. The resolution is requested for every cache operation, letting the implementation actually resolve the caches to use based on runtime arguments. The following example shows how to specify a CacheResolver: @Cacheable(cacheResolver=\"runtimeCacheResolver\") \u2460 public Book findBook(ISBN isbn) {...} \u2460 Specifying the CacheResolver.\uf05a Since Spring 4.1, the value attribute of the cache annotations are no longer mandatory, since this particular information can be provided by the CacheResolver regardless of the content of the annotation. Similarly to key and keyGenerator, the cacheManager and cacheResolver parameters are mutually exclusive, and an operation specifying both results in an exception, as a custom CacheManager is ignored by the CacheResolver implementation. This is probably not what you expect. Synchronized Caching In a multi-threaded environment, certain operations might be concurrently invoked for the same argument (typically on startup). By default, the cache abstraction does not lock anything, and the same value may be computed several times, defeating the purpose of caching. For those particular cases, you can use the sync attribute to instruct the underlying cache provider to lock the cache entry while the value is being computed.", "chunk_char_count": 1550, "chunk_word_count": 215, "chunk_token_count": 387.5}, {"page_number": 1370, "sentence_chunk": "As a result, only one thread is busy computing the value, while the others are blocked until the entry is updated in the cache. The following example shows how to use the sync attribute: @Cacheable(cacheNames=\"foos\", sync=true) \u2460 public Foo executeExpensiveOperation(String id) {...} \u2460 Using the sync attribute.\uf05a This is an optional feature, and your favorite cache library may not support it. All CacheManager implementations provided by the core framework support it. See the documentation of your cache provider for more details.1370", "chunk_char_count": 536, "chunk_word_count": 81, "chunk_token_count": 134.0}, {"page_number": 1371, "sentence_chunk": "Conditional Caching Sometimes, a method might not be suitable for caching all the time (for example, it might depend on the given arguments). The cache annotations support such use cases through the condition parameter, which takes a SpEL expression that is evaluated to either true or false. If true, the method is cached. If not, it behaves as if the method is not cached (that is, the method is invoked every time no matter what values are in the cache or what arguments are used). For example, the following method is cached only if the argument name has a length shorter than 32: @Cacheable(cacheNames=\"book\", condition=\"#name.length() < 32\") \u2460 public Book findBook(String name) \u2460 Setting a condition on @Cacheable. In addition to the condition parameter, you can use the unless parameter to veto the adding of a value to the cache. Unlike condition, unless expressions are evaluated after the method has been invoked. To expand on the previous example, perhaps we only want to cache paperback books, as the following example does: @Cacheable(cacheNames=\"book\", condition=\"#name.length() < 32\", unless=\"#result.hardback\") \u2460 public Book findBook(String name) \u2460 Using the unless attribute to block hardbacks. The cache abstraction supports java.util. Optional return types.", "chunk_char_count": 1276, "chunk_word_count": 197, "chunk_token_count": 319.0}, {"page_number": 1371, "sentence_chunk": "If an Optional value is present, it will be stored in the associated cache. If an Optional value is not present, null will be stored in the associated cache. #result always refers to the business entity and never a supported wrapper, so the previous example can be rewritten as follows: @Cacheable(cacheNames=\"book\", condition=\"#name.length() < 32\", unless=\"#result?.hardback\") public Optional<Book> findBook(String name) Note that #result still refers to Book and not Optional<Book>. Since it might be null, we use SpEL\u2019s safe navigation operator. Available Caching SpEL Evaluation Context Each SpEL expression evaluates against a dedicated context. In addition to the built-in parameters, the framework provides dedicated caching-related metadata, such as the argument names. The following table describes the items made available to the context so that you can use them for key and conditional computations: Table 35. Cache SpEL available metadata 1371", "chunk_char_count": 955, "chunk_word_count": 139, "chunk_token_count": 238.75}, {"page_number": 1372, "sentence_chunk": "Name Location Description Example methodName Root object The name of the method being invoked #root.methodName method Root object The method being invoked #root.method.name target Root object The target object being invoked #root.target targetClass Root object The class of the target being invoked #root.targetClass args Root object The arguments (as array) used for invoking the target #root.args[0] caches Root object Collection of caches against which the current method is run #root.caches[0].name Argument name Evaluation context Name of any of the method arguments. If the names are not available (perhaps due to having no debug information), the argument names are also available under the #a<#arg> where #arg stands for the argument index (starting from 0). #iban or #a0 (you can also use #p0 or #p<#arg> notation as an alias).result Evaluation context The result of the method call (the value to be cached). Only available in unless expressions, cache put expressions (to compute the key), or cache evict expressions (when beforeInvocation is false). For supported wrappers (such as Optional), #result refers to the actual object, not the wrapper. #result 1372", "chunk_char_count": 1170, "chunk_word_count": 177, "chunk_token_count": 292.5}, {"page_number": 1373, "sentence_chunk": "The @CachePut Annotation When the cache needs to be updated without interfering with the method execution, you can use the @CachePut annotation. That is, the method is always invoked and its result is placed into the cache (according to the @CachePut options). It supports the same options as @Cacheable and should be used for cache population rather than method flow optimization. The following example uses the @CachePut annotation: @CachePut(cacheNames=\"book\", key=\"#isbn\") public Book updateBook(ISBN isbn, BookDescriptor descriptor) \uf06a Using @CachePut and @Cacheable annotations on the same method is generally strongly discouraged because they have different behaviors. While the latter causes the method invocation to be skipped by using the cache, the former forces the invocation in order to run a cache update. This leads to unexpected behavior and, with the exception of specific corner-cases (such as annotations having conditions that exclude them from each other), such declarations should be avoided. Note also that such conditions should not rely on the result object (that is, the #result variable), as these are validated up-front to confirm the exclusion. The @CacheEvict annotation The cache abstraction allows not just population of a cache store but also eviction. This process is useful for removing stale or unused data from the cache. As opposed to @Cacheable, @CacheEvict demarcates methods that perform cache eviction (that is, methods that act as triggers for removing data from the cache).", "chunk_char_count": 1517, "chunk_word_count": 229, "chunk_token_count": 379.25}, {"page_number": 1373, "sentence_chunk": "Similarly to its sibling, @CacheEvict requires specifying one or more caches that are affected by the action, allows a custom cache and key resolution or a condition to be specified, and features an extra parameter (allEntries) that indicates whether a cache-wide eviction needs to be performed rather than just an entry eviction (based on the key). The following example evicts all entries from the books cache: @CacheEvict(cacheNames=\"books\", allEntries=true) \u2460 public void loadBooks(InputStream batch) \u2460 Using the allEntries attribute to evict all entries from the cache. This option comes in handy when an entire cache region needs to be cleared out. Rather than evicting each entry (which would take a long time, since it is inefficient), all the entries are removed in one operation, as the preceding example shows. Note that the framework ignores any key specified in this scenario as it does not apply (the entire cache is evicted, not only one entry). You can also indicate whether the eviction should occur after (the default) or before the method is invoked by using the beforeInvocation attribute. The former provides the same semantics as the rest of the annotations: Once the method completes successfully, an action (in this case, eviction) on the cache is run. If the method does not run (as it might be cached) or an exception is thrown, the eviction does not occur. The latter (beforeInvocation=true) causes the eviction to always occur before the method is invoked. This is useful in cases where the eviction does not need to be tied to 1373", "chunk_char_count": 1560, "chunk_word_count": 255, "chunk_token_count": 390.0}, {"page_number": 1374, "sentence_chunk": "the method outcome. Note that void methods can be used with @CacheEvict - as the methods act as a trigger, the return values are ignored (as they do not interact with the cache). This is not the case with @Cacheable which adds data to the cache or updates data in the cache and, thus, requires a result. The @Caching Annotation Sometimes, multiple annotations of the same type (such as @CacheEvict or @CachePut) need to be specified\u2009\u2014\u2009for example, because the condition or the key expression is different between different caches.@Caching lets multiple nested @Cacheable, @CachePut, and @CacheEvict annotations be used on the same method. The following example uses two @CacheEvict annotations: @Caching(evict = { @CacheEvict(\"primary\"), @CacheEvict(cacheNames=\"secondary\", key=\"#p0\") }) public Book importBooks(String deposit, Date date) The @CacheConfig annotation So far, we have seen that caching operations offer many customization options and that you can set these options for each operation. However, some of the customization options can be tedious to configure if they apply to all operations of the class. For instance, specifying the name of the cache to use for every cache operation of the class can be replaced by a single class-level definition. This is where @CacheConfig comes into play. The following examples uses @CacheConfig to set the name of the cache: @CacheConfig(\"books\") \u2460 public class BookRepositoryImpl implements BookRepository { \u00a0  @Cacheable \u00a0  public Book findBook(ISBN isbn) {...} } \u2460 Using @CacheConfig to set the name of the cache.", "chunk_char_count": 1568, "chunk_word_count": 241, "chunk_token_count": 392.0}, {"page_number": 1374, "sentence_chunk": "@CacheConfig is a class-level annotation that allows sharing the cache names, the custom KeyGenerator, the custom CacheManager, and the custom CacheResolver. Placing this annotation on the class does not turn on any caching operation. An operation-level customization always overrides a customization set on @CacheConfig. Therefore, this gives three levels of customizations for each cache operation: \u2022 Globally configured, available for CacheManager, KeyGenerator. \u2022At the class level, using @CacheConfig. \u2022At the operation level.1374", "chunk_char_count": 535, "chunk_word_count": 72, "chunk_token_count": 133.75}, {"page_number": 1375, "sentence_chunk": "Enabling Caching Annotations It is important to note that even though declaring the cache annotations does not automatically trigger their actions - like many things in Spring, the feature has to be declaratively enabled (which means if you ever suspect caching is to blame, you can disable it by removing only one configuration line rather than all the annotations in your code). To enable caching annotations add the annotation @EnableCaching to one of your @Configuration classes: @Configuration @EnableCaching public class AppConfig { } Alternatively, for XML configuration you can use the cache:annotation-driven element: <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:cache=\"http://www.springframework.org/schema/cache\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/cache https://www.springframework.org/schema/cache/spring-cache.xsd\"> \u00a0    <cache:annotation-driven/> </beans> Both the cache:annotation-driven element and the @EnableCaching annotation let you specify various options that influence the way the caching behavior is added to the application through AOP. The configuration is intentionally similar with that of @Transactional.\uf05a The default advice mode for processing caching annotations is proxy, which allows for interception of calls through the proxy only. Local calls within the same class cannot get intercepted that way. For a more advanced mode of interception, consider switching to aspectj mode in combination with compile-time or load-time weaving.\uf05a For more detail about advanced customizations (using Java configuration) that are required to implement CachingConfigurer, see the javadoc. Table 36. Cache annotation settings 1375", "chunk_char_count": 1870, "chunk_word_count": 232, "chunk_token_count": 467.5}, {"page_number": 1376, "sentence_chunk": "XML Attribute Annotation Attribute Default Description cache-manager N/A (see the CachingConfigu rer javadoc) cacheManager The name of the cache manager to use. A default CacheResolver is initialized behind the scenes with this cache manager (or cacheManager if not set). For more fine-grained management of the cache resolution, consider setting the 'cache- resolver' attribute.cache-resolver N/A (see the CachingConfigu rer javadoc) A SimpleCacheRes olver using the configured cacheManager. The bean name of the CacheResolver that is to be used to resolve the backing caches. This attribute is not required and needs to be specified only as an alternative to the 'cache- manager' attribute.key-generator N/A (see the CachingConfigu rer javadoc) SimpleKeyGener ator Name of the custom key generator to use.error-handler N/A (see the CachingConfigu rer javadoc) SimpleCacheErr orHandler The name of the custom cache error handler to use. By default, any exception thrown during a cache related operation is thrown back at the client.mode mode proxy The default mode (proxy) processes annotated beans to be proxied by using Spring\u2019s AOP framework (following proxy semantics, as discussed earlier, applying to method calls coming in through the proxy only).", "chunk_char_count": 1255, "chunk_word_count": 184, "chunk_token_count": 313.75}, {"page_number": 1376, "sentence_chunk": "The alternative mode (aspectj) instead weaves the affected classes with Spring\u2019s AspectJ caching aspect, modifying the target class byte code to apply to any kind of method call. AspectJ weaving requires spring-aspects.jar in the classpath as well as load-time weaving (or compile-time weaving) enabled. (See Spring configuration for details on how to set up load- time weaving.)proxy-target- class proxyTargetCla ss false Applies to proxy mode only. Controls what type of caching proxies are created for classes annotated with the @Cacheable or @CacheEvict annotations. If the proxy-target-class attribute is set to true, class-based proxies are created. If proxy-target-class is false or if the attribute is omitted, standard JDK interface-based proxies are created. (See Proxying Mechanisms for a detailed examination of the different proxy types.)1376", "chunk_char_count": 855, "chunk_word_count": 123, "chunk_token_count": 213.75}, {"page_number": 1377, "sentence_chunk": "XML Attribute Annotation Attribute Default Description order order Ordered. LOWE ST_PRECEDEN CE Defines the order of the cache advice that is applied to beans annotated with @Cacheable or @CacheEvict. (For more information about the rules related to ordering AOP advice, see Advice Ordering.)No specified ordering means that the AOP subsystem determines the order of the advice.\uf05a <cache:annotation-driven/> looks for @Cacheable/@CachePut/@CacheEvict/@Caching only on beans in the same application context in which it is defined. This means that, if you put <cache:annotation-driven/> in a WebApplicationContext for a DispatcherServlet, it checks for beans only in your controllers, not your services. See the MVC section for more information. Method visibility and cache annotations When you use proxies, you should apply the cache annotations only to methods with public visibility. If you do annotate protected, private, or package-visible methods with these annotations, no error is raised, but the annotated method does not exhibit the configured caching settings. Consider using AspectJ (see the rest of this section) if you need to annotate non-public methods, as it changes the bytecode itself.", "chunk_char_count": 1201, "chunk_word_count": 174, "chunk_token_count": 300.25}, {"page_number": 1377, "sentence_chunk": "\uf0eb Spring recommends that you only annotate concrete classes (and methods of concrete classes) with the @Cache* annotations, as opposed to annotating interfaces. You certainly can place an @Cache* annotation on an interface (or an interface method), but this works only if you use the proxy mode (mode=\"proxy\"). If you use the weaving-based aspect (mode=\"aspectj\"), the caching settings are not recognized on interface-level declarations by the weaving infrastructure.\uf05a In proxy mode (the default), only external method calls coming in through the proxy are intercepted. This means that self-invocation (in effect, a method within the target object that calls another method of the target object) does not lead to actual caching at runtime even if the invoked method is marked with @Cacheable. Consider using the aspectj mode in this case. Also, the proxy must be fully initialized to provide the expected behavior, so you should not rely on this feature in your initialization code (that is, @PostConstruct). Using Custom Annotations 1377", "chunk_char_count": 1038, "chunk_word_count": 160, "chunk_token_count": 259.5}, {"page_number": 1378, "sentence_chunk": "Custom annotation and AspectJ This feature works only with the proxy-based approach but can be enabled with a bit of extra effort by using AspectJ. The spring-aspects module defines an aspect for the standard annotations only. If you have defined your own annotations, you also need to define an aspect for those. Check AnnotationCacheAspect for an example. The caching abstraction lets you use your own annotations to identify what method triggers cache population or eviction. This is quite handy as a template mechanism, as it eliminates the need to duplicate cache annotation declarations, which is especially useful if the key or condition are specified or if the foreign imports (org.springframework) are not allowed in your code base. Similarly to the rest of the stereotype annotations, you can use @Cacheable, @CachePut, @CacheEvict, and @CacheConfig as meta-annotations (that is, annotations that can annotate other annotations). In the following example, we replace a common @Cacheable declaration with our own custom annotation: @Retention(RetentionPolicy. RUNTIME) @Target({ElementType. METHOD}) @Cacheable(cacheNames=\"books\", key=\"#isbn\") public @interface SlowService { } In the preceding example, we have defined our own SlowService annotation, which itself is annotated with @Cacheable. Now we can replace the following code: @Cacheable(cacheNames=\"books\", key=\"#isbn\") public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed) The following example shows the custom annotation with which we can replace the preceding code: @SlowService public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed) Even though @SlowService is not a Spring annotation, the container automatically picks up its declaration at runtime and understands its meaning.", "chunk_char_count": 1795, "chunk_word_count": 248, "chunk_token_count": 448.75}, {"page_number": 1378, "sentence_chunk": "Note that, as mentioned earlier, annotation- driven behavior needs to be enabled.7.6.3. JCache (JSR-107) Annotations Since version 4.1, Spring\u2019s caching abstraction fully supports the JCache standard (JSR-107) annotations: @CacheResult, @CachePut, @CacheRemove, and @CacheRemoveAll as well as the @CacheDefaults, @CacheKey, and @CacheValue companions. You can use these annotations even 1378", "chunk_char_count": 391, "chunk_word_count": 49, "chunk_token_count": 97.75}, {"page_number": 1379, "sentence_chunk": "without migrating your cache store to JSR-107. The internal implementation uses Spring\u2019s caching abstraction and provides default CacheResolver and KeyGenerator implementations that are compliant with the specification. In other words, if you are already using Spring\u2019s caching abstraction, you can switch to these standard annotations without changing your cache storage (or configuration, for that matter). Feature Summary For those who are familiar with Spring\u2019s caching annotations, the following table describes the main differences between the Spring annotations and their JSR-107 counterparts: Table 37. Spring vs. JSR-107 caching annotations Spring JSR-107 Remark @Cacheable @CacheResult Fairly similar.@CacheResult can cache specific exceptions and force the execution of the method regardless of the content of the cache.@CachePut @CachePut While Spring updates the cache with the result of the method invocation, JCache requires that it be passed it as an argument that is annotated with @CacheValue. Due to this difference, JCache allows updating the cache before or after the actual method invocation.@CacheEvict @CacheRemove Fairly similar.@CacheRemove supports conditional eviction when the method invocation results in an exception.", "chunk_char_count": 1248, "chunk_word_count": 171, "chunk_token_count": 312.0}, {"page_number": 1379, "sentence_chunk": "@CacheEvict(allEnt ries=true) @CacheRemoveAll See @CacheRemove.@CacheConfig @CacheDefaults Lets you configure the same concepts, in a similar fashion. JCache has the notion of javax.cache.annotation. CacheResolver, which is identical to the Spring\u2019s CacheResolver interface, except that JCache supports only a single cache. By default, a simple implementation retrieves the cache to use based on the name declared on the annotation. It should be noted that, if no cache name is specified on the annotation, a default is automatically generated. See the javadoc of @CacheResult#cacheName() for more information. CacheResolver instances are retrieved by a CacheResolverFactory. It is possible to customize the factory for each cache operation, as the following example shows: @CacheResult(cacheNames=\"books\", cacheResolverFactory=MyCacheResolverFactory.class) \u2460 public Book findBook(ISBN isbn) \u2460 Customizing the factory for this operation.\uf05a For all referenced classes, Spring tries to locate a bean with the given type.", "chunk_char_count": 1017, "chunk_word_count": 135, "chunk_token_count": 254.25}, {"page_number": 1379, "sentence_chunk": "If more than one match exists, a new instance is created and can use the regular bean lifecycle callbacks, such as dependency injection. Keys are generated by a javax.cache.annotation. CacheKeyGenerator that serves the same purpose as 1379", "chunk_char_count": 239, "chunk_word_count": 37, "chunk_token_count": 59.75}, {"page_number": 1380, "sentence_chunk": "Spring\u2019s KeyGenerator. By default, all method arguments are taken into account, unless at least one parameter is annotated with @CacheKey. This is similar to Spring\u2019s custom key generation declaration. For instance, the following are identical operations, one using Spring\u2019s abstraction and the other using JCache: @Cacheable(cacheNames=\"books\", key=\"#isbn\") public Book findBook(ISBN isbn, boolean checkWarehouse, boolean includeUsed) @CacheResult(cacheName=\"books\") public Book findBook(@CacheKey ISBN isbn, boolean checkWarehouse, boolean includeUsed) You can also specify the CacheKeyResolver on the operation, similar to how you can specify the CacheResolverFactory. JCache can manage exceptions thrown by annotated methods. This can prevent an update of the cache, but it can also cache the exception as an indicator of the failure instead of calling the method again. Assume that InvalidIsbnNotFoundException is thrown if the structure of the ISBN is invalid. This is a permanent failure (no book could ever be retrieved with such a parameter). The following caches the exception so that further calls with the same, invalid, ISBN throw the cached exception directly instead of invoking the method again: @CacheResult(cacheName=\"books\", exceptionCacheName=\"failures\" \u00a0      cachedExceptions = InvalidIsbnNotFoundException.class) public Book findBook(ISBN isbn) Enabling JSR-107 Support You do not need to do anything specific to enable the JSR-107 support alongside Spring\u2019s declarative annotation support. Both @EnableCaching and the cache:annotation-driven XML element automatically enable the JCache support if both the JSR-107 API and the spring-context-support module are present in the classpath.", "chunk_char_count": 1709, "chunk_word_count": 232, "chunk_token_count": 427.25}, {"page_number": 1380, "sentence_chunk": "\uf05a Depending on your use case, the choice is basically yours. You can even mix and match services by using the JSR-107 API on some and using Spring\u2019s own annotations on others. However, if these services impact the same caches, you should use a consistent and identical key generation implementation.7.6.4. Declarative XML-based Caching If annotations are not an option (perhaps due to having no access to the sources or no external code), you can use XML for declarative caching. So, instead of annotating the methods for caching, you can specify the target method and the caching directives externally (similar to the declarative transaction management advice). The example from the previous section can be translated into the following example: 1380", "chunk_char_count": 751, "chunk_word_count": 119, "chunk_token_count": 187.75}, {"page_number": 1381, "sentence_chunk": "<!--the service we want to make cacheable --> <bean id=\"bookService\" class=\"x.y.service. DefaultBookService\"/> <!--cache definitions --> <cache:advice id=\"cacheAdvice\" cache-manager=\"cacheManager\"> \u00a0  <cache:caching cache=\"books\"> \u00a0    <cache:cacheable method=\"findBook\" key=\"#isbn\"/> \u00a0    <cache:cache-evict method=\"loadBooks\" all-entries=\"true\"/> \u00a0  </cache:caching> </cache:advice> <!--apply the cacheable behavior to all BookService interfaces --> <aop:config> \u00a0  <aop:advisor advice-ref=\"cacheAdvice\" pointcut=\"execution(* x.y. BookService.*(..))\"/> </aop:config> <!--cache manager definition omitted --> In the preceding configuration, the bookService is made cacheable. The caching semantics to apply are encapsulated in the cache:advice definition, which causes the findBooks method to be used for putting data into the cache and the loadBooks method for evicting data. Both definitions work against the books cache. The aop:config definition applies the cache advice to the appropriate points in the program by using the AspectJ pointcut expression (more information is available in Aspect Oriented Programming with Spring).", "chunk_char_count": 1133, "chunk_word_count": 141, "chunk_token_count": 283.25}, {"page_number": 1381, "sentence_chunk": "In the preceding example, all methods from the BookService are considered and the cache advice is applied to them. The declarative XML caching supports all of the annotation-based model, so moving between the two should be fairly easy. Furthermore, both can be used inside the same application. The XML- based approach does not touch the target code. However, it is inherently more verbose. When dealing with classes that have overloaded methods that are targeted for caching, identifying the proper methods does take an extra effort, since the method argument is not a good discriminator. In these cases, you can use the AspectJ pointcut to cherry pick the target methods and apply the appropriate caching functionality. However, through XML, it is easier to apply package or group or interface-wide caching (again, due to the AspectJ pointcut) and to create template-like definitions (as we did in the preceding example by defining the target cache through the cache:definitions cache attribute).7.6.5. Configuring the Cache Storage The cache abstraction provides several storage integration options.", "chunk_char_count": 1102, "chunk_word_count": 169, "chunk_token_count": 275.5}, {"page_number": 1381, "sentence_chunk": "To use them, you need to declare an appropriate CacheManager (an entity that controls and manages Cache instances and that can be used to retrieve these for storage).1381", "chunk_char_count": 170, "chunk_word_count": 28, "chunk_token_count": 42.5}, {"page_number": 1382, "sentence_chunk": "JDK ConcurrentMap-based Cache The JDK-based Cache implementation resides under org.springframework.cache.concurrent package. It lets you use ConcurrentHashMap as a backing Cache store. The following example shows how to configure two caches: <!--simple cache manager --> <bean id=\"cacheManager\" class=\"org.springframework.cache.support. SimpleCacheManager\"> \u00a0  <property name=\"caches\"> \u00a0    <set> \u00a0      <bean class=\"org.springframework.cache.concurrent. ConcurrentMapCacheFactoryBean\" p:name=\"default\"/> \u00a0      <bean class=\"org.springframework.cache.concurrent. ConcurrentMapCacheFactoryBean\" p:name=\"books\"/> \u00a0    </set> \u00a0  </property> </bean> The preceding snippet uses the SimpleCacheManager to create a CacheManager for the two nested ConcurrentMapCache instances named default and books. Note that the names are configured directly for each cache. As the cache is created by the application, it is bound to its lifecycle, making it suitable for basic use cases, tests, or simple applications. The cache scales well and is very fast, but it does not provide any management, persistence capabilities, or eviction contracts.", "chunk_char_count": 1127, "chunk_word_count": 151, "chunk_token_count": 281.75}, {"page_number": 1382, "sentence_chunk": "Ehcache-based Cache Ehcache 3.x is fully JSR-107 compliant and no dedicated support is required for it. See JSR-107 Cache for details. Caffeine Cache Caffeine is a Java 8 rewrite of Guava\u2019s cache, and its implementation is located in the org.springframework.cache.caffeine package and provides access to several features of Caffeine. The following example configures a CacheManager that creates the cache on demand: <bean id=\"cacheManager\" \u00a0    class=\"org.springframework.cache.caffeine. CaffeineCacheManager\"/> You can also provide the caches to use explicitly. In that case, only those are made available by the manager. The following example shows how to do so: 1382", "chunk_char_count": 669, "chunk_word_count": 98, "chunk_token_count": 167.25}, {"page_number": 1383, "sentence_chunk": "<bean id=\"cacheManager\" class=\"org.springframework.cache.caffeine. CaffeineCacheManager\"> \u00a0  <property name=\"cacheNames\"> \u00a0    <set> \u00a0      <value>default</value> \u00a0      <value>books</value> \u00a0    </set> \u00a0  </property> </bean> The Caffeine CacheManager also supports custom Caffeine and CacheLoader. See the Caffeine documentation for more information about those. GemFire-based Cache GemFire is a memory-oriented, disk-backed, elastically scalable, continuously available, active (with built-in pattern-based subscription notifications), globally replicated database and provides fully-featured edge caching. For further information on how to use GemFire as a CacheManager (and more), see the Spring Data GemFire reference documentation. JSR-107 Cache Spring\u2019s caching abstraction can also use JSR-107-compliant caches. The JCache implementation is located in the org.springframework.cache.jcache package. Again, to use it, you need to declare the appropriate CacheManager. The following example shows how to do so: <bean id=\"cacheManager\" \u00a0    class=\"org.springframework.cache.jcache. JCacheCacheManager\" \u00a0    p:cache-manager-ref=\"jCacheManager\"/> <!--", "chunk_char_count": 1153, "chunk_word_count": 151, "chunk_token_count": 288.25}, {"page_number": 1383, "sentence_chunk": "JSR-107 cache manager setup --> <bean id=\"jCacheManager\" .../> Dealing with Caches without a Backing Store Sometimes, when switching environments or doing testing, you might have cache declarations without having an actual backing cache configured. As this is an invalid configuration, an exception is thrown at runtime, since the caching infrastructure is unable to find a suitable store. In situations like this, rather than removing the cache declarations (which can prove tedious), you can wire in a simple dummy cache that performs no caching\u2009\u2014\u2009that is, it forces the cached methods to be invoked every time. The following example shows how to do so: 1383", "chunk_char_count": 660, "chunk_word_count": 103, "chunk_token_count": 165.0}, {"page_number": 1384, "sentence_chunk": "<bean id=\"cacheManager\" class=\"org.springframework.cache.support. CompositeCacheManager\"> \u00a0  <property name=\"cacheManagers\"> \u00a0    <list> \u00a0      <ref bean=\"jdkCache\"/> \u00a0      <ref bean=\"gemfireCache\"/> \u00a0    </list> \u00a0  </property> \u00a0  <property name=\"fallbackToNoOpCache\" value=\"true\"/> </bean> The CompositeCacheManager in the preceding chains multiple CacheManager instances and, through the fallbackToNoOpCache flag, adds a no-op cache for all the definitions not handled by the configured cache managers. That is, every cache definition not found in either jdkCache or gemfireCache (configured earlier in the example) is handled by the no-op cache, which does not store any information, causing the target method to be invoked every time.7.6.6. Plugging-in Different Back-end Caches Clearly, there are plenty of caching products out there that you can use as a backing store. For those that do not support JSR-107 you need to provide a CacheManager and a Cache implementation. This may sound harder than it is, since, in practice, the classes tend to be simple adapters that map the caching abstraction framework on top of the storage API, as the Caffeine classes do. Most CacheManager classes can use the classes in the org.springframework.cache.support package (such as AbstractCacheManager which takes care of the boiler-plate code, leaving only the actual mapping to be completed).7.6.7. How can I Set the TTL/TTI/Eviction policy/XXX feature?", "chunk_char_count": 1447, "chunk_word_count": 219, "chunk_token_count": 361.75}, {"page_number": 1384, "sentence_chunk": "Directly through your cache provider. The cache abstraction is an abstraction, not a cache implementation. The solution you use might support various data policies and different topologies that other solutions do not support (for example, the JDK ConcurrentHashMap\u2009\u2014\u2009exposing that in the cache abstraction would be useless because there would no backing support). Such functionality should be controlled directly through the backing cache (when configuring it) or through its native API.7.7. Appendix 7.7.1. XML Schemas This part of the appendix lists XML schemas related to integration technologies. The jee Schema The jee elements deal with issues related to Jakarta EE (Enterprise Edition) configuration, such as looking up a JNDI object and defining EJB references. To use the elements in the jee schema, you need to have the following preamble at the top of your 1384", "chunk_char_count": 872, "chunk_word_count": 134, "chunk_token_count": 218.0}, {"page_number": 1385, "sentence_chunk": "Spring XML configuration file. The text in the following snippet references the correct schema so that the elements in the jee namespace are available to you: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:jee=\"http://www.springframework.org/schema/jee\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/jee https://www.springframework.org/schema/jee/spring-jee.xsd\"> \u00a0  <!--bean definitions here --> </beans> <jee:jndi-lookup/> (simple) The following example shows how to use JNDI to look up a data source without the jee schema: <bean id=\"dataSource\" class=\"org.springframework.jndi. JndiObjectFactoryBean\"> \u00a0  <property name=\"jndiName\" value=\"jdbc/MyDataSource\"/> </bean> <bean id=\"userDao\" class=\"com.foo. JdbcUserDao\"> \u00a0  <!--Spring will do the cast automatically (as usual) --> \u00a0  <property name=\"dataSource\" ref=\"dataSource\"/> </bean> The following example shows how to use JNDI to look up a data source with the jee schema: <jee:jndi-lookup id=\"dataSource\" jndi-name=\"jdbc/MyDataSource\"/> <bean id=\"userDao\" class=\"com.foo. JdbcUserDao\"> \u00a0  <!--Spring will do the cast automatically (as usual) --> \u00a0  <property name=\"dataSource\" ref=\"dataSource\"/> </bean> <jee:jndi-lookup/> (with Single JNDI Environment Setting) The following example shows how to use JNDI to look up an environment variable without jee: 1385", "chunk_char_count": 1563, "chunk_word_count": 175, "chunk_token_count": 390.75}, {"page_number": 1386, "sentence_chunk": "<bean id=\"simple\" class=\"org.springframework.jndi. JndiObjectFactoryBean\"> \u00a0  <property name=\"jndiName\" value=\"jdbc/MyDataSource\"/> \u00a0  <property name=\"jndiEnvironment\"> \u00a0    <props> \u00a0      <prop key=\"ping\">pong</prop> \u00a0    </props> \u00a0  </property> </bean> The following example shows how to use JNDI to look up an environment variable with jee: <jee:jndi-lookup id=\"simple\" jndi-name=\"jdbc/MyDataSource\"> \u00a0  <jee:environment>ping=pong</jee:environment> </jee:jndi-lookup> <jee:jndi-lookup/> (with Multiple JNDI Environment Settings) The following example shows how to use JNDI to look up multiple environment variables without jee: <bean id=\"simple\" class=\"org.springframework.jndi. JndiObjectFactoryBean\"> \u00a0  <property name=\"jndiName\" value=\"jdbc/MyDataSource\"/> \u00a0  <property name=\"jndiEnvironment\"> \u00a0    <props> \u00a0      <prop key=\"sing\">song</prop> \u00a0      <prop key=\"ping\">pong</prop> \u00a0    </props> \u00a0  </property> </bean> The following example shows how to use JNDI to look up multiple environment variables with jee: <jee:jndi-lookup id=\"simple\" jndi-name=\"jdbc/MyDataSource\"> \u00a0  <!--newline-separated, key-value pairs for the environment (standard Properties format) --> \u00a0  <jee:environment> \u00a0    sing=song \u00a0    ping=pong \u00a0  </jee:environment> </jee:jndi-lookup> <jee:jndi-lookup/> (Complex) The following example shows how to use JNDI to look up a data source and a number of different properties without jee: 1386", "chunk_char_count": 1417, "chunk_word_count": 196, "chunk_token_count": 354.25}, {"page_number": 1387, "sentence_chunk": "<bean id=\"simple\" class=\"org.springframework.jndi. JndiObjectFactoryBean\"> \u00a0  <property name=\"jndiName\" value=\"jdbc/MyDataSource\"/> \u00a0  <property name=\"cache\" value=\"true\"/> \u00a0  <property name=\"resourceRef\" value=\"true\"/> \u00a0  <property name=\"lookupOnStartup\" value=\"false\"/> \u00a0  <property name=\"expectedType\" value=\"com.myapp. DefaultThing\"/> \u00a0  <property name=\"proxyInterface\" value=\"com.myapp. Thing\"/> </bean> The following example shows how to use JNDI to look up a data source and a number of different properties with jee: <jee:jndi-lookup id=\"simple\" \u00a0    jndi-name=\"jdbc/MyDataSource\" \u00a0    cache=\"true\" \u00a0    resource-ref=\"true\" \u00a0    lookup-on-startup=\"false\" \u00a0    expected-type=\"com.myapp. DefaultThing\" \u00a0    proxy-interface=\"com.myapp. Thing\"/> <jee:local-slsb/> (Simple) The <jee:local-slsb/> element configures a reference to a local EJB Stateless Session Bean. The following example shows how to configures a reference to a local EJB Stateless Session Bean without jee: <bean id=\"simple\" \u00a0    class=\"org.springframework.ejb.access. LocalStatelessSessionProxyFactoryBean\"> \u00a0  <property name=\"jndiName\" value=\"ejb/RentalServiceBean\"/> \u00a0  <property name=\"businessInterface\" value=\"com.foo.service. RentalService\"/> </bean> The following example shows how to configures a reference to a local EJB Stateless Session Bean with jee: <jee:local-slsb id=\"simpleSlsb\" jndi-name=\"ejb/RentalServiceBean\" \u00a0    business-interface=\"com.foo.service. RentalService\"/> <jee:local-slsb/> (Complex) The <jee:local-slsb/> element configures a reference to a local EJB Stateless Session Bean.", "chunk_char_count": 1578, "chunk_word_count": 188, "chunk_token_count": 394.5}, {"page_number": 1387, "sentence_chunk": "The following example shows how to configures a reference to a local EJB Stateless Session Bean and a number of properties without jee: 1387", "chunk_char_count": 140, "chunk_word_count": 24, "chunk_token_count": 35.0}, {"page_number": 1388, "sentence_chunk": "<bean id=\"complexLocalEjb\" \u00a0    class=\"org.springframework.ejb.access. LocalStatelessSessionProxyFactoryBean\"> \u00a0  <property name=\"jndiName\" value=\"ejb/RentalServiceBean\"/> \u00a0  <property name=\"businessInterface\" value=\"com.example.service. RentalService\"/> \u00a0  <property name=\"cacheHome\" value=\"true\"/> \u00a0  <property name=\"lookupHomeOnStartup\" value=\"true\"/> \u00a0  <property name=\"resourceRef\" value=\"true\"/> </bean> The following example shows how to configures a reference to a local EJB Stateless Session Bean and a number of properties with jee: <jee:local-slsb id=\"complexLocalEjb\" \u00a0    jndi-name=\"ejb/RentalServiceBean\" \u00a0    business-interface=\"com.foo.service. RentalService\" \u00a0    cache-home=\"true\" \u00a0    lookup-home-on-startup=\"true\" \u00a0    resource-ref=\"true\"> <jee:remote-slsb/> The <jee:remote-slsb/> element configures a reference to a remote EJB Stateless Session Bean. The following example shows how to configures a reference to a remote EJB Stateless Session Bean without jee: <bean id=\"complexRemoteEjb\" \u00a0 class=\"org.springframework.ejb.access. SimpleRemoteStatelessSessionProxyFactoryBean\"> \u00a0  <property name=\"jndiName\" value=\"ejb/MyRemoteBean\"/> \u00a0  <property name=\"businessInterface\" value=\"com.foo.service. RentalService\"/> \u00a0  <property name=\"cacheHome\" value=\"true\"/> \u00a0  <property name=\"lookupHomeOnStartup\" value=\"true\"/> \u00a0  <property name=\"resourceRef\" value=\"true\"/> \u00a0  <property name=\"homeInterface\" value=\"com.foo.service. RentalService\"/> \u00a0  <property name=\"refreshHomeOnConnectFailure\" value=\"true\"/> </bean> The following example shows how to configures a reference to a remote EJB Stateless Session Bean with jee: 1388", "chunk_char_count": 1638, "chunk_word_count": 180, "chunk_token_count": 409.5}, {"page_number": 1389, "sentence_chunk": "<jee:remote-slsb id=\"complexRemoteEjb\" \u00a0    jndi-name=\"ejb/MyRemoteBean\" \u00a0    business-interface=\"com.foo.service. RentalService\" \u00a0    cache-home=\"true\" \u00a0    lookup-home-on-startup=\"true\" \u00a0    resource-ref=\"true\" \u00a0    home-interface=\"com.foo.service. RentalService\" \u00a0    refresh-home-on-connect-failure=\"true\"> The jms Schema The jms elements deal with configuring JMS-related beans, such as Spring\u2019s Message Listener Containers. These elements are detailed in the section of the JMS chapter entitled JMS Namespace Support. See that chapter for full details on this support and the jms elements themselves. In the interest of completeness, to use the elements in the jms schema, you need to have the following preamble at the top of your Spring XML configuration file. The text in the following snippet references the correct schema so that the elements in the jms namespace are available to you: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:jms=\"http://www.springframework.org/schema/jms\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/jms https://www.springframework.org/schema/jms/spring-jms.xsd\"> \u00a0  <!--bean definitions here --> </beans> Using <context:mbean-export/> This element is detailed in Configuring Annotation-based MBean Export.", "chunk_char_count": 1493, "chunk_word_count": 180, "chunk_token_count": 373.25}, {"page_number": 1389, "sentence_chunk": "The cache Schema You can use the cache elements to enable support for Spring\u2019s @CacheEvict, @CachePut, and @Caching annotations. It it also supports declarative XML-based caching. See Enabling Caching Annotations and Declarative XML-based Caching for details. To use the elements in the cache schema, you need to have the following preamble at the top of your Spring XML configuration file. The text in the following snippet references the correct schema so that the elements in the cache namespace are available to you: 1389", "chunk_char_count": 525, "chunk_word_count": 83, "chunk_token_count": 131.25}, {"page_number": 1390, "sentence_chunk": "<?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:cache=\"http://www.springframework.org/schema/cache\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/cache https://www.springframework.org/schema/cache/spring-cache.xsd\"> \u00a0  <!--bean definitions here --> </beans> 1390", "chunk_char_count": 510, "chunk_word_count": 34, "chunk_token_count": 127.5}, {"page_number": 1391, "sentence_chunk": "Chapter 8. Language Support 8.1. Kotlin Kotlin is a statically typed language that targets the JVM (and other platforms) which allows writing concise and elegant code while providing very good interoperability with existing libraries written in Java. The Spring Framework provides first-class support for Kotlin and lets developers write Kotlin applications almost as if the Spring Framework was a native Kotlin framework. Most of the code samples of the reference documentation are provided in Kotlin in addition to Java. The easiest way to build a Spring application with Kotlin is to leverage Spring Boot and its dedicated Kotlin support. This comprehensive tutorial will teach you how to build Spring Boot applications with Kotlin using start.spring.io. Feel free to join the #spring channel of Kotlin Slack or ask a question with spring and kotlin as tags on Stackoverflow if you need support.8.1.1. Requirements Spring Framework supports Kotlin 1.3+ and requires kotlin-stdlib (or one of its variants, such as kotlin-stdlib-jdk8) and kotlin-reflect to be present on the classpath.", "chunk_char_count": 1086, "chunk_word_count": 166, "chunk_token_count": 271.5}, {"page_number": 1391, "sentence_chunk": "They are provided by default if you bootstrap a Kotlin project on start.spring.io.\uf071 Kotlin inline classes are not yet supported.\uf05a The Jackson Kotlin module is required for serializing or deserializing JSON data for Kotlin classes with Jackson, so make sure to add the com.fasterxml.jackson.module:jackson-module-kotlin dependency to your project if you have such need. It is automatically registered when found in the classpath.8.1.2. Extensions Kotlin extensions provide the ability to extend existing classes with additional functionality. The Spring Framework Kotlin APIs use these extensions to add new Kotlin-specific conveniences to existing Spring APIs. The Spring Framework KDoc API lists and documents all available Kotlin extensions and DSLs.\uf05a Keep in mind that Kotlin extensions need to be imported to be used. This means, for example, that the GenericApplicationContext.registerBean Kotlin extension is available only if org.springframework.context.support.registerBean is imported.", "chunk_char_count": 994, "chunk_word_count": 135, "chunk_token_count": 248.5}, {"page_number": 1391, "sentence_chunk": "That said, similar to static imports, an IDE should automatically suggest the import in most cases. For example, Kotlin reified type parameters provide a workaround for JVM generics type erasure, 1391", "chunk_char_count": 200, "chunk_word_count": 31, "chunk_token_count": 50.0}, {"page_number": 1392, "sentence_chunk": "and the Spring Framework provides some extensions to take advantage of this feature. This allows for a better Kotlin API RestTemplate, for the new WebClient from Spring WebFlux, and for various other APIs.\uf05a Other libraries, such as Reactor and Spring Data, also provide Kotlin extensions for their APIs, thus giving a better Kotlin development experience overall. To retrieve a list of User objects in Java, you would normally write the following: Flux<User> users = client.get().retrieve().bodyToFlux(User.class) With Kotlin and the Spring Framework extensions, you can instead write the following: val users = client.get().retrieve().bodyToFlux<User>() // or (both are equivalent) val users : Flux<User> = client.get().retrieve().bodyToFlux() As in Java, users in Kotlin is strongly typed, but Kotlin\u2019s clever type inference allows for shorter syntax.8.1.3. Null-safety One of Kotlin\u2019s key features is null-safety, which cleanly deals with null values at compile time rather than bumping into the famous NullPointerException at runtime. This makes applications safer through nullability declarations and expressing \u201cvalue or no value\u201d semantics without paying the cost of wrappers, such as Optional. (Kotlin allows using functional constructs with nullable values. See this comprehensive guide to Kotlin null-safety.)Although Java does not let you express null-safety in its type-system, the Spring Framework provides null-safety of the whole Spring Framework API via tooling-friendly annotations declared in the org.springframework.lang package.", "chunk_char_count": 1548, "chunk_word_count": 214, "chunk_token_count": 387.0}, {"page_number": 1392, "sentence_chunk": "By default, types from Java APIs used in Kotlin are recognized as platform types, for which null-checks are relaxed. Kotlin support for JSR-305 annotations and Spring nullability annotations provide null-safety for the whole Spring Framework API to Kotlin developers, with the advantage of dealing with null-related issues at compile time.\uf05a Libraries such as Reactor or Spring Data provide null-safe APIs to leverage this feature. You can configure JSR-305 checks by adding the -Xjsr305 compiler flag with the following options: -Xjsr305={strict|warn|ignore}. For kotlin versions 1.1+, the default behavior is the same as -Xjsr305=warn. The strict value is required to have Spring Framework API null-safety taken into account in Kotlin types inferred from Spring API but should be used with the knowledge that Spring API nullability declaration could evolve even between minor releases and that more checks may be added in the future.1392", "chunk_char_count": 938, "chunk_word_count": 141, "chunk_token_count": 234.5}, {"page_number": 1393, "sentence_chunk": "\uf05a Generic type arguments, varargs, and array elements nullability are not supported yet, but should be in an upcoming release. See this discussion for up-to-date information.8.1.4. Classes and Interfaces The Spring Framework supports various Kotlin constructs, such as instantiating Kotlin classes through primary constructors, immutable classes data binding, and function optional parameters with default values. Kotlin parameter names are recognized through a dedicated KotlinReflectionParameterNameDiscoverer, which allows finding interface method parameter names without requiring the Java 8 -parameters compiler flag to be enabled during compilation. You can declare configuration classes as top level or nested but not inner, since the later requires a reference to the outer class.8.1.5. Annotations The Spring Framework also takes advantage of Kotlin null-safety to determine if an HTTP parameter is required without having to explicitly define the required attribute. That means @RequestParam name: String?is treated as not required and, conversely, @RequestParam name: String is treated as being required.", "chunk_char_count": 1115, "chunk_word_count": 152, "chunk_token_count": 278.75}, {"page_number": 1393, "sentence_chunk": "This feature is also supported on the Spring Messaging @Header annotation. In a similar fashion, Spring bean injection with @Autowired, @Bean, or @Inject uses this information to determine if a bean is required or not. For example, @Autowired lateinit var thing: Thing implies that a bean of type Thing must be registered in the application context, while @Autowired lateinit var thing: Thing?does not raise an error if such a bean does not exist. Following the same principle, @Bean fun play(toy: Toy, car: Car?)= Baz(toy, Car) implies that a bean of type Toy must be registered in the application context, while a bean of type Car may or may not exist. The same behavior applies to autowired constructor parameters.\uf05a If you use bean validation on classes with properties or a primary constructor parameters, you may need to use annotation use-site targets, such as @field:NotNull or @get:Size(min=5, max=15), as described in this Stack Overflow response.8.1.6. Bean Definition DSL Spring Framework supports registering beans in a functional way by using lambdas as an alternative to XML or Java configuration (@Configuration and @Bean).", "chunk_char_count": 1138, "chunk_word_count": 179, "chunk_token_count": 284.5}, {"page_number": 1393, "sentence_chunk": "In a nutshell, it lets you register beans with a lambda that acts as a FactoryBean. This mechanism is very efficient, as it does not require any reflection or CGLIB proxies. In Java, you can, for example, write the following: 1393", "chunk_char_count": 230, "chunk_word_count": 41, "chunk_token_count": 57.5}, {"page_number": 1394, "sentence_chunk": "class Foo {} class Bar { \u00a0  private final Foo foo; \u00a0  public Bar(Foo foo) { \u00a0    this.foo = foo; \u00a0  } } GenericApplicationContext context = new GenericApplicationContext(); context.registerBean(Foo.class); context.registerBean(Bar.class, () -> new Bar(context.getBean(Foo.class))); In Kotlin, with reified type parameters and GenericApplicationContext Kotlin extensions, you can instead write the following: class Foo class Bar(private val foo: Foo) val context = GenericApplicationContext().apply { \u00a0  registerBean<Foo>() \u00a0  registerBean { Bar(it.getBean()) } } When the class Bar has a single constructor, you can even just specify the bean class, the constructor parameters will be autowired by type: val context = GenericApplicationContext().apply { \u00a0  registerBean<Foo>() \u00a0  registerBean<Bar>() } In order to allow a more declarative approach and cleaner syntax, Spring Framework provides a Kotlin bean definition DSL It declares an ApplicationContextInitializer through a clean declarative API, which lets you deal with profiles and Environment for customizing how beans are registered. In the following example notice that: \u2022 Type inference usually allows to avoid specifying the type for bean references like ref(\"bazBean\") \u2022 It is possible to use Kotlin top level functions to declare beans using callable references like bean(::myRouter) in this example \u2022 When specifying bean<Bar>() or bean(::myRouter), parameters are autowired by type 1394", "chunk_char_count": 1452, "chunk_word_count": 210, "chunk_token_count": 363.0}, {"page_number": 1395, "sentence_chunk": "\u2022 The FooBar bean will be registered only if the foobar profile is active class Foo class Bar(private val foo: Foo) class Baz(var message: String = \"\") class FooBar(private val baz: Baz) val myBeans = beans { \u00a0  bean<Foo>() \u00a0  bean<Bar>() \u00a0  bean(\"bazBean\") { \u00a0    Baz().apply { \u00a0      message = \"Hello world\" \u00a0    } \u00a0  } \u00a0  profile(\"foobar\") { \u00a0    bean { FooBar(ref(\"bazBean\")) } \u00a0  } \u00a0  bean(::myRouter) } fun myRouter(foo: Foo, bar: Bar, baz: Baz) = router { \u00a0  // ... } \uf05a This DSL is programmatic, meaning it allows custom registration logic of beans through an if expression, a for loop, or any other Kotlin constructs. You can then use this beans() function to register beans on the application context, as the following example shows: val context = GenericApplicationContext().apply { \u00a0  myBeans.initialize(this) \u00a0  refresh() } \uf05a Spring Boot is based on JavaConfig and does not yet provide specific support for functional bean definition, but you can experimentally use functional bean definitions through Spring Boot\u2019s ApplicationContextInitializer support. See this Stack Overflow answer for more details and up-to-date information. See also the experimental Kofu DSL developed in Spring Fu incubator.8.1.7. Web Router DSL Spring Framework comes with a Kotlin router DSL available in 3 flavors: 1395", "chunk_char_count": 1309, "chunk_word_count": 230, "chunk_token_count": 327.25}, {"page_number": 1396, "sentence_chunk": "\u2022 WebMvc.fn DSL with router { } \u2022 WebFlux.fn Reactive DSL with router { } \u2022 WebFlux.fn Coroutines DSL with coRouter { } These DSL let you write clean and idiomatic Kotlin code to build a RouterFunction instance as the following example shows: @Configuration class RouterRouterConfiguration { \u00a0  @Bean \u00a0  fun mainRouter(userHandler: UserHandler) = router { \u00a0    accept(TEXT_HTML).nest { \u00a0      GET(\"/\") { ok().render(\"index\") } \u00a0      GET(\"/sse\") { ok().render(\"sse\") } \u00a0      GET(\"/users\", userHandler::findAllView) \u00a0    } \u00a0    \"/api\".nest { \u00a0      accept(APPLICATION_JSON).nest { \u00a0        GET(\"/users\", userHandler::findAll) \u00a0      } \u00a0      accept(TEXT_EVENT_STREAM).nest { \u00a0        GET(\"/users\", userHandler::stream) \u00a0      } \u00a0    } \u00a0    resources(\"/**\", ClassPathResource(\"static/\")) \u00a0  } } \uf05a This DSL is programmatic, meaning that it allows custom registration logic of beans through an if expression, a for loop, or any other Kotlin constructs. That can be useful when you need to register routes depending on dynamic data (for example, from a database). See MiXiT project for a concrete example. MockMvc DSL A Kotlin DSL is provided via MockMvc Kotlin extensions in order to provide a more idiomatic Kotlin API and to allow better discoverability (no usage of static methods).1396", "chunk_char_count": 1286, "chunk_word_count": 250, "chunk_token_count": 321.5}, {"page_number": 1397, "sentence_chunk": "val mockMvc: MockMvc = ... mockMvc.get(\"/person/{name}\", \"Lee\") { \u00a0  secure = true \u00a0  accept = APPLICATION_JSON \u00a0  headers { \u00a0    contentLanguage = Locale. FRANCE \u00a0  } \u00a0  principal = Principal { \"foo\" } }.andExpect { \u00a0  status { isOk } \u00a0  content { contentType(APPLICATION_JSON) } \u00a0  jsonPath(\"$.name\") { value(\"Lee\") } \u00a0  content { json(\"\"\"{\"someBoolean\": false}\"\"\", false) } }.andDo { \u00a0  print() } Kotlin Script Templates Spring Framework provides a ScriptTemplateView which supports JSR-223 to render templates by using script engines. By leveraging scripting-jsr223 dependencies, it is possible to use such feature to render Kotlin- based templates with kotlinx.html DSL or Kotlin multiline interpolated String.build.gradle.kts dependencies { \u00a0    runtime(\"org.jetbrains.kotlin:kotlin-scripting-jsr223:${kotlinVersion}\") } Configuration is usually done with ScriptTemplateConfigurer and ScriptTemplateViewResolver beans. KotlinScriptConfiguration.kt 1397", "chunk_char_count": 958, "chunk_word_count": 136, "chunk_token_count": 239.5}, {"page_number": 1398, "sentence_chunk": "@Configuration class KotlinScriptConfiguration { \u00a0  @Bean \u00a0  fun kotlinScriptConfigurer() = ScriptTemplateConfigurer().apply { \u00a0    engineName = \"kotlin\" \u00a0    setScripts(\"scripts/render.kts\") \u00a0    renderFunction = \"render\" \u00a0    isSharedEngine = false \u00a0  } \u00a0  @Bean \u00a0  fun kotlinScriptViewResolver() = ScriptTemplateViewResolver().apply { \u00a0    setPrefix(\"templates/\") \u00a0    setSuffix(\".kts\") \u00a0  } } See the kotlin-script-templating example project for more details. Kotlin multiplatform serialization As of Spring Framework 5.3, Kotlin multiplatform serialization is supported in Spring MVC, Spring WebFlux and Spring Messaging (RSocket). The builtin support currently targets CBOR, JSON, and ProtoBuf formats. To enable it, follow those instructions to add the related dependency and plugin. With Spring MVC and WebFlux, both Kotlin serialization and Jackson will be configured by default if they are in the classpath since Kotlin serialization is designed to serialize only Kotlin classes annotated with @Serializable. With Spring Messaging (RSocket), make sure that neither Jackson, GSON or JSONB are in the classpath if you want automatic configuration, if Jackson is needed configure KotlinSerializationJsonMessageConverter manually.8.1.8. Coroutines Kotlin Coroutines are Kotlin lightweight threads allowing to write non-blocking code in an imperative way. On language side, suspending functions provides an abstraction for asynchronous operations while on library side kotlinx.coroutines provides functions like async { } and types like Flow. Spring Framework provides support for Coroutines on the following scope: \u2022 Deferred and Flow return values support in Spring MVC and WebFlux annotated @Controller \u2022 Suspending function support in Spring MVC and WebFlux annotated @Controller \u2022 Extensions for WebFlux client and server functional API. \u2022", "chunk_char_count": 1849, "chunk_word_count": 269, "chunk_token_count": 462.25}, {"page_number": 1399, "sentence_chunk": "\u2022 Extensions for RSocketRequester Dependencies Coroutines support is enabled when kotlinx-coroutines-core and kotlinx-coroutines-reactor dependencies are in the classpath: build.gradle.kts dependencies { \u00a0  implementation(\"org.jetbrains.kotlinx:kotlinx-coroutines- core:${coroutinesVersion}\") \u00a0  implementation(\"org.jetbrains.kotlinx:kotlinx-coroutines- reactor:${coroutinesVersion}\") } Version 1.4.0 and above are supported. How Reactive translates to Coroutines?For return values, the translation from Reactive to Coroutines APIs is the following: \u2022 fun handler(): Mono<Void> becomes suspend fun handler() \u2022 fun handler(): Mono<T> becomes suspend fun handler(): T or suspend fun handler(): T?depending on if the Mono can be empty or not (with the advantage of being more statically typed) \u2022 fun handler(): Flux<T> becomes fun handler(): Flow<T> For input parameters: \u2022 If laziness is not needed, fun handler(mono: Mono<T>) becomes fun handler(value: T) since a suspending functions can be invoked to get the value parameter. \u2022If laziness is needed, fun handler(mono: Mono<T>) becomes fun handler(supplier: suspend () \u2192 T) or fun handler(supplier: suspend () \u2192 T?)Flow is Flux equivalent in Coroutines world, suitable for hot or cold stream, finite or infinite streams, with the following main differences: \u2022 Flow is push-based while Flux is push-pull hybrid \u2022 Backpressure is implemented via suspending functions \u2022 Flow has only a single suspending collect method and operators are implemented as extensions \u2022 Operators are easy to implement thanks to Coroutines \u2022 Extensions allow to add custom operators to Flow \u2022 Collect operations are suspending functions \u2022 map operator supports asynchronous operation (no need for flatMap) since it takes a suspending function parameter 1399", "chunk_char_count": 1782, "chunk_word_count": 243, "chunk_token_count": 445.5}, {"page_number": 1400, "sentence_chunk": "Read this blog post about Going Reactive with Spring, Coroutines and Kotlin Flow for more details, including how to run code concurrently with Coroutines. Controllers Here is an example of a Coroutines @RestController.@RestController class CoroutinesRestController(client: WebClient, banner: Banner) { \u00a0  @GetMapping(\"/suspend\") \u00a0  suspend fun suspendingEndpoint(): Banner { \u00a0    delay(10) \u00a0    return banner \u00a0  } \u00a0  @GetMapping(\"/flow\") \u00a0  fun flowEndpoint() = flow { \u00a0    delay(10) \u00a0    emit(banner) \u00a0    delay(10) \u00a0    emit(banner) \u00a0  } \u00a0  @GetMapping(\"/deferred\") \u00a0  fun deferredEndpoint() = GlobalScope.async { \u00a0    delay(10) \u00a0    banner \u00a0  } \u00a0  @GetMapping(\"/sequential\") \u00a0  suspend fun sequential(): List<Banner> { \u00a0    val banner1 = client \u00a0        .get() \u00a0        .uri(\"/suspend\") \u00a0        .accept(MediaType. APPLICATION_JSON) \u00a0        .awaitExchange() \u00a0        .awaitBody<Banner>() \u00a0    val banner2 = client \u00a0        .get() \u00a0        .uri(\"/suspend\") \u00a0        .accept(MediaType. APPLICATION_JSON) \u00a0        .awaitExchange() \u00a0        .awaitBody<Banner>() \u00a0    return listOf(banner1, banner2) \u00a0  } \u00a0  @GetMapping(\"/parallel\") \u00a0  suspend fun parallel(): List<Banner> = coroutineScope { \u00a0    val deferredBanner1: Deferred<Banner> = async { 1400", "chunk_char_count": 1248, "chunk_word_count": 270, "chunk_token_count": 312.0}, {"page_number": 1401, "sentence_chunk": "client \u00a0          .get() \u00a0          .uri(\"/suspend\") \u00a0          .accept(MediaType. APPLICATION_JSON) \u00a0          .awaitExchange() \u00a0          .awaitBody<Banner>() \u00a0    } \u00a0    val deferredBanner2: Deferred<Banner> = async { \u00a0      client \u00a0          .get() \u00a0          .uri(\"/suspend\") \u00a0          .accept(MediaType. APPLICATION_JSON) \u00a0          .awaitExchange() \u00a0          .awaitBody<Banner>() \u00a0    } \u00a0    listOf(deferredBanner1.await(), deferredBanner2.await()) \u00a0  } \u00a0  @GetMapping(\"/error\") \u00a0  suspend fun error() { \u00a0    throw IllegalStateException() \u00a0  } \u00a0  @GetMapping(\"/cancel\") \u00a0  suspend fun cancel() { \u00a0    throw CancellationException() \u00a0  } } View rendering with a @Controller is also supported.@Controller class CoroutinesViewController(banner: Banner) { \u00a0  @GetMapping(\"/\") \u00a0  suspend fun render(model: Model): String { \u00a0    delay(10) \u00a0    model[\"banner\"] = banner \u00a0    return \"index\" \u00a0  } } WebFlux.fn Here is an example of Coroutines router defined via the coRouter { } DSL and related handlers.1401", "chunk_char_count": 1007, "chunk_word_count": 249, "chunk_token_count": 251.75}, {"page_number": 1402, "sentence_chunk": "@Configuration class RouterConfiguration { \u00a0  @Bean \u00a0  fun mainRouter(userHandler: UserHandler) = coRouter { \u00a0    GET(\"/\", userHandler::listView) \u00a0    GET(\"/api/user\", userHandler::listApi) \u00a0  } } class UserHandler(builder: WebClient. Builder) { \u00a0  private val client = builder.baseUrl(\"...\").build() \u00a0  suspend fun listView(request: ServerRequest): ServerResponse = \u00a0      ServerResponse.ok().renderAndAwait(\"users\", mapOf(\"users\" to \u00a0      client.get().uri(\"...\").awaitExchange().awaitBody<User>())) \u00a0  suspend fun listApi(request: ServerRequest): ServerResponse = \u00a0 ServerResponse.ok().contentType(MediaType. APPLICATION_JSON).bodyAndAwait( \u00a0        client.get().uri(\"...\").awaitExchange().awaitBody<User>()) } Transactions Transactions on Coroutines are supported via the programmatic variant of the Reactive transaction management provided as of Spring Framework 5.2. For suspending functions, a TransactionalOperator.executeAndAwait extension is provided.1402", "chunk_char_count": 965, "chunk_word_count": 117, "chunk_token_count": 241.25}, {"page_number": 1403, "sentence_chunk": "import org.springframework.transaction.reactive.executeAndAwait class PersonRepository(private val operator: TransactionalOperator) { \u00a0  suspend fun initDatabase() = operator.executeAndAwait { \u00a0    insertPerson1() \u00a0    insertPerson2() \u00a0  } \u00a0  private suspend fun insertPerson1() { \u00a0    // INSERT SQL statement \u00a0  } \u00a0  private suspend fun insertPerson2() { \u00a0    // INSERT SQL statement \u00a0  } } For Kotlin Flow, a Flow<T>.transactional extension is provided.import org.springframework.transaction.reactive.transactional class PersonRepository(private val operator: TransactionalOperator) { \u00a0  fun updatePeople() = findPeople().map(::updatePerson).transactional(operator) \u00a0  private fun findPeople(): Flow<Person> { \u00a0    // SELECT SQL statement \u00a0  } \u00a0  private suspend fun updatePerson(person: Person): Person { \u00a0    // UPDATE SQL statement \u00a0  } } 8.1.9. Spring Projects in Kotlin This section provides some specific hints and recommendations worth for developing Spring projects in Kotlin. Final by Default By default, all classes in Kotlin are final. The open modifier on a class is the opposite of Java\u2019s final: It allows others to inherit from this class. This also applies to member functions, in that they need to be marked as open to be overridden. While Kotlin\u2019s JVM-friendly design is generally frictionless with Spring, this specific Kotlin feature can prevent the application from starting, if this fact is not taken into consideration. This is because 1403", "chunk_char_count": 1464, "chunk_word_count": 226, "chunk_token_count": 366.0}, {"page_number": 1404, "sentence_chunk": "Spring beans (such as @Configuration annotated classes which by default need to be extended at runtime for technical reasons) are normally proxied by CGLIB. The workaround is to add an open keyword on each class and member function of Spring beans that are proxied by CGLIB, which can quickly become painful and is against the Kotlin principle of keeping code concise and predictable.\uf05a It is also possible to avoid CGLIB proxies for configuration classes by using @Configuration(proxyBeanMethods = false). See proxyBeanMethods Javadoc for more details. Fortunately, Kotlin provides a kotlin-spring plugin (a preconfigured version of the kotlin-allopen plugin) that automatically opens classes and their member functions for types that are annotated or meta-annotated with one of the following annotations: \u2022 @Component \u2022 @Async \u2022 @Transactional \u2022 @Cacheable Meta-annotation support means that types annotated with @Configuration, @Controller, @RestController, @Service, or @Repository are automatically opened since these annotations are meta-annotated with @Component.start.spring.io enables the kotlin-spring plugin by default. So, in practice, you can write your Kotlin beans without any additional open keyword, as in Java.\uf05a The Kotlin code samples in Spring Framework documentation do not explicitly specify open on the classes and their member functions. The samples are written for projects using the kotlin-allopen plugin, since this is the most commonly used setup. Using Immutable Class Instances for Persistence In Kotlin, it is convenient and considered to be a best practice to declare read-only properties within the primary constructor, as in the following example: class Person(val name: String, val age: Int) You can optionally add the data keyword to make the compiler automatically derive the following members from all properties declared in the primary constructor: \u2022 equals() and hashCode() \u2022 toString() of the form \"User(name=John, age=42)\" \u2022 componentN() functions that correspond to the properties in their order of declaration \u2022 copy() function As the following example shows, this allows for easy changes to individual properties, even if 1404", "chunk_char_count": 2170, "chunk_word_count": 316, "chunk_token_count": 542.5}, {"page_number": 1405, "sentence_chunk": "Person properties are read-only: data class Person(val name: String, val age: Int) val jack = Person(name = \"Jack\", age = 1) val olderJack = jack.copy(age = 2) Common persistence technologies (such as JPA) require a default constructor, preventing this kind of design. Fortunately, there is a workaround for this \u201cdefault constructor hell\u201d, since Kotlin provides a kotlin-jpa plugin that generates synthetic no-arg constructor for classes annotated with JPA annotations. If you need to leverage this kind of mechanism for other persistence technologies, you can configure the kotlin-noarg plugin.\uf05a As of the Kay release train, Spring Data supports Kotlin immutable class instances and does not require the kotlin-noarg plugin if the module uses Spring Data object mappings (such as MongoDB, Redis, Cassandra, and others). Injecting Dependencies Our recommendation is to try to favor constructor injection with val read-only (and non-nullable when possible) properties, as the following example shows: @Component class YourBean( \u00a0  private val mongoTemplate: MongoTemplate, \u00a0  private val solrClient: SolrClient ) \uf05a Classes with a single constructor have their parameters automatically autowired. That\u2019s why there is no need for an explicit @Autowired constructor in the example shown above. If you really need to use field injection, you can use the lateinit var construct, as the following example shows: @Component class YourBean { \u00a0  @Autowired \u00a0  lateinit var mongoTemplate: MongoTemplate \u00a0  @Autowired \u00a0  lateinit var solrClient: SolrClient } 1405", "chunk_char_count": 1552, "chunk_word_count": 234, "chunk_token_count": 388.0}, {"page_number": 1406, "sentence_chunk": "Injecting Configuration Properties In Java, you can inject configuration properties by using annotations (such as @Value(\"${property}\")). However, in Kotlin, $ is a reserved character that is used for string interpolation. Therefore, if you wish to use the @Value annotation in Kotlin, you need to escape the $ character by writing @Value(\"\\${property}\").\uf05a If you use Spring Boot, you should probably use @ConfigurationProperties instead of @Value annotations. As an alternative, you can customize the property placeholder prefix by declaring the following configuration beans: @Bean fun propertyConfigurer() = PropertySourcesPlaceholderConfigurer().apply { \u00a0  setPlaceholderPrefix(\"%{\") } You can customize existing code (such as Spring Boot actuators or @LocalServerPort) that uses the ${\u2026} syntax, with configuration beans, as the following example shows: @Bean fun kotlinPropertyConfigurer() = PropertySourcesPlaceholderConfigurer().apply { \u00a0  setPlaceholderPrefix(\"%{\") \u00a0  setIgnoreUnresolvablePlaceholders(true) } @Bean fun defaultPropertyConfigurer() = PropertySourcesPlaceholderConfigurer() Checked Exceptions Java and Kotlin exception handling are pretty close, with the main difference being that Kotlin treats all exceptions as unchecked exceptions. However, when using proxied objects (for example classes or methods annotated with @Transactional), checked exceptions thrown will be wrapped by default in an UndeclaredThrowableException. To get the original exception thrown like in Java, methods should be annotated with @Throws to specify explicitly the checked exceptions thrown (for example @Throws(IOException::class)). Annotation Array Attributes Kotlin annotations are mostly similar to Java annotations, but array attributes (which are extensively used in Spring) behave differently. As explained in the Kotlin documentation you can omit the value attribute name, unlike other attributes, and specify it as a vararg parameter.1406", "chunk_char_count": 1950, "chunk_word_count": 251, "chunk_token_count": 487.5}, {"page_number": 1407, "sentence_chunk": "To understand what that means, consider @RequestMapping (which is one of the most widely used Spring annotations) as an example. This Java annotation is declared as follows: public @interface RequestMapping { \u00a0  @AliasFor(\"path\") \u00a0  String[] value() default {}; \u00a0  @AliasFor(\"value\") \u00a0  String[] path() default {}; \u00a0  RequestMethod[] method() default {}; \u00a0  // ... } The typical use case for @RequestMapping is to map a handler method to a specific path and method. In Java, you can specify a single value for the annotation array attribute, and it is automatically converted to an array. That is why one can write @RequestMapping(value = \"/toys\", method = RequestMethod. GET) or @RequestMapping(path = \"/toys\", method = RequestMethod. GET). However, in Kotlin, you must write @RequestMapping(\"/toys\", method = [RequestMethod. GET]) or @RequestMapping(path = [\"/toys\"], method = [RequestMethod. GET]) (square brackets need to be specified with named array attributes). An alternative for this specific method attribute (the most common one) is to use a shortcut annotation, such as @GetMapping, @PostMapping, and others.", "chunk_char_count": 1120, "chunk_word_count": 172, "chunk_token_count": 280.0}, {"page_number": 1407, "sentence_chunk": "\uf05a If the @RequestMapping method attribute is not specified, all HTTP methods will be matched, not only the GET method. Testing This section addresses testing with the combination of Kotlin and Spring Framework. The recommended testing framework is JUnit 5 along with Mockk for mocking.\uf05a If you are using Spring Boot, see this related documentation. Constructor injection As described in the dedicated section, JUnit 5 allows constructor injection of beans which is pretty useful with Kotlin in order to use val instead of lateinit var. You can use @TestConstructor(autowireMode = AutowireMode. ALL) to enable autowiring for all parameters.1407", "chunk_char_count": 643, "chunk_word_count": 98, "chunk_token_count": 160.75}, {"page_number": 1408, "sentence_chunk": "@SpringJUnitConfig(TestConfig::class) @TestConstructor(autowireMode = AutowireMode. ALL) class OrderServiceIntegrationTests(val orderService: OrderService, \u00a0                 val customerService: CustomerService) { \u00a0  // tests that use the injected OrderService and CustomerService } PER_CLASS Lifecycle Kotlin lets you specify meaningful test function names between backticks (`). As of JUnit 5, Kotlin test classes can use the @TestInstance(TestInstance. Lifecycle. PER_CLASS) annotation to enable single instantiation of test classes, which allows the use of @BeforeAll and @AfterAll annotations on non-static methods, which is a good fit for Kotlin. You can also change the default behavior to PER_CLASS thanks to a junit-platform.properties file with a junit.jupiter.testinstance.lifecycle.default = per_class property. The following example demonstrates @BeforeAll and @AfterAll annotations on non-static methods: @TestInstance(TestInstance. Lifecycle. PER_CLASS) class IntegrationTests { \u00a0 val application = Application(8181) \u00a0 val client = WebClient.create(\"http://localhost:8181\") \u00a0 @BeforeAll \u00a0 fun beforeAll() { \u00a0  application.start() \u00a0 } \u00a0 @Test \u00a0 fun `Find all users on HTML page`() { \u00a0  client.get().uri(\"/users\") \u00a0    .accept(TEXT_HTML) \u00a0    .retrieve() \u00a0    .bodyToMono<String>() \u00a0    .test() \u00a0    .expectNextMatches { it.contains(\"Foo\") } \u00a0    .verifyComplete() \u00a0 } \u00a0 @AfterAll \u00a0 fun afterAll() { \u00a0  application.stop() \u00a0 } } 1408", "chunk_char_count": 1445, "chunk_word_count": 215, "chunk_token_count": 361.25}, {"page_number": 1409, "sentence_chunk": "Specification-like Tests You can create specification-like tests with JUnit 5 and Kotlin. The following example shows how to do so: class SpecificationLikeTests { \u00a0 @Nested \u00a0 @DisplayName(\"a calculator\") \u00a0 inner class Calculator { \u00a0  val calculator = SampleCalculator() \u00a0  @Test \u00a0  fun `should return the result of adding the first number to the second number`() { \u00a0    val sum = calculator.sum(2, 4) \u00a0    assertEquals(6, sum) \u00a0  } \u00a0  @Test \u00a0  fun `should return the result of subtracting the second number from the first number`() { \u00a0    val subtract = calculator.subtract(4, 2) \u00a0    assertEquals(2, subtract) \u00a0  } \u00a0 } } WebTestClient Type Inference Issue in Kotlin Due to a type inference issue, you must use the Kotlin expectBody extension (such as .expectBody<String>().isEqualTo(\"toys\")), since it provides a workaround for the Kotlin issue with the Java API. See also the related SPR-16057 issue.8.1.10. Getting Started The easiest way to learn how to build a Spring application with Kotlin is to follow the dedicated tutorial.start.spring.io The easiest way to start a new Spring Framework project in Kotlin is to create a new Spring Boot 2 project on start.spring.io. Choosing the Web Flavor Spring Framework now comes with two different web stacks: Spring MVC and Spring WebFlux.1409", "chunk_char_count": 1292, "chunk_word_count": 221, "chunk_token_count": 323.0}, {"page_number": 1410, "sentence_chunk": "Spring WebFlux is recommended if you want to create applications that will deal with latency, long- lived connections, streaming scenarios or if you want to use the web functional Kotlin DSL. For other use cases, especially if you are using blocking technologies such as JPA, Spring MVC and its annotation-based programming model is the recommended choice.8.1.11. Resources We recommend the following resources for people learning how to build applications with Kotlin and the Spring Framework: \u2022 Kotlin language reference \u2022 Kotlin Slack (with a dedicated #spring channel) \u2022 Stackoverflow, with spring and kotlin tags \u2022 Try Kotlin in your browser \u2022 Kotlin blog \u2022 Awesome Kotlin Examples The following Github projects offer examples that you can learn from and possibly even extend: \u2022 spring-boot-kotlin-demo: Regular Spring Boot and Spring Data JPA project \u2022 mixit: Spring Boot 2, WebFlux, and Reactive Spring Data MongoDB \u2022 spring-kotlin-functional: Standalone WebFlux and functional bean definition DSL \u2022 spring-kotlin-fullstack: WebFlux Kotlin fullstack example with Kotlin2js for frontend instead of JavaScript or TypeScript \u2022 spring-petclinic-kotlin: Kotlin version of the Spring PetClinic Sample Application \u2022 spring-kotlin-deepdive: A step-by-step migration guide for Boot 1.0 and Java to Boot 2.0 and Kotlin \u2022 spring-cloud-gcp-kotlin-app-sample: Spring Boot with Google Cloud Platform Integrations Issues The following list categorizes the pending issues related to Spring and Kotlin support: \u2022 Spring Framework \u25e6 Unable to use WebTestClient with mock server in Kotlin \u25e6 Support null-safety at generics, varargs and array elements level \u2022 Kotlin \u25e6 Parent issue for Spring Framework support \u25e6 Kotlin requires type inference where Java doesn\u2019t \u25e6 Smart cast regression with open classes 1410", "chunk_char_count": 1796, "chunk_word_count": 264, "chunk_token_count": 449.0}, {"page_number": 1411, "sentence_chunk": "\u25e6 Impossible to pass not all SAM argument as function \u25e6 Support JSR 223 bindings directly via script variables \u25e6 Kotlin properties do not override Java-style getters and setters 8.2. Apache Groovy Groovy is a powerful, optionally typed, and dynamic language, with static-typing and static compilation capabilities. It offers a concise syntax and integrates smoothly with any existing Java application. The Spring Framework provides a dedicated ApplicationContext that supports a Groovy-based Bean Definition DSL. For more details, see The Groovy Bean Definition DSL. Further support for Groovy, including beans written in Groovy, refreshable script beans, and more is available in Dynamic Language Support.8.3. Dynamic Language Support Spring provides comprehensive support for using classes and objects that have been defined by using a dynamic language (such as Groovy) with Spring. This support lets you write any number of classes in a supported dynamic language and have the Spring container transparently instantiate, configure, and dependency inject the resulting objects. Spring\u2019s scripting support primarily targets Groovy and BeanShell.", "chunk_char_count": 1146, "chunk_word_count": 165, "chunk_token_count": 286.5}, {"page_number": 1411, "sentence_chunk": "Beyond those specifically supported languages, the JSR-223 scripting mechanism is supported for integration with any JSR- 223 capable language provider (as of Spring 4.2), e.g. JRuby. You can find fully working examples of where this dynamic language support can be immediately useful in Scenarios.8.3.1. A First Example The bulk of this chapter is concerned with describing the dynamic language support in detail. Before diving into all of the ins and outs of the dynamic language support, we look at a quick example of a bean defined in a dynamic language. The dynamic language for this first bean is Groovy. (The basis of this example was taken from the Spring test suite. If you want to see equivalent examples in any of the other supported languages, take a look at the source code). The next example shows the Messenger interface, which the Groovy bean is going to implement. Note that this interface is defined in plain Java.", "chunk_char_count": 932, "chunk_word_count": 156, "chunk_token_count": 233.0}, {"page_number": 1411, "sentence_chunk": "Dependent objects that are injected with a reference to the Messenger do not know that the underlying implementation is a Groovy script. The following listing shows the Messenger interface: 1411", "chunk_char_count": 194, "chunk_word_count": 30, "chunk_token_count": 48.5}, {"page_number": 1412, "sentence_chunk": "package org.springframework.scripting; public interface Messenger { \u00a0  String getMessage(); } The following example defines a class that has a dependency on the Messenger interface: package org.springframework.scripting; public class DefaultBookingService implements BookingService { \u00a0  private Messenger messenger; \u00a0  public void setMessenger(Messenger messenger) { \u00a0    this.messenger = messenger; \u00a0  } \u00a0  public void processBooking() { \u00a0    // use the injected Messenger object... \u00a0  } } The following example implements the Messenger interface in Groovy: // from the file 'Messenger.groovy' package org.springframework.scripting.groovy; // import the Messenger interface (written in Java) that is to be implemented import org.springframework.scripting. Messenger // define the implementation in Groovy class GroovyMessenger implements Messenger { \u00a0  String message } 1412", "chunk_char_count": 875, "chunk_word_count": 124, "chunk_token_count": 218.75}, {"page_number": 1413, "sentence_chunk": "\uf05a To use the custom dynamic language tags to define dynamic-language-backed beans, you need to have the XML Schema preamble at the top of your Spring XML configuration file. You also need to use a Spring ApplicationContext implementation as your IoC container. Using the dynamic-language-backed beans with a plain BeanFactory implementation is supported, but you have to manage the plumbing of the Spring internals to do so. For more information on schema-based configuration, see XML Schema-based Configuration. Finally, the following example shows the bean definitions that effect the injection of the Groovy- defined Messenger implementation into an instance of the DefaultBookingService class: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:lang=\"http://www.springframework.org/schema/lang\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/lang https://www.springframework.org/schema/lang/spring-lang.xsd\"> \u00a0  <!--this is the bean definition for the Groovy-backed Messenger implementation --> \u00a0  <lang:groovy id=\"messenger\" script-source=\"classpath:Messenger.groovy\"> \u00a0    <lang:property name=\"message\" value=\"I Can Do The Frug\" /> \u00a0  </lang:groovy> \u00a0  <!--an otherwise normal bean that will be injected by the Groovy-backed Messenger --> \u00a0  <bean id=\"bookingService\" class=\"x.y. DefaultBookingService\"> \u00a0    <property name=\"messenger\" ref=\"messenger\" /> \u00a0  </bean> </beans> The bookingService bean (a DefaultBookingService) can now use its private messenger member variable as normal, because the Messenger instance that was injected into it is a Messenger instance.", "chunk_char_count": 1814, "chunk_word_count": 220, "chunk_token_count": 453.5}, {"page_number": 1413, "sentence_chunk": "There is nothing special going on here\u2009\u2014\u2009just plain Java and plain Groovy. Hopefully, the preceding XML snippet is self-explanatory, but do not worry unduly if it is not. Keep reading for the in-depth detail on the whys and wherefores of the preceding configuration.8.3.2. Defining Beans that Are Backed by Dynamic Languages This section describes exactly how you define Spring-managed beans in any of the supported dynamic languages.1413", "chunk_char_count": 438, "chunk_word_count": 67, "chunk_token_count": 109.5}, {"page_number": 1414, "sentence_chunk": "Note that this chapter does not attempt to explain the syntax and idioms of the supported dynamic languages. For example, if you want to use Groovy to write certain of the classes in your application, we assume that you already know Groovy. If you need further details about the dynamic languages themselves, see Further Resources at the end of this chapter. Common Concepts The steps involved in using dynamic-language-backed beans are as follows: 1. Write the test for the dynamic language source code (naturally).2. Then write the dynamic language source code itself.3. Define your dynamic-language-backed beans by using the appropriate <lang:language/> element in the XML configuration (you can define such beans programmatically by using the Spring API, although you will have to consult the source code for directions on how to do this, as this chapter does not cover this type of advanced configuration). Note that this is an iterative step.", "chunk_char_count": 948, "chunk_word_count": 151, "chunk_token_count": 237.0}, {"page_number": 1414, "sentence_chunk": "You need at least one bean definition for each dynamic language source file (although multiple bean definitions can reference the same source file). The first two steps (testing and writing your dynamic language source files) are beyond the scope of this chapter. See the language specification and reference manual for your chosen dynamic language and crack on with developing your dynamic language source files. You first want to read the rest of this chapter, though, as Spring\u2019s dynamic language support does make some (small) assumptions about the contents of your dynamic language source files. The <lang:language/> element The final step in the list in the preceding section involves defining dynamic-language-backed bean definitions, one for each bean that you want to configure (this is no different from normal JavaBean configuration). However, instead of specifying the fully qualified class name of the class that is to be instantiated and configured by the container, you can use the <lang:language/> element to define the dynamic language-backed bean. Each of the supported languages has a corresponding <lang:language/> element: \u2022 <lang:groovy/> (Groovy) \u2022 <lang:bsh/> (BeanShell) \u2022 <lang:std/> (JSR-223, e.g. with JRuby) The exact attributes and child elements that are available for configuration depends on exactly which language the bean has been defined in (the language-specific sections later in this chapter detail this). Refreshable Beans One of the (and perhaps the single) most compelling value adds of the dynamic language support in Spring is the \u201crefreshable bean\u201d feature. A refreshable bean is a dynamic-language-backed bean. With a small amount of configuration, a dynamic-language-backed bean can monitor changes in its underlying source file resource and 1414", "chunk_char_count": 1793, "chunk_word_count": 268, "chunk_token_count": 448.25}, {"page_number": 1415, "sentence_chunk": "then reload itself when the dynamic language source file is changed (for example, when you edit and save changes to the file on the file system). This lets you deploy any number of dynamic language source files as part of an application, configure the Spring container to create beans backed by dynamic language source files (using the mechanisms described in this chapter), and (later, as requirements change or some other external factor comes into play) edit a dynamic language source file and have any change they make be reflected in the bean that is backed by the changed dynamic language source file. There is no need to shut down a running application (or redeploy in the case of a web application). The dynamic- language-backed bean so amended picks up the new state and logic from the changed dynamic language source file.\uf05a This feature is off by default. Now we can take a look at an example to see how easy it is to start using refreshable beans. To turn on the refreshable beans feature, you have to specify exactly one additional attribute on the <lang:language/> element of your bean definition. So, if we stick with the example from earlier in this chapter, the following example shows what we would change in the Spring XML configuration to effect refreshable beans: <beans> \u00a0  <!--this bean is now 'refreshable' due to the presence of the 'refresh-check- delay' attribute --> \u00a0  <lang:groovy id=\"messenger\" \u00a0      refresh-check-delay=\"5000\" <!--switches refreshing on with 5 seconds between checks --> \u00a0      script-source=\"classpath:Messenger.groovy\"> \u00a0    <lang:property name=\"message\" value=\"I Can Do The Frug\" /> \u00a0  </lang:groovy> \u00a0  <bean id=\"bookingService\" class=\"x.y.", "chunk_char_count": 1693, "chunk_word_count": 284, "chunk_token_count": 423.25}, {"page_number": 1415, "sentence_chunk": "DefaultBookingService\"> \u00a0    <property name=\"messenger\" ref=\"messenger\" /> \u00a0  </bean> </beans> That really is all you have to do. The refresh-check-delay attribute defined on the messenger bean definition is the number of milliseconds after which the bean is refreshed with any changes made to the underlying dynamic language source file. You can turn off the refresh behavior by assigning a negative value to the refresh-check-delay attribute. Remember that, by default, the refresh behavior is disabled. If you do not want the refresh behavior, do not define the attribute. If we then run the following application, we can exercise the refreshable feature. (Please excuse the \u201cjumping-through-hoops-to-pause-the-execution\u201d shenanigans in this next slice of code.)The System.in.read() call is only there so that the execution of the program pauses while you (the developer in this scenario) go off and edit the underlying dynamic language source file so that the refresh triggers on the dynamic-language-backed bean when the program resumes execution.1415", "chunk_char_count": 1056, "chunk_word_count": 158, "chunk_token_count": 264.0}, {"page_number": 1416, "sentence_chunk": "The following listing shows this sample application: import org.springframework.context. ApplicationContext; import org.springframework.context.support. ClassPathXmlApplicationContext; import org.springframework.scripting. Messenger; public final class Boot { \u00a0  public static void main(final String[] args) throws Exception { \u00a0    ApplicationContext ctx = new ClassPathXmlApplicationContext(\"beans.xml\"); \u00a0    Messenger messenger = (Messenger) ctx.getBean(\"messenger\"); \u00a0    System.out.println(messenger.getMessage()); \u00a0    // pause execution while I go off and make changes to the source file... \u00a0    System.in.read(); \u00a0    System.out.println(messenger.getMessage()); \u00a0  } } Assume then, for the purposes of this example, that all calls to the getMessage() method of Messenger implementations have to be changed such that the message is surrounded by quotation marks. The following listing shows the changes that you (the developer) should make to the Messenger.groovy source file when the execution of the program is paused: package org.springframework.scripting class GroovyMessenger implements Messenger { \u00a0  private String message = \"Bingo\" \u00a0  public String getMessage() { \u00a0    // change the implementation to surround the message in quotes \u00a0    return \"'\" + this.message + \"'\" \u00a0  } \u00a0  public void setMessage(String message) { \u00a0    this.message = message \u00a0  } } When the program runs, the output before the input pause will be I Can Do The Frug. After the change to the source file is made and saved and the program resumes execution, the result of calling the getMessage() method on the dynamic-language-backed Messenger implementation is 'I Can Do The Frug' (notice the inclusion of the additional quotation marks). Changes to a script do not trigger a refresh if the changes occur within the window of the refresh- check-delay value. Changes to the script are not actually picked up until a method is called on the dynamic-language-backed bean. It is only when a method is called on a dynamic-language-backed bean that it checks to see if its underlying script source has changed. Any exceptions that relate to 1416", "chunk_char_count": 2124, "chunk_word_count": 336, "chunk_token_count": 531.0}, {"page_number": 1417, "sentence_chunk": "refreshing the script (such as encountering a compilation error or finding that the script file has been deleted) results in a fatal exception being propagated to the calling code. The refreshable bean behavior described earlier does not apply to dynamic language source files defined with the <lang:inline-script/> element notation (see Inline Dynamic Language Source Files). Additionally, it applies only to beans where changes to the underlying source file can actually be detected (for example, by code that checks the last modified date of a dynamic language source file that exists on the file system). Inline Dynamic Language Source Files The dynamic language support can also cater to dynamic language source files that are embedded directly in Spring bean definitions. More specifically, the <lang:inline-script/> element lets you define dynamic language source immediately inside a Spring configuration file. An example might clarify how the inline script feature works: <lang:groovy id=\"messenger\"> \u00a0  <lang:inline-script> package org.springframework.scripting.groovy; import org.springframework.scripting. Messenger class GroovyMessenger implements Messenger { \u00a0  String message } \u00a0  </lang:inline-script> \u00a0  <lang:property name=\"message\" value=\"I Can Do The Frug\" /> </lang:groovy> If we put to one side the issues surrounding whether it is good practice to define dynamic language source inside a Spring configuration file, the <lang:inline-script/> element can be useful in some scenarios. For instance, we might want to quickly add a Spring Validator implementation to a Spring MVC Controller. This is but a moment\u2019s work using inline source. (See Scripted Validators for such an example.)", "chunk_char_count": 1705, "chunk_word_count": 246, "chunk_token_count": 426.25}, {"page_number": 1417, "sentence_chunk": "Understanding Constructor Injection in the Context of Dynamic-language-backed Beans There is one very important thing to be aware of with regard to Spring\u2019s dynamic language support. Namely, you can not (currently) supply constructor arguments to dynamic-language-backed beans (and, hence, constructor-injection is not available for dynamic-language-backed beans). In the interests of making this special handling of constructors and properties 100% clear, the following mixture of code and configuration does not work: 1417", "chunk_char_count": 524, "chunk_word_count": 71, "chunk_token_count": 131.0}, {"page_number": 1418, "sentence_chunk": "An approach that cannot work // from the file 'Messenger.groovy' package org.springframework.scripting.groovy; import org.springframework.scripting. Messenger class GroovyMessenger implements Messenger { \u00a0  GroovyMessenger() {} \u00a0  // this constructor is not available for Constructor Injection \u00a0  GroovyMessenger(String message) { \u00a0    this.message = message; \u00a0  } \u00a0  String message \u00a0  String anotherMessage } <lang:groovy id=\"badMessenger\" \u00a0  script-source=\"classpath:Messenger.groovy\"> \u00a0  <!--this next constructor argument will not be injected into the GroovyMessenger --> \u00a0  <!--in fact, this isn't even allowed according to the schema --> \u00a0  <constructor-arg value=\"This will not work\" /> \u00a0  <!--only property values are injected into the dynamic-language-backed object --> \u00a0  <lang:property name=\"anotherMessage\" value=\"Passed straight through to the dynamic-language-backed object\" /> </lang> In practice this limitation is not as significant as it first appears, since setter injection is the injection style favored by the overwhelming majority of developers (we leave the discussion as to whether that is a good thing to another day). Groovy Beans This section describes how to use beans defined in Groovy in Spring. The Groovy homepage includes the following description: \u201cGroovy is an agile dynamic language for the Java 2 Platform that has many of the features that people like so much in languages like Python, Ruby and Smalltalk, making them available to Java developers using a Java-like syntax.\u201dIf you have read this chapter straight from the top, you have already seen an example of a Groovy- 1418", "chunk_char_count": 1615, "chunk_word_count": 244, "chunk_token_count": 403.75}, {"page_number": 1419, "sentence_chunk": "dynamic-language-backed bean. Now consider another example (again using an example from the Spring test suite): package org.springframework.scripting; public interface Calculator { \u00a0  int add(int x, int y); } The following example implements the Calculator interface in Groovy: // from the file 'calculator.groovy' package org.springframework.scripting.groovy class GroovyCalculator implements Calculator { \u00a0  int add(int x, int y) { \u00a0    x + y \u00a0  } } The following bean definition uses the calculator defined in Groovy: <!--from the file 'beans.xml' --> <beans> \u00a0  <lang:groovy id=\"calculator\" script-source=\"classpath:calculator.groovy\"/> </beans> Finally, the following small application exercises the preceding configuration: package org.springframework.scripting; import org.springframework.context. ApplicationContext; import org.springframework.context.support. ClassPathXmlApplicationContext; public class Main { \u00a0  public static void main(String[] args) { \u00a0    ApplicationContext ctx = new ClassPathXmlApplicationContext(\"beans.xml\"); \u00a0    Calculator calc = ctx.getBean(\"calculator\", Calculator.class); \u00a0    System.out.println(calc.add(2, 8)); \u00a0  } } The resulting output from running the above program is (unsurprisingly) 10. (For more interesting 1419", "chunk_char_count": 1262, "chunk_word_count": 163, "chunk_token_count": 315.5}, {"page_number": 1420, "sentence_chunk": "examples, see the dynamic language showcase project for a more complex example or see the examples Scenarios later in this chapter). You must not define more than one class per Groovy source file. While this is perfectly legal in Groovy, it is (arguably) a bad practice. In the interests of a consistent approach, you should (in the opinion of the Spring team) respect the standard Java conventions of one (public) class per source file. Customizing Groovy Objects by Using a Callback The GroovyObjectCustomizer interface is a callback that lets you hook additional creation logic into the process of creating a Groovy-backed bean. For example, implementations of this interface could invoke any required initialization methods, set some default property values, or specify a custom MetaClass. The following listing shows the GroovyObjectCustomizer interface definition: public interface GroovyObjectCustomizer { \u00a0  void customize(GroovyObject goo); } The Spring Framework instantiates an instance of your Groovy-backed bean and then passes the created GroovyObject to the specified GroovyObjectCustomizer (if one has been defined). You can do whatever you like with the supplied GroovyObject reference. We expect that most people want to set a custom MetaClass with this callback, and the following example shows how to do so: public final class SimpleMethodTracingCustomizer implements GroovyObjectCustomizer { \u00a0  public void customize(GroovyObject goo) { \u00a0    DelegatingMetaClass metaClass = new DelegatingMetaClass(goo.getMetaClass()) { \u00a0      public Object invokeMethod(Object object, String methodName, Object[] arguments) { \u00a0        System.out.println(\"Invoking '\" + methodName + \"'.\");\u00a0        return super.invokeMethod(object, methodName, arguments); \u00a0      } \u00a0    }; \u00a0    metaClass.initialize(); \u00a0    goo.setMetaClass(metaClass); \u00a0  } } A full discussion of meta-programming in Groovy is beyond the scope of the Spring reference manual.", "chunk_char_count": 1946, "chunk_word_count": 307, "chunk_token_count": 486.5}, {"page_number": 1420, "sentence_chunk": "See the relevant section of the Groovy reference manual or do a search online. Plenty of articles address this topic. Actually, making use of a GroovyObjectCustomizer is easy if you use the Spring namespace support, as the following example shows: 1420", "chunk_char_count": 252, "chunk_word_count": 41, "chunk_token_count": 63.0}, {"page_number": 1421, "sentence_chunk": "<!--define the GroovyObjectCustomizer just like any other bean --> <bean id=\"tracingCustomizer\" class=\"example. SimpleMethodTracingCustomizer\"/> \u00a0  <!-- ...and plug it into the desired Groovy bean via the 'customizer-ref' attribute --> \u00a0  <lang:groovy id=\"calculator\" \u00a0    script- source=\"classpath:org/springframework/scripting/groovy/Calculator.groovy\" \u00a0    customizer-ref=\"tracingCustomizer\"/> If you do not use the Spring namespace support, you can still use the GroovyObjectCustomizer functionality, as the following example shows: <bean id=\"calculator\" class=\"org.springframework.scripting.groovy. GroovyScriptFactory\"> \u00a0  <constructor-arg value=\"classpath:org/springframework/scripting/groovy/Calculator.groovy\"/> \u00a0  <!--define the GroovyObjectCustomizer (as an inner bean) --> \u00a0  <constructor-arg> \u00a0    <bean id=\"tracingCustomizer\" class=\"example. SimpleMethodTracingCustomizer\"/> \u00a0  </constructor-arg> </bean> <bean class=\"org.springframework.scripting.support. ScriptFactoryPostProcessor\"/> \uf05a You may also specify a Groovy CompilationCustomizer (such as an ImportCustomizer) or even a full Groovy CompilerConfiguration object in the same place as Spring\u2019s GroovyObjectCustomizer. Furthermore, you may set a common GroovyClassLoader with custom configuration for your beans at the ConfigurableApplicationContext.setClassLoader level; this also leads to shared GroovyClassLoader usage and is therefore recommendable in case of a large number of scripted beans (avoiding an isolated GroovyClassLoader instance per bean). BeanShell Beans This section describes how to use BeanShell beans in Spring.", "chunk_char_count": 1604, "chunk_word_count": 183, "chunk_token_count": 401.0}, {"page_number": 1421, "sentence_chunk": "The BeanShell homepage includes the following description: BeanShell is a small, free, embeddable Java source interpreter with dynamic language features, written in Java. BeanShell dynamically runs standard Java syntax and extends it with common scripting conveniences such as loose types, commands, and method closures like those in Perl and JavaScript.1421", "chunk_char_count": 358, "chunk_word_count": 50, "chunk_token_count": 89.5}, {"page_number": 1422, "sentence_chunk": "In contrast to Groovy, BeanShell-backed bean definitions require some (small) additional configuration. The implementation of the BeanShell dynamic language support in Spring is interesting, because Spring creates a JDK dynamic proxy that implements all of the interfaces that are specified in the script-interfaces attribute value of the <lang:bsh> element (this is why you must supply at least one interface in the value of the attribute, and, consequently, program to interfaces when you use BeanShell-backed beans). This means that every method call on a BeanShell-backed object goes through the JDK dynamic proxy invocation mechanism. Now we can show a fully working example of using a BeanShell-based bean that implements the Messenger interface that was defined earlier in this chapter. We again show the definition of the Messenger interface: package org.springframework.scripting; public interface Messenger { \u00a0  String getMessage(); } The following example shows the BeanShell \u201cimplementation\u201d (we use the term loosely here) of the Messenger interface: String message; String getMessage() { \u00a0  return message; } void setMessage(String aMessage) { \u00a0  message = aMessage; } The following example shows the Spring XML that defines an \u201cinstance\u201d of the above \u201cclass\u201d (again, we use these terms very loosely here): <lang:bsh id=\"messageService\" script-source=\"classpath:BshMessenger.bsh\" \u00a0  script-interfaces=\"org.springframework.scripting. Messenger\"> \u00a0  <lang:property name=\"message\" value=\"Hello World!\" /> </lang:bsh> See Scenarios for some scenarios where you might want to use BeanShell-based beans.8.3.3. Scenarios The possible scenarios where defining Spring managed beans in a scripting language would be beneficial are many and varied. This section describes two possible use cases for the dynamic 1422", "chunk_char_count": 1817, "chunk_word_count": 257, "chunk_token_count": 454.25}, {"page_number": 1423, "sentence_chunk": "language support in Spring. Scripted Spring MVC Controllers One group of classes that can benefit from using dynamic-language-backed beans is that of Spring MVC controllers. In pure Spring MVC applications, the navigational flow through a web application is, to a large extent, determined by code encapsulated within your Spring MVC controllers. As the navigational flow and other presentation layer logic of a web application needs to be updated to respond to support issues or changing business requirements, it may well be easier to effect any such required changes by editing one or more dynamic language source files and seeing those changes being immediately reflected in the state of a running application. Remember that, in the lightweight architectural model espoused by projects such as Spring, you typically aim to have a really thin presentation layer, with all the meaty business logic of an application being contained in the domain and service layer classes. Developing Spring MVC controllers as dynamic-language-backed beans lets you change presentation layer logic by editing and saving text files. Any changes to such dynamic language source files is (depending on the configuration) automatically reflected in the beans that are backed by dynamic language source files.\uf05a To effect this automatic \u201cpickup\u201d of any changes to dynamic-language-backed beans, you have to enable the \u201crefreshable beans\u201d functionality. See Refreshable Beans for a full treatment of this feature. The following example shows an org.springframework.web.servlet.mvc.", "chunk_char_count": 1558, "chunk_word_count": 232, "chunk_token_count": 389.5}, {"page_number": 1423, "sentence_chunk": "Controller implemented by using the Groovy dynamic language: // from the file '/WEB-INF/groovy/FortuneController.groovy' package org.springframework.showcase.fortune.web import org.springframework.showcase.fortune.service. FortuneService import org.springframework.showcase.fortune.domain. Fortune import org.springframework.web.servlet. ModelAndView import org.springframework.web.servlet.mvc. Controller import jakarta.servlet.http. HttpServletRequest import jakarta.servlet.http. HttpServletResponse class FortuneController implements Controller { \u00a0  @Property FortuneService fortuneService \u00a0  ModelAndView handleRequest(HttpServletRequest request, \u00a0      HttpServletResponse httpServletResponse) { \u00a0    return new ModelAndView(\"tell\", \"fortune\", this.fortuneService.tellFortune()) \u00a0  } } 1423", "chunk_char_count": 796, "chunk_word_count": 71, "chunk_token_count": 199.0}, {"page_number": 1424, "sentence_chunk": "<lang:groovy id=\"fortune\" \u00a0    refresh-check-delay=\"3000\" \u00a0    script-source=\"/WEB-INF/groovy/FortuneController.groovy\"> \u00a0  <lang:property name=\"fortuneService\" ref=\"fortuneService\"/> </lang:groovy> Scripted Validators Another area of application development with Spring that may benefit from the flexibility afforded by dynamic-language-backed beans is that of validation. It can be easier to express complex validation logic by using a loosely typed dynamic language (that may also have support for inline regular expressions) as opposed to regular Java. Again, developing validators as dynamic-language-backed beans lets you change validation logic by editing and saving a simple text file. Any such changes is (depending on the configuration) automatically reflected in the execution of a running application and would not require the restart of an application.\uf05a To effect the automatic \u201cpickup\u201d of any changes to dynamic-language-backed beans, you have to enable the 'refreshable beans' feature. See Refreshable Beans for a full and detailed treatment of this feature. The following example shows a Spring org.springframework.validation. Validator implemented by using the Groovy dynamic language (see Validation using Spring\u2019s Validator interface for a discussion of the Validator interface): import org.springframework.validation. Validator import org.springframework.validation. Errors import org.springframework.beans.", "chunk_char_count": 1427, "chunk_word_count": 183, "chunk_token_count": 356.75}, {"page_number": 1424, "sentence_chunk": "TestBean class TestBeanValidator implements Validator { \u00a0  boolean supports(Class clazz) { \u00a0    return TestBean.class.isAssignableFrom(clazz) \u00a0  } \u00a0  void validate(Object bean, Errors errors) { \u00a0    if(bean.name?.trim()?.size() > 0) { \u00a0      return \u00a0    } \u00a0    errors.reject(\"whitespace\", \"Cannot be composed wholly of whitespace.\")\u00a0  } } 8.3.4. Additional Details This last section contains some additional details related to the dynamic language support.1424", "chunk_char_count": 460, "chunk_word_count": 79, "chunk_token_count": 115.0}, {"page_number": 1425, "sentence_chunk": "AOP\u2009\u2014\u2009Advising Scripted Beans You can use the Spring AOP framework to advise scripted beans. The Spring AOP framework actually is unaware that a bean that is being advised might be a scripted bean, so all of the AOP use cases and functionality that you use (or aim to use) work with scripted beans. When you advise scripted beans, you cannot use class-based proxies. You must use interface-based proxies. You are not limited to advising scripted beans. You can also write aspects themselves in a supported dynamic language and use such beans to advise other Spring beans. This really would be an advanced use of the dynamic language support though. Scoping In case it is not immediately obvious, scripted beans can be scoped in the same way as any other bean. The scope attribute on the various <lang:language/> elements lets you control the scope of the underlying scripted bean, as it does with a regular bean. (The default scope is singleton, as it is with \u201cregular\u201d beans.)", "chunk_char_count": 977, "chunk_word_count": 166, "chunk_token_count": 244.25}, {"page_number": 1425, "sentence_chunk": "The following example uses the scope attribute to define a Groovy bean scoped as a prototype: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:lang=\"http://www.springframework.org/schema/lang\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/lang https://www.springframework.org/schema/lang/spring-lang.xsd\"> \u00a0  <lang:groovy id=\"messenger\" script-source=\"classpath:Messenger.groovy\" scope=\"prototype\"> \u00a0    <lang:property name=\"message\" value=\"I Can Do The RoboCop\" /> \u00a0  </lang:groovy> \u00a0  <bean id=\"bookingService\" class=\"x.y. DefaultBookingService\"> \u00a0    <property name=\"messenger\" ref=\"messenger\" /> \u00a0  </bean> </beans> See Bean Scopes in The IoC Container for a full discussion of the scoping support in the Spring Framework. The lang XML schema The lang elements in Spring XML configuration deal with exposing objects that have been written in a dynamic language (such as Groovy or BeanShell) as beans in the Spring container. These elements (and the dynamic language support) are comprehensively covered in Dynamic 1425", "chunk_char_count": 1266, "chunk_word_count": 145, "chunk_token_count": 316.5}, {"page_number": 1426, "sentence_chunk": "Language Support. See that section for full details on this support and the lang elements. To use the elements in the lang schema, you need to have the following preamble at the top of your Spring XML configuration file. The text in the following snippet references the correct schema so that the tags in the lang namespace are available to you: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <beans xmlns=\"http://www.springframework.org/schema/beans\" \u00a0  xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" \u00a0  xmlns:lang=\"http://www.springframework.org/schema/lang\" \u00a0  xsi:schemaLocation=\" \u00a0    http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd \u00a0    http://www.springframework.org/schema/lang https://www.springframework.org/schema/lang/spring-lang.xsd\"> \u00a0  <!--bean definitions here --> </beans> 8.3.5. Further Resources The following links go to further resources about the various dynamic languages referenced in this chapter: \u2022 The Groovy homepage \u2022 The BeanShell homepage \u2022 The JRuby homepage 1426", "chunk_char_count": 1052, "chunk_word_count": 126, "chunk_token_count": 263.0}, {"page_number": 1427, "sentence_chunk": "Chapter 9. Appendix This part of the reference documentation covers topics that apply to multiple modules within the core Spring Framework.9.1. Spring Properties SpringProperties is a static holder for properties that control certain low-level aspects of the Spring Framework. Users can configure these properties via JVM system properties or programmatically via the SpringProperties.setProperty(String key, String value) method. The latter may be necessary if the deployment environment disallows custom JVM system properties. As an alternative, these properties may be configured in a spring.properties file in the root of the classpath\u2009\u2014\u2009for example, deployed within the application\u2019s JAR file. The following table lists all currently supported Spring properties. Table 38. Supported Spring Properties Name Description spring.beaninfo.ignore Instructs Spring to use the Introspector.", "chunk_char_count": 887, "chunk_word_count": 119, "chunk_token_count": 221.75}, {"page_number": 1427, "sentence_chunk": "IGNORE_ALL_BEANINFO mode when calling the JavaBeans Introspector. See CachedIntrospectionResults for details.spring.expression.compiler.mode The mode to use when compiling expressions for the Spring Expression Language.spring.getenv.ignore Instructs Spring to ignore operating system environment variables if a Spring Environment property\u2009\u2014\u2009for example, a placeholder in a configuration String\u2009\u2014\u2009isn\u2019t resolvable otherwise. See AbstractEnvironment for details.spring.index.ignore Instructs Spring to ignore the components index located in META-INF/spring.components. See Generating an Index of Candidate Components.spring.jdbc.getParameterType.ignore Instructs Spring to ignore java.sql. ParameterMetaData.getParameterType completely. See the note in Batch Operations with a List of Objects.", "chunk_char_count": 791, "chunk_word_count": 84, "chunk_token_count": 197.75}, {"page_number": 1427, "sentence_chunk": "spring.jndi.ignore Instructs Spring to ignore a default JNDI environment, as an optimization for scenarios where nothing is ever to be found for such JNDI fallback searches to begin with, avoiding the repeated JNDI lookup overhead. See JndiLocatorDelegate for details.1427", "chunk_char_count": 272, "chunk_word_count": 39, "chunk_token_count": 68.0}, {"page_number": 1428, "sentence_chunk": "Name Description spring.objenesis.ignore Instructs Spring to ignore Objenesis, not even attempting to use it. See SpringObjenesis for details.spring.test.constructor.autowire.mode The default test constructor autowire mode to use if @TestConstructor is not present on a test class. See Changing the default test constructor autowire mode.spring.test.context.cache.maxSize The maximum size of the context cache in the Spring TestContext Framework. See Context Caching.spring.test.enclosing.configuration The default enclosing configuration inheritance mode to use if @NestedTestConfiguration is not present on a test class. See Changing the default enclosing configuration inheritance mode. Rod Johnson, Juergen Hoeller, Keith Donald, Colin Sampaleanu, Rob Harrop, Thomas Risberg, Alef Arendsen, Darren Davison, Dmitriy Kopylenko, Mark Pollack, Thierry Templier, Erwin Vervaet, Portia Tung, Ben Hale, Adrian Colyer, John Lewis, Costin Leau, Mark Fisher, Sam Brannen, Ramnivas Laddad, Arjen Poutsma, Chris Beams, Tareq Abedrabbo, Andy Clement, Dave Syer, Oliver Gierke, Rossen Stoyanchev, Phillip Webb, Rob Winch, Brian Clozel, Stephane Nicoll, Sebastien Deleuze, Jay Bryant, Mark Paluch Copyright \u00a9 2002 - 2022 VMware, Inc. All Rights Reserved. Copies of this document may be made for your own use and for distribution to others, provided that you do not charge any fee for such copies and further provided that each copy contains this Copyright Notice, whether distributed in print or electronically.", "chunk_char_count": 1500, "chunk_word_count": 204, "chunk_token_count": 375.0}]